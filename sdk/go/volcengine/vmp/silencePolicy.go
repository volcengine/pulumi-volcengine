// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package vmp

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/volcengine/pulumi-volcengine/sdk/go/volcengine/internal"
)

// Provides a resource to manage vmp silence policy
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/volcengine/pulumi-volcengine/sdk/go/volcengine/vmp"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := vmp.NewSilencePolicy(ctx, "example", &vmp.SilencePolicyArgs{
//				Description: pulumi.String("terraform silence policy"),
//				MetricLabelMatchers: vmp.SilencePolicyMetricLabelMatcherArray{
//					&vmp.SilencePolicyMetricLabelMatcherArgs{
//						Matchers: vmp.SilencePolicyMetricLabelMatcherMatcherArray{
//							&vmp.SilencePolicyMetricLabelMatcherMatcherArgs{
//								Label:    pulumi.String("app"),
//								Operator: pulumi.String("NotEqual"),
//								Value:    pulumi.String("test"),
//							},
//							&vmp.SilencePolicyMetricLabelMatcherMatcherArgs{
//								Label:    pulumi.String("env"),
//								Operator: pulumi.String("Equal"),
//								Value:    pulumi.String("prod"),
//							},
//						},
//					},
//				},
//				TimeRangeMatchers: vmp.SilencePolicyTimeRangeMatcherArray{
//					&vmp.SilencePolicyTimeRangeMatcherArgs{
//						Location: pulumi.String("Asia/Shanghai"),
//						PeriodicDate: &vmp.SilencePolicyTimeRangeMatcherPeriodicDateArgs{
//							Time:    pulumi.String("20:00~21:12"),
//							Weekday: pulumi.String("1,5"),
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// VmpSilencePolicy can be imported using the id, e.g.
//
// ```sh
// $ pulumi import volcengine:vmp/silencePolicy:SilencePolicy default resource_id
// ```
type SilencePolicy struct {
	pulumi.CustomResourceState

	// The auto delete time of the silence policy.
	AutoDeleteTime pulumi.StringOutput `pulumi:"autoDeleteTime"`
	// The create time of the silence policy.
	CreateTime pulumi.StringOutput `pulumi:"createTime"`
	// The description of the silence policy.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// Alarm event Label matcher, allowing a maximum of 32 entries, with an "OR" relationship between different entries. Different labelMatchers in the Matcher follow an "AND" relationship.
	MetricLabelMatchers SilencePolicyMetricLabelMatcherArrayOutput `pulumi:"metricLabelMatchers"`
	// The name of the silence policy.
	Name pulumi.StringOutput `pulumi:"name"`
	// The source of the silence policy.
	Source pulumi.StringOutput `pulumi:"source"`
	// The status of the silence policy.
	Status pulumi.StringOutput `pulumi:"status"`
	// Alarm silence time. Case 1: Always effective. When the switch is turned on, the matched alarm events are always silenced, and only the location needs to be set. Case 2: Periodic effective. When the switch is turned on, the matched alarm events are silenced periodically, and the location and periodicDate need to be set. Case 3: Custom effective. When the switch is turned on, the matched alarm events are silenced in the specified time range, and the location and date need to be set.
	TimeRangeMatchers SilencePolicyTimeRangeMatcherArrayOutput `pulumi:"timeRangeMatchers"`
	// The update time of the silence policy.
	UpdateTime pulumi.StringOutput `pulumi:"updateTime"`
}

// NewSilencePolicy registers a new resource with the given unique name, arguments, and options.
func NewSilencePolicy(ctx *pulumi.Context,
	name string, args *SilencePolicyArgs, opts ...pulumi.ResourceOption) (*SilencePolicy, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.MetricLabelMatchers == nil {
		return nil, errors.New("invalid value for required argument 'MetricLabelMatchers'")
	}
	if args.TimeRangeMatchers == nil {
		return nil, errors.New("invalid value for required argument 'TimeRangeMatchers'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource SilencePolicy
	err := ctx.RegisterResource("volcengine:vmp/silencePolicy:SilencePolicy", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSilencePolicy gets an existing SilencePolicy resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSilencePolicy(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SilencePolicyState, opts ...pulumi.ResourceOption) (*SilencePolicy, error) {
	var resource SilencePolicy
	err := ctx.ReadResource("volcengine:vmp/silencePolicy:SilencePolicy", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering SilencePolicy resources.
type silencePolicyState struct {
	// The auto delete time of the silence policy.
	AutoDeleteTime *string `pulumi:"autoDeleteTime"`
	// The create time of the silence policy.
	CreateTime *string `pulumi:"createTime"`
	// The description of the silence policy.
	Description *string `pulumi:"description"`
	// Alarm event Label matcher, allowing a maximum of 32 entries, with an "OR" relationship between different entries. Different labelMatchers in the Matcher follow an "AND" relationship.
	MetricLabelMatchers []SilencePolicyMetricLabelMatcher `pulumi:"metricLabelMatchers"`
	// The name of the silence policy.
	Name *string `pulumi:"name"`
	// The source of the silence policy.
	Source *string `pulumi:"source"`
	// The status of the silence policy.
	Status *string `pulumi:"status"`
	// Alarm silence time. Case 1: Always effective. When the switch is turned on, the matched alarm events are always silenced, and only the location needs to be set. Case 2: Periodic effective. When the switch is turned on, the matched alarm events are silenced periodically, and the location and periodicDate need to be set. Case 3: Custom effective. When the switch is turned on, the matched alarm events are silenced in the specified time range, and the location and date need to be set.
	TimeRangeMatchers []SilencePolicyTimeRangeMatcher `pulumi:"timeRangeMatchers"`
	// The update time of the silence policy.
	UpdateTime *string `pulumi:"updateTime"`
}

type SilencePolicyState struct {
	// The auto delete time of the silence policy.
	AutoDeleteTime pulumi.StringPtrInput
	// The create time of the silence policy.
	CreateTime pulumi.StringPtrInput
	// The description of the silence policy.
	Description pulumi.StringPtrInput
	// Alarm event Label matcher, allowing a maximum of 32 entries, with an "OR" relationship between different entries. Different labelMatchers in the Matcher follow an "AND" relationship.
	MetricLabelMatchers SilencePolicyMetricLabelMatcherArrayInput
	// The name of the silence policy.
	Name pulumi.StringPtrInput
	// The source of the silence policy.
	Source pulumi.StringPtrInput
	// The status of the silence policy.
	Status pulumi.StringPtrInput
	// Alarm silence time. Case 1: Always effective. When the switch is turned on, the matched alarm events are always silenced, and only the location needs to be set. Case 2: Periodic effective. When the switch is turned on, the matched alarm events are silenced periodically, and the location and periodicDate need to be set. Case 3: Custom effective. When the switch is turned on, the matched alarm events are silenced in the specified time range, and the location and date need to be set.
	TimeRangeMatchers SilencePolicyTimeRangeMatcherArrayInput
	// The update time of the silence policy.
	UpdateTime pulumi.StringPtrInput
}

func (SilencePolicyState) ElementType() reflect.Type {
	return reflect.TypeOf((*silencePolicyState)(nil)).Elem()
}

type silencePolicyArgs struct {
	// The description of the silence policy.
	Description *string `pulumi:"description"`
	// Alarm event Label matcher, allowing a maximum of 32 entries, with an "OR" relationship between different entries. Different labelMatchers in the Matcher follow an "AND" relationship.
	MetricLabelMatchers []SilencePolicyMetricLabelMatcher `pulumi:"metricLabelMatchers"`
	// The name of the silence policy.
	Name *string `pulumi:"name"`
	// Alarm silence time. Case 1: Always effective. When the switch is turned on, the matched alarm events are always silenced, and only the location needs to be set. Case 2: Periodic effective. When the switch is turned on, the matched alarm events are silenced periodically, and the location and periodicDate need to be set. Case 3: Custom effective. When the switch is turned on, the matched alarm events are silenced in the specified time range, and the location and date need to be set.
	TimeRangeMatchers []SilencePolicyTimeRangeMatcher `pulumi:"timeRangeMatchers"`
}

// The set of arguments for constructing a SilencePolicy resource.
type SilencePolicyArgs struct {
	// The description of the silence policy.
	Description pulumi.StringPtrInput
	// Alarm event Label matcher, allowing a maximum of 32 entries, with an "OR" relationship between different entries. Different labelMatchers in the Matcher follow an "AND" relationship.
	MetricLabelMatchers SilencePolicyMetricLabelMatcherArrayInput
	// The name of the silence policy.
	Name pulumi.StringPtrInput
	// Alarm silence time. Case 1: Always effective. When the switch is turned on, the matched alarm events are always silenced, and only the location needs to be set. Case 2: Periodic effective. When the switch is turned on, the matched alarm events are silenced periodically, and the location and periodicDate need to be set. Case 3: Custom effective. When the switch is turned on, the matched alarm events are silenced in the specified time range, and the location and date need to be set.
	TimeRangeMatchers SilencePolicyTimeRangeMatcherArrayInput
}

func (SilencePolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*silencePolicyArgs)(nil)).Elem()
}

type SilencePolicyInput interface {
	pulumi.Input

	ToSilencePolicyOutput() SilencePolicyOutput
	ToSilencePolicyOutputWithContext(ctx context.Context) SilencePolicyOutput
}

func (*SilencePolicy) ElementType() reflect.Type {
	return reflect.TypeOf((**SilencePolicy)(nil)).Elem()
}

func (i *SilencePolicy) ToSilencePolicyOutput() SilencePolicyOutput {
	return i.ToSilencePolicyOutputWithContext(context.Background())
}

func (i *SilencePolicy) ToSilencePolicyOutputWithContext(ctx context.Context) SilencePolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SilencePolicyOutput)
}

// SilencePolicyArrayInput is an input type that accepts SilencePolicyArray and SilencePolicyArrayOutput values.
// You can construct a concrete instance of `SilencePolicyArrayInput` via:
//
//	SilencePolicyArray{ SilencePolicyArgs{...} }
type SilencePolicyArrayInput interface {
	pulumi.Input

	ToSilencePolicyArrayOutput() SilencePolicyArrayOutput
	ToSilencePolicyArrayOutputWithContext(context.Context) SilencePolicyArrayOutput
}

type SilencePolicyArray []SilencePolicyInput

func (SilencePolicyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SilencePolicy)(nil)).Elem()
}

func (i SilencePolicyArray) ToSilencePolicyArrayOutput() SilencePolicyArrayOutput {
	return i.ToSilencePolicyArrayOutputWithContext(context.Background())
}

func (i SilencePolicyArray) ToSilencePolicyArrayOutputWithContext(ctx context.Context) SilencePolicyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SilencePolicyArrayOutput)
}

// SilencePolicyMapInput is an input type that accepts SilencePolicyMap and SilencePolicyMapOutput values.
// You can construct a concrete instance of `SilencePolicyMapInput` via:
//
//	SilencePolicyMap{ "key": SilencePolicyArgs{...} }
type SilencePolicyMapInput interface {
	pulumi.Input

	ToSilencePolicyMapOutput() SilencePolicyMapOutput
	ToSilencePolicyMapOutputWithContext(context.Context) SilencePolicyMapOutput
}

type SilencePolicyMap map[string]SilencePolicyInput

func (SilencePolicyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SilencePolicy)(nil)).Elem()
}

func (i SilencePolicyMap) ToSilencePolicyMapOutput() SilencePolicyMapOutput {
	return i.ToSilencePolicyMapOutputWithContext(context.Background())
}

func (i SilencePolicyMap) ToSilencePolicyMapOutputWithContext(ctx context.Context) SilencePolicyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SilencePolicyMapOutput)
}

type SilencePolicyOutput struct{ *pulumi.OutputState }

func (SilencePolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SilencePolicy)(nil)).Elem()
}

func (o SilencePolicyOutput) ToSilencePolicyOutput() SilencePolicyOutput {
	return o
}

func (o SilencePolicyOutput) ToSilencePolicyOutputWithContext(ctx context.Context) SilencePolicyOutput {
	return o
}

// The auto delete time of the silence policy.
func (o SilencePolicyOutput) AutoDeleteTime() pulumi.StringOutput {
	return o.ApplyT(func(v *SilencePolicy) pulumi.StringOutput { return v.AutoDeleteTime }).(pulumi.StringOutput)
}

// The create time of the silence policy.
func (o SilencePolicyOutput) CreateTime() pulumi.StringOutput {
	return o.ApplyT(func(v *SilencePolicy) pulumi.StringOutput { return v.CreateTime }).(pulumi.StringOutput)
}

// The description of the silence policy.
func (o SilencePolicyOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SilencePolicy) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// Alarm event Label matcher, allowing a maximum of 32 entries, with an "OR" relationship between different entries. Different labelMatchers in the Matcher follow an "AND" relationship.
func (o SilencePolicyOutput) MetricLabelMatchers() SilencePolicyMetricLabelMatcherArrayOutput {
	return o.ApplyT(func(v *SilencePolicy) SilencePolicyMetricLabelMatcherArrayOutput { return v.MetricLabelMatchers }).(SilencePolicyMetricLabelMatcherArrayOutput)
}

// The name of the silence policy.
func (o SilencePolicyOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *SilencePolicy) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The source of the silence policy.
func (o SilencePolicyOutput) Source() pulumi.StringOutput {
	return o.ApplyT(func(v *SilencePolicy) pulumi.StringOutput { return v.Source }).(pulumi.StringOutput)
}

// The status of the silence policy.
func (o SilencePolicyOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v *SilencePolicy) pulumi.StringOutput { return v.Status }).(pulumi.StringOutput)
}

// Alarm silence time. Case 1: Always effective. When the switch is turned on, the matched alarm events are always silenced, and only the location needs to be set. Case 2: Periodic effective. When the switch is turned on, the matched alarm events are silenced periodically, and the location and periodicDate need to be set. Case 3: Custom effective. When the switch is turned on, the matched alarm events are silenced in the specified time range, and the location and date need to be set.
func (o SilencePolicyOutput) TimeRangeMatchers() SilencePolicyTimeRangeMatcherArrayOutput {
	return o.ApplyT(func(v *SilencePolicy) SilencePolicyTimeRangeMatcherArrayOutput { return v.TimeRangeMatchers }).(SilencePolicyTimeRangeMatcherArrayOutput)
}

// The update time of the silence policy.
func (o SilencePolicyOutput) UpdateTime() pulumi.StringOutput {
	return o.ApplyT(func(v *SilencePolicy) pulumi.StringOutput { return v.UpdateTime }).(pulumi.StringOutput)
}

type SilencePolicyArrayOutput struct{ *pulumi.OutputState }

func (SilencePolicyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SilencePolicy)(nil)).Elem()
}

func (o SilencePolicyArrayOutput) ToSilencePolicyArrayOutput() SilencePolicyArrayOutput {
	return o
}

func (o SilencePolicyArrayOutput) ToSilencePolicyArrayOutputWithContext(ctx context.Context) SilencePolicyArrayOutput {
	return o
}

func (o SilencePolicyArrayOutput) Index(i pulumi.IntInput) SilencePolicyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *SilencePolicy {
		return vs[0].([]*SilencePolicy)[vs[1].(int)]
	}).(SilencePolicyOutput)
}

type SilencePolicyMapOutput struct{ *pulumi.OutputState }

func (SilencePolicyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SilencePolicy)(nil)).Elem()
}

func (o SilencePolicyMapOutput) ToSilencePolicyMapOutput() SilencePolicyMapOutput {
	return o
}

func (o SilencePolicyMapOutput) ToSilencePolicyMapOutputWithContext(ctx context.Context) SilencePolicyMapOutput {
	return o
}

func (o SilencePolicyMapOutput) MapIndex(k pulumi.StringInput) SilencePolicyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *SilencePolicy {
		return vs[0].(map[string]*SilencePolicy)[vs[1].(string)]
	}).(SilencePolicyOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SilencePolicyInput)(nil)).Elem(), &SilencePolicy{})
	pulumi.RegisterInputType(reflect.TypeOf((*SilencePolicyArrayInput)(nil)).Elem(), SilencePolicyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SilencePolicyMapInput)(nil)).Elem(), SilencePolicyMap{})
	pulumi.RegisterOutputType(SilencePolicyOutput{})
	pulumi.RegisterOutputType(SilencePolicyArrayOutput{})
	pulumi.RegisterOutputType(SilencePolicyMapOutput{})
}
