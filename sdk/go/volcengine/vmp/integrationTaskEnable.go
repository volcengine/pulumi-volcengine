// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package vmp

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/volcengine/pulumi-volcengine/sdk/go/volcengine/internal"
)

// Provides a resource to manage vmp integration task enable
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/volcengine/pulumi-volcengine/sdk/go/volcengine/vmp"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// Create a VMP integration task enable
//			_, err := vmp.NewIntegrationTaskEnable(ctx, "default", &vmp.IntegrationTaskEnableArgs{
//				TaskIds: pulumi.StringArray{
//					pulumi.String("3c55cdd4-f240-4fc8-a43b-ca83ad44807a"),
//					pulumi.String("a09fdaf5-ce90-4f34-8ab3-4decd5aef8e1"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// VMP Integration Task Enable can be imported using the task ids, e.g.
//
// ```sh
// $ pulumi import volcengine:vmp/integrationTaskEnable:IntegrationTaskEnable default task-id1,task-id2
// ```
type IntegrationTaskEnable struct {
	pulumi.CustomResourceState

	// A list of integration task IDs to enable.
	TaskIds pulumi.StringArrayOutput `pulumi:"taskIds"`
}

// NewIntegrationTaskEnable registers a new resource with the given unique name, arguments, and options.
func NewIntegrationTaskEnable(ctx *pulumi.Context,
	name string, args *IntegrationTaskEnableArgs, opts ...pulumi.ResourceOption) (*IntegrationTaskEnable, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.TaskIds == nil {
		return nil, errors.New("invalid value for required argument 'TaskIds'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource IntegrationTaskEnable
	err := ctx.RegisterResource("volcengine:vmp/integrationTaskEnable:IntegrationTaskEnable", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetIntegrationTaskEnable gets an existing IntegrationTaskEnable resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetIntegrationTaskEnable(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *IntegrationTaskEnableState, opts ...pulumi.ResourceOption) (*IntegrationTaskEnable, error) {
	var resource IntegrationTaskEnable
	err := ctx.ReadResource("volcengine:vmp/integrationTaskEnable:IntegrationTaskEnable", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering IntegrationTaskEnable resources.
type integrationTaskEnableState struct {
	// A list of integration task IDs to enable.
	TaskIds []string `pulumi:"taskIds"`
}

type IntegrationTaskEnableState struct {
	// A list of integration task IDs to enable.
	TaskIds pulumi.StringArrayInput
}

func (IntegrationTaskEnableState) ElementType() reflect.Type {
	return reflect.TypeOf((*integrationTaskEnableState)(nil)).Elem()
}

type integrationTaskEnableArgs struct {
	// A list of integration task IDs to enable.
	TaskIds []string `pulumi:"taskIds"`
}

// The set of arguments for constructing a IntegrationTaskEnable resource.
type IntegrationTaskEnableArgs struct {
	// A list of integration task IDs to enable.
	TaskIds pulumi.StringArrayInput
}

func (IntegrationTaskEnableArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*integrationTaskEnableArgs)(nil)).Elem()
}

type IntegrationTaskEnableInput interface {
	pulumi.Input

	ToIntegrationTaskEnableOutput() IntegrationTaskEnableOutput
	ToIntegrationTaskEnableOutputWithContext(ctx context.Context) IntegrationTaskEnableOutput
}

func (*IntegrationTaskEnable) ElementType() reflect.Type {
	return reflect.TypeOf((**IntegrationTaskEnable)(nil)).Elem()
}

func (i *IntegrationTaskEnable) ToIntegrationTaskEnableOutput() IntegrationTaskEnableOutput {
	return i.ToIntegrationTaskEnableOutputWithContext(context.Background())
}

func (i *IntegrationTaskEnable) ToIntegrationTaskEnableOutputWithContext(ctx context.Context) IntegrationTaskEnableOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IntegrationTaskEnableOutput)
}

// IntegrationTaskEnableArrayInput is an input type that accepts IntegrationTaskEnableArray and IntegrationTaskEnableArrayOutput values.
// You can construct a concrete instance of `IntegrationTaskEnableArrayInput` via:
//
//	IntegrationTaskEnableArray{ IntegrationTaskEnableArgs{...} }
type IntegrationTaskEnableArrayInput interface {
	pulumi.Input

	ToIntegrationTaskEnableArrayOutput() IntegrationTaskEnableArrayOutput
	ToIntegrationTaskEnableArrayOutputWithContext(context.Context) IntegrationTaskEnableArrayOutput
}

type IntegrationTaskEnableArray []IntegrationTaskEnableInput

func (IntegrationTaskEnableArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*IntegrationTaskEnable)(nil)).Elem()
}

func (i IntegrationTaskEnableArray) ToIntegrationTaskEnableArrayOutput() IntegrationTaskEnableArrayOutput {
	return i.ToIntegrationTaskEnableArrayOutputWithContext(context.Background())
}

func (i IntegrationTaskEnableArray) ToIntegrationTaskEnableArrayOutputWithContext(ctx context.Context) IntegrationTaskEnableArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IntegrationTaskEnableArrayOutput)
}

// IntegrationTaskEnableMapInput is an input type that accepts IntegrationTaskEnableMap and IntegrationTaskEnableMapOutput values.
// You can construct a concrete instance of `IntegrationTaskEnableMapInput` via:
//
//	IntegrationTaskEnableMap{ "key": IntegrationTaskEnableArgs{...} }
type IntegrationTaskEnableMapInput interface {
	pulumi.Input

	ToIntegrationTaskEnableMapOutput() IntegrationTaskEnableMapOutput
	ToIntegrationTaskEnableMapOutputWithContext(context.Context) IntegrationTaskEnableMapOutput
}

type IntegrationTaskEnableMap map[string]IntegrationTaskEnableInput

func (IntegrationTaskEnableMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*IntegrationTaskEnable)(nil)).Elem()
}

func (i IntegrationTaskEnableMap) ToIntegrationTaskEnableMapOutput() IntegrationTaskEnableMapOutput {
	return i.ToIntegrationTaskEnableMapOutputWithContext(context.Background())
}

func (i IntegrationTaskEnableMap) ToIntegrationTaskEnableMapOutputWithContext(ctx context.Context) IntegrationTaskEnableMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IntegrationTaskEnableMapOutput)
}

type IntegrationTaskEnableOutput struct{ *pulumi.OutputState }

func (IntegrationTaskEnableOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IntegrationTaskEnable)(nil)).Elem()
}

func (o IntegrationTaskEnableOutput) ToIntegrationTaskEnableOutput() IntegrationTaskEnableOutput {
	return o
}

func (o IntegrationTaskEnableOutput) ToIntegrationTaskEnableOutputWithContext(ctx context.Context) IntegrationTaskEnableOutput {
	return o
}

// A list of integration task IDs to enable.
func (o IntegrationTaskEnableOutput) TaskIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *IntegrationTaskEnable) pulumi.StringArrayOutput { return v.TaskIds }).(pulumi.StringArrayOutput)
}

type IntegrationTaskEnableArrayOutput struct{ *pulumi.OutputState }

func (IntegrationTaskEnableArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*IntegrationTaskEnable)(nil)).Elem()
}

func (o IntegrationTaskEnableArrayOutput) ToIntegrationTaskEnableArrayOutput() IntegrationTaskEnableArrayOutput {
	return o
}

func (o IntegrationTaskEnableArrayOutput) ToIntegrationTaskEnableArrayOutputWithContext(ctx context.Context) IntegrationTaskEnableArrayOutput {
	return o
}

func (o IntegrationTaskEnableArrayOutput) Index(i pulumi.IntInput) IntegrationTaskEnableOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *IntegrationTaskEnable {
		return vs[0].([]*IntegrationTaskEnable)[vs[1].(int)]
	}).(IntegrationTaskEnableOutput)
}

type IntegrationTaskEnableMapOutput struct{ *pulumi.OutputState }

func (IntegrationTaskEnableMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*IntegrationTaskEnable)(nil)).Elem()
}

func (o IntegrationTaskEnableMapOutput) ToIntegrationTaskEnableMapOutput() IntegrationTaskEnableMapOutput {
	return o
}

func (o IntegrationTaskEnableMapOutput) ToIntegrationTaskEnableMapOutputWithContext(ctx context.Context) IntegrationTaskEnableMapOutput {
	return o
}

func (o IntegrationTaskEnableMapOutput) MapIndex(k pulumi.StringInput) IntegrationTaskEnableOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *IntegrationTaskEnable {
		return vs[0].(map[string]*IntegrationTaskEnable)[vs[1].(string)]
	}).(IntegrationTaskEnableOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*IntegrationTaskEnableInput)(nil)).Elem(), &IntegrationTaskEnable{})
	pulumi.RegisterInputType(reflect.TypeOf((*IntegrationTaskEnableArrayInput)(nil)).Elem(), IntegrationTaskEnableArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*IntegrationTaskEnableMapInput)(nil)).Elem(), IntegrationTaskEnableMap{})
	pulumi.RegisterOutputType(IntegrationTaskEnableOutput{})
	pulumi.RegisterOutputType(IntegrationTaskEnableArrayOutput{})
	pulumi.RegisterOutputType(IntegrationTaskEnableMapOutput{})
}
