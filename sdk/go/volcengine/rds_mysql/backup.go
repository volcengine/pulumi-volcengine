// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package rds_mysql

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/volcengine/pulumi-volcengine/sdk/go/volcengine/internal"
)

// Provides a resource to manage rds mysql backup
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/volcengine/pulumi-volcengine/sdk/go/volcengine/rds_mysql"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := rds_mysql.NewBackup(ctx, "foo", &rds_mysql.BackupArgs{
//				BackupMetas: rds_mysql.BackupBackupMetaArray{
//					&rds_mysql.BackupBackupMetaArgs{
//						DbName: pulumi.String("order"),
//					},
//				},
//				BackupMethod: pulumi.String("Logical"),
//				InstanceId:   pulumi.String("mysql-c8c3f45c4b07"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// RdsMysqlBackup can be imported using the id, e.g.
//
// ```sh
// $ pulumi import volcengine:rds_mysql/backup:Backup default instanceId:backupId
// ```
type Backup struct {
	pulumi.CustomResourceState

	// The id of the backup.
	BackupId pulumi.StringOutput `pulumi:"backupId"`
	// When creating a library table backup of logical backup type, it is used to specify the library table information to be backed up.
	// Prerequisite: When the value of BackupMethod is Logical, and the BackupType field is not passed.
	// Mutual exclusion situation: When the value of the BackupType field is DumpAll, this field is not effective.
	// Quantity limit: When creating a specified library table backup, the upper limit of the number of libraries is 5000, and the upper limit of the number of tables in each library is 5000.
	BackupMetas BackupBackupMetaArrayOutput `pulumi:"backupMetas"`
	// Backup method. Value range: Full, full backup under physical backup type. Default value. DumpAll: full database backup under logical backup type. Prerequisite: If you need to create a full database backup of logical backup type, that is, when the value of BackupType is DumpAll, the backup type should be set to logical backup, that is, the value of BackupMethod should be Logical. If you need to create a database table backup of logical backup type, you do not need to pass in this field. You only need to specify the database and table to be backed up in the BackupMeta field.
	BackupMethod pulumi.StringOutput `pulumi:"backupMethod"`
	// Backup type. Currently, only full backup is supported. The value is Full.
	BackupType pulumi.StringOutput `pulumi:"backupType"`
	// The id of the instance.
	InstanceId pulumi.StringOutput `pulumi:"instanceId"`
}

// NewBackup registers a new resource with the given unique name, arguments, and options.
func NewBackup(ctx *pulumi.Context,
	name string, args *BackupArgs, opts ...pulumi.ResourceOption) (*Backup, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.InstanceId == nil {
		return nil, errors.New("invalid value for required argument 'InstanceId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Backup
	err := ctx.RegisterResource("volcengine:rds_mysql/backup:Backup", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetBackup gets an existing Backup resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetBackup(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *BackupState, opts ...pulumi.ResourceOption) (*Backup, error) {
	var resource Backup
	err := ctx.ReadResource("volcengine:rds_mysql/backup:Backup", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Backup resources.
type backupState struct {
	// The id of the backup.
	BackupId *string `pulumi:"backupId"`
	// When creating a library table backup of logical backup type, it is used to specify the library table information to be backed up.
	// Prerequisite: When the value of BackupMethod is Logical, and the BackupType field is not passed.
	// Mutual exclusion situation: When the value of the BackupType field is DumpAll, this field is not effective.
	// Quantity limit: When creating a specified library table backup, the upper limit of the number of libraries is 5000, and the upper limit of the number of tables in each library is 5000.
	BackupMetas []BackupBackupMeta `pulumi:"backupMetas"`
	// Backup method. Value range: Full, full backup under physical backup type. Default value. DumpAll: full database backup under logical backup type. Prerequisite: If you need to create a full database backup of logical backup type, that is, when the value of BackupType is DumpAll, the backup type should be set to logical backup, that is, the value of BackupMethod should be Logical. If you need to create a database table backup of logical backup type, you do not need to pass in this field. You only need to specify the database and table to be backed up in the BackupMeta field.
	BackupMethod *string `pulumi:"backupMethod"`
	// Backup type. Currently, only full backup is supported. The value is Full.
	BackupType *string `pulumi:"backupType"`
	// The id of the instance.
	InstanceId *string `pulumi:"instanceId"`
}

type BackupState struct {
	// The id of the backup.
	BackupId pulumi.StringPtrInput
	// When creating a library table backup of logical backup type, it is used to specify the library table information to be backed up.
	// Prerequisite: When the value of BackupMethod is Logical, and the BackupType field is not passed.
	// Mutual exclusion situation: When the value of the BackupType field is DumpAll, this field is not effective.
	// Quantity limit: When creating a specified library table backup, the upper limit of the number of libraries is 5000, and the upper limit of the number of tables in each library is 5000.
	BackupMetas BackupBackupMetaArrayInput
	// Backup method. Value range: Full, full backup under physical backup type. Default value. DumpAll: full database backup under logical backup type. Prerequisite: If you need to create a full database backup of logical backup type, that is, when the value of BackupType is DumpAll, the backup type should be set to logical backup, that is, the value of BackupMethod should be Logical. If you need to create a database table backup of logical backup type, you do not need to pass in this field. You only need to specify the database and table to be backed up in the BackupMeta field.
	BackupMethod pulumi.StringPtrInput
	// Backup type. Currently, only full backup is supported. The value is Full.
	BackupType pulumi.StringPtrInput
	// The id of the instance.
	InstanceId pulumi.StringPtrInput
}

func (BackupState) ElementType() reflect.Type {
	return reflect.TypeOf((*backupState)(nil)).Elem()
}

type backupArgs struct {
	// When creating a library table backup of logical backup type, it is used to specify the library table information to be backed up.
	// Prerequisite: When the value of BackupMethod is Logical, and the BackupType field is not passed.
	// Mutual exclusion situation: When the value of the BackupType field is DumpAll, this field is not effective.
	// Quantity limit: When creating a specified library table backup, the upper limit of the number of libraries is 5000, and the upper limit of the number of tables in each library is 5000.
	BackupMetas []BackupBackupMeta `pulumi:"backupMetas"`
	// Backup method. Value range: Full, full backup under physical backup type. Default value. DumpAll: full database backup under logical backup type. Prerequisite: If you need to create a full database backup of logical backup type, that is, when the value of BackupType is DumpAll, the backup type should be set to logical backup, that is, the value of BackupMethod should be Logical. If you need to create a database table backup of logical backup type, you do not need to pass in this field. You only need to specify the database and table to be backed up in the BackupMeta field.
	BackupMethod *string `pulumi:"backupMethod"`
	// Backup type. Currently, only full backup is supported. The value is Full.
	BackupType *string `pulumi:"backupType"`
	// The id of the instance.
	InstanceId string `pulumi:"instanceId"`
}

// The set of arguments for constructing a Backup resource.
type BackupArgs struct {
	// When creating a library table backup of logical backup type, it is used to specify the library table information to be backed up.
	// Prerequisite: When the value of BackupMethod is Logical, and the BackupType field is not passed.
	// Mutual exclusion situation: When the value of the BackupType field is DumpAll, this field is not effective.
	// Quantity limit: When creating a specified library table backup, the upper limit of the number of libraries is 5000, and the upper limit of the number of tables in each library is 5000.
	BackupMetas BackupBackupMetaArrayInput
	// Backup method. Value range: Full, full backup under physical backup type. Default value. DumpAll: full database backup under logical backup type. Prerequisite: If you need to create a full database backup of logical backup type, that is, when the value of BackupType is DumpAll, the backup type should be set to logical backup, that is, the value of BackupMethod should be Logical. If you need to create a database table backup of logical backup type, you do not need to pass in this field. You only need to specify the database and table to be backed up in the BackupMeta field.
	BackupMethod pulumi.StringPtrInput
	// Backup type. Currently, only full backup is supported. The value is Full.
	BackupType pulumi.StringPtrInput
	// The id of the instance.
	InstanceId pulumi.StringInput
}

func (BackupArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*backupArgs)(nil)).Elem()
}

type BackupInput interface {
	pulumi.Input

	ToBackupOutput() BackupOutput
	ToBackupOutputWithContext(ctx context.Context) BackupOutput
}

func (*Backup) ElementType() reflect.Type {
	return reflect.TypeOf((**Backup)(nil)).Elem()
}

func (i *Backup) ToBackupOutput() BackupOutput {
	return i.ToBackupOutputWithContext(context.Background())
}

func (i *Backup) ToBackupOutputWithContext(ctx context.Context) BackupOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BackupOutput)
}

// BackupArrayInput is an input type that accepts BackupArray and BackupArrayOutput values.
// You can construct a concrete instance of `BackupArrayInput` via:
//
//	BackupArray{ BackupArgs{...} }
type BackupArrayInput interface {
	pulumi.Input

	ToBackupArrayOutput() BackupArrayOutput
	ToBackupArrayOutputWithContext(context.Context) BackupArrayOutput
}

type BackupArray []BackupInput

func (BackupArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Backup)(nil)).Elem()
}

func (i BackupArray) ToBackupArrayOutput() BackupArrayOutput {
	return i.ToBackupArrayOutputWithContext(context.Background())
}

func (i BackupArray) ToBackupArrayOutputWithContext(ctx context.Context) BackupArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BackupArrayOutput)
}

// BackupMapInput is an input type that accepts BackupMap and BackupMapOutput values.
// You can construct a concrete instance of `BackupMapInput` via:
//
//	BackupMap{ "key": BackupArgs{...} }
type BackupMapInput interface {
	pulumi.Input

	ToBackupMapOutput() BackupMapOutput
	ToBackupMapOutputWithContext(context.Context) BackupMapOutput
}

type BackupMap map[string]BackupInput

func (BackupMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Backup)(nil)).Elem()
}

func (i BackupMap) ToBackupMapOutput() BackupMapOutput {
	return i.ToBackupMapOutputWithContext(context.Background())
}

func (i BackupMap) ToBackupMapOutputWithContext(ctx context.Context) BackupMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BackupMapOutput)
}

type BackupOutput struct{ *pulumi.OutputState }

func (BackupOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Backup)(nil)).Elem()
}

func (o BackupOutput) ToBackupOutput() BackupOutput {
	return o
}

func (o BackupOutput) ToBackupOutputWithContext(ctx context.Context) BackupOutput {
	return o
}

// The id of the backup.
func (o BackupOutput) BackupId() pulumi.StringOutput {
	return o.ApplyT(func(v *Backup) pulumi.StringOutput { return v.BackupId }).(pulumi.StringOutput)
}

// When creating a library table backup of logical backup type, it is used to specify the library table information to be backed up.
// Prerequisite: When the value of BackupMethod is Logical, and the BackupType field is not passed.
// Mutual exclusion situation: When the value of the BackupType field is DumpAll, this field is not effective.
// Quantity limit: When creating a specified library table backup, the upper limit of the number of libraries is 5000, and the upper limit of the number of tables in each library is 5000.
func (o BackupOutput) BackupMetas() BackupBackupMetaArrayOutput {
	return o.ApplyT(func(v *Backup) BackupBackupMetaArrayOutput { return v.BackupMetas }).(BackupBackupMetaArrayOutput)
}

// Backup method. Value range: Full, full backup under physical backup type. Default value. DumpAll: full database backup under logical backup type. Prerequisite: If you need to create a full database backup of logical backup type, that is, when the value of BackupType is DumpAll, the backup type should be set to logical backup, that is, the value of BackupMethod should be Logical. If you need to create a database table backup of logical backup type, you do not need to pass in this field. You only need to specify the database and table to be backed up in the BackupMeta field.
func (o BackupOutput) BackupMethod() pulumi.StringOutput {
	return o.ApplyT(func(v *Backup) pulumi.StringOutput { return v.BackupMethod }).(pulumi.StringOutput)
}

// Backup type. Currently, only full backup is supported. The value is Full.
func (o BackupOutput) BackupType() pulumi.StringOutput {
	return o.ApplyT(func(v *Backup) pulumi.StringOutput { return v.BackupType }).(pulumi.StringOutput)
}

// The id of the instance.
func (o BackupOutput) InstanceId() pulumi.StringOutput {
	return o.ApplyT(func(v *Backup) pulumi.StringOutput { return v.InstanceId }).(pulumi.StringOutput)
}

type BackupArrayOutput struct{ *pulumi.OutputState }

func (BackupArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Backup)(nil)).Elem()
}

func (o BackupArrayOutput) ToBackupArrayOutput() BackupArrayOutput {
	return o
}

func (o BackupArrayOutput) ToBackupArrayOutputWithContext(ctx context.Context) BackupArrayOutput {
	return o
}

func (o BackupArrayOutput) Index(i pulumi.IntInput) BackupOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Backup {
		return vs[0].([]*Backup)[vs[1].(int)]
	}).(BackupOutput)
}

type BackupMapOutput struct{ *pulumi.OutputState }

func (BackupMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Backup)(nil)).Elem()
}

func (o BackupMapOutput) ToBackupMapOutput() BackupMapOutput {
	return o
}

func (o BackupMapOutput) ToBackupMapOutputWithContext(ctx context.Context) BackupMapOutput {
	return o
}

func (o BackupMapOutput) MapIndex(k pulumi.StringInput) BackupOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Backup {
		return vs[0].(map[string]*Backup)[vs[1].(string)]
	}).(BackupOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*BackupInput)(nil)).Elem(), &Backup{})
	pulumi.RegisterInputType(reflect.TypeOf((*BackupArrayInput)(nil)).Elem(), BackupArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*BackupMapInput)(nil)).Elem(), BackupMap{})
	pulumi.RegisterOutputType(BackupOutput{})
	pulumi.RegisterOutputType(BackupArrayOutput{})
	pulumi.RegisterOutputType(BackupMapOutput{})
}
