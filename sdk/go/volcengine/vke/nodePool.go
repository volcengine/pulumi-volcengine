// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package vke

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/volcengine/pulumi-volcengine/sdk/go/volcengine/internal"
)

// Provides a resource to manage vke node pool
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"fmt"
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/volcengine/pulumi-volcengine/sdk/go/volcengine/ecs"
//	"github.com/volcengine/pulumi-volcengine/sdk/go/volcengine/vke"
//	"github.com/volcengine/pulumi-volcengine/sdk/go/volcengine/vpc"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			fooZones, err := ecs.Zones(ctx, nil, nil)
//			if err != nil {
//				return err
//			}
//			fooVpc, err := vpc.NewVpc(ctx, "fooVpc", &vpc.VpcArgs{
//				VpcName:   pulumi.String("acc-test-vpc"),
//				CidrBlock: pulumi.String("172.16.0.0/16"),
//			})
//			if err != nil {
//				return err
//			}
//			fooSubnet, err := vpc.NewSubnet(ctx, "fooSubnet", &vpc.SubnetArgs{
//				SubnetName: pulumi.String("acc-test-subnet"),
//				CidrBlock:  pulumi.String("172.16.0.0/24"),
//				ZoneId:     *pulumi.String(fooZones.Zones[0].Id),
//				VpcId:      fooVpc.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			fooSecurityGroup, err := vpc.NewSecurityGroup(ctx, "fooSecurityGroup", &vpc.SecurityGroupArgs{
//				SecurityGroupName: pulumi.String("acc-test-security-group"),
//				VpcId:             fooVpc.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			fooImages, err := ecs.Images(ctx, &ecs.ImagesArgs{
//				NameRegex: pulumi.StringRef("veLinux 1.0 CentOS兼容版 64位"),
//			}, nil)
//			if err != nil {
//				return err
//			}
//			fooCluster, err := vke.NewCluster(ctx, "fooCluster", &vke.ClusterArgs{
//				Description:             pulumi.String("created by terraform"),
//				DeleteProtectionEnabled: pulumi.Bool(false),
//				ClusterConfig: &vke.ClusterClusterConfigArgs{
//					SubnetIds: pulumi.StringArray{
//						fooSubnet.ID(),
//					},
//					ApiServerPublicAccessEnabled: pulumi.Bool(true),
//					ApiServerPublicAccessConfig: &vke.ClusterClusterConfigApiServerPublicAccessConfigArgs{
//						PublicAccessNetworkConfig: &vke.ClusterClusterConfigApiServerPublicAccessConfigPublicAccessNetworkConfigArgs{
//							BillingType: pulumi.String("PostPaidByBandwidth"),
//							Bandwidth:   pulumi.Int(1),
//						},
//					},
//					ResourcePublicAccessDefaultEnabled: pulumi.Bool(true),
//				},
//				PodsConfig: &vke.ClusterPodsConfigArgs{
//					PodNetworkMode: pulumi.String("VpcCniShared"),
//					VpcCniConfig: &vke.ClusterPodsConfigVpcCniConfigArgs{
//						SubnetIds: pulumi.StringArray{
//							fooSubnet.ID(),
//						},
//					},
//				},
//				ServicesConfig: &vke.ClusterServicesConfigArgs{
//					ServiceCidrsv4s: pulumi.StringArray{
//						pulumi.String("172.30.0.0/18"),
//					},
//				},
//				Tags: vke.ClusterTagArray{
//					&vke.ClusterTagArgs{
//						Key:   pulumi.String("tf-k1"),
//						Value: pulumi.String("tf-v1"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = vke.NewNodePool(ctx, "fooNodePool", &vke.NodePoolArgs{
//				ClusterId: fooCluster.ID(),
//				AutoScaling: &vke.NodePoolAutoScalingArgs{
//					Enabled:         pulumi.Bool(true),
//					MinReplicas:     pulumi.Int(0),
//					MaxReplicas:     pulumi.Int(5),
//					DesiredReplicas: pulumi.Int(0),
//					Priority:        pulumi.Int(5),
//					SubnetPolicy:    pulumi.String("ZoneBalance"),
//				},
//				NodeConfig: &vke.NodePoolNodeConfigArgs{
//					InstanceTypeIds: pulumi.StringArray{
//						pulumi.String("ecs.g1ie.xlarge"),
//					},
//					SubnetIds: pulumi.StringArray{
//						fooSubnet.ID(),
//					},
//					ImageId: "TODO: For expression"[0],
//					SystemVolume: &vke.NodePoolNodeConfigSystemVolumeArgs{
//						Type: pulumi.String("ESSD_PL0"),
//						Size: pulumi.Int(80),
//					},
//					DataVolumes: vke.NodePoolNodeConfigDataVolumeArray{
//						&vke.NodePoolNodeConfigDataVolumeArgs{
//							Type:       pulumi.String("ESSD_PL0"),
//							Size:       pulumi.Int(80),
//							MountPoint: pulumi.String("/tf1"),
//						},
//						&vke.NodePoolNodeConfigDataVolumeArgs{
//							Type:       pulumi.String("ESSD_PL0"),
//							Size:       pulumi.Int(60),
//							MountPoint: pulumi.String("/tf2"),
//						},
//					},
//					InitializeScript: pulumi.String("ZWNobyBoZWxsbyB0ZXJyYWZvcm0h"),
//					Security: &vke.NodePoolNodeConfigSecurityArgs{
//						Login: &vke.NodePoolNodeConfigSecurityLoginArgs{
//							Password: pulumi.String("UHdkMTIzNDU2"),
//						},
//						SecurityStrategies: pulumi.StringArray{
//							pulumi.String("Hids"),
//						},
//						SecurityGroupIds: pulumi.StringArray{
//							fooSecurityGroup.ID(),
//						},
//					},
//					AdditionalContainerStorageEnabled: pulumi.Bool(false),
//					InstanceChargeType:                pulumi.String("PostPaid"),
//					NamePrefix:                        pulumi.String("acc-test"),
//					EcsTags: vke.NodePoolNodeConfigEcsTagArray{
//						&vke.NodePoolNodeConfigEcsTagArgs{
//							Key:   pulumi.String("ecs_k1"),
//							Value: pulumi.String("ecs_v1"),
//						},
//					},
//				},
//				KubernetesConfig: &vke.NodePoolKubernetesConfigArgs{
//					Labels: vke.NodePoolKubernetesConfigLabelArray{
//						&vke.NodePoolKubernetesConfigLabelArgs{
//							Key:   pulumi.String("label1"),
//							Value: pulumi.String("value1"),
//						},
//					},
//					Taints: vke.NodePoolKubernetesConfigTaintArray{
//						&vke.NodePoolKubernetesConfigTaintArgs{
//							Key:    pulumi.String("taint-key/node-type"),
//							Value:  pulumi.String("taint-value"),
//							Effect: pulumi.String("NoSchedule"),
//						},
//					},
//					Cordon: pulumi.Bool(true),
//				},
//				Tags: vke.NodePoolTagArray{
//					&vke.NodePoolTagArgs{
//						Key:   pulumi.String("node-pool-k1"),
//						Value: pulumi.String("node-pool-v1"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			var fooInstance []*ecs.Instance
//			for index := 0; index < 2; index++ {
//				key0 := index
//				val0 := index
//				__res, err := ecs.NewInstance(ctx, fmt.Sprintf("fooInstance-%v", key0), &ecs.InstanceArgs{
//					InstanceName:       pulumi.String(fmt.Sprintf("acc-test-ecs-%v", val0)),
//					HostName:           pulumi.String("tf-acc-test"),
//					ImageId:            "TODO: For expression"[0],
//					InstanceType:       pulumi.String("ecs.g1ie.xlarge"),
//					Password:           pulumi.String("93f0cb0614Aab12"),
//					InstanceChargeType: pulumi.String("PostPaid"),
//					SystemVolumeType:   pulumi.String("ESSD_PL0"),
//					SystemVolumeSize:   pulumi.Int(50),
//					DataVolumes: ecs.InstanceDataVolumeArray{
//						&ecs.InstanceDataVolumeArgs{
//							VolumeType:         pulumi.String("ESSD_PL0"),
//							Size:               pulumi.Int(50),
//							DeleteWithInstance: pulumi.Bool(true),
//						},
//					},
//					SubnetId: fooSubnet.ID(),
//					SecurityGroupIds: pulumi.StringArray{
//						fooSecurityGroup.ID(),
//					},
//					ProjectName: pulumi.String("default"),
//					Tags: ecs.InstanceTagArray{
//						&ecs.InstanceTagArgs{
//							Key:   pulumi.String("k1"),
//							Value: pulumi.String("v1"),
//						},
//					},
//				})
//				if err != nil {
//					return err
//				}
//				fooInstance = append(fooInstance, __res)
//			}
//			var splat0 pulumi.StringArray
//			for _, val0 := range fooInstance {
//				splat0 = append(splat0, val0.ID())
//			}
//			_, err = vke.NewNodePool(ctx, "foo1", &vke.NodePoolArgs{
//				ClusterId:        fooCluster.ID(),
//				InstanceIds:      splat0,
//				KeepInstanceName: pulumi.Bool(true),
//				NodeConfig: &vke.NodePoolNodeConfigArgs{
//					InstanceTypeIds: pulumi.StringArray{
//						pulumi.String("ecs.g1ie.xlarge"),
//					},
//					SubnetIds: pulumi.StringArray{
//						fooSubnet.ID(),
//					},
//					ImageId: "TODO: For expression"[0],
//					SystemVolume: &vke.NodePoolNodeConfigSystemVolumeArgs{
//						Type: pulumi.String("ESSD_PL0"),
//						Size: pulumi.Int(50),
//					},
//					DataVolumes: vke.NodePoolNodeConfigDataVolumeArray{
//						&vke.NodePoolNodeConfigDataVolumeArgs{
//							Type:       pulumi.String("ESSD_PL0"),
//							Size:       pulumi.Int(50),
//							MountPoint: pulumi.String("/tf1"),
//						},
//					},
//					InitializeScript: pulumi.String("ZWNobyBoZWxsbyB0ZXJyYWZvcm0h"),
//					Security: &vke.NodePoolNodeConfigSecurityArgs{
//						Login: &vke.NodePoolNodeConfigSecurityLoginArgs{
//							Password: pulumi.String("UHdkMTIzNDU2"),
//						},
//						SecurityStrategies: pulumi.StringArray{
//							pulumi.String("Hids"),
//						},
//						SecurityGroupIds: pulumi.StringArray{
//							fooSecurityGroup.ID(),
//						},
//					},
//					AdditionalContainerStorageEnabled: pulumi.Bool(false),
//					InstanceChargeType:                pulumi.String("PostPaid"),
//					NamePrefix:                        pulumi.String("acc-test"),
//					EcsTags: vke.NodePoolNodeConfigEcsTagArray{
//						&vke.NodePoolNodeConfigEcsTagArgs{
//							Key:   pulumi.String("ecs_k1"),
//							Value: pulumi.String("ecs_v1"),
//						},
//					},
//				},
//				KubernetesConfig: &vke.NodePoolKubernetesConfigArgs{
//					Labels: vke.NodePoolKubernetesConfigLabelArray{
//						&vke.NodePoolKubernetesConfigLabelArgs{
//							Key:   pulumi.String("label1"),
//							Value: pulumi.String("value1"),
//						},
//					},
//					Taints: vke.NodePoolKubernetesConfigTaintArray{
//						&vke.NodePoolKubernetesConfigTaintArgs{
//							Key:    pulumi.String("taint-key/node-type"),
//							Value:  pulumi.String("taint-value"),
//							Effect: pulumi.String("NoSchedule"),
//						},
//					},
//					Cordon: pulumi.Bool(true),
//				},
//				Tags: vke.NodePoolTagArray{
//					&vke.NodePoolTagArgs{
//						Key:   pulumi.String("node-pool-k1"),
//						Value: pulumi.String("node-pool-v1"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// NodePool can be imported using the id, e.g.
//
// ```sh
//
//	$ pulumi import volcengine:vke/nodePool:NodePool default pcabe57vqtofgrbln3dp0
//
// ```
type NodePool struct {
	pulumi.CustomResourceState

	// The node pool elastic scaling configuration information.
	AutoScaling NodePoolAutoScalingOutput `pulumi:"autoScaling"`
	// The ClientToken of NodePool.
	ClientToken pulumi.StringPtrOutput `pulumi:"clientToken"`
	// The ClusterId of NodePool.
	ClusterId pulumi.StringPtrOutput `pulumi:"clusterId"`
	// The list of existing ECS instance ids. Add existing instances with same type of security group under the same cluster VPC to the custom node pool.
	// Note that removing instance ids from the list will only remove the nodes from cluster and not release the ECS instances. But deleting node pool will release the ECS instances in it.
	// It is not recommended to use this field, it is recommended to use `vke.Node` resource to add an existing instance to a custom node pool.
	InstanceIds pulumi.StringArrayOutput `pulumi:"instanceIds"`
	// Whether to keep instance name when adding an existing instance to a custom node pool, the value is `true` or `false`.
	// This field is valid only when adding new instances to the custom node pool.
	KeepInstanceName pulumi.BoolPtrOutput `pulumi:"keepInstanceName"`
	// The KubernetesConfig of NodeConfig.
	KubernetesConfig NodePoolKubernetesConfigOutput `pulumi:"kubernetesConfig"`
	// The Name of NodePool.
	Name pulumi.StringOutput `pulumi:"name"`
	// The Config of NodePool.
	NodeConfig NodePoolNodeConfigOutput `pulumi:"nodeConfig"`
	// The NodeStatistics of NodeConfig.
	NodeStatistics NodePoolNodeStatisticArrayOutput `pulumi:"nodeStatistics"`
	// Tags.
	Tags NodePoolTagArrayOutput `pulumi:"tags"`
}

// NewNodePool registers a new resource with the given unique name, arguments, and options.
func NewNodePool(ctx *pulumi.Context,
	name string, args *NodePoolArgs, opts ...pulumi.ResourceOption) (*NodePool, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.KubernetesConfig == nil {
		return nil, errors.New("invalid value for required argument 'KubernetesConfig'")
	}
	if args.NodeConfig == nil {
		return nil, errors.New("invalid value for required argument 'NodeConfig'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource NodePool
	err := ctx.RegisterResource("volcengine:vke/nodePool:NodePool", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetNodePool gets an existing NodePool resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetNodePool(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *NodePoolState, opts ...pulumi.ResourceOption) (*NodePool, error) {
	var resource NodePool
	err := ctx.ReadResource("volcengine:vke/nodePool:NodePool", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering NodePool resources.
type nodePoolState struct {
	// The node pool elastic scaling configuration information.
	AutoScaling *NodePoolAutoScaling `pulumi:"autoScaling"`
	// The ClientToken of NodePool.
	ClientToken *string `pulumi:"clientToken"`
	// The ClusterId of NodePool.
	ClusterId *string `pulumi:"clusterId"`
	// The list of existing ECS instance ids. Add existing instances with same type of security group under the same cluster VPC to the custom node pool.
	// Note that removing instance ids from the list will only remove the nodes from cluster and not release the ECS instances. But deleting node pool will release the ECS instances in it.
	// It is not recommended to use this field, it is recommended to use `vke.Node` resource to add an existing instance to a custom node pool.
	InstanceIds []string `pulumi:"instanceIds"`
	// Whether to keep instance name when adding an existing instance to a custom node pool, the value is `true` or `false`.
	// This field is valid only when adding new instances to the custom node pool.
	KeepInstanceName *bool `pulumi:"keepInstanceName"`
	// The KubernetesConfig of NodeConfig.
	KubernetesConfig *NodePoolKubernetesConfig `pulumi:"kubernetesConfig"`
	// The Name of NodePool.
	Name *string `pulumi:"name"`
	// The Config of NodePool.
	NodeConfig *NodePoolNodeConfig `pulumi:"nodeConfig"`
	// The NodeStatistics of NodeConfig.
	NodeStatistics []NodePoolNodeStatistic `pulumi:"nodeStatistics"`
	// Tags.
	Tags []NodePoolTag `pulumi:"tags"`
}

type NodePoolState struct {
	// The node pool elastic scaling configuration information.
	AutoScaling NodePoolAutoScalingPtrInput
	// The ClientToken of NodePool.
	ClientToken pulumi.StringPtrInput
	// The ClusterId of NodePool.
	ClusterId pulumi.StringPtrInput
	// The list of existing ECS instance ids. Add existing instances with same type of security group under the same cluster VPC to the custom node pool.
	// Note that removing instance ids from the list will only remove the nodes from cluster and not release the ECS instances. But deleting node pool will release the ECS instances in it.
	// It is not recommended to use this field, it is recommended to use `vke.Node` resource to add an existing instance to a custom node pool.
	InstanceIds pulumi.StringArrayInput
	// Whether to keep instance name when adding an existing instance to a custom node pool, the value is `true` or `false`.
	// This field is valid only when adding new instances to the custom node pool.
	KeepInstanceName pulumi.BoolPtrInput
	// The KubernetesConfig of NodeConfig.
	KubernetesConfig NodePoolKubernetesConfigPtrInput
	// The Name of NodePool.
	Name pulumi.StringPtrInput
	// The Config of NodePool.
	NodeConfig NodePoolNodeConfigPtrInput
	// The NodeStatistics of NodeConfig.
	NodeStatistics NodePoolNodeStatisticArrayInput
	// Tags.
	Tags NodePoolTagArrayInput
}

func (NodePoolState) ElementType() reflect.Type {
	return reflect.TypeOf((*nodePoolState)(nil)).Elem()
}

type nodePoolArgs struct {
	// The node pool elastic scaling configuration information.
	AutoScaling *NodePoolAutoScaling `pulumi:"autoScaling"`
	// The ClientToken of NodePool.
	ClientToken *string `pulumi:"clientToken"`
	// The ClusterId of NodePool.
	ClusterId *string `pulumi:"clusterId"`
	// The list of existing ECS instance ids. Add existing instances with same type of security group under the same cluster VPC to the custom node pool.
	// Note that removing instance ids from the list will only remove the nodes from cluster and not release the ECS instances. But deleting node pool will release the ECS instances in it.
	// It is not recommended to use this field, it is recommended to use `vke.Node` resource to add an existing instance to a custom node pool.
	InstanceIds []string `pulumi:"instanceIds"`
	// Whether to keep instance name when adding an existing instance to a custom node pool, the value is `true` or `false`.
	// This field is valid only when adding new instances to the custom node pool.
	KeepInstanceName *bool `pulumi:"keepInstanceName"`
	// The KubernetesConfig of NodeConfig.
	KubernetesConfig NodePoolKubernetesConfig `pulumi:"kubernetesConfig"`
	// The Name of NodePool.
	Name *string `pulumi:"name"`
	// The Config of NodePool.
	NodeConfig NodePoolNodeConfig `pulumi:"nodeConfig"`
	// Tags.
	Tags []NodePoolTag `pulumi:"tags"`
}

// The set of arguments for constructing a NodePool resource.
type NodePoolArgs struct {
	// The node pool elastic scaling configuration information.
	AutoScaling NodePoolAutoScalingPtrInput
	// The ClientToken of NodePool.
	ClientToken pulumi.StringPtrInput
	// The ClusterId of NodePool.
	ClusterId pulumi.StringPtrInput
	// The list of existing ECS instance ids. Add existing instances with same type of security group under the same cluster VPC to the custom node pool.
	// Note that removing instance ids from the list will only remove the nodes from cluster and not release the ECS instances. But deleting node pool will release the ECS instances in it.
	// It is not recommended to use this field, it is recommended to use `vke.Node` resource to add an existing instance to a custom node pool.
	InstanceIds pulumi.StringArrayInput
	// Whether to keep instance name when adding an existing instance to a custom node pool, the value is `true` or `false`.
	// This field is valid only when adding new instances to the custom node pool.
	KeepInstanceName pulumi.BoolPtrInput
	// The KubernetesConfig of NodeConfig.
	KubernetesConfig NodePoolKubernetesConfigInput
	// The Name of NodePool.
	Name pulumi.StringPtrInput
	// The Config of NodePool.
	NodeConfig NodePoolNodeConfigInput
	// Tags.
	Tags NodePoolTagArrayInput
}

func (NodePoolArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*nodePoolArgs)(nil)).Elem()
}

type NodePoolInput interface {
	pulumi.Input

	ToNodePoolOutput() NodePoolOutput
	ToNodePoolOutputWithContext(ctx context.Context) NodePoolOutput
}

func (*NodePool) ElementType() reflect.Type {
	return reflect.TypeOf((**NodePool)(nil)).Elem()
}

func (i *NodePool) ToNodePoolOutput() NodePoolOutput {
	return i.ToNodePoolOutputWithContext(context.Background())
}

func (i *NodePool) ToNodePoolOutputWithContext(ctx context.Context) NodePoolOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NodePoolOutput)
}

// NodePoolArrayInput is an input type that accepts NodePoolArray and NodePoolArrayOutput values.
// You can construct a concrete instance of `NodePoolArrayInput` via:
//
//	NodePoolArray{ NodePoolArgs{...} }
type NodePoolArrayInput interface {
	pulumi.Input

	ToNodePoolArrayOutput() NodePoolArrayOutput
	ToNodePoolArrayOutputWithContext(context.Context) NodePoolArrayOutput
}

type NodePoolArray []NodePoolInput

func (NodePoolArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*NodePool)(nil)).Elem()
}

func (i NodePoolArray) ToNodePoolArrayOutput() NodePoolArrayOutput {
	return i.ToNodePoolArrayOutputWithContext(context.Background())
}

func (i NodePoolArray) ToNodePoolArrayOutputWithContext(ctx context.Context) NodePoolArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NodePoolArrayOutput)
}

// NodePoolMapInput is an input type that accepts NodePoolMap and NodePoolMapOutput values.
// You can construct a concrete instance of `NodePoolMapInput` via:
//
//	NodePoolMap{ "key": NodePoolArgs{...} }
type NodePoolMapInput interface {
	pulumi.Input

	ToNodePoolMapOutput() NodePoolMapOutput
	ToNodePoolMapOutputWithContext(context.Context) NodePoolMapOutput
}

type NodePoolMap map[string]NodePoolInput

func (NodePoolMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*NodePool)(nil)).Elem()
}

func (i NodePoolMap) ToNodePoolMapOutput() NodePoolMapOutput {
	return i.ToNodePoolMapOutputWithContext(context.Background())
}

func (i NodePoolMap) ToNodePoolMapOutputWithContext(ctx context.Context) NodePoolMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NodePoolMapOutput)
}

type NodePoolOutput struct{ *pulumi.OutputState }

func (NodePoolOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NodePool)(nil)).Elem()
}

func (o NodePoolOutput) ToNodePoolOutput() NodePoolOutput {
	return o
}

func (o NodePoolOutput) ToNodePoolOutputWithContext(ctx context.Context) NodePoolOutput {
	return o
}

// The node pool elastic scaling configuration information.
func (o NodePoolOutput) AutoScaling() NodePoolAutoScalingOutput {
	return o.ApplyT(func(v *NodePool) NodePoolAutoScalingOutput { return v.AutoScaling }).(NodePoolAutoScalingOutput)
}

// The ClientToken of NodePool.
func (o NodePoolOutput) ClientToken() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NodePool) pulumi.StringPtrOutput { return v.ClientToken }).(pulumi.StringPtrOutput)
}

// The ClusterId of NodePool.
func (o NodePoolOutput) ClusterId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NodePool) pulumi.StringPtrOutput { return v.ClusterId }).(pulumi.StringPtrOutput)
}

// The list of existing ECS instance ids. Add existing instances with same type of security group under the same cluster VPC to the custom node pool.
// Note that removing instance ids from the list will only remove the nodes from cluster and not release the ECS instances. But deleting node pool will release the ECS instances in it.
// It is not recommended to use this field, it is recommended to use `vke.Node` resource to add an existing instance to a custom node pool.
func (o NodePoolOutput) InstanceIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *NodePool) pulumi.StringArrayOutput { return v.InstanceIds }).(pulumi.StringArrayOutput)
}

// Whether to keep instance name when adding an existing instance to a custom node pool, the value is `true` or `false`.
// This field is valid only when adding new instances to the custom node pool.
func (o NodePoolOutput) KeepInstanceName() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *NodePool) pulumi.BoolPtrOutput { return v.KeepInstanceName }).(pulumi.BoolPtrOutput)
}

// The KubernetesConfig of NodeConfig.
func (o NodePoolOutput) KubernetesConfig() NodePoolKubernetesConfigOutput {
	return o.ApplyT(func(v *NodePool) NodePoolKubernetesConfigOutput { return v.KubernetesConfig }).(NodePoolKubernetesConfigOutput)
}

// The Name of NodePool.
func (o NodePoolOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *NodePool) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The Config of NodePool.
func (o NodePoolOutput) NodeConfig() NodePoolNodeConfigOutput {
	return o.ApplyT(func(v *NodePool) NodePoolNodeConfigOutput { return v.NodeConfig }).(NodePoolNodeConfigOutput)
}

// The NodeStatistics of NodeConfig.
func (o NodePoolOutput) NodeStatistics() NodePoolNodeStatisticArrayOutput {
	return o.ApplyT(func(v *NodePool) NodePoolNodeStatisticArrayOutput { return v.NodeStatistics }).(NodePoolNodeStatisticArrayOutput)
}

// Tags.
func (o NodePoolOutput) Tags() NodePoolTagArrayOutput {
	return o.ApplyT(func(v *NodePool) NodePoolTagArrayOutput { return v.Tags }).(NodePoolTagArrayOutput)
}

type NodePoolArrayOutput struct{ *pulumi.OutputState }

func (NodePoolArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*NodePool)(nil)).Elem()
}

func (o NodePoolArrayOutput) ToNodePoolArrayOutput() NodePoolArrayOutput {
	return o
}

func (o NodePoolArrayOutput) ToNodePoolArrayOutputWithContext(ctx context.Context) NodePoolArrayOutput {
	return o
}

func (o NodePoolArrayOutput) Index(i pulumi.IntInput) NodePoolOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *NodePool {
		return vs[0].([]*NodePool)[vs[1].(int)]
	}).(NodePoolOutput)
}

type NodePoolMapOutput struct{ *pulumi.OutputState }

func (NodePoolMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*NodePool)(nil)).Elem()
}

func (o NodePoolMapOutput) ToNodePoolMapOutput() NodePoolMapOutput {
	return o
}

func (o NodePoolMapOutput) ToNodePoolMapOutputWithContext(ctx context.Context) NodePoolMapOutput {
	return o
}

func (o NodePoolMapOutput) MapIndex(k pulumi.StringInput) NodePoolOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *NodePool {
		return vs[0].(map[string]*NodePool)[vs[1].(string)]
	}).(NodePoolOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*NodePoolInput)(nil)).Elem(), &NodePool{})
	pulumi.RegisterInputType(reflect.TypeOf((*NodePoolArrayInput)(nil)).Elem(), NodePoolArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*NodePoolMapInput)(nil)).Elem(), NodePoolMap{})
	pulumi.RegisterOutputType(NodePoolOutput{})
	pulumi.RegisterOutputType(NodePoolArrayOutput{})
	pulumi.RegisterOutputType(NodePoolMapOutput{})
}
