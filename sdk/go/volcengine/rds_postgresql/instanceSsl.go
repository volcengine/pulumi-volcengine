// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package rds_postgresql

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/volcengine/pulumi-volcengine/sdk/go/volcengine/internal"
)

// Provides a resource to manage rds postgresql instance ssl
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/volcengine/pulumi-volcengine/sdk/go/volcengine/rds_postgresql"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := rds_postgresql.NewInstanceSsl(ctx, "example", &rds_postgresql.InstanceSslArgs{
//				ForceEncryption: pulumi.Bool(true),
//				InstanceId:      pulumi.String("postgres-72715e0d9f58"),
//				SslEnable:       pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// RdsPostgresqlInstanceSsl can be imported using the id, e.g.
//
// ```sh
// $ pulumi import volcengine:rds_postgresql/instanceSsl:InstanceSsl default resource_id
// ```
type InstanceSsl struct {
	pulumi.CustomResourceState

	// Whether to enable force encryption. This only takes effect when the SSL encryption function of the instance is enabled.
	ForceEncryption pulumi.BoolPtrOutput `pulumi:"forceEncryption"`
	// The id of the postgresql Instance.
	InstanceId pulumi.StringOutput `pulumi:"instanceId"`
	// Update the validity period of the SSL certificate. This only takes effect when the SSL encryption function of the instance is enabled. It is not supported to pass in reloadSslCertificate and sslEnable at the same time.
	ReloadSslCertificate pulumi.BoolPtrOutput `pulumi:"reloadSslCertificate"`
	// Whether to enable SSL.
	SslEnable pulumi.BoolPtrOutput `pulumi:"sslEnable"`
}

// NewInstanceSsl registers a new resource with the given unique name, arguments, and options.
func NewInstanceSsl(ctx *pulumi.Context,
	name string, args *InstanceSslArgs, opts ...pulumi.ResourceOption) (*InstanceSsl, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.InstanceId == nil {
		return nil, errors.New("invalid value for required argument 'InstanceId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource InstanceSsl
	err := ctx.RegisterResource("volcengine:rds_postgresql/instanceSsl:InstanceSsl", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetInstanceSsl gets an existing InstanceSsl resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetInstanceSsl(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *InstanceSslState, opts ...pulumi.ResourceOption) (*InstanceSsl, error) {
	var resource InstanceSsl
	err := ctx.ReadResource("volcengine:rds_postgresql/instanceSsl:InstanceSsl", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering InstanceSsl resources.
type instanceSslState struct {
	// Whether to enable force encryption. This only takes effect when the SSL encryption function of the instance is enabled.
	ForceEncryption *bool `pulumi:"forceEncryption"`
	// The id of the postgresql Instance.
	InstanceId *string `pulumi:"instanceId"`
	// Update the validity period of the SSL certificate. This only takes effect when the SSL encryption function of the instance is enabled. It is not supported to pass in reloadSslCertificate and sslEnable at the same time.
	ReloadSslCertificate *bool `pulumi:"reloadSslCertificate"`
	// Whether to enable SSL.
	SslEnable *bool `pulumi:"sslEnable"`
}

type InstanceSslState struct {
	// Whether to enable force encryption. This only takes effect when the SSL encryption function of the instance is enabled.
	ForceEncryption pulumi.BoolPtrInput
	// The id of the postgresql Instance.
	InstanceId pulumi.StringPtrInput
	// Update the validity period of the SSL certificate. This only takes effect when the SSL encryption function of the instance is enabled. It is not supported to pass in reloadSslCertificate and sslEnable at the same time.
	ReloadSslCertificate pulumi.BoolPtrInput
	// Whether to enable SSL.
	SslEnable pulumi.BoolPtrInput
}

func (InstanceSslState) ElementType() reflect.Type {
	return reflect.TypeOf((*instanceSslState)(nil)).Elem()
}

type instanceSslArgs struct {
	// Whether to enable force encryption. This only takes effect when the SSL encryption function of the instance is enabled.
	ForceEncryption *bool `pulumi:"forceEncryption"`
	// The id of the postgresql Instance.
	InstanceId string `pulumi:"instanceId"`
	// Update the validity period of the SSL certificate. This only takes effect when the SSL encryption function of the instance is enabled. It is not supported to pass in reloadSslCertificate and sslEnable at the same time.
	ReloadSslCertificate *bool `pulumi:"reloadSslCertificate"`
	// Whether to enable SSL.
	SslEnable *bool `pulumi:"sslEnable"`
}

// The set of arguments for constructing a InstanceSsl resource.
type InstanceSslArgs struct {
	// Whether to enable force encryption. This only takes effect when the SSL encryption function of the instance is enabled.
	ForceEncryption pulumi.BoolPtrInput
	// The id of the postgresql Instance.
	InstanceId pulumi.StringInput
	// Update the validity period of the SSL certificate. This only takes effect when the SSL encryption function of the instance is enabled. It is not supported to pass in reloadSslCertificate and sslEnable at the same time.
	ReloadSslCertificate pulumi.BoolPtrInput
	// Whether to enable SSL.
	SslEnable pulumi.BoolPtrInput
}

func (InstanceSslArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*instanceSslArgs)(nil)).Elem()
}

type InstanceSslInput interface {
	pulumi.Input

	ToInstanceSslOutput() InstanceSslOutput
	ToInstanceSslOutputWithContext(ctx context.Context) InstanceSslOutput
}

func (*InstanceSsl) ElementType() reflect.Type {
	return reflect.TypeOf((**InstanceSsl)(nil)).Elem()
}

func (i *InstanceSsl) ToInstanceSslOutput() InstanceSslOutput {
	return i.ToInstanceSslOutputWithContext(context.Background())
}

func (i *InstanceSsl) ToInstanceSslOutputWithContext(ctx context.Context) InstanceSslOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceSslOutput)
}

// InstanceSslArrayInput is an input type that accepts InstanceSslArray and InstanceSslArrayOutput values.
// You can construct a concrete instance of `InstanceSslArrayInput` via:
//
//	InstanceSslArray{ InstanceSslArgs{...} }
type InstanceSslArrayInput interface {
	pulumi.Input

	ToInstanceSslArrayOutput() InstanceSslArrayOutput
	ToInstanceSslArrayOutputWithContext(context.Context) InstanceSslArrayOutput
}

type InstanceSslArray []InstanceSslInput

func (InstanceSslArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*InstanceSsl)(nil)).Elem()
}

func (i InstanceSslArray) ToInstanceSslArrayOutput() InstanceSslArrayOutput {
	return i.ToInstanceSslArrayOutputWithContext(context.Background())
}

func (i InstanceSslArray) ToInstanceSslArrayOutputWithContext(ctx context.Context) InstanceSslArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceSslArrayOutput)
}

// InstanceSslMapInput is an input type that accepts InstanceSslMap and InstanceSslMapOutput values.
// You can construct a concrete instance of `InstanceSslMapInput` via:
//
//	InstanceSslMap{ "key": InstanceSslArgs{...} }
type InstanceSslMapInput interface {
	pulumi.Input

	ToInstanceSslMapOutput() InstanceSslMapOutput
	ToInstanceSslMapOutputWithContext(context.Context) InstanceSslMapOutput
}

type InstanceSslMap map[string]InstanceSslInput

func (InstanceSslMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*InstanceSsl)(nil)).Elem()
}

func (i InstanceSslMap) ToInstanceSslMapOutput() InstanceSslMapOutput {
	return i.ToInstanceSslMapOutputWithContext(context.Background())
}

func (i InstanceSslMap) ToInstanceSslMapOutputWithContext(ctx context.Context) InstanceSslMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(InstanceSslMapOutput)
}

type InstanceSslOutput struct{ *pulumi.OutputState }

func (InstanceSslOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**InstanceSsl)(nil)).Elem()
}

func (o InstanceSslOutput) ToInstanceSslOutput() InstanceSslOutput {
	return o
}

func (o InstanceSslOutput) ToInstanceSslOutputWithContext(ctx context.Context) InstanceSslOutput {
	return o
}

// Whether to enable force encryption. This only takes effect when the SSL encryption function of the instance is enabled.
func (o InstanceSslOutput) ForceEncryption() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *InstanceSsl) pulumi.BoolPtrOutput { return v.ForceEncryption }).(pulumi.BoolPtrOutput)
}

// The id of the postgresql Instance.
func (o InstanceSslOutput) InstanceId() pulumi.StringOutput {
	return o.ApplyT(func(v *InstanceSsl) pulumi.StringOutput { return v.InstanceId }).(pulumi.StringOutput)
}

// Update the validity period of the SSL certificate. This only takes effect when the SSL encryption function of the instance is enabled. It is not supported to pass in reloadSslCertificate and sslEnable at the same time.
func (o InstanceSslOutput) ReloadSslCertificate() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *InstanceSsl) pulumi.BoolPtrOutput { return v.ReloadSslCertificate }).(pulumi.BoolPtrOutput)
}

// Whether to enable SSL.
func (o InstanceSslOutput) SslEnable() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *InstanceSsl) pulumi.BoolPtrOutput { return v.SslEnable }).(pulumi.BoolPtrOutput)
}

type InstanceSslArrayOutput struct{ *pulumi.OutputState }

func (InstanceSslArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*InstanceSsl)(nil)).Elem()
}

func (o InstanceSslArrayOutput) ToInstanceSslArrayOutput() InstanceSslArrayOutput {
	return o
}

func (o InstanceSslArrayOutput) ToInstanceSslArrayOutputWithContext(ctx context.Context) InstanceSslArrayOutput {
	return o
}

func (o InstanceSslArrayOutput) Index(i pulumi.IntInput) InstanceSslOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *InstanceSsl {
		return vs[0].([]*InstanceSsl)[vs[1].(int)]
	}).(InstanceSslOutput)
}

type InstanceSslMapOutput struct{ *pulumi.OutputState }

func (InstanceSslMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*InstanceSsl)(nil)).Elem()
}

func (o InstanceSslMapOutput) ToInstanceSslMapOutput() InstanceSslMapOutput {
	return o
}

func (o InstanceSslMapOutput) ToInstanceSslMapOutputWithContext(ctx context.Context) InstanceSslMapOutput {
	return o
}

func (o InstanceSslMapOutput) MapIndex(k pulumi.StringInput) InstanceSslOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *InstanceSsl {
		return vs[0].(map[string]*InstanceSsl)[vs[1].(string)]
	}).(InstanceSslOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*InstanceSslInput)(nil)).Elem(), &InstanceSsl{})
	pulumi.RegisterInputType(reflect.TypeOf((*InstanceSslArrayInput)(nil)).Elem(), InstanceSslArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*InstanceSslMapInput)(nil)).Elem(), InstanceSslMap{})
	pulumi.RegisterOutputType(InstanceSslOutput{})
	pulumi.RegisterOutputType(InstanceSslArrayOutput{})
	pulumi.RegisterOutputType(InstanceSslMapOutput{})
}
