// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package tls

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/volcengine/pulumi-volcengine/sdk/go/volcengine/internal"
)

var _ = internal.GetEnvOrDefault

type AlarmAlarmPeriodDetail struct {
	// Email alarm period, the unit is minutes, and the value range is 1~1440.
	Email int `pulumi:"email"`
	// Customize the webhook alarm period, the unit is minutes, and the value range is 1~1440.
	GeneralWebhook int `pulumi:"generalWebhook"`
	// Telephone alarm cycle, the unit is minutes, and the value range is 10~1440.
	Phone int `pulumi:"phone"`
	// SMS alarm cycle, the unit is minutes, and the value range is 10~1440.
	Sms int `pulumi:"sms"`
}

// AlarmAlarmPeriodDetailInput is an input type that accepts AlarmAlarmPeriodDetailArgs and AlarmAlarmPeriodDetailOutput values.
// You can construct a concrete instance of `AlarmAlarmPeriodDetailInput` via:
//
//	AlarmAlarmPeriodDetailArgs{...}
type AlarmAlarmPeriodDetailInput interface {
	pulumi.Input

	ToAlarmAlarmPeriodDetailOutput() AlarmAlarmPeriodDetailOutput
	ToAlarmAlarmPeriodDetailOutputWithContext(context.Context) AlarmAlarmPeriodDetailOutput
}

type AlarmAlarmPeriodDetailArgs struct {
	// Email alarm period, the unit is minutes, and the value range is 1~1440.
	Email pulumi.IntInput `pulumi:"email"`
	// Customize the webhook alarm period, the unit is minutes, and the value range is 1~1440.
	GeneralWebhook pulumi.IntInput `pulumi:"generalWebhook"`
	// Telephone alarm cycle, the unit is minutes, and the value range is 10~1440.
	Phone pulumi.IntInput `pulumi:"phone"`
	// SMS alarm cycle, the unit is minutes, and the value range is 10~1440.
	Sms pulumi.IntInput `pulumi:"sms"`
}

func (AlarmAlarmPeriodDetailArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AlarmAlarmPeriodDetail)(nil)).Elem()
}

func (i AlarmAlarmPeriodDetailArgs) ToAlarmAlarmPeriodDetailOutput() AlarmAlarmPeriodDetailOutput {
	return i.ToAlarmAlarmPeriodDetailOutputWithContext(context.Background())
}

func (i AlarmAlarmPeriodDetailArgs) ToAlarmAlarmPeriodDetailOutputWithContext(ctx context.Context) AlarmAlarmPeriodDetailOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlarmAlarmPeriodDetailOutput)
}

func (i AlarmAlarmPeriodDetailArgs) ToAlarmAlarmPeriodDetailPtrOutput() AlarmAlarmPeriodDetailPtrOutput {
	return i.ToAlarmAlarmPeriodDetailPtrOutputWithContext(context.Background())
}

func (i AlarmAlarmPeriodDetailArgs) ToAlarmAlarmPeriodDetailPtrOutputWithContext(ctx context.Context) AlarmAlarmPeriodDetailPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlarmAlarmPeriodDetailOutput).ToAlarmAlarmPeriodDetailPtrOutputWithContext(ctx)
}

// AlarmAlarmPeriodDetailPtrInput is an input type that accepts AlarmAlarmPeriodDetailArgs, AlarmAlarmPeriodDetailPtr and AlarmAlarmPeriodDetailPtrOutput values.
// You can construct a concrete instance of `AlarmAlarmPeriodDetailPtrInput` via:
//
//	        AlarmAlarmPeriodDetailArgs{...}
//
//	or:
//
//	        nil
type AlarmAlarmPeriodDetailPtrInput interface {
	pulumi.Input

	ToAlarmAlarmPeriodDetailPtrOutput() AlarmAlarmPeriodDetailPtrOutput
	ToAlarmAlarmPeriodDetailPtrOutputWithContext(context.Context) AlarmAlarmPeriodDetailPtrOutput
}

type alarmAlarmPeriodDetailPtrType AlarmAlarmPeriodDetailArgs

func AlarmAlarmPeriodDetailPtr(v *AlarmAlarmPeriodDetailArgs) AlarmAlarmPeriodDetailPtrInput {
	return (*alarmAlarmPeriodDetailPtrType)(v)
}

func (*alarmAlarmPeriodDetailPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AlarmAlarmPeriodDetail)(nil)).Elem()
}

func (i *alarmAlarmPeriodDetailPtrType) ToAlarmAlarmPeriodDetailPtrOutput() AlarmAlarmPeriodDetailPtrOutput {
	return i.ToAlarmAlarmPeriodDetailPtrOutputWithContext(context.Background())
}

func (i *alarmAlarmPeriodDetailPtrType) ToAlarmAlarmPeriodDetailPtrOutputWithContext(ctx context.Context) AlarmAlarmPeriodDetailPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlarmAlarmPeriodDetailPtrOutput)
}

type AlarmAlarmPeriodDetailOutput struct{ *pulumi.OutputState }

func (AlarmAlarmPeriodDetailOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AlarmAlarmPeriodDetail)(nil)).Elem()
}

func (o AlarmAlarmPeriodDetailOutput) ToAlarmAlarmPeriodDetailOutput() AlarmAlarmPeriodDetailOutput {
	return o
}

func (o AlarmAlarmPeriodDetailOutput) ToAlarmAlarmPeriodDetailOutputWithContext(ctx context.Context) AlarmAlarmPeriodDetailOutput {
	return o
}

func (o AlarmAlarmPeriodDetailOutput) ToAlarmAlarmPeriodDetailPtrOutput() AlarmAlarmPeriodDetailPtrOutput {
	return o.ToAlarmAlarmPeriodDetailPtrOutputWithContext(context.Background())
}

func (o AlarmAlarmPeriodDetailOutput) ToAlarmAlarmPeriodDetailPtrOutputWithContext(ctx context.Context) AlarmAlarmPeriodDetailPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v AlarmAlarmPeriodDetail) *AlarmAlarmPeriodDetail {
		return &v
	}).(AlarmAlarmPeriodDetailPtrOutput)
}

// Email alarm period, the unit is minutes, and the value range is 1~1440.
func (o AlarmAlarmPeriodDetailOutput) Email() pulumi.IntOutput {
	return o.ApplyT(func(v AlarmAlarmPeriodDetail) int { return v.Email }).(pulumi.IntOutput)
}

// Customize the webhook alarm period, the unit is minutes, and the value range is 1~1440.
func (o AlarmAlarmPeriodDetailOutput) GeneralWebhook() pulumi.IntOutput {
	return o.ApplyT(func(v AlarmAlarmPeriodDetail) int { return v.GeneralWebhook }).(pulumi.IntOutput)
}

// Telephone alarm cycle, the unit is minutes, and the value range is 10~1440.
func (o AlarmAlarmPeriodDetailOutput) Phone() pulumi.IntOutput {
	return o.ApplyT(func(v AlarmAlarmPeriodDetail) int { return v.Phone }).(pulumi.IntOutput)
}

// SMS alarm cycle, the unit is minutes, and the value range is 10~1440.
func (o AlarmAlarmPeriodDetailOutput) Sms() pulumi.IntOutput {
	return o.ApplyT(func(v AlarmAlarmPeriodDetail) int { return v.Sms }).(pulumi.IntOutput)
}

type AlarmAlarmPeriodDetailPtrOutput struct{ *pulumi.OutputState }

func (AlarmAlarmPeriodDetailPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AlarmAlarmPeriodDetail)(nil)).Elem()
}

func (o AlarmAlarmPeriodDetailPtrOutput) ToAlarmAlarmPeriodDetailPtrOutput() AlarmAlarmPeriodDetailPtrOutput {
	return o
}

func (o AlarmAlarmPeriodDetailPtrOutput) ToAlarmAlarmPeriodDetailPtrOutputWithContext(ctx context.Context) AlarmAlarmPeriodDetailPtrOutput {
	return o
}

func (o AlarmAlarmPeriodDetailPtrOutput) Elem() AlarmAlarmPeriodDetailOutput {
	return o.ApplyT(func(v *AlarmAlarmPeriodDetail) AlarmAlarmPeriodDetail {
		if v != nil {
			return *v
		}
		var ret AlarmAlarmPeriodDetail
		return ret
	}).(AlarmAlarmPeriodDetailOutput)
}

// Email alarm period, the unit is minutes, and the value range is 1~1440.
func (o AlarmAlarmPeriodDetailPtrOutput) Email() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *AlarmAlarmPeriodDetail) *int {
		if v == nil {
			return nil
		}
		return &v.Email
	}).(pulumi.IntPtrOutput)
}

// Customize the webhook alarm period, the unit is minutes, and the value range is 1~1440.
func (o AlarmAlarmPeriodDetailPtrOutput) GeneralWebhook() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *AlarmAlarmPeriodDetail) *int {
		if v == nil {
			return nil
		}
		return &v.GeneralWebhook
	}).(pulumi.IntPtrOutput)
}

// Telephone alarm cycle, the unit is minutes, and the value range is 10~1440.
func (o AlarmAlarmPeriodDetailPtrOutput) Phone() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *AlarmAlarmPeriodDetail) *int {
		if v == nil {
			return nil
		}
		return &v.Phone
	}).(pulumi.IntPtrOutput)
}

// SMS alarm cycle, the unit is minutes, and the value range is 10~1440.
func (o AlarmAlarmPeriodDetailPtrOutput) Sms() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *AlarmAlarmPeriodDetail) *int {
		if v == nil {
			return nil
		}
		return &v.Sms
	}).(pulumi.IntPtrOutput)
}

type AlarmNotifyGroupReceiver struct {
	// The end time.
	EndTime string `pulumi:"endTime"`
	// The list of the receiver channels. Currently supported channels: Email, Sms, Phone.
	ReceiverChannels []string `pulumi:"receiverChannels"`
	// List of the receiver names.
	ReceiverNames []string `pulumi:"receiverNames"`
	// The receiver type, Can be set as: `User`(The id of user).
	ReceiverType string `pulumi:"receiverType"`
	// The start time.
	StartTime string `pulumi:"startTime"`
}

// AlarmNotifyGroupReceiverInput is an input type that accepts AlarmNotifyGroupReceiverArgs and AlarmNotifyGroupReceiverOutput values.
// You can construct a concrete instance of `AlarmNotifyGroupReceiverInput` via:
//
//	AlarmNotifyGroupReceiverArgs{...}
type AlarmNotifyGroupReceiverInput interface {
	pulumi.Input

	ToAlarmNotifyGroupReceiverOutput() AlarmNotifyGroupReceiverOutput
	ToAlarmNotifyGroupReceiverOutputWithContext(context.Context) AlarmNotifyGroupReceiverOutput
}

type AlarmNotifyGroupReceiverArgs struct {
	// The end time.
	EndTime pulumi.StringInput `pulumi:"endTime"`
	// The list of the receiver channels. Currently supported channels: Email, Sms, Phone.
	ReceiverChannels pulumi.StringArrayInput `pulumi:"receiverChannels"`
	// List of the receiver names.
	ReceiverNames pulumi.StringArrayInput `pulumi:"receiverNames"`
	// The receiver type, Can be set as: `User`(The id of user).
	ReceiverType pulumi.StringInput `pulumi:"receiverType"`
	// The start time.
	StartTime pulumi.StringInput `pulumi:"startTime"`
}

func (AlarmNotifyGroupReceiverArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AlarmNotifyGroupReceiver)(nil)).Elem()
}

func (i AlarmNotifyGroupReceiverArgs) ToAlarmNotifyGroupReceiverOutput() AlarmNotifyGroupReceiverOutput {
	return i.ToAlarmNotifyGroupReceiverOutputWithContext(context.Background())
}

func (i AlarmNotifyGroupReceiverArgs) ToAlarmNotifyGroupReceiverOutputWithContext(ctx context.Context) AlarmNotifyGroupReceiverOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlarmNotifyGroupReceiverOutput)
}

// AlarmNotifyGroupReceiverArrayInput is an input type that accepts AlarmNotifyGroupReceiverArray and AlarmNotifyGroupReceiverArrayOutput values.
// You can construct a concrete instance of `AlarmNotifyGroupReceiverArrayInput` via:
//
//	AlarmNotifyGroupReceiverArray{ AlarmNotifyGroupReceiverArgs{...} }
type AlarmNotifyGroupReceiverArrayInput interface {
	pulumi.Input

	ToAlarmNotifyGroupReceiverArrayOutput() AlarmNotifyGroupReceiverArrayOutput
	ToAlarmNotifyGroupReceiverArrayOutputWithContext(context.Context) AlarmNotifyGroupReceiverArrayOutput
}

type AlarmNotifyGroupReceiverArray []AlarmNotifyGroupReceiverInput

func (AlarmNotifyGroupReceiverArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AlarmNotifyGroupReceiver)(nil)).Elem()
}

func (i AlarmNotifyGroupReceiverArray) ToAlarmNotifyGroupReceiverArrayOutput() AlarmNotifyGroupReceiverArrayOutput {
	return i.ToAlarmNotifyGroupReceiverArrayOutputWithContext(context.Background())
}

func (i AlarmNotifyGroupReceiverArray) ToAlarmNotifyGroupReceiverArrayOutputWithContext(ctx context.Context) AlarmNotifyGroupReceiverArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlarmNotifyGroupReceiverArrayOutput)
}

type AlarmNotifyGroupReceiverOutput struct{ *pulumi.OutputState }

func (AlarmNotifyGroupReceiverOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AlarmNotifyGroupReceiver)(nil)).Elem()
}

func (o AlarmNotifyGroupReceiverOutput) ToAlarmNotifyGroupReceiverOutput() AlarmNotifyGroupReceiverOutput {
	return o
}

func (o AlarmNotifyGroupReceiverOutput) ToAlarmNotifyGroupReceiverOutputWithContext(ctx context.Context) AlarmNotifyGroupReceiverOutput {
	return o
}

// The end time.
func (o AlarmNotifyGroupReceiverOutput) EndTime() pulumi.StringOutput {
	return o.ApplyT(func(v AlarmNotifyGroupReceiver) string { return v.EndTime }).(pulumi.StringOutput)
}

// The list of the receiver channels. Currently supported channels: Email, Sms, Phone.
func (o AlarmNotifyGroupReceiverOutput) ReceiverChannels() pulumi.StringArrayOutput {
	return o.ApplyT(func(v AlarmNotifyGroupReceiver) []string { return v.ReceiverChannels }).(pulumi.StringArrayOutput)
}

// List of the receiver names.
func (o AlarmNotifyGroupReceiverOutput) ReceiverNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v AlarmNotifyGroupReceiver) []string { return v.ReceiverNames }).(pulumi.StringArrayOutput)
}

// The receiver type, Can be set as: `User`(The id of user).
func (o AlarmNotifyGroupReceiverOutput) ReceiverType() pulumi.StringOutput {
	return o.ApplyT(func(v AlarmNotifyGroupReceiver) string { return v.ReceiverType }).(pulumi.StringOutput)
}

// The start time.
func (o AlarmNotifyGroupReceiverOutput) StartTime() pulumi.StringOutput {
	return o.ApplyT(func(v AlarmNotifyGroupReceiver) string { return v.StartTime }).(pulumi.StringOutput)
}

type AlarmNotifyGroupReceiverArrayOutput struct{ *pulumi.OutputState }

func (AlarmNotifyGroupReceiverArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AlarmNotifyGroupReceiver)(nil)).Elem()
}

func (o AlarmNotifyGroupReceiverArrayOutput) ToAlarmNotifyGroupReceiverArrayOutput() AlarmNotifyGroupReceiverArrayOutput {
	return o
}

func (o AlarmNotifyGroupReceiverArrayOutput) ToAlarmNotifyGroupReceiverArrayOutputWithContext(ctx context.Context) AlarmNotifyGroupReceiverArrayOutput {
	return o
}

func (o AlarmNotifyGroupReceiverArrayOutput) Index(i pulumi.IntInput) AlarmNotifyGroupReceiverOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AlarmNotifyGroupReceiver {
		return vs[0].([]AlarmNotifyGroupReceiver)[vs[1].(int)]
	}).(AlarmNotifyGroupReceiverOutput)
}

type AlarmNotifyGroupsGroup struct {
	// The id of the alarm notify group.
	AlarmNotifyGroupId string `pulumi:"alarmNotifyGroupId"`
	// The name of the alarm notify group.
	AlarmNotifyGroupName string `pulumi:"alarmNotifyGroupName"`
	// The create time the notification.
	CreateTime string `pulumi:"createTime"`
	// The name of the iam project.
	IamProjectName string `pulumi:"iamProjectName"`
	// The modification time the notification.
	ModifyTime string `pulumi:"modifyTime"`
	// The notify group type.
	NotifyTypes []string `pulumi:"notifyTypes"`
	// List of IAM users to receive alerts.
	Receivers []AlarmNotifyGroupsGroupReceiver `pulumi:"receivers"`
}

// AlarmNotifyGroupsGroupInput is an input type that accepts AlarmNotifyGroupsGroupArgs and AlarmNotifyGroupsGroupOutput values.
// You can construct a concrete instance of `AlarmNotifyGroupsGroupInput` via:
//
//	AlarmNotifyGroupsGroupArgs{...}
type AlarmNotifyGroupsGroupInput interface {
	pulumi.Input

	ToAlarmNotifyGroupsGroupOutput() AlarmNotifyGroupsGroupOutput
	ToAlarmNotifyGroupsGroupOutputWithContext(context.Context) AlarmNotifyGroupsGroupOutput
}

type AlarmNotifyGroupsGroupArgs struct {
	// The id of the alarm notify group.
	AlarmNotifyGroupId pulumi.StringInput `pulumi:"alarmNotifyGroupId"`
	// The name of the alarm notify group.
	AlarmNotifyGroupName pulumi.StringInput `pulumi:"alarmNotifyGroupName"`
	// The create time the notification.
	CreateTime pulumi.StringInput `pulumi:"createTime"`
	// The name of the iam project.
	IamProjectName pulumi.StringInput `pulumi:"iamProjectName"`
	// The modification time the notification.
	ModifyTime pulumi.StringInput `pulumi:"modifyTime"`
	// The notify group type.
	NotifyTypes pulumi.StringArrayInput `pulumi:"notifyTypes"`
	// List of IAM users to receive alerts.
	Receivers AlarmNotifyGroupsGroupReceiverArrayInput `pulumi:"receivers"`
}

func (AlarmNotifyGroupsGroupArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AlarmNotifyGroupsGroup)(nil)).Elem()
}

func (i AlarmNotifyGroupsGroupArgs) ToAlarmNotifyGroupsGroupOutput() AlarmNotifyGroupsGroupOutput {
	return i.ToAlarmNotifyGroupsGroupOutputWithContext(context.Background())
}

func (i AlarmNotifyGroupsGroupArgs) ToAlarmNotifyGroupsGroupOutputWithContext(ctx context.Context) AlarmNotifyGroupsGroupOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlarmNotifyGroupsGroupOutput)
}

// AlarmNotifyGroupsGroupArrayInput is an input type that accepts AlarmNotifyGroupsGroupArray and AlarmNotifyGroupsGroupArrayOutput values.
// You can construct a concrete instance of `AlarmNotifyGroupsGroupArrayInput` via:
//
//	AlarmNotifyGroupsGroupArray{ AlarmNotifyGroupsGroupArgs{...} }
type AlarmNotifyGroupsGroupArrayInput interface {
	pulumi.Input

	ToAlarmNotifyGroupsGroupArrayOutput() AlarmNotifyGroupsGroupArrayOutput
	ToAlarmNotifyGroupsGroupArrayOutputWithContext(context.Context) AlarmNotifyGroupsGroupArrayOutput
}

type AlarmNotifyGroupsGroupArray []AlarmNotifyGroupsGroupInput

func (AlarmNotifyGroupsGroupArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AlarmNotifyGroupsGroup)(nil)).Elem()
}

func (i AlarmNotifyGroupsGroupArray) ToAlarmNotifyGroupsGroupArrayOutput() AlarmNotifyGroupsGroupArrayOutput {
	return i.ToAlarmNotifyGroupsGroupArrayOutputWithContext(context.Background())
}

func (i AlarmNotifyGroupsGroupArray) ToAlarmNotifyGroupsGroupArrayOutputWithContext(ctx context.Context) AlarmNotifyGroupsGroupArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlarmNotifyGroupsGroupArrayOutput)
}

type AlarmNotifyGroupsGroupOutput struct{ *pulumi.OutputState }

func (AlarmNotifyGroupsGroupOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AlarmNotifyGroupsGroup)(nil)).Elem()
}

func (o AlarmNotifyGroupsGroupOutput) ToAlarmNotifyGroupsGroupOutput() AlarmNotifyGroupsGroupOutput {
	return o
}

func (o AlarmNotifyGroupsGroupOutput) ToAlarmNotifyGroupsGroupOutputWithContext(ctx context.Context) AlarmNotifyGroupsGroupOutput {
	return o
}

// The id of the alarm notify group.
func (o AlarmNotifyGroupsGroupOutput) AlarmNotifyGroupId() pulumi.StringOutput {
	return o.ApplyT(func(v AlarmNotifyGroupsGroup) string { return v.AlarmNotifyGroupId }).(pulumi.StringOutput)
}

// The name of the alarm notify group.
func (o AlarmNotifyGroupsGroupOutput) AlarmNotifyGroupName() pulumi.StringOutput {
	return o.ApplyT(func(v AlarmNotifyGroupsGroup) string { return v.AlarmNotifyGroupName }).(pulumi.StringOutput)
}

// The create time the notification.
func (o AlarmNotifyGroupsGroupOutput) CreateTime() pulumi.StringOutput {
	return o.ApplyT(func(v AlarmNotifyGroupsGroup) string { return v.CreateTime }).(pulumi.StringOutput)
}

// The name of the iam project.
func (o AlarmNotifyGroupsGroupOutput) IamProjectName() pulumi.StringOutput {
	return o.ApplyT(func(v AlarmNotifyGroupsGroup) string { return v.IamProjectName }).(pulumi.StringOutput)
}

// The modification time the notification.
func (o AlarmNotifyGroupsGroupOutput) ModifyTime() pulumi.StringOutput {
	return o.ApplyT(func(v AlarmNotifyGroupsGroup) string { return v.ModifyTime }).(pulumi.StringOutput)
}

// The notify group type.
func (o AlarmNotifyGroupsGroupOutput) NotifyTypes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v AlarmNotifyGroupsGroup) []string { return v.NotifyTypes }).(pulumi.StringArrayOutput)
}

// List of IAM users to receive alerts.
func (o AlarmNotifyGroupsGroupOutput) Receivers() AlarmNotifyGroupsGroupReceiverArrayOutput {
	return o.ApplyT(func(v AlarmNotifyGroupsGroup) []AlarmNotifyGroupsGroupReceiver { return v.Receivers }).(AlarmNotifyGroupsGroupReceiverArrayOutput)
}

type AlarmNotifyGroupsGroupArrayOutput struct{ *pulumi.OutputState }

func (AlarmNotifyGroupsGroupArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AlarmNotifyGroupsGroup)(nil)).Elem()
}

func (o AlarmNotifyGroupsGroupArrayOutput) ToAlarmNotifyGroupsGroupArrayOutput() AlarmNotifyGroupsGroupArrayOutput {
	return o
}

func (o AlarmNotifyGroupsGroupArrayOutput) ToAlarmNotifyGroupsGroupArrayOutputWithContext(ctx context.Context) AlarmNotifyGroupsGroupArrayOutput {
	return o
}

func (o AlarmNotifyGroupsGroupArrayOutput) Index(i pulumi.IntInput) AlarmNotifyGroupsGroupOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AlarmNotifyGroupsGroup {
		return vs[0].([]AlarmNotifyGroupsGroup)[vs[1].(int)]
	}).(AlarmNotifyGroupsGroupOutput)
}

type AlarmNotifyGroupsGroupReceiver struct {
	// The end time.
	EndTime string `pulumi:"endTime"`
	// The list of the receiver channels.
	ReceiverChannels []string `pulumi:"receiverChannels"`
	// List of the receiver names.
	ReceiverNames []string `pulumi:"receiverNames"`
	// The receiver type.
	ReceiverType string `pulumi:"receiverType"`
	// The start time.
	StartTime string `pulumi:"startTime"`
}

// AlarmNotifyGroupsGroupReceiverInput is an input type that accepts AlarmNotifyGroupsGroupReceiverArgs and AlarmNotifyGroupsGroupReceiverOutput values.
// You can construct a concrete instance of `AlarmNotifyGroupsGroupReceiverInput` via:
//
//	AlarmNotifyGroupsGroupReceiverArgs{...}
type AlarmNotifyGroupsGroupReceiverInput interface {
	pulumi.Input

	ToAlarmNotifyGroupsGroupReceiverOutput() AlarmNotifyGroupsGroupReceiverOutput
	ToAlarmNotifyGroupsGroupReceiverOutputWithContext(context.Context) AlarmNotifyGroupsGroupReceiverOutput
}

type AlarmNotifyGroupsGroupReceiverArgs struct {
	// The end time.
	EndTime pulumi.StringInput `pulumi:"endTime"`
	// The list of the receiver channels.
	ReceiverChannels pulumi.StringArrayInput `pulumi:"receiverChannels"`
	// List of the receiver names.
	ReceiverNames pulumi.StringArrayInput `pulumi:"receiverNames"`
	// The receiver type.
	ReceiverType pulumi.StringInput `pulumi:"receiverType"`
	// The start time.
	StartTime pulumi.StringInput `pulumi:"startTime"`
}

func (AlarmNotifyGroupsGroupReceiverArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AlarmNotifyGroupsGroupReceiver)(nil)).Elem()
}

func (i AlarmNotifyGroupsGroupReceiverArgs) ToAlarmNotifyGroupsGroupReceiverOutput() AlarmNotifyGroupsGroupReceiverOutput {
	return i.ToAlarmNotifyGroupsGroupReceiverOutputWithContext(context.Background())
}

func (i AlarmNotifyGroupsGroupReceiverArgs) ToAlarmNotifyGroupsGroupReceiverOutputWithContext(ctx context.Context) AlarmNotifyGroupsGroupReceiverOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlarmNotifyGroupsGroupReceiverOutput)
}

// AlarmNotifyGroupsGroupReceiverArrayInput is an input type that accepts AlarmNotifyGroupsGroupReceiverArray and AlarmNotifyGroupsGroupReceiverArrayOutput values.
// You can construct a concrete instance of `AlarmNotifyGroupsGroupReceiverArrayInput` via:
//
//	AlarmNotifyGroupsGroupReceiverArray{ AlarmNotifyGroupsGroupReceiverArgs{...} }
type AlarmNotifyGroupsGroupReceiverArrayInput interface {
	pulumi.Input

	ToAlarmNotifyGroupsGroupReceiverArrayOutput() AlarmNotifyGroupsGroupReceiverArrayOutput
	ToAlarmNotifyGroupsGroupReceiverArrayOutputWithContext(context.Context) AlarmNotifyGroupsGroupReceiverArrayOutput
}

type AlarmNotifyGroupsGroupReceiverArray []AlarmNotifyGroupsGroupReceiverInput

func (AlarmNotifyGroupsGroupReceiverArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AlarmNotifyGroupsGroupReceiver)(nil)).Elem()
}

func (i AlarmNotifyGroupsGroupReceiverArray) ToAlarmNotifyGroupsGroupReceiverArrayOutput() AlarmNotifyGroupsGroupReceiverArrayOutput {
	return i.ToAlarmNotifyGroupsGroupReceiverArrayOutputWithContext(context.Background())
}

func (i AlarmNotifyGroupsGroupReceiverArray) ToAlarmNotifyGroupsGroupReceiverArrayOutputWithContext(ctx context.Context) AlarmNotifyGroupsGroupReceiverArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlarmNotifyGroupsGroupReceiverArrayOutput)
}

type AlarmNotifyGroupsGroupReceiverOutput struct{ *pulumi.OutputState }

func (AlarmNotifyGroupsGroupReceiverOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AlarmNotifyGroupsGroupReceiver)(nil)).Elem()
}

func (o AlarmNotifyGroupsGroupReceiverOutput) ToAlarmNotifyGroupsGroupReceiverOutput() AlarmNotifyGroupsGroupReceiverOutput {
	return o
}

func (o AlarmNotifyGroupsGroupReceiverOutput) ToAlarmNotifyGroupsGroupReceiverOutputWithContext(ctx context.Context) AlarmNotifyGroupsGroupReceiverOutput {
	return o
}

// The end time.
func (o AlarmNotifyGroupsGroupReceiverOutput) EndTime() pulumi.StringOutput {
	return o.ApplyT(func(v AlarmNotifyGroupsGroupReceiver) string { return v.EndTime }).(pulumi.StringOutput)
}

// The list of the receiver channels.
func (o AlarmNotifyGroupsGroupReceiverOutput) ReceiverChannels() pulumi.StringArrayOutput {
	return o.ApplyT(func(v AlarmNotifyGroupsGroupReceiver) []string { return v.ReceiverChannels }).(pulumi.StringArrayOutput)
}

// List of the receiver names.
func (o AlarmNotifyGroupsGroupReceiverOutput) ReceiverNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v AlarmNotifyGroupsGroupReceiver) []string { return v.ReceiverNames }).(pulumi.StringArrayOutput)
}

// The receiver type.
func (o AlarmNotifyGroupsGroupReceiverOutput) ReceiverType() pulumi.StringOutput {
	return o.ApplyT(func(v AlarmNotifyGroupsGroupReceiver) string { return v.ReceiverType }).(pulumi.StringOutput)
}

// The start time.
func (o AlarmNotifyGroupsGroupReceiverOutput) StartTime() pulumi.StringOutput {
	return o.ApplyT(func(v AlarmNotifyGroupsGroupReceiver) string { return v.StartTime }).(pulumi.StringOutput)
}

type AlarmNotifyGroupsGroupReceiverArrayOutput struct{ *pulumi.OutputState }

func (AlarmNotifyGroupsGroupReceiverArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AlarmNotifyGroupsGroupReceiver)(nil)).Elem()
}

func (o AlarmNotifyGroupsGroupReceiverArrayOutput) ToAlarmNotifyGroupsGroupReceiverArrayOutput() AlarmNotifyGroupsGroupReceiverArrayOutput {
	return o
}

func (o AlarmNotifyGroupsGroupReceiverArrayOutput) ToAlarmNotifyGroupsGroupReceiverArrayOutputWithContext(ctx context.Context) AlarmNotifyGroupsGroupReceiverArrayOutput {
	return o
}

func (o AlarmNotifyGroupsGroupReceiverArrayOutput) Index(i pulumi.IntInput) AlarmNotifyGroupsGroupReceiverOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AlarmNotifyGroupsGroupReceiver {
		return vs[0].([]AlarmNotifyGroupsGroupReceiver)[vs[1].(int)]
	}).(AlarmNotifyGroupsGroupReceiverOutput)
}

type AlarmQueryRequest struct {
	// The end time of the query range is relative to the current historical time. The unit is minutes. The value is not positive and must be greater than StartTimeOffset. The maximum value is 0 and the minimum value is -1440.
	EndTimeOffset int `pulumi:"endTimeOffset"`
	// Alarm object sequence number; increments from 1.
	Number int `pulumi:"number"`
	// Query statement, the maximum supported length is 1024.
	Query string `pulumi:"query"`
	// The start time of the query range is relative to the current historical time, in minutes. The value is non-positive, the maximum value is 0, and the minimum value is -1440.
	StartTimeOffset int `pulumi:"startTimeOffset"`
	// The id of the topic.
	TopicId string `pulumi:"topicId"`
}

// AlarmQueryRequestInput is an input type that accepts AlarmQueryRequestArgs and AlarmQueryRequestOutput values.
// You can construct a concrete instance of `AlarmQueryRequestInput` via:
//
//	AlarmQueryRequestArgs{...}
type AlarmQueryRequestInput interface {
	pulumi.Input

	ToAlarmQueryRequestOutput() AlarmQueryRequestOutput
	ToAlarmQueryRequestOutputWithContext(context.Context) AlarmQueryRequestOutput
}

type AlarmQueryRequestArgs struct {
	// The end time of the query range is relative to the current historical time. The unit is minutes. The value is not positive and must be greater than StartTimeOffset. The maximum value is 0 and the minimum value is -1440.
	EndTimeOffset pulumi.IntInput `pulumi:"endTimeOffset"`
	// Alarm object sequence number; increments from 1.
	Number pulumi.IntInput `pulumi:"number"`
	// Query statement, the maximum supported length is 1024.
	Query pulumi.StringInput `pulumi:"query"`
	// The start time of the query range is relative to the current historical time, in minutes. The value is non-positive, the maximum value is 0, and the minimum value is -1440.
	StartTimeOffset pulumi.IntInput `pulumi:"startTimeOffset"`
	// The id of the topic.
	TopicId pulumi.StringInput `pulumi:"topicId"`
}

func (AlarmQueryRequestArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AlarmQueryRequest)(nil)).Elem()
}

func (i AlarmQueryRequestArgs) ToAlarmQueryRequestOutput() AlarmQueryRequestOutput {
	return i.ToAlarmQueryRequestOutputWithContext(context.Background())
}

func (i AlarmQueryRequestArgs) ToAlarmQueryRequestOutputWithContext(ctx context.Context) AlarmQueryRequestOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlarmQueryRequestOutput)
}

// AlarmQueryRequestArrayInput is an input type that accepts AlarmQueryRequestArray and AlarmQueryRequestArrayOutput values.
// You can construct a concrete instance of `AlarmQueryRequestArrayInput` via:
//
//	AlarmQueryRequestArray{ AlarmQueryRequestArgs{...} }
type AlarmQueryRequestArrayInput interface {
	pulumi.Input

	ToAlarmQueryRequestArrayOutput() AlarmQueryRequestArrayOutput
	ToAlarmQueryRequestArrayOutputWithContext(context.Context) AlarmQueryRequestArrayOutput
}

type AlarmQueryRequestArray []AlarmQueryRequestInput

func (AlarmQueryRequestArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AlarmQueryRequest)(nil)).Elem()
}

func (i AlarmQueryRequestArray) ToAlarmQueryRequestArrayOutput() AlarmQueryRequestArrayOutput {
	return i.ToAlarmQueryRequestArrayOutputWithContext(context.Background())
}

func (i AlarmQueryRequestArray) ToAlarmQueryRequestArrayOutputWithContext(ctx context.Context) AlarmQueryRequestArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlarmQueryRequestArrayOutput)
}

type AlarmQueryRequestOutput struct{ *pulumi.OutputState }

func (AlarmQueryRequestOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AlarmQueryRequest)(nil)).Elem()
}

func (o AlarmQueryRequestOutput) ToAlarmQueryRequestOutput() AlarmQueryRequestOutput {
	return o
}

func (o AlarmQueryRequestOutput) ToAlarmQueryRequestOutputWithContext(ctx context.Context) AlarmQueryRequestOutput {
	return o
}

// The end time of the query range is relative to the current historical time. The unit is minutes. The value is not positive and must be greater than StartTimeOffset. The maximum value is 0 and the minimum value is -1440.
func (o AlarmQueryRequestOutput) EndTimeOffset() pulumi.IntOutput {
	return o.ApplyT(func(v AlarmQueryRequest) int { return v.EndTimeOffset }).(pulumi.IntOutput)
}

// Alarm object sequence number; increments from 1.
func (o AlarmQueryRequestOutput) Number() pulumi.IntOutput {
	return o.ApplyT(func(v AlarmQueryRequest) int { return v.Number }).(pulumi.IntOutput)
}

// Query statement, the maximum supported length is 1024.
func (o AlarmQueryRequestOutput) Query() pulumi.StringOutput {
	return o.ApplyT(func(v AlarmQueryRequest) string { return v.Query }).(pulumi.StringOutput)
}

// The start time of the query range is relative to the current historical time, in minutes. The value is non-positive, the maximum value is 0, and the minimum value is -1440.
func (o AlarmQueryRequestOutput) StartTimeOffset() pulumi.IntOutput {
	return o.ApplyT(func(v AlarmQueryRequest) int { return v.StartTimeOffset }).(pulumi.IntOutput)
}

// The id of the topic.
func (o AlarmQueryRequestOutput) TopicId() pulumi.StringOutput {
	return o.ApplyT(func(v AlarmQueryRequest) string { return v.TopicId }).(pulumi.StringOutput)
}

type AlarmQueryRequestArrayOutput struct{ *pulumi.OutputState }

func (AlarmQueryRequestArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AlarmQueryRequest)(nil)).Elem()
}

func (o AlarmQueryRequestArrayOutput) ToAlarmQueryRequestArrayOutput() AlarmQueryRequestArrayOutput {
	return o
}

func (o AlarmQueryRequestArrayOutput) ToAlarmQueryRequestArrayOutputWithContext(ctx context.Context) AlarmQueryRequestArrayOutput {
	return o
}

func (o AlarmQueryRequestArrayOutput) Index(i pulumi.IntInput) AlarmQueryRequestOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AlarmQueryRequest {
		return vs[0].([]AlarmQueryRequest)[vs[1].(int)]
	}).(AlarmQueryRequestOutput)
}

type AlarmRequestCycle struct {
	// The cycle of alarm task execution, or the time point of periodic execution. The unit is minutes, and the value range is 1~1440.
	Time int `pulumi:"time"`
	// Execution cycle type.
	// Period: Periodic execution, which means executing once every certain period of time.
	// Fixed: Regular execution, which means executing at a fixed time point every day.
	Type string `pulumi:"type"`
}

// AlarmRequestCycleInput is an input type that accepts AlarmRequestCycleArgs and AlarmRequestCycleOutput values.
// You can construct a concrete instance of `AlarmRequestCycleInput` via:
//
//	AlarmRequestCycleArgs{...}
type AlarmRequestCycleInput interface {
	pulumi.Input

	ToAlarmRequestCycleOutput() AlarmRequestCycleOutput
	ToAlarmRequestCycleOutputWithContext(context.Context) AlarmRequestCycleOutput
}

type AlarmRequestCycleArgs struct {
	// The cycle of alarm task execution, or the time point of periodic execution. The unit is minutes, and the value range is 1~1440.
	Time pulumi.IntInput `pulumi:"time"`
	// Execution cycle type.
	// Period: Periodic execution, which means executing once every certain period of time.
	// Fixed: Regular execution, which means executing at a fixed time point every day.
	Type pulumi.StringInput `pulumi:"type"`
}

func (AlarmRequestCycleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AlarmRequestCycle)(nil)).Elem()
}

func (i AlarmRequestCycleArgs) ToAlarmRequestCycleOutput() AlarmRequestCycleOutput {
	return i.ToAlarmRequestCycleOutputWithContext(context.Background())
}

func (i AlarmRequestCycleArgs) ToAlarmRequestCycleOutputWithContext(ctx context.Context) AlarmRequestCycleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlarmRequestCycleOutput)
}

func (i AlarmRequestCycleArgs) ToAlarmRequestCyclePtrOutput() AlarmRequestCyclePtrOutput {
	return i.ToAlarmRequestCyclePtrOutputWithContext(context.Background())
}

func (i AlarmRequestCycleArgs) ToAlarmRequestCyclePtrOutputWithContext(ctx context.Context) AlarmRequestCyclePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlarmRequestCycleOutput).ToAlarmRequestCyclePtrOutputWithContext(ctx)
}

// AlarmRequestCyclePtrInput is an input type that accepts AlarmRequestCycleArgs, AlarmRequestCyclePtr and AlarmRequestCyclePtrOutput values.
// You can construct a concrete instance of `AlarmRequestCyclePtrInput` via:
//
//	        AlarmRequestCycleArgs{...}
//
//	or:
//
//	        nil
type AlarmRequestCyclePtrInput interface {
	pulumi.Input

	ToAlarmRequestCyclePtrOutput() AlarmRequestCyclePtrOutput
	ToAlarmRequestCyclePtrOutputWithContext(context.Context) AlarmRequestCyclePtrOutput
}

type alarmRequestCyclePtrType AlarmRequestCycleArgs

func AlarmRequestCyclePtr(v *AlarmRequestCycleArgs) AlarmRequestCyclePtrInput {
	return (*alarmRequestCyclePtrType)(v)
}

func (*alarmRequestCyclePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**AlarmRequestCycle)(nil)).Elem()
}

func (i *alarmRequestCyclePtrType) ToAlarmRequestCyclePtrOutput() AlarmRequestCyclePtrOutput {
	return i.ToAlarmRequestCyclePtrOutputWithContext(context.Background())
}

func (i *alarmRequestCyclePtrType) ToAlarmRequestCyclePtrOutputWithContext(ctx context.Context) AlarmRequestCyclePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlarmRequestCyclePtrOutput)
}

type AlarmRequestCycleOutput struct{ *pulumi.OutputState }

func (AlarmRequestCycleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AlarmRequestCycle)(nil)).Elem()
}

func (o AlarmRequestCycleOutput) ToAlarmRequestCycleOutput() AlarmRequestCycleOutput {
	return o
}

func (o AlarmRequestCycleOutput) ToAlarmRequestCycleOutputWithContext(ctx context.Context) AlarmRequestCycleOutput {
	return o
}

func (o AlarmRequestCycleOutput) ToAlarmRequestCyclePtrOutput() AlarmRequestCyclePtrOutput {
	return o.ToAlarmRequestCyclePtrOutputWithContext(context.Background())
}

func (o AlarmRequestCycleOutput) ToAlarmRequestCyclePtrOutputWithContext(ctx context.Context) AlarmRequestCyclePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v AlarmRequestCycle) *AlarmRequestCycle {
		return &v
	}).(AlarmRequestCyclePtrOutput)
}

// The cycle of alarm task execution, or the time point of periodic execution. The unit is minutes, and the value range is 1~1440.
func (o AlarmRequestCycleOutput) Time() pulumi.IntOutput {
	return o.ApplyT(func(v AlarmRequestCycle) int { return v.Time }).(pulumi.IntOutput)
}

// Execution cycle type.
// Period: Periodic execution, which means executing once every certain period of time.
// Fixed: Regular execution, which means executing at a fixed time point every day.
func (o AlarmRequestCycleOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v AlarmRequestCycle) string { return v.Type }).(pulumi.StringOutput)
}

type AlarmRequestCyclePtrOutput struct{ *pulumi.OutputState }

func (AlarmRequestCyclePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AlarmRequestCycle)(nil)).Elem()
}

func (o AlarmRequestCyclePtrOutput) ToAlarmRequestCyclePtrOutput() AlarmRequestCyclePtrOutput {
	return o
}

func (o AlarmRequestCyclePtrOutput) ToAlarmRequestCyclePtrOutputWithContext(ctx context.Context) AlarmRequestCyclePtrOutput {
	return o
}

func (o AlarmRequestCyclePtrOutput) Elem() AlarmRequestCycleOutput {
	return o.ApplyT(func(v *AlarmRequestCycle) AlarmRequestCycle {
		if v != nil {
			return *v
		}
		var ret AlarmRequestCycle
		return ret
	}).(AlarmRequestCycleOutput)
}

// The cycle of alarm task execution, or the time point of periodic execution. The unit is minutes, and the value range is 1~1440.
func (o AlarmRequestCyclePtrOutput) Time() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *AlarmRequestCycle) *int {
		if v == nil {
			return nil
		}
		return &v.Time
	}).(pulumi.IntPtrOutput)
}

// Execution cycle type.
// Period: Periodic execution, which means executing once every certain period of time.
// Fixed: Regular execution, which means executing at a fixed time point every day.
func (o AlarmRequestCyclePtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AlarmRequestCycle) *string {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(pulumi.StringPtrOutput)
}

type AlarmsAlarm struct {
	// The alarm id.
	AlarmId string `pulumi:"alarmId"`
	// The alarm name.
	AlarmName string `pulumi:"alarmName"`
	// List of notification groups corresponding to the alarm.
	AlarmNotifyGroups []AlarmsAlarmAlarmNotifyGroup `pulumi:"alarmNotifyGroups"`
	// Period for sending alarm notifications. When the number of continuous alarm triggers reaches the specified limit (TriggerPeriod), Log Service will send alarm notifications according to the specified period.
	AlarmPeriod int `pulumi:"alarmPeriod"`
	// Period for sending alarm notifications. When the number of continuous alarm triggers reaches the specified limit (TriggerPeriod), Log Service will send alarm notifications according to the specified period.
	AlarmPeriodDetails []AlarmsAlarmAlarmPeriodDetail `pulumi:"alarmPeriodDetails"`
	// Alarm trigger condition.
	Condition string `pulumi:"condition"`
	// The create time.
	CreateTime string `pulumi:"createTime"`
	// The modify time.
	ModifyTime string `pulumi:"modifyTime"`
	// The project id.
	ProjectId string `pulumi:"projectId"`
	// Search and analyze sentences, 1~3 can be configured.
	QueryRequests []AlarmsAlarmQueryRequest `pulumi:"queryRequests"`
	// The execution period of the alarm task.
	RequestCycles []AlarmsAlarmRequestCycle `pulumi:"requestCycles"`
	// The status.
	Status bool `pulumi:"status"`
	// Continuous cycle. The alarm will be issued after the trigger condition is continuously met for TriggerPeriod periods; the minimum value is 1, the maximum value is 10, and the default value is 1.
	TriggerPeriod int `pulumi:"triggerPeriod"`
	// Customize the alarm notification content.
	UserDefineMsg string `pulumi:"userDefineMsg"`
}

// AlarmsAlarmInput is an input type that accepts AlarmsAlarmArgs and AlarmsAlarmOutput values.
// You can construct a concrete instance of `AlarmsAlarmInput` via:
//
//	AlarmsAlarmArgs{...}
type AlarmsAlarmInput interface {
	pulumi.Input

	ToAlarmsAlarmOutput() AlarmsAlarmOutput
	ToAlarmsAlarmOutputWithContext(context.Context) AlarmsAlarmOutput
}

type AlarmsAlarmArgs struct {
	// The alarm id.
	AlarmId pulumi.StringInput `pulumi:"alarmId"`
	// The alarm name.
	AlarmName pulumi.StringInput `pulumi:"alarmName"`
	// List of notification groups corresponding to the alarm.
	AlarmNotifyGroups AlarmsAlarmAlarmNotifyGroupArrayInput `pulumi:"alarmNotifyGroups"`
	// Period for sending alarm notifications. When the number of continuous alarm triggers reaches the specified limit (TriggerPeriod), Log Service will send alarm notifications according to the specified period.
	AlarmPeriod pulumi.IntInput `pulumi:"alarmPeriod"`
	// Period for sending alarm notifications. When the number of continuous alarm triggers reaches the specified limit (TriggerPeriod), Log Service will send alarm notifications according to the specified period.
	AlarmPeriodDetails AlarmsAlarmAlarmPeriodDetailArrayInput `pulumi:"alarmPeriodDetails"`
	// Alarm trigger condition.
	Condition pulumi.StringInput `pulumi:"condition"`
	// The create time.
	CreateTime pulumi.StringInput `pulumi:"createTime"`
	// The modify time.
	ModifyTime pulumi.StringInput `pulumi:"modifyTime"`
	// The project id.
	ProjectId pulumi.StringInput `pulumi:"projectId"`
	// Search and analyze sentences, 1~3 can be configured.
	QueryRequests AlarmsAlarmQueryRequestArrayInput `pulumi:"queryRequests"`
	// The execution period of the alarm task.
	RequestCycles AlarmsAlarmRequestCycleArrayInput `pulumi:"requestCycles"`
	// The status.
	Status pulumi.BoolInput `pulumi:"status"`
	// Continuous cycle. The alarm will be issued after the trigger condition is continuously met for TriggerPeriod periods; the minimum value is 1, the maximum value is 10, and the default value is 1.
	TriggerPeriod pulumi.IntInput `pulumi:"triggerPeriod"`
	// Customize the alarm notification content.
	UserDefineMsg pulumi.StringInput `pulumi:"userDefineMsg"`
}

func (AlarmsAlarmArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AlarmsAlarm)(nil)).Elem()
}

func (i AlarmsAlarmArgs) ToAlarmsAlarmOutput() AlarmsAlarmOutput {
	return i.ToAlarmsAlarmOutputWithContext(context.Background())
}

func (i AlarmsAlarmArgs) ToAlarmsAlarmOutputWithContext(ctx context.Context) AlarmsAlarmOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlarmsAlarmOutput)
}

// AlarmsAlarmArrayInput is an input type that accepts AlarmsAlarmArray and AlarmsAlarmArrayOutput values.
// You can construct a concrete instance of `AlarmsAlarmArrayInput` via:
//
//	AlarmsAlarmArray{ AlarmsAlarmArgs{...} }
type AlarmsAlarmArrayInput interface {
	pulumi.Input

	ToAlarmsAlarmArrayOutput() AlarmsAlarmArrayOutput
	ToAlarmsAlarmArrayOutputWithContext(context.Context) AlarmsAlarmArrayOutput
}

type AlarmsAlarmArray []AlarmsAlarmInput

func (AlarmsAlarmArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AlarmsAlarm)(nil)).Elem()
}

func (i AlarmsAlarmArray) ToAlarmsAlarmArrayOutput() AlarmsAlarmArrayOutput {
	return i.ToAlarmsAlarmArrayOutputWithContext(context.Background())
}

func (i AlarmsAlarmArray) ToAlarmsAlarmArrayOutputWithContext(ctx context.Context) AlarmsAlarmArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlarmsAlarmArrayOutput)
}

type AlarmsAlarmOutput struct{ *pulumi.OutputState }

func (AlarmsAlarmOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AlarmsAlarm)(nil)).Elem()
}

func (o AlarmsAlarmOutput) ToAlarmsAlarmOutput() AlarmsAlarmOutput {
	return o
}

func (o AlarmsAlarmOutput) ToAlarmsAlarmOutputWithContext(ctx context.Context) AlarmsAlarmOutput {
	return o
}

// The alarm id.
func (o AlarmsAlarmOutput) AlarmId() pulumi.StringOutput {
	return o.ApplyT(func(v AlarmsAlarm) string { return v.AlarmId }).(pulumi.StringOutput)
}

// The alarm name.
func (o AlarmsAlarmOutput) AlarmName() pulumi.StringOutput {
	return o.ApplyT(func(v AlarmsAlarm) string { return v.AlarmName }).(pulumi.StringOutput)
}

// List of notification groups corresponding to the alarm.
func (o AlarmsAlarmOutput) AlarmNotifyGroups() AlarmsAlarmAlarmNotifyGroupArrayOutput {
	return o.ApplyT(func(v AlarmsAlarm) []AlarmsAlarmAlarmNotifyGroup { return v.AlarmNotifyGroups }).(AlarmsAlarmAlarmNotifyGroupArrayOutput)
}

// Period for sending alarm notifications. When the number of continuous alarm triggers reaches the specified limit (TriggerPeriod), Log Service will send alarm notifications according to the specified period.
func (o AlarmsAlarmOutput) AlarmPeriod() pulumi.IntOutput {
	return o.ApplyT(func(v AlarmsAlarm) int { return v.AlarmPeriod }).(pulumi.IntOutput)
}

// Period for sending alarm notifications. When the number of continuous alarm triggers reaches the specified limit (TriggerPeriod), Log Service will send alarm notifications according to the specified period.
func (o AlarmsAlarmOutput) AlarmPeriodDetails() AlarmsAlarmAlarmPeriodDetailArrayOutput {
	return o.ApplyT(func(v AlarmsAlarm) []AlarmsAlarmAlarmPeriodDetail { return v.AlarmPeriodDetails }).(AlarmsAlarmAlarmPeriodDetailArrayOutput)
}

// Alarm trigger condition.
func (o AlarmsAlarmOutput) Condition() pulumi.StringOutput {
	return o.ApplyT(func(v AlarmsAlarm) string { return v.Condition }).(pulumi.StringOutput)
}

// The create time.
func (o AlarmsAlarmOutput) CreateTime() pulumi.StringOutput {
	return o.ApplyT(func(v AlarmsAlarm) string { return v.CreateTime }).(pulumi.StringOutput)
}

// The modify time.
func (o AlarmsAlarmOutput) ModifyTime() pulumi.StringOutput {
	return o.ApplyT(func(v AlarmsAlarm) string { return v.ModifyTime }).(pulumi.StringOutput)
}

// The project id.
func (o AlarmsAlarmOutput) ProjectId() pulumi.StringOutput {
	return o.ApplyT(func(v AlarmsAlarm) string { return v.ProjectId }).(pulumi.StringOutput)
}

// Search and analyze sentences, 1~3 can be configured.
func (o AlarmsAlarmOutput) QueryRequests() AlarmsAlarmQueryRequestArrayOutput {
	return o.ApplyT(func(v AlarmsAlarm) []AlarmsAlarmQueryRequest { return v.QueryRequests }).(AlarmsAlarmQueryRequestArrayOutput)
}

// The execution period of the alarm task.
func (o AlarmsAlarmOutput) RequestCycles() AlarmsAlarmRequestCycleArrayOutput {
	return o.ApplyT(func(v AlarmsAlarm) []AlarmsAlarmRequestCycle { return v.RequestCycles }).(AlarmsAlarmRequestCycleArrayOutput)
}

// The status.
func (o AlarmsAlarmOutput) Status() pulumi.BoolOutput {
	return o.ApplyT(func(v AlarmsAlarm) bool { return v.Status }).(pulumi.BoolOutput)
}

// Continuous cycle. The alarm will be issued after the trigger condition is continuously met for TriggerPeriod periods; the minimum value is 1, the maximum value is 10, and the default value is 1.
func (o AlarmsAlarmOutput) TriggerPeriod() pulumi.IntOutput {
	return o.ApplyT(func(v AlarmsAlarm) int { return v.TriggerPeriod }).(pulumi.IntOutput)
}

// Customize the alarm notification content.
func (o AlarmsAlarmOutput) UserDefineMsg() pulumi.StringOutput {
	return o.ApplyT(func(v AlarmsAlarm) string { return v.UserDefineMsg }).(pulumi.StringOutput)
}

type AlarmsAlarmArrayOutput struct{ *pulumi.OutputState }

func (AlarmsAlarmArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AlarmsAlarm)(nil)).Elem()
}

func (o AlarmsAlarmArrayOutput) ToAlarmsAlarmArrayOutput() AlarmsAlarmArrayOutput {
	return o
}

func (o AlarmsAlarmArrayOutput) ToAlarmsAlarmArrayOutputWithContext(ctx context.Context) AlarmsAlarmArrayOutput {
	return o
}

func (o AlarmsAlarmArrayOutput) Index(i pulumi.IntInput) AlarmsAlarmOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AlarmsAlarm {
		return vs[0].([]AlarmsAlarm)[vs[1].(int)]
	}).(AlarmsAlarmOutput)
}

type AlarmsAlarmAlarmNotifyGroup struct {
	// The id of the notify group.
	AlarmNotifyGroupId string `pulumi:"alarmNotifyGroupId"`
	// Name of the notification group.
	AlarmNotifyGroupName string `pulumi:"alarmNotifyGroupName"`
	// The create time.
	CreateTime string `pulumi:"createTime"`
	// The iam project name.
	IamProjectName string `pulumi:"iamProjectName"`
	// The modify time.
	ModifyTime string `pulumi:"modifyTime"`
	// The notify group type.
	NotifyTypes []string `pulumi:"notifyTypes"`
	// List of IAM users to receive alerts.
	Receivers []AlarmsAlarmAlarmNotifyGroupReceiver `pulumi:"receivers"`
}

// AlarmsAlarmAlarmNotifyGroupInput is an input type that accepts AlarmsAlarmAlarmNotifyGroupArgs and AlarmsAlarmAlarmNotifyGroupOutput values.
// You can construct a concrete instance of `AlarmsAlarmAlarmNotifyGroupInput` via:
//
//	AlarmsAlarmAlarmNotifyGroupArgs{...}
type AlarmsAlarmAlarmNotifyGroupInput interface {
	pulumi.Input

	ToAlarmsAlarmAlarmNotifyGroupOutput() AlarmsAlarmAlarmNotifyGroupOutput
	ToAlarmsAlarmAlarmNotifyGroupOutputWithContext(context.Context) AlarmsAlarmAlarmNotifyGroupOutput
}

type AlarmsAlarmAlarmNotifyGroupArgs struct {
	// The id of the notify group.
	AlarmNotifyGroupId pulumi.StringInput `pulumi:"alarmNotifyGroupId"`
	// Name of the notification group.
	AlarmNotifyGroupName pulumi.StringInput `pulumi:"alarmNotifyGroupName"`
	// The create time.
	CreateTime pulumi.StringInput `pulumi:"createTime"`
	// The iam project name.
	IamProjectName pulumi.StringInput `pulumi:"iamProjectName"`
	// The modify time.
	ModifyTime pulumi.StringInput `pulumi:"modifyTime"`
	// The notify group type.
	NotifyTypes pulumi.StringArrayInput `pulumi:"notifyTypes"`
	// List of IAM users to receive alerts.
	Receivers AlarmsAlarmAlarmNotifyGroupReceiverArrayInput `pulumi:"receivers"`
}

func (AlarmsAlarmAlarmNotifyGroupArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AlarmsAlarmAlarmNotifyGroup)(nil)).Elem()
}

func (i AlarmsAlarmAlarmNotifyGroupArgs) ToAlarmsAlarmAlarmNotifyGroupOutput() AlarmsAlarmAlarmNotifyGroupOutput {
	return i.ToAlarmsAlarmAlarmNotifyGroupOutputWithContext(context.Background())
}

func (i AlarmsAlarmAlarmNotifyGroupArgs) ToAlarmsAlarmAlarmNotifyGroupOutputWithContext(ctx context.Context) AlarmsAlarmAlarmNotifyGroupOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlarmsAlarmAlarmNotifyGroupOutput)
}

// AlarmsAlarmAlarmNotifyGroupArrayInput is an input type that accepts AlarmsAlarmAlarmNotifyGroupArray and AlarmsAlarmAlarmNotifyGroupArrayOutput values.
// You can construct a concrete instance of `AlarmsAlarmAlarmNotifyGroupArrayInput` via:
//
//	AlarmsAlarmAlarmNotifyGroupArray{ AlarmsAlarmAlarmNotifyGroupArgs{...} }
type AlarmsAlarmAlarmNotifyGroupArrayInput interface {
	pulumi.Input

	ToAlarmsAlarmAlarmNotifyGroupArrayOutput() AlarmsAlarmAlarmNotifyGroupArrayOutput
	ToAlarmsAlarmAlarmNotifyGroupArrayOutputWithContext(context.Context) AlarmsAlarmAlarmNotifyGroupArrayOutput
}

type AlarmsAlarmAlarmNotifyGroupArray []AlarmsAlarmAlarmNotifyGroupInput

func (AlarmsAlarmAlarmNotifyGroupArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AlarmsAlarmAlarmNotifyGroup)(nil)).Elem()
}

func (i AlarmsAlarmAlarmNotifyGroupArray) ToAlarmsAlarmAlarmNotifyGroupArrayOutput() AlarmsAlarmAlarmNotifyGroupArrayOutput {
	return i.ToAlarmsAlarmAlarmNotifyGroupArrayOutputWithContext(context.Background())
}

func (i AlarmsAlarmAlarmNotifyGroupArray) ToAlarmsAlarmAlarmNotifyGroupArrayOutputWithContext(ctx context.Context) AlarmsAlarmAlarmNotifyGroupArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlarmsAlarmAlarmNotifyGroupArrayOutput)
}

type AlarmsAlarmAlarmNotifyGroupOutput struct{ *pulumi.OutputState }

func (AlarmsAlarmAlarmNotifyGroupOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AlarmsAlarmAlarmNotifyGroup)(nil)).Elem()
}

func (o AlarmsAlarmAlarmNotifyGroupOutput) ToAlarmsAlarmAlarmNotifyGroupOutput() AlarmsAlarmAlarmNotifyGroupOutput {
	return o
}

func (o AlarmsAlarmAlarmNotifyGroupOutput) ToAlarmsAlarmAlarmNotifyGroupOutputWithContext(ctx context.Context) AlarmsAlarmAlarmNotifyGroupOutput {
	return o
}

// The id of the notify group.
func (o AlarmsAlarmAlarmNotifyGroupOutput) AlarmNotifyGroupId() pulumi.StringOutput {
	return o.ApplyT(func(v AlarmsAlarmAlarmNotifyGroup) string { return v.AlarmNotifyGroupId }).(pulumi.StringOutput)
}

// Name of the notification group.
func (o AlarmsAlarmAlarmNotifyGroupOutput) AlarmNotifyGroupName() pulumi.StringOutput {
	return o.ApplyT(func(v AlarmsAlarmAlarmNotifyGroup) string { return v.AlarmNotifyGroupName }).(pulumi.StringOutput)
}

// The create time.
func (o AlarmsAlarmAlarmNotifyGroupOutput) CreateTime() pulumi.StringOutput {
	return o.ApplyT(func(v AlarmsAlarmAlarmNotifyGroup) string { return v.CreateTime }).(pulumi.StringOutput)
}

// The iam project name.
func (o AlarmsAlarmAlarmNotifyGroupOutput) IamProjectName() pulumi.StringOutput {
	return o.ApplyT(func(v AlarmsAlarmAlarmNotifyGroup) string { return v.IamProjectName }).(pulumi.StringOutput)
}

// The modify time.
func (o AlarmsAlarmAlarmNotifyGroupOutput) ModifyTime() pulumi.StringOutput {
	return o.ApplyT(func(v AlarmsAlarmAlarmNotifyGroup) string { return v.ModifyTime }).(pulumi.StringOutput)
}

// The notify group type.
func (o AlarmsAlarmAlarmNotifyGroupOutput) NotifyTypes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v AlarmsAlarmAlarmNotifyGroup) []string { return v.NotifyTypes }).(pulumi.StringArrayOutput)
}

// List of IAM users to receive alerts.
func (o AlarmsAlarmAlarmNotifyGroupOutput) Receivers() AlarmsAlarmAlarmNotifyGroupReceiverArrayOutput {
	return o.ApplyT(func(v AlarmsAlarmAlarmNotifyGroup) []AlarmsAlarmAlarmNotifyGroupReceiver { return v.Receivers }).(AlarmsAlarmAlarmNotifyGroupReceiverArrayOutput)
}

type AlarmsAlarmAlarmNotifyGroupArrayOutput struct{ *pulumi.OutputState }

func (AlarmsAlarmAlarmNotifyGroupArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AlarmsAlarmAlarmNotifyGroup)(nil)).Elem()
}

func (o AlarmsAlarmAlarmNotifyGroupArrayOutput) ToAlarmsAlarmAlarmNotifyGroupArrayOutput() AlarmsAlarmAlarmNotifyGroupArrayOutput {
	return o
}

func (o AlarmsAlarmAlarmNotifyGroupArrayOutput) ToAlarmsAlarmAlarmNotifyGroupArrayOutputWithContext(ctx context.Context) AlarmsAlarmAlarmNotifyGroupArrayOutput {
	return o
}

func (o AlarmsAlarmAlarmNotifyGroupArrayOutput) Index(i pulumi.IntInput) AlarmsAlarmAlarmNotifyGroupOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AlarmsAlarmAlarmNotifyGroup {
		return vs[0].([]AlarmsAlarmAlarmNotifyGroup)[vs[1].(int)]
	}).(AlarmsAlarmAlarmNotifyGroupOutput)
}

type AlarmsAlarmAlarmNotifyGroupReceiver struct {
	// The end time.
	EndTime string `pulumi:"endTime"`
	// The list of the receiver channels.
	ReceiverChannels []string `pulumi:"receiverChannels"`
	// List of the receiver names.
	ReceiverNames []string `pulumi:"receiverNames"`
	// The receiver type.
	ReceiverType string `pulumi:"receiverType"`
	// The start time.
	StartTime string `pulumi:"startTime"`
}

// AlarmsAlarmAlarmNotifyGroupReceiverInput is an input type that accepts AlarmsAlarmAlarmNotifyGroupReceiverArgs and AlarmsAlarmAlarmNotifyGroupReceiverOutput values.
// You can construct a concrete instance of `AlarmsAlarmAlarmNotifyGroupReceiverInput` via:
//
//	AlarmsAlarmAlarmNotifyGroupReceiverArgs{...}
type AlarmsAlarmAlarmNotifyGroupReceiverInput interface {
	pulumi.Input

	ToAlarmsAlarmAlarmNotifyGroupReceiverOutput() AlarmsAlarmAlarmNotifyGroupReceiverOutput
	ToAlarmsAlarmAlarmNotifyGroupReceiverOutputWithContext(context.Context) AlarmsAlarmAlarmNotifyGroupReceiverOutput
}

type AlarmsAlarmAlarmNotifyGroupReceiverArgs struct {
	// The end time.
	EndTime pulumi.StringInput `pulumi:"endTime"`
	// The list of the receiver channels.
	ReceiverChannels pulumi.StringArrayInput `pulumi:"receiverChannels"`
	// List of the receiver names.
	ReceiverNames pulumi.StringArrayInput `pulumi:"receiverNames"`
	// The receiver type.
	ReceiverType pulumi.StringInput `pulumi:"receiverType"`
	// The start time.
	StartTime pulumi.StringInput `pulumi:"startTime"`
}

func (AlarmsAlarmAlarmNotifyGroupReceiverArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AlarmsAlarmAlarmNotifyGroupReceiver)(nil)).Elem()
}

func (i AlarmsAlarmAlarmNotifyGroupReceiverArgs) ToAlarmsAlarmAlarmNotifyGroupReceiverOutput() AlarmsAlarmAlarmNotifyGroupReceiverOutput {
	return i.ToAlarmsAlarmAlarmNotifyGroupReceiverOutputWithContext(context.Background())
}

func (i AlarmsAlarmAlarmNotifyGroupReceiverArgs) ToAlarmsAlarmAlarmNotifyGroupReceiverOutputWithContext(ctx context.Context) AlarmsAlarmAlarmNotifyGroupReceiverOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlarmsAlarmAlarmNotifyGroupReceiverOutput)
}

// AlarmsAlarmAlarmNotifyGroupReceiverArrayInput is an input type that accepts AlarmsAlarmAlarmNotifyGroupReceiverArray and AlarmsAlarmAlarmNotifyGroupReceiverArrayOutput values.
// You can construct a concrete instance of `AlarmsAlarmAlarmNotifyGroupReceiverArrayInput` via:
//
//	AlarmsAlarmAlarmNotifyGroupReceiverArray{ AlarmsAlarmAlarmNotifyGroupReceiverArgs{...} }
type AlarmsAlarmAlarmNotifyGroupReceiverArrayInput interface {
	pulumi.Input

	ToAlarmsAlarmAlarmNotifyGroupReceiverArrayOutput() AlarmsAlarmAlarmNotifyGroupReceiverArrayOutput
	ToAlarmsAlarmAlarmNotifyGroupReceiverArrayOutputWithContext(context.Context) AlarmsAlarmAlarmNotifyGroupReceiverArrayOutput
}

type AlarmsAlarmAlarmNotifyGroupReceiverArray []AlarmsAlarmAlarmNotifyGroupReceiverInput

func (AlarmsAlarmAlarmNotifyGroupReceiverArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AlarmsAlarmAlarmNotifyGroupReceiver)(nil)).Elem()
}

func (i AlarmsAlarmAlarmNotifyGroupReceiverArray) ToAlarmsAlarmAlarmNotifyGroupReceiverArrayOutput() AlarmsAlarmAlarmNotifyGroupReceiverArrayOutput {
	return i.ToAlarmsAlarmAlarmNotifyGroupReceiverArrayOutputWithContext(context.Background())
}

func (i AlarmsAlarmAlarmNotifyGroupReceiverArray) ToAlarmsAlarmAlarmNotifyGroupReceiverArrayOutputWithContext(ctx context.Context) AlarmsAlarmAlarmNotifyGroupReceiverArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlarmsAlarmAlarmNotifyGroupReceiverArrayOutput)
}

type AlarmsAlarmAlarmNotifyGroupReceiverOutput struct{ *pulumi.OutputState }

func (AlarmsAlarmAlarmNotifyGroupReceiverOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AlarmsAlarmAlarmNotifyGroupReceiver)(nil)).Elem()
}

func (o AlarmsAlarmAlarmNotifyGroupReceiverOutput) ToAlarmsAlarmAlarmNotifyGroupReceiverOutput() AlarmsAlarmAlarmNotifyGroupReceiverOutput {
	return o
}

func (o AlarmsAlarmAlarmNotifyGroupReceiverOutput) ToAlarmsAlarmAlarmNotifyGroupReceiverOutputWithContext(ctx context.Context) AlarmsAlarmAlarmNotifyGroupReceiverOutput {
	return o
}

// The end time.
func (o AlarmsAlarmAlarmNotifyGroupReceiverOutput) EndTime() pulumi.StringOutput {
	return o.ApplyT(func(v AlarmsAlarmAlarmNotifyGroupReceiver) string { return v.EndTime }).(pulumi.StringOutput)
}

// The list of the receiver channels.
func (o AlarmsAlarmAlarmNotifyGroupReceiverOutput) ReceiverChannels() pulumi.StringArrayOutput {
	return o.ApplyT(func(v AlarmsAlarmAlarmNotifyGroupReceiver) []string { return v.ReceiverChannels }).(pulumi.StringArrayOutput)
}

// List of the receiver names.
func (o AlarmsAlarmAlarmNotifyGroupReceiverOutput) ReceiverNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v AlarmsAlarmAlarmNotifyGroupReceiver) []string { return v.ReceiverNames }).(pulumi.StringArrayOutput)
}

// The receiver type.
func (o AlarmsAlarmAlarmNotifyGroupReceiverOutput) ReceiverType() pulumi.StringOutput {
	return o.ApplyT(func(v AlarmsAlarmAlarmNotifyGroupReceiver) string { return v.ReceiverType }).(pulumi.StringOutput)
}

// The start time.
func (o AlarmsAlarmAlarmNotifyGroupReceiverOutput) StartTime() pulumi.StringOutput {
	return o.ApplyT(func(v AlarmsAlarmAlarmNotifyGroupReceiver) string { return v.StartTime }).(pulumi.StringOutput)
}

type AlarmsAlarmAlarmNotifyGroupReceiverArrayOutput struct{ *pulumi.OutputState }

func (AlarmsAlarmAlarmNotifyGroupReceiverArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AlarmsAlarmAlarmNotifyGroupReceiver)(nil)).Elem()
}

func (o AlarmsAlarmAlarmNotifyGroupReceiverArrayOutput) ToAlarmsAlarmAlarmNotifyGroupReceiverArrayOutput() AlarmsAlarmAlarmNotifyGroupReceiverArrayOutput {
	return o
}

func (o AlarmsAlarmAlarmNotifyGroupReceiverArrayOutput) ToAlarmsAlarmAlarmNotifyGroupReceiverArrayOutputWithContext(ctx context.Context) AlarmsAlarmAlarmNotifyGroupReceiverArrayOutput {
	return o
}

func (o AlarmsAlarmAlarmNotifyGroupReceiverArrayOutput) Index(i pulumi.IntInput) AlarmsAlarmAlarmNotifyGroupReceiverOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AlarmsAlarmAlarmNotifyGroupReceiver {
		return vs[0].([]AlarmsAlarmAlarmNotifyGroupReceiver)[vs[1].(int)]
	}).(AlarmsAlarmAlarmNotifyGroupReceiverOutput)
}

type AlarmsAlarmAlarmPeriodDetail struct {
	// Email alarm period, the unit is minutes, and the value range is 1~1440.
	Email int `pulumi:"email"`
	// Customize the webhook alarm period, the unit is minutes, and the value range is 1~1440.
	GeneralWebhook int `pulumi:"generalWebhook"`
	// Telephone alarm cycle, the unit is minutes, and the value range is 10~1440.
	Phone int `pulumi:"phone"`
	// SMS alarm cycle, the unit is minutes, and the value range is 10~1440.
	Sms int `pulumi:"sms"`
}

// AlarmsAlarmAlarmPeriodDetailInput is an input type that accepts AlarmsAlarmAlarmPeriodDetailArgs and AlarmsAlarmAlarmPeriodDetailOutput values.
// You can construct a concrete instance of `AlarmsAlarmAlarmPeriodDetailInput` via:
//
//	AlarmsAlarmAlarmPeriodDetailArgs{...}
type AlarmsAlarmAlarmPeriodDetailInput interface {
	pulumi.Input

	ToAlarmsAlarmAlarmPeriodDetailOutput() AlarmsAlarmAlarmPeriodDetailOutput
	ToAlarmsAlarmAlarmPeriodDetailOutputWithContext(context.Context) AlarmsAlarmAlarmPeriodDetailOutput
}

type AlarmsAlarmAlarmPeriodDetailArgs struct {
	// Email alarm period, the unit is minutes, and the value range is 1~1440.
	Email pulumi.IntInput `pulumi:"email"`
	// Customize the webhook alarm period, the unit is minutes, and the value range is 1~1440.
	GeneralWebhook pulumi.IntInput `pulumi:"generalWebhook"`
	// Telephone alarm cycle, the unit is minutes, and the value range is 10~1440.
	Phone pulumi.IntInput `pulumi:"phone"`
	// SMS alarm cycle, the unit is minutes, and the value range is 10~1440.
	Sms pulumi.IntInput `pulumi:"sms"`
}

func (AlarmsAlarmAlarmPeriodDetailArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AlarmsAlarmAlarmPeriodDetail)(nil)).Elem()
}

func (i AlarmsAlarmAlarmPeriodDetailArgs) ToAlarmsAlarmAlarmPeriodDetailOutput() AlarmsAlarmAlarmPeriodDetailOutput {
	return i.ToAlarmsAlarmAlarmPeriodDetailOutputWithContext(context.Background())
}

func (i AlarmsAlarmAlarmPeriodDetailArgs) ToAlarmsAlarmAlarmPeriodDetailOutputWithContext(ctx context.Context) AlarmsAlarmAlarmPeriodDetailOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlarmsAlarmAlarmPeriodDetailOutput)
}

// AlarmsAlarmAlarmPeriodDetailArrayInput is an input type that accepts AlarmsAlarmAlarmPeriodDetailArray and AlarmsAlarmAlarmPeriodDetailArrayOutput values.
// You can construct a concrete instance of `AlarmsAlarmAlarmPeriodDetailArrayInput` via:
//
//	AlarmsAlarmAlarmPeriodDetailArray{ AlarmsAlarmAlarmPeriodDetailArgs{...} }
type AlarmsAlarmAlarmPeriodDetailArrayInput interface {
	pulumi.Input

	ToAlarmsAlarmAlarmPeriodDetailArrayOutput() AlarmsAlarmAlarmPeriodDetailArrayOutput
	ToAlarmsAlarmAlarmPeriodDetailArrayOutputWithContext(context.Context) AlarmsAlarmAlarmPeriodDetailArrayOutput
}

type AlarmsAlarmAlarmPeriodDetailArray []AlarmsAlarmAlarmPeriodDetailInput

func (AlarmsAlarmAlarmPeriodDetailArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AlarmsAlarmAlarmPeriodDetail)(nil)).Elem()
}

func (i AlarmsAlarmAlarmPeriodDetailArray) ToAlarmsAlarmAlarmPeriodDetailArrayOutput() AlarmsAlarmAlarmPeriodDetailArrayOutput {
	return i.ToAlarmsAlarmAlarmPeriodDetailArrayOutputWithContext(context.Background())
}

func (i AlarmsAlarmAlarmPeriodDetailArray) ToAlarmsAlarmAlarmPeriodDetailArrayOutputWithContext(ctx context.Context) AlarmsAlarmAlarmPeriodDetailArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlarmsAlarmAlarmPeriodDetailArrayOutput)
}

type AlarmsAlarmAlarmPeriodDetailOutput struct{ *pulumi.OutputState }

func (AlarmsAlarmAlarmPeriodDetailOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AlarmsAlarmAlarmPeriodDetail)(nil)).Elem()
}

func (o AlarmsAlarmAlarmPeriodDetailOutput) ToAlarmsAlarmAlarmPeriodDetailOutput() AlarmsAlarmAlarmPeriodDetailOutput {
	return o
}

func (o AlarmsAlarmAlarmPeriodDetailOutput) ToAlarmsAlarmAlarmPeriodDetailOutputWithContext(ctx context.Context) AlarmsAlarmAlarmPeriodDetailOutput {
	return o
}

// Email alarm period, the unit is minutes, and the value range is 1~1440.
func (o AlarmsAlarmAlarmPeriodDetailOutput) Email() pulumi.IntOutput {
	return o.ApplyT(func(v AlarmsAlarmAlarmPeriodDetail) int { return v.Email }).(pulumi.IntOutput)
}

// Customize the webhook alarm period, the unit is minutes, and the value range is 1~1440.
func (o AlarmsAlarmAlarmPeriodDetailOutput) GeneralWebhook() pulumi.IntOutput {
	return o.ApplyT(func(v AlarmsAlarmAlarmPeriodDetail) int { return v.GeneralWebhook }).(pulumi.IntOutput)
}

// Telephone alarm cycle, the unit is minutes, and the value range is 10~1440.
func (o AlarmsAlarmAlarmPeriodDetailOutput) Phone() pulumi.IntOutput {
	return o.ApplyT(func(v AlarmsAlarmAlarmPeriodDetail) int { return v.Phone }).(pulumi.IntOutput)
}

// SMS alarm cycle, the unit is minutes, and the value range is 10~1440.
func (o AlarmsAlarmAlarmPeriodDetailOutput) Sms() pulumi.IntOutput {
	return o.ApplyT(func(v AlarmsAlarmAlarmPeriodDetail) int { return v.Sms }).(pulumi.IntOutput)
}

type AlarmsAlarmAlarmPeriodDetailArrayOutput struct{ *pulumi.OutputState }

func (AlarmsAlarmAlarmPeriodDetailArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AlarmsAlarmAlarmPeriodDetail)(nil)).Elem()
}

func (o AlarmsAlarmAlarmPeriodDetailArrayOutput) ToAlarmsAlarmAlarmPeriodDetailArrayOutput() AlarmsAlarmAlarmPeriodDetailArrayOutput {
	return o
}

func (o AlarmsAlarmAlarmPeriodDetailArrayOutput) ToAlarmsAlarmAlarmPeriodDetailArrayOutputWithContext(ctx context.Context) AlarmsAlarmAlarmPeriodDetailArrayOutput {
	return o
}

func (o AlarmsAlarmAlarmPeriodDetailArrayOutput) Index(i pulumi.IntInput) AlarmsAlarmAlarmPeriodDetailOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AlarmsAlarmAlarmPeriodDetail {
		return vs[0].([]AlarmsAlarmAlarmPeriodDetail)[vs[1].(int)]
	}).(AlarmsAlarmAlarmPeriodDetailOutput)
}

type AlarmsAlarmQueryRequest struct {
	// The end time of the query range is relative to the current historical time. The unit is minutes. The value is not positive and must be greater than StartTimeOffset. The maximum value is 0 and the minimum value is -1440.
	EndTimeOffset int `pulumi:"endTimeOffset"`
	// Alarm object sequence number; increments from 1.
	Number int `pulumi:"number"`
	// Query statement, the maximum supported length is 1024.
	Query string `pulumi:"query"`
	// The start time of the query range is relative to the current historical time, in minutes. The value is non-positive, the maximum value is 0, and the minimum value is -1440.
	StartTimeOffset int `pulumi:"startTimeOffset"`
	// The topic id.
	TopicId string `pulumi:"topicId"`
	// The topic name.
	TopicName string `pulumi:"topicName"`
}

// AlarmsAlarmQueryRequestInput is an input type that accepts AlarmsAlarmQueryRequestArgs and AlarmsAlarmQueryRequestOutput values.
// You can construct a concrete instance of `AlarmsAlarmQueryRequestInput` via:
//
//	AlarmsAlarmQueryRequestArgs{...}
type AlarmsAlarmQueryRequestInput interface {
	pulumi.Input

	ToAlarmsAlarmQueryRequestOutput() AlarmsAlarmQueryRequestOutput
	ToAlarmsAlarmQueryRequestOutputWithContext(context.Context) AlarmsAlarmQueryRequestOutput
}

type AlarmsAlarmQueryRequestArgs struct {
	// The end time of the query range is relative to the current historical time. The unit is minutes. The value is not positive and must be greater than StartTimeOffset. The maximum value is 0 and the minimum value is -1440.
	EndTimeOffset pulumi.IntInput `pulumi:"endTimeOffset"`
	// Alarm object sequence number; increments from 1.
	Number pulumi.IntInput `pulumi:"number"`
	// Query statement, the maximum supported length is 1024.
	Query pulumi.StringInput `pulumi:"query"`
	// The start time of the query range is relative to the current historical time, in minutes. The value is non-positive, the maximum value is 0, and the minimum value is -1440.
	StartTimeOffset pulumi.IntInput `pulumi:"startTimeOffset"`
	// The topic id.
	TopicId pulumi.StringInput `pulumi:"topicId"`
	// The topic name.
	TopicName pulumi.StringInput `pulumi:"topicName"`
}

func (AlarmsAlarmQueryRequestArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AlarmsAlarmQueryRequest)(nil)).Elem()
}

func (i AlarmsAlarmQueryRequestArgs) ToAlarmsAlarmQueryRequestOutput() AlarmsAlarmQueryRequestOutput {
	return i.ToAlarmsAlarmQueryRequestOutputWithContext(context.Background())
}

func (i AlarmsAlarmQueryRequestArgs) ToAlarmsAlarmQueryRequestOutputWithContext(ctx context.Context) AlarmsAlarmQueryRequestOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlarmsAlarmQueryRequestOutput)
}

// AlarmsAlarmQueryRequestArrayInput is an input type that accepts AlarmsAlarmQueryRequestArray and AlarmsAlarmQueryRequestArrayOutput values.
// You can construct a concrete instance of `AlarmsAlarmQueryRequestArrayInput` via:
//
//	AlarmsAlarmQueryRequestArray{ AlarmsAlarmQueryRequestArgs{...} }
type AlarmsAlarmQueryRequestArrayInput interface {
	pulumi.Input

	ToAlarmsAlarmQueryRequestArrayOutput() AlarmsAlarmQueryRequestArrayOutput
	ToAlarmsAlarmQueryRequestArrayOutputWithContext(context.Context) AlarmsAlarmQueryRequestArrayOutput
}

type AlarmsAlarmQueryRequestArray []AlarmsAlarmQueryRequestInput

func (AlarmsAlarmQueryRequestArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AlarmsAlarmQueryRequest)(nil)).Elem()
}

func (i AlarmsAlarmQueryRequestArray) ToAlarmsAlarmQueryRequestArrayOutput() AlarmsAlarmQueryRequestArrayOutput {
	return i.ToAlarmsAlarmQueryRequestArrayOutputWithContext(context.Background())
}

func (i AlarmsAlarmQueryRequestArray) ToAlarmsAlarmQueryRequestArrayOutputWithContext(ctx context.Context) AlarmsAlarmQueryRequestArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlarmsAlarmQueryRequestArrayOutput)
}

type AlarmsAlarmQueryRequestOutput struct{ *pulumi.OutputState }

func (AlarmsAlarmQueryRequestOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AlarmsAlarmQueryRequest)(nil)).Elem()
}

func (o AlarmsAlarmQueryRequestOutput) ToAlarmsAlarmQueryRequestOutput() AlarmsAlarmQueryRequestOutput {
	return o
}

func (o AlarmsAlarmQueryRequestOutput) ToAlarmsAlarmQueryRequestOutputWithContext(ctx context.Context) AlarmsAlarmQueryRequestOutput {
	return o
}

// The end time of the query range is relative to the current historical time. The unit is minutes. The value is not positive and must be greater than StartTimeOffset. The maximum value is 0 and the minimum value is -1440.
func (o AlarmsAlarmQueryRequestOutput) EndTimeOffset() pulumi.IntOutput {
	return o.ApplyT(func(v AlarmsAlarmQueryRequest) int { return v.EndTimeOffset }).(pulumi.IntOutput)
}

// Alarm object sequence number; increments from 1.
func (o AlarmsAlarmQueryRequestOutput) Number() pulumi.IntOutput {
	return o.ApplyT(func(v AlarmsAlarmQueryRequest) int { return v.Number }).(pulumi.IntOutput)
}

// Query statement, the maximum supported length is 1024.
func (o AlarmsAlarmQueryRequestOutput) Query() pulumi.StringOutput {
	return o.ApplyT(func(v AlarmsAlarmQueryRequest) string { return v.Query }).(pulumi.StringOutput)
}

// The start time of the query range is relative to the current historical time, in minutes. The value is non-positive, the maximum value is 0, and the minimum value is -1440.
func (o AlarmsAlarmQueryRequestOutput) StartTimeOffset() pulumi.IntOutput {
	return o.ApplyT(func(v AlarmsAlarmQueryRequest) int { return v.StartTimeOffset }).(pulumi.IntOutput)
}

// The topic id.
func (o AlarmsAlarmQueryRequestOutput) TopicId() pulumi.StringOutput {
	return o.ApplyT(func(v AlarmsAlarmQueryRequest) string { return v.TopicId }).(pulumi.StringOutput)
}

// The topic name.
func (o AlarmsAlarmQueryRequestOutput) TopicName() pulumi.StringOutput {
	return o.ApplyT(func(v AlarmsAlarmQueryRequest) string { return v.TopicName }).(pulumi.StringOutput)
}

type AlarmsAlarmQueryRequestArrayOutput struct{ *pulumi.OutputState }

func (AlarmsAlarmQueryRequestArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AlarmsAlarmQueryRequest)(nil)).Elem()
}

func (o AlarmsAlarmQueryRequestArrayOutput) ToAlarmsAlarmQueryRequestArrayOutput() AlarmsAlarmQueryRequestArrayOutput {
	return o
}

func (o AlarmsAlarmQueryRequestArrayOutput) ToAlarmsAlarmQueryRequestArrayOutputWithContext(ctx context.Context) AlarmsAlarmQueryRequestArrayOutput {
	return o
}

func (o AlarmsAlarmQueryRequestArrayOutput) Index(i pulumi.IntInput) AlarmsAlarmQueryRequestOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AlarmsAlarmQueryRequest {
		return vs[0].([]AlarmsAlarmQueryRequest)[vs[1].(int)]
	}).(AlarmsAlarmQueryRequestOutput)
}

type AlarmsAlarmRequestCycle struct {
	// The cycle of alarm task execution, or the time point of periodic execution. The unit is minutes, and the value range is 1~1440.
	Time int `pulumi:"time"`
	// Execution cycle type.
	Type string `pulumi:"type"`
}

// AlarmsAlarmRequestCycleInput is an input type that accepts AlarmsAlarmRequestCycleArgs and AlarmsAlarmRequestCycleOutput values.
// You can construct a concrete instance of `AlarmsAlarmRequestCycleInput` via:
//
//	AlarmsAlarmRequestCycleArgs{...}
type AlarmsAlarmRequestCycleInput interface {
	pulumi.Input

	ToAlarmsAlarmRequestCycleOutput() AlarmsAlarmRequestCycleOutput
	ToAlarmsAlarmRequestCycleOutputWithContext(context.Context) AlarmsAlarmRequestCycleOutput
}

type AlarmsAlarmRequestCycleArgs struct {
	// The cycle of alarm task execution, or the time point of periodic execution. The unit is minutes, and the value range is 1~1440.
	Time pulumi.IntInput `pulumi:"time"`
	// Execution cycle type.
	Type pulumi.StringInput `pulumi:"type"`
}

func (AlarmsAlarmRequestCycleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*AlarmsAlarmRequestCycle)(nil)).Elem()
}

func (i AlarmsAlarmRequestCycleArgs) ToAlarmsAlarmRequestCycleOutput() AlarmsAlarmRequestCycleOutput {
	return i.ToAlarmsAlarmRequestCycleOutputWithContext(context.Background())
}

func (i AlarmsAlarmRequestCycleArgs) ToAlarmsAlarmRequestCycleOutputWithContext(ctx context.Context) AlarmsAlarmRequestCycleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlarmsAlarmRequestCycleOutput)
}

// AlarmsAlarmRequestCycleArrayInput is an input type that accepts AlarmsAlarmRequestCycleArray and AlarmsAlarmRequestCycleArrayOutput values.
// You can construct a concrete instance of `AlarmsAlarmRequestCycleArrayInput` via:
//
//	AlarmsAlarmRequestCycleArray{ AlarmsAlarmRequestCycleArgs{...} }
type AlarmsAlarmRequestCycleArrayInput interface {
	pulumi.Input

	ToAlarmsAlarmRequestCycleArrayOutput() AlarmsAlarmRequestCycleArrayOutput
	ToAlarmsAlarmRequestCycleArrayOutputWithContext(context.Context) AlarmsAlarmRequestCycleArrayOutput
}

type AlarmsAlarmRequestCycleArray []AlarmsAlarmRequestCycleInput

func (AlarmsAlarmRequestCycleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AlarmsAlarmRequestCycle)(nil)).Elem()
}

func (i AlarmsAlarmRequestCycleArray) ToAlarmsAlarmRequestCycleArrayOutput() AlarmsAlarmRequestCycleArrayOutput {
	return i.ToAlarmsAlarmRequestCycleArrayOutputWithContext(context.Background())
}

func (i AlarmsAlarmRequestCycleArray) ToAlarmsAlarmRequestCycleArrayOutputWithContext(ctx context.Context) AlarmsAlarmRequestCycleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AlarmsAlarmRequestCycleArrayOutput)
}

type AlarmsAlarmRequestCycleOutput struct{ *pulumi.OutputState }

func (AlarmsAlarmRequestCycleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*AlarmsAlarmRequestCycle)(nil)).Elem()
}

func (o AlarmsAlarmRequestCycleOutput) ToAlarmsAlarmRequestCycleOutput() AlarmsAlarmRequestCycleOutput {
	return o
}

func (o AlarmsAlarmRequestCycleOutput) ToAlarmsAlarmRequestCycleOutputWithContext(ctx context.Context) AlarmsAlarmRequestCycleOutput {
	return o
}

// The cycle of alarm task execution, or the time point of periodic execution. The unit is minutes, and the value range is 1~1440.
func (o AlarmsAlarmRequestCycleOutput) Time() pulumi.IntOutput {
	return o.ApplyT(func(v AlarmsAlarmRequestCycle) int { return v.Time }).(pulumi.IntOutput)
}

// Execution cycle type.
func (o AlarmsAlarmRequestCycleOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v AlarmsAlarmRequestCycle) string { return v.Type }).(pulumi.StringOutput)
}

type AlarmsAlarmRequestCycleArrayOutput struct{ *pulumi.OutputState }

func (AlarmsAlarmRequestCycleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]AlarmsAlarmRequestCycle)(nil)).Elem()
}

func (o AlarmsAlarmRequestCycleArrayOutput) ToAlarmsAlarmRequestCycleArrayOutput() AlarmsAlarmRequestCycleArrayOutput {
	return o
}

func (o AlarmsAlarmRequestCycleArrayOutput) ToAlarmsAlarmRequestCycleArrayOutputWithContext(ctx context.Context) AlarmsAlarmRequestCycleArrayOutput {
	return o
}

func (o AlarmsAlarmRequestCycleArrayOutput) Index(i pulumi.IntInput) AlarmsAlarmRequestCycleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) AlarmsAlarmRequestCycle {
		return vs[0].([]AlarmsAlarmRequestCycle)[vs[1].(int)]
	}).(AlarmsAlarmRequestCycleOutput)
}

type HostGroupsInfo struct {
	// The abnormal heartbeat status count of host.
	AbnormalHeartbeatStatusCount int `pulumi:"abnormalHeartbeatStatusCount"`
	// The latest version of log collector.
	AgentLatestVersion string `pulumi:"agentLatestVersion"`
	// Whether enable auto update.
	AutoUpdate bool `pulumi:"autoUpdate"`
	// The create time of host group.
	CreateTime string `pulumi:"createTime"`
	// The count of host.
	HostCount int `pulumi:"hostCount"`
	// The id of host group.
	HostGroupId string `pulumi:"hostGroupId"`
	// The name of host group.
	HostGroupName string `pulumi:"hostGroupName"`
	// The type of host group.
	HostGroupType string `pulumi:"hostGroupType"`
	// The identifier of host.
	HostIdentifier string `pulumi:"hostIdentifier"`
	// The ip list of host group.
	HostIpLists []string `pulumi:"hostIpLists"`
	// The project name of iam.
	IamProjectName string `pulumi:"iamProjectName"`
	// The modify time of host group.
	ModifyTime string `pulumi:"modifyTime"`
	// The normal heartbeat status count of host.
	NormalHeartbeatStatusCount int `pulumi:"normalHeartbeatStatusCount"`
	// The rule count of host.
	RuleCount int `pulumi:"ruleCount"`
	// Whether enable service logging.
	ServiceLogging bool `pulumi:"serviceLogging"`
	// The update end time of log collector.
	UpdateEndTime string `pulumi:"updateEndTime"`
	// The update start time of log collector.
	UpdateStartTime string `pulumi:"updateStartTime"`
}

// HostGroupsInfoInput is an input type that accepts HostGroupsInfoArgs and HostGroupsInfoOutput values.
// You can construct a concrete instance of `HostGroupsInfoInput` via:
//
//	HostGroupsInfoArgs{...}
type HostGroupsInfoInput interface {
	pulumi.Input

	ToHostGroupsInfoOutput() HostGroupsInfoOutput
	ToHostGroupsInfoOutputWithContext(context.Context) HostGroupsInfoOutput
}

type HostGroupsInfoArgs struct {
	// The abnormal heartbeat status count of host.
	AbnormalHeartbeatStatusCount pulumi.IntInput `pulumi:"abnormalHeartbeatStatusCount"`
	// The latest version of log collector.
	AgentLatestVersion pulumi.StringInput `pulumi:"agentLatestVersion"`
	// Whether enable auto update.
	AutoUpdate pulumi.BoolInput `pulumi:"autoUpdate"`
	// The create time of host group.
	CreateTime pulumi.StringInput `pulumi:"createTime"`
	// The count of host.
	HostCount pulumi.IntInput `pulumi:"hostCount"`
	// The id of host group.
	HostGroupId pulumi.StringInput `pulumi:"hostGroupId"`
	// The name of host group.
	HostGroupName pulumi.StringInput `pulumi:"hostGroupName"`
	// The type of host group.
	HostGroupType pulumi.StringInput `pulumi:"hostGroupType"`
	// The identifier of host.
	HostIdentifier pulumi.StringInput `pulumi:"hostIdentifier"`
	// The ip list of host group.
	HostIpLists pulumi.StringArrayInput `pulumi:"hostIpLists"`
	// The project name of iam.
	IamProjectName pulumi.StringInput `pulumi:"iamProjectName"`
	// The modify time of host group.
	ModifyTime pulumi.StringInput `pulumi:"modifyTime"`
	// The normal heartbeat status count of host.
	NormalHeartbeatStatusCount pulumi.IntInput `pulumi:"normalHeartbeatStatusCount"`
	// The rule count of host.
	RuleCount pulumi.IntInput `pulumi:"ruleCount"`
	// Whether enable service logging.
	ServiceLogging pulumi.BoolInput `pulumi:"serviceLogging"`
	// The update end time of log collector.
	UpdateEndTime pulumi.StringInput `pulumi:"updateEndTime"`
	// The update start time of log collector.
	UpdateStartTime pulumi.StringInput `pulumi:"updateStartTime"`
}

func (HostGroupsInfoArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HostGroupsInfo)(nil)).Elem()
}

func (i HostGroupsInfoArgs) ToHostGroupsInfoOutput() HostGroupsInfoOutput {
	return i.ToHostGroupsInfoOutputWithContext(context.Background())
}

func (i HostGroupsInfoArgs) ToHostGroupsInfoOutputWithContext(ctx context.Context) HostGroupsInfoOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HostGroupsInfoOutput)
}

// HostGroupsInfoArrayInput is an input type that accepts HostGroupsInfoArray and HostGroupsInfoArrayOutput values.
// You can construct a concrete instance of `HostGroupsInfoArrayInput` via:
//
//	HostGroupsInfoArray{ HostGroupsInfoArgs{...} }
type HostGroupsInfoArrayInput interface {
	pulumi.Input

	ToHostGroupsInfoArrayOutput() HostGroupsInfoArrayOutput
	ToHostGroupsInfoArrayOutputWithContext(context.Context) HostGroupsInfoArrayOutput
}

type HostGroupsInfoArray []HostGroupsInfoInput

func (HostGroupsInfoArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HostGroupsInfo)(nil)).Elem()
}

func (i HostGroupsInfoArray) ToHostGroupsInfoArrayOutput() HostGroupsInfoArrayOutput {
	return i.ToHostGroupsInfoArrayOutputWithContext(context.Background())
}

func (i HostGroupsInfoArray) ToHostGroupsInfoArrayOutputWithContext(ctx context.Context) HostGroupsInfoArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HostGroupsInfoArrayOutput)
}

type HostGroupsInfoOutput struct{ *pulumi.OutputState }

func (HostGroupsInfoOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HostGroupsInfo)(nil)).Elem()
}

func (o HostGroupsInfoOutput) ToHostGroupsInfoOutput() HostGroupsInfoOutput {
	return o
}

func (o HostGroupsInfoOutput) ToHostGroupsInfoOutputWithContext(ctx context.Context) HostGroupsInfoOutput {
	return o
}

// The abnormal heartbeat status count of host.
func (o HostGroupsInfoOutput) AbnormalHeartbeatStatusCount() pulumi.IntOutput {
	return o.ApplyT(func(v HostGroupsInfo) int { return v.AbnormalHeartbeatStatusCount }).(pulumi.IntOutput)
}

// The latest version of log collector.
func (o HostGroupsInfoOutput) AgentLatestVersion() pulumi.StringOutput {
	return o.ApplyT(func(v HostGroupsInfo) string { return v.AgentLatestVersion }).(pulumi.StringOutput)
}

// Whether enable auto update.
func (o HostGroupsInfoOutput) AutoUpdate() pulumi.BoolOutput {
	return o.ApplyT(func(v HostGroupsInfo) bool { return v.AutoUpdate }).(pulumi.BoolOutput)
}

// The create time of host group.
func (o HostGroupsInfoOutput) CreateTime() pulumi.StringOutput {
	return o.ApplyT(func(v HostGroupsInfo) string { return v.CreateTime }).(pulumi.StringOutput)
}

// The count of host.
func (o HostGroupsInfoOutput) HostCount() pulumi.IntOutput {
	return o.ApplyT(func(v HostGroupsInfo) int { return v.HostCount }).(pulumi.IntOutput)
}

// The id of host group.
func (o HostGroupsInfoOutput) HostGroupId() pulumi.StringOutput {
	return o.ApplyT(func(v HostGroupsInfo) string { return v.HostGroupId }).(pulumi.StringOutput)
}

// The name of host group.
func (o HostGroupsInfoOutput) HostGroupName() pulumi.StringOutput {
	return o.ApplyT(func(v HostGroupsInfo) string { return v.HostGroupName }).(pulumi.StringOutput)
}

// The type of host group.
func (o HostGroupsInfoOutput) HostGroupType() pulumi.StringOutput {
	return o.ApplyT(func(v HostGroupsInfo) string { return v.HostGroupType }).(pulumi.StringOutput)
}

// The identifier of host.
func (o HostGroupsInfoOutput) HostIdentifier() pulumi.StringOutput {
	return o.ApplyT(func(v HostGroupsInfo) string { return v.HostIdentifier }).(pulumi.StringOutput)
}

// The ip list of host group.
func (o HostGroupsInfoOutput) HostIpLists() pulumi.StringArrayOutput {
	return o.ApplyT(func(v HostGroupsInfo) []string { return v.HostIpLists }).(pulumi.StringArrayOutput)
}

// The project name of iam.
func (o HostGroupsInfoOutput) IamProjectName() pulumi.StringOutput {
	return o.ApplyT(func(v HostGroupsInfo) string { return v.IamProjectName }).(pulumi.StringOutput)
}

// The modify time of host group.
func (o HostGroupsInfoOutput) ModifyTime() pulumi.StringOutput {
	return o.ApplyT(func(v HostGroupsInfo) string { return v.ModifyTime }).(pulumi.StringOutput)
}

// The normal heartbeat status count of host.
func (o HostGroupsInfoOutput) NormalHeartbeatStatusCount() pulumi.IntOutput {
	return o.ApplyT(func(v HostGroupsInfo) int { return v.NormalHeartbeatStatusCount }).(pulumi.IntOutput)
}

// The rule count of host.
func (o HostGroupsInfoOutput) RuleCount() pulumi.IntOutput {
	return o.ApplyT(func(v HostGroupsInfo) int { return v.RuleCount }).(pulumi.IntOutput)
}

// Whether enable service logging.
func (o HostGroupsInfoOutput) ServiceLogging() pulumi.BoolOutput {
	return o.ApplyT(func(v HostGroupsInfo) bool { return v.ServiceLogging }).(pulumi.BoolOutput)
}

// The update end time of log collector.
func (o HostGroupsInfoOutput) UpdateEndTime() pulumi.StringOutput {
	return o.ApplyT(func(v HostGroupsInfo) string { return v.UpdateEndTime }).(pulumi.StringOutput)
}

// The update start time of log collector.
func (o HostGroupsInfoOutput) UpdateStartTime() pulumi.StringOutput {
	return o.ApplyT(func(v HostGroupsInfo) string { return v.UpdateStartTime }).(pulumi.StringOutput)
}

type HostGroupsInfoArrayOutput struct{ *pulumi.OutputState }

func (HostGroupsInfoArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HostGroupsInfo)(nil)).Elem()
}

func (o HostGroupsInfoArrayOutput) ToHostGroupsInfoArrayOutput() HostGroupsInfoArrayOutput {
	return o
}

func (o HostGroupsInfoArrayOutput) ToHostGroupsInfoArrayOutputWithContext(ctx context.Context) HostGroupsInfoArrayOutput {
	return o
}

func (o HostGroupsInfoArrayOutput) Index(i pulumi.IntInput) HostGroupsInfoOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HostGroupsInfo {
		return vs[0].([]HostGroupsInfo)[vs[1].(int)]
	}).(HostGroupsInfoOutput)
}

type HostsHostInfo struct {
	// The the heartbeat status.
	HeartbeatStatus int `pulumi:"heartbeatStatus"`
	// The id of host group.
	HostGroupId string `pulumi:"hostGroupId"`
	// The ip address.
	Ip string `pulumi:"ip"`
	// The version of log collector.
	LogCollectorVersion string `pulumi:"logCollectorVersion"`
}

// HostsHostInfoInput is an input type that accepts HostsHostInfoArgs and HostsHostInfoOutput values.
// You can construct a concrete instance of `HostsHostInfoInput` via:
//
//	HostsHostInfoArgs{...}
type HostsHostInfoInput interface {
	pulumi.Input

	ToHostsHostInfoOutput() HostsHostInfoOutput
	ToHostsHostInfoOutputWithContext(context.Context) HostsHostInfoOutput
}

type HostsHostInfoArgs struct {
	// The the heartbeat status.
	HeartbeatStatus pulumi.IntInput `pulumi:"heartbeatStatus"`
	// The id of host group.
	HostGroupId pulumi.StringInput `pulumi:"hostGroupId"`
	// The ip address.
	Ip pulumi.StringInput `pulumi:"ip"`
	// The version of log collector.
	LogCollectorVersion pulumi.StringInput `pulumi:"logCollectorVersion"`
}

func (HostsHostInfoArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HostsHostInfo)(nil)).Elem()
}

func (i HostsHostInfoArgs) ToHostsHostInfoOutput() HostsHostInfoOutput {
	return i.ToHostsHostInfoOutputWithContext(context.Background())
}

func (i HostsHostInfoArgs) ToHostsHostInfoOutputWithContext(ctx context.Context) HostsHostInfoOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HostsHostInfoOutput)
}

// HostsHostInfoArrayInput is an input type that accepts HostsHostInfoArray and HostsHostInfoArrayOutput values.
// You can construct a concrete instance of `HostsHostInfoArrayInput` via:
//
//	HostsHostInfoArray{ HostsHostInfoArgs{...} }
type HostsHostInfoArrayInput interface {
	pulumi.Input

	ToHostsHostInfoArrayOutput() HostsHostInfoArrayOutput
	ToHostsHostInfoArrayOutputWithContext(context.Context) HostsHostInfoArrayOutput
}

type HostsHostInfoArray []HostsHostInfoInput

func (HostsHostInfoArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HostsHostInfo)(nil)).Elem()
}

func (i HostsHostInfoArray) ToHostsHostInfoArrayOutput() HostsHostInfoArrayOutput {
	return i.ToHostsHostInfoArrayOutputWithContext(context.Background())
}

func (i HostsHostInfoArray) ToHostsHostInfoArrayOutputWithContext(ctx context.Context) HostsHostInfoArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HostsHostInfoArrayOutput)
}

type HostsHostInfoOutput struct{ *pulumi.OutputState }

func (HostsHostInfoOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HostsHostInfo)(nil)).Elem()
}

func (o HostsHostInfoOutput) ToHostsHostInfoOutput() HostsHostInfoOutput {
	return o
}

func (o HostsHostInfoOutput) ToHostsHostInfoOutputWithContext(ctx context.Context) HostsHostInfoOutput {
	return o
}

// The the heartbeat status.
func (o HostsHostInfoOutput) HeartbeatStatus() pulumi.IntOutput {
	return o.ApplyT(func(v HostsHostInfo) int { return v.HeartbeatStatus }).(pulumi.IntOutput)
}

// The id of host group.
func (o HostsHostInfoOutput) HostGroupId() pulumi.StringOutput {
	return o.ApplyT(func(v HostsHostInfo) string { return v.HostGroupId }).(pulumi.StringOutput)
}

// The ip address.
func (o HostsHostInfoOutput) Ip() pulumi.StringOutput {
	return o.ApplyT(func(v HostsHostInfo) string { return v.Ip }).(pulumi.StringOutput)
}

// The version of log collector.
func (o HostsHostInfoOutput) LogCollectorVersion() pulumi.StringOutput {
	return o.ApplyT(func(v HostsHostInfo) string { return v.LogCollectorVersion }).(pulumi.StringOutput)
}

type HostsHostInfoArrayOutput struct{ *pulumi.OutputState }

func (HostsHostInfoArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HostsHostInfo)(nil)).Elem()
}

func (o HostsHostInfoArrayOutput) ToHostsHostInfoArrayOutput() HostsHostInfoArrayOutput {
	return o
}

func (o HostsHostInfoArrayOutput) ToHostsHostInfoArrayOutputWithContext(ctx context.Context) HostsHostInfoArrayOutput {
	return o
}

func (o HostsHostInfoArrayOutput) Index(i pulumi.IntInput) HostsHostInfoOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HostsHostInfo {
		return vs[0].([]HostsHostInfo)[vs[1].(int)]
	}).(HostsHostInfoOutput)
}

type IndexFullText struct {
	// Whether the FullTextInfo is case sensitive.
	CaseSensitive bool `pulumi:"caseSensitive"`
	// The delimiter of the FullTextInfo.
	Delimiter *string `pulumi:"delimiter"`
	// Whether the FullTextInfo include chinese.
	IncludeChinese *bool `pulumi:"includeChinese"`
}

// IndexFullTextInput is an input type that accepts IndexFullTextArgs and IndexFullTextOutput values.
// You can construct a concrete instance of `IndexFullTextInput` via:
//
//	IndexFullTextArgs{...}
type IndexFullTextInput interface {
	pulumi.Input

	ToIndexFullTextOutput() IndexFullTextOutput
	ToIndexFullTextOutputWithContext(context.Context) IndexFullTextOutput
}

type IndexFullTextArgs struct {
	// Whether the FullTextInfo is case sensitive.
	CaseSensitive pulumi.BoolInput `pulumi:"caseSensitive"`
	// The delimiter of the FullTextInfo.
	Delimiter pulumi.StringPtrInput `pulumi:"delimiter"`
	// Whether the FullTextInfo include chinese.
	IncludeChinese pulumi.BoolPtrInput `pulumi:"includeChinese"`
}

func (IndexFullTextArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexFullText)(nil)).Elem()
}

func (i IndexFullTextArgs) ToIndexFullTextOutput() IndexFullTextOutput {
	return i.ToIndexFullTextOutputWithContext(context.Background())
}

func (i IndexFullTextArgs) ToIndexFullTextOutputWithContext(ctx context.Context) IndexFullTextOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexFullTextOutput)
}

func (i IndexFullTextArgs) ToIndexFullTextPtrOutput() IndexFullTextPtrOutput {
	return i.ToIndexFullTextPtrOutputWithContext(context.Background())
}

func (i IndexFullTextArgs) ToIndexFullTextPtrOutputWithContext(ctx context.Context) IndexFullTextPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexFullTextOutput).ToIndexFullTextPtrOutputWithContext(ctx)
}

// IndexFullTextPtrInput is an input type that accepts IndexFullTextArgs, IndexFullTextPtr and IndexFullTextPtrOutput values.
// You can construct a concrete instance of `IndexFullTextPtrInput` via:
//
//	        IndexFullTextArgs{...}
//
//	or:
//
//	        nil
type IndexFullTextPtrInput interface {
	pulumi.Input

	ToIndexFullTextPtrOutput() IndexFullTextPtrOutput
	ToIndexFullTextPtrOutputWithContext(context.Context) IndexFullTextPtrOutput
}

type indexFullTextPtrType IndexFullTextArgs

func IndexFullTextPtr(v *IndexFullTextArgs) IndexFullTextPtrInput {
	return (*indexFullTextPtrType)(v)
}

func (*indexFullTextPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexFullText)(nil)).Elem()
}

func (i *indexFullTextPtrType) ToIndexFullTextPtrOutput() IndexFullTextPtrOutput {
	return i.ToIndexFullTextPtrOutputWithContext(context.Background())
}

func (i *indexFullTextPtrType) ToIndexFullTextPtrOutputWithContext(ctx context.Context) IndexFullTextPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexFullTextPtrOutput)
}

type IndexFullTextOutput struct{ *pulumi.OutputState }

func (IndexFullTextOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexFullText)(nil)).Elem()
}

func (o IndexFullTextOutput) ToIndexFullTextOutput() IndexFullTextOutput {
	return o
}

func (o IndexFullTextOutput) ToIndexFullTextOutputWithContext(ctx context.Context) IndexFullTextOutput {
	return o
}

func (o IndexFullTextOutput) ToIndexFullTextPtrOutput() IndexFullTextPtrOutput {
	return o.ToIndexFullTextPtrOutputWithContext(context.Background())
}

func (o IndexFullTextOutput) ToIndexFullTextPtrOutputWithContext(ctx context.Context) IndexFullTextPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v IndexFullText) *IndexFullText {
		return &v
	}).(IndexFullTextPtrOutput)
}

// Whether the FullTextInfo is case sensitive.
func (o IndexFullTextOutput) CaseSensitive() pulumi.BoolOutput {
	return o.ApplyT(func(v IndexFullText) bool { return v.CaseSensitive }).(pulumi.BoolOutput)
}

// The delimiter of the FullTextInfo.
func (o IndexFullTextOutput) Delimiter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexFullText) *string { return v.Delimiter }).(pulumi.StringPtrOutput)
}

// Whether the FullTextInfo include chinese.
func (o IndexFullTextOutput) IncludeChinese() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v IndexFullText) *bool { return v.IncludeChinese }).(pulumi.BoolPtrOutput)
}

type IndexFullTextPtrOutput struct{ *pulumi.OutputState }

func (IndexFullTextPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IndexFullText)(nil)).Elem()
}

func (o IndexFullTextPtrOutput) ToIndexFullTextPtrOutput() IndexFullTextPtrOutput {
	return o
}

func (o IndexFullTextPtrOutput) ToIndexFullTextPtrOutputWithContext(ctx context.Context) IndexFullTextPtrOutput {
	return o
}

func (o IndexFullTextPtrOutput) Elem() IndexFullTextOutput {
	return o.ApplyT(func(v *IndexFullText) IndexFullText {
		if v != nil {
			return *v
		}
		var ret IndexFullText
		return ret
	}).(IndexFullTextOutput)
}

// Whether the FullTextInfo is case sensitive.
func (o IndexFullTextPtrOutput) CaseSensitive() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *IndexFullText) *bool {
		if v == nil {
			return nil
		}
		return &v.CaseSensitive
	}).(pulumi.BoolPtrOutput)
}

// The delimiter of the FullTextInfo.
func (o IndexFullTextPtrOutput) Delimiter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IndexFullText) *string {
		if v == nil {
			return nil
		}
		return v.Delimiter
	}).(pulumi.StringPtrOutput)
}

// Whether the FullTextInfo include chinese.
func (o IndexFullTextPtrOutput) IncludeChinese() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *IndexFullText) *bool {
		if v == nil {
			return nil
		}
		return v.IncludeChinese
	}).(pulumi.BoolPtrOutput)
}

type IndexKeyValue struct {
	// Whether the value is case sensitive.
	CaseSensitive *bool `pulumi:"caseSensitive"`
	// The delimiter of the value.
	Delimiter *string `pulumi:"delimiter"`
	// Whether the value include chinese.
	IncludeChinese *bool `pulumi:"includeChinese"`
	// Whether to create indexes for all fields in JSON fields with text values. This field is valid when the `valueType` is `json`.
	IndexAll *bool `pulumi:"indexAll"`
	// The JSON subfield key value index.
	JsonKeys []IndexKeyValueJsonKey `pulumi:"jsonKeys"`
	// The key of the KeyValueInfo.
	Key string `pulumi:"key"`
	// Whether the filed is enabled for analysis.
	SqlFlag *bool `pulumi:"sqlFlag"`
	// The type of value. Valid values: `long`, `double`, `text`, `json`.
	ValueType string `pulumi:"valueType"`
}

// IndexKeyValueInput is an input type that accepts IndexKeyValueArgs and IndexKeyValueOutput values.
// You can construct a concrete instance of `IndexKeyValueInput` via:
//
//	IndexKeyValueArgs{...}
type IndexKeyValueInput interface {
	pulumi.Input

	ToIndexKeyValueOutput() IndexKeyValueOutput
	ToIndexKeyValueOutputWithContext(context.Context) IndexKeyValueOutput
}

type IndexKeyValueArgs struct {
	// Whether the value is case sensitive.
	CaseSensitive pulumi.BoolPtrInput `pulumi:"caseSensitive"`
	// The delimiter of the value.
	Delimiter pulumi.StringPtrInput `pulumi:"delimiter"`
	// Whether the value include chinese.
	IncludeChinese pulumi.BoolPtrInput `pulumi:"includeChinese"`
	// Whether to create indexes for all fields in JSON fields with text values. This field is valid when the `valueType` is `json`.
	IndexAll pulumi.BoolPtrInput `pulumi:"indexAll"`
	// The JSON subfield key value index.
	JsonKeys IndexKeyValueJsonKeyArrayInput `pulumi:"jsonKeys"`
	// The key of the KeyValueInfo.
	Key pulumi.StringInput `pulumi:"key"`
	// Whether the filed is enabled for analysis.
	SqlFlag pulumi.BoolPtrInput `pulumi:"sqlFlag"`
	// The type of value. Valid values: `long`, `double`, `text`, `json`.
	ValueType pulumi.StringInput `pulumi:"valueType"`
}

func (IndexKeyValueArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexKeyValue)(nil)).Elem()
}

func (i IndexKeyValueArgs) ToIndexKeyValueOutput() IndexKeyValueOutput {
	return i.ToIndexKeyValueOutputWithContext(context.Background())
}

func (i IndexKeyValueArgs) ToIndexKeyValueOutputWithContext(ctx context.Context) IndexKeyValueOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexKeyValueOutput)
}

// IndexKeyValueArrayInput is an input type that accepts IndexKeyValueArray and IndexKeyValueArrayOutput values.
// You can construct a concrete instance of `IndexKeyValueArrayInput` via:
//
//	IndexKeyValueArray{ IndexKeyValueArgs{...} }
type IndexKeyValueArrayInput interface {
	pulumi.Input

	ToIndexKeyValueArrayOutput() IndexKeyValueArrayOutput
	ToIndexKeyValueArrayOutputWithContext(context.Context) IndexKeyValueArrayOutput
}

type IndexKeyValueArray []IndexKeyValueInput

func (IndexKeyValueArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexKeyValue)(nil)).Elem()
}

func (i IndexKeyValueArray) ToIndexKeyValueArrayOutput() IndexKeyValueArrayOutput {
	return i.ToIndexKeyValueArrayOutputWithContext(context.Background())
}

func (i IndexKeyValueArray) ToIndexKeyValueArrayOutputWithContext(ctx context.Context) IndexKeyValueArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexKeyValueArrayOutput)
}

type IndexKeyValueOutput struct{ *pulumi.OutputState }

func (IndexKeyValueOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexKeyValue)(nil)).Elem()
}

func (o IndexKeyValueOutput) ToIndexKeyValueOutput() IndexKeyValueOutput {
	return o
}

func (o IndexKeyValueOutput) ToIndexKeyValueOutputWithContext(ctx context.Context) IndexKeyValueOutput {
	return o
}

// Whether the value is case sensitive.
func (o IndexKeyValueOutput) CaseSensitive() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v IndexKeyValue) *bool { return v.CaseSensitive }).(pulumi.BoolPtrOutput)
}

// The delimiter of the value.
func (o IndexKeyValueOutput) Delimiter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexKeyValue) *string { return v.Delimiter }).(pulumi.StringPtrOutput)
}

// Whether the value include chinese.
func (o IndexKeyValueOutput) IncludeChinese() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v IndexKeyValue) *bool { return v.IncludeChinese }).(pulumi.BoolPtrOutput)
}

// Whether to create indexes for all fields in JSON fields with text values. This field is valid when the `valueType` is `json`.
func (o IndexKeyValueOutput) IndexAll() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v IndexKeyValue) *bool { return v.IndexAll }).(pulumi.BoolPtrOutput)
}

// The JSON subfield key value index.
func (o IndexKeyValueOutput) JsonKeys() IndexKeyValueJsonKeyArrayOutput {
	return o.ApplyT(func(v IndexKeyValue) []IndexKeyValueJsonKey { return v.JsonKeys }).(IndexKeyValueJsonKeyArrayOutput)
}

// The key of the KeyValueInfo.
func (o IndexKeyValueOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v IndexKeyValue) string { return v.Key }).(pulumi.StringOutput)
}

// Whether the filed is enabled for analysis.
func (o IndexKeyValueOutput) SqlFlag() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v IndexKeyValue) *bool { return v.SqlFlag }).(pulumi.BoolPtrOutput)
}

// The type of value. Valid values: `long`, `double`, `text`, `json`.
func (o IndexKeyValueOutput) ValueType() pulumi.StringOutput {
	return o.ApplyT(func(v IndexKeyValue) string { return v.ValueType }).(pulumi.StringOutput)
}

type IndexKeyValueArrayOutput struct{ *pulumi.OutputState }

func (IndexKeyValueArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexKeyValue)(nil)).Elem()
}

func (o IndexKeyValueArrayOutput) ToIndexKeyValueArrayOutput() IndexKeyValueArrayOutput {
	return o
}

func (o IndexKeyValueArrayOutput) ToIndexKeyValueArrayOutputWithContext(ctx context.Context) IndexKeyValueArrayOutput {
	return o
}

func (o IndexKeyValueArrayOutput) Index(i pulumi.IntInput) IndexKeyValueOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IndexKeyValue {
		return vs[0].([]IndexKeyValue)[vs[1].(int)]
	}).(IndexKeyValueOutput)
}

type IndexKeyValueJsonKey struct {
	// The key of the subfield key value index.
	Key string `pulumi:"key"`
	// The type of value. Valid values: `long`, `double`, `text`.
	ValueType string `pulumi:"valueType"`
}

// IndexKeyValueJsonKeyInput is an input type that accepts IndexKeyValueJsonKeyArgs and IndexKeyValueJsonKeyOutput values.
// You can construct a concrete instance of `IndexKeyValueJsonKeyInput` via:
//
//	IndexKeyValueJsonKeyArgs{...}
type IndexKeyValueJsonKeyInput interface {
	pulumi.Input

	ToIndexKeyValueJsonKeyOutput() IndexKeyValueJsonKeyOutput
	ToIndexKeyValueJsonKeyOutputWithContext(context.Context) IndexKeyValueJsonKeyOutput
}

type IndexKeyValueJsonKeyArgs struct {
	// The key of the subfield key value index.
	Key pulumi.StringInput `pulumi:"key"`
	// The type of value. Valid values: `long`, `double`, `text`.
	ValueType pulumi.StringInput `pulumi:"valueType"`
}

func (IndexKeyValueJsonKeyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexKeyValueJsonKey)(nil)).Elem()
}

func (i IndexKeyValueJsonKeyArgs) ToIndexKeyValueJsonKeyOutput() IndexKeyValueJsonKeyOutput {
	return i.ToIndexKeyValueJsonKeyOutputWithContext(context.Background())
}

func (i IndexKeyValueJsonKeyArgs) ToIndexKeyValueJsonKeyOutputWithContext(ctx context.Context) IndexKeyValueJsonKeyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexKeyValueJsonKeyOutput)
}

// IndexKeyValueJsonKeyArrayInput is an input type that accepts IndexKeyValueJsonKeyArray and IndexKeyValueJsonKeyArrayOutput values.
// You can construct a concrete instance of `IndexKeyValueJsonKeyArrayInput` via:
//
//	IndexKeyValueJsonKeyArray{ IndexKeyValueJsonKeyArgs{...} }
type IndexKeyValueJsonKeyArrayInput interface {
	pulumi.Input

	ToIndexKeyValueJsonKeyArrayOutput() IndexKeyValueJsonKeyArrayOutput
	ToIndexKeyValueJsonKeyArrayOutputWithContext(context.Context) IndexKeyValueJsonKeyArrayOutput
}

type IndexKeyValueJsonKeyArray []IndexKeyValueJsonKeyInput

func (IndexKeyValueJsonKeyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexKeyValueJsonKey)(nil)).Elem()
}

func (i IndexKeyValueJsonKeyArray) ToIndexKeyValueJsonKeyArrayOutput() IndexKeyValueJsonKeyArrayOutput {
	return i.ToIndexKeyValueJsonKeyArrayOutputWithContext(context.Background())
}

func (i IndexKeyValueJsonKeyArray) ToIndexKeyValueJsonKeyArrayOutputWithContext(ctx context.Context) IndexKeyValueJsonKeyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexKeyValueJsonKeyArrayOutput)
}

type IndexKeyValueJsonKeyOutput struct{ *pulumi.OutputState }

func (IndexKeyValueJsonKeyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexKeyValueJsonKey)(nil)).Elem()
}

func (o IndexKeyValueJsonKeyOutput) ToIndexKeyValueJsonKeyOutput() IndexKeyValueJsonKeyOutput {
	return o
}

func (o IndexKeyValueJsonKeyOutput) ToIndexKeyValueJsonKeyOutputWithContext(ctx context.Context) IndexKeyValueJsonKeyOutput {
	return o
}

// The key of the subfield key value index.
func (o IndexKeyValueJsonKeyOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v IndexKeyValueJsonKey) string { return v.Key }).(pulumi.StringOutput)
}

// The type of value. Valid values: `long`, `double`, `text`.
func (o IndexKeyValueJsonKeyOutput) ValueType() pulumi.StringOutput {
	return o.ApplyT(func(v IndexKeyValueJsonKey) string { return v.ValueType }).(pulumi.StringOutput)
}

type IndexKeyValueJsonKeyArrayOutput struct{ *pulumi.OutputState }

func (IndexKeyValueJsonKeyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexKeyValueJsonKey)(nil)).Elem()
}

func (o IndexKeyValueJsonKeyArrayOutput) ToIndexKeyValueJsonKeyArrayOutput() IndexKeyValueJsonKeyArrayOutput {
	return o
}

func (o IndexKeyValueJsonKeyArrayOutput) ToIndexKeyValueJsonKeyArrayOutputWithContext(ctx context.Context) IndexKeyValueJsonKeyArrayOutput {
	return o
}

func (o IndexKeyValueJsonKeyArrayOutput) Index(i pulumi.IntInput) IndexKeyValueJsonKeyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IndexKeyValueJsonKey {
		return vs[0].([]IndexKeyValueJsonKey)[vs[1].(int)]
	}).(IndexKeyValueJsonKeyOutput)
}

type IndexUserInnerKeyValue struct {
	// Whether the value is case sensitive.
	CaseSensitive *bool `pulumi:"caseSensitive"`
	// The delimiter of the value.
	Delimiter *string `pulumi:"delimiter"`
	// Whether the value include chinese.
	IncludeChinese *bool `pulumi:"includeChinese"`
	// The JSON subfield key value index.
	JsonKeys []IndexUserInnerKeyValueJsonKey `pulumi:"jsonKeys"`
	// The key of the KeyValueInfo.
	Key string `pulumi:"key"`
	// Whether the filed is enabled for analysis.
	SqlFlag *bool `pulumi:"sqlFlag"`
	// The type of value. Valid values: `long`, `double`, `text`, `json`.
	ValueType string `pulumi:"valueType"`
}

// IndexUserInnerKeyValueInput is an input type that accepts IndexUserInnerKeyValueArgs and IndexUserInnerKeyValueOutput values.
// You can construct a concrete instance of `IndexUserInnerKeyValueInput` via:
//
//	IndexUserInnerKeyValueArgs{...}
type IndexUserInnerKeyValueInput interface {
	pulumi.Input

	ToIndexUserInnerKeyValueOutput() IndexUserInnerKeyValueOutput
	ToIndexUserInnerKeyValueOutputWithContext(context.Context) IndexUserInnerKeyValueOutput
}

type IndexUserInnerKeyValueArgs struct {
	// Whether the value is case sensitive.
	CaseSensitive pulumi.BoolPtrInput `pulumi:"caseSensitive"`
	// The delimiter of the value.
	Delimiter pulumi.StringPtrInput `pulumi:"delimiter"`
	// Whether the value include chinese.
	IncludeChinese pulumi.BoolPtrInput `pulumi:"includeChinese"`
	// The JSON subfield key value index.
	JsonKeys IndexUserInnerKeyValueJsonKeyArrayInput `pulumi:"jsonKeys"`
	// The key of the KeyValueInfo.
	Key pulumi.StringInput `pulumi:"key"`
	// Whether the filed is enabled for analysis.
	SqlFlag pulumi.BoolPtrInput `pulumi:"sqlFlag"`
	// The type of value. Valid values: `long`, `double`, `text`, `json`.
	ValueType pulumi.StringInput `pulumi:"valueType"`
}

func (IndexUserInnerKeyValueArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexUserInnerKeyValue)(nil)).Elem()
}

func (i IndexUserInnerKeyValueArgs) ToIndexUserInnerKeyValueOutput() IndexUserInnerKeyValueOutput {
	return i.ToIndexUserInnerKeyValueOutputWithContext(context.Background())
}

func (i IndexUserInnerKeyValueArgs) ToIndexUserInnerKeyValueOutputWithContext(ctx context.Context) IndexUserInnerKeyValueOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexUserInnerKeyValueOutput)
}

// IndexUserInnerKeyValueArrayInput is an input type that accepts IndexUserInnerKeyValueArray and IndexUserInnerKeyValueArrayOutput values.
// You can construct a concrete instance of `IndexUserInnerKeyValueArrayInput` via:
//
//	IndexUserInnerKeyValueArray{ IndexUserInnerKeyValueArgs{...} }
type IndexUserInnerKeyValueArrayInput interface {
	pulumi.Input

	ToIndexUserInnerKeyValueArrayOutput() IndexUserInnerKeyValueArrayOutput
	ToIndexUserInnerKeyValueArrayOutputWithContext(context.Context) IndexUserInnerKeyValueArrayOutput
}

type IndexUserInnerKeyValueArray []IndexUserInnerKeyValueInput

func (IndexUserInnerKeyValueArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexUserInnerKeyValue)(nil)).Elem()
}

func (i IndexUserInnerKeyValueArray) ToIndexUserInnerKeyValueArrayOutput() IndexUserInnerKeyValueArrayOutput {
	return i.ToIndexUserInnerKeyValueArrayOutputWithContext(context.Background())
}

func (i IndexUserInnerKeyValueArray) ToIndexUserInnerKeyValueArrayOutputWithContext(ctx context.Context) IndexUserInnerKeyValueArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexUserInnerKeyValueArrayOutput)
}

type IndexUserInnerKeyValueOutput struct{ *pulumi.OutputState }

func (IndexUserInnerKeyValueOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexUserInnerKeyValue)(nil)).Elem()
}

func (o IndexUserInnerKeyValueOutput) ToIndexUserInnerKeyValueOutput() IndexUserInnerKeyValueOutput {
	return o
}

func (o IndexUserInnerKeyValueOutput) ToIndexUserInnerKeyValueOutputWithContext(ctx context.Context) IndexUserInnerKeyValueOutput {
	return o
}

// Whether the value is case sensitive.
func (o IndexUserInnerKeyValueOutput) CaseSensitive() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v IndexUserInnerKeyValue) *bool { return v.CaseSensitive }).(pulumi.BoolPtrOutput)
}

// The delimiter of the value.
func (o IndexUserInnerKeyValueOutput) Delimiter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v IndexUserInnerKeyValue) *string { return v.Delimiter }).(pulumi.StringPtrOutput)
}

// Whether the value include chinese.
func (o IndexUserInnerKeyValueOutput) IncludeChinese() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v IndexUserInnerKeyValue) *bool { return v.IncludeChinese }).(pulumi.BoolPtrOutput)
}

// The JSON subfield key value index.
func (o IndexUserInnerKeyValueOutput) JsonKeys() IndexUserInnerKeyValueJsonKeyArrayOutput {
	return o.ApplyT(func(v IndexUserInnerKeyValue) []IndexUserInnerKeyValueJsonKey { return v.JsonKeys }).(IndexUserInnerKeyValueJsonKeyArrayOutput)
}

// The key of the KeyValueInfo.
func (o IndexUserInnerKeyValueOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v IndexUserInnerKeyValue) string { return v.Key }).(pulumi.StringOutput)
}

// Whether the filed is enabled for analysis.
func (o IndexUserInnerKeyValueOutput) SqlFlag() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v IndexUserInnerKeyValue) *bool { return v.SqlFlag }).(pulumi.BoolPtrOutput)
}

// The type of value. Valid values: `long`, `double`, `text`, `json`.
func (o IndexUserInnerKeyValueOutput) ValueType() pulumi.StringOutput {
	return o.ApplyT(func(v IndexUserInnerKeyValue) string { return v.ValueType }).(pulumi.StringOutput)
}

type IndexUserInnerKeyValueArrayOutput struct{ *pulumi.OutputState }

func (IndexUserInnerKeyValueArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexUserInnerKeyValue)(nil)).Elem()
}

func (o IndexUserInnerKeyValueArrayOutput) ToIndexUserInnerKeyValueArrayOutput() IndexUserInnerKeyValueArrayOutput {
	return o
}

func (o IndexUserInnerKeyValueArrayOutput) ToIndexUserInnerKeyValueArrayOutputWithContext(ctx context.Context) IndexUserInnerKeyValueArrayOutput {
	return o
}

func (o IndexUserInnerKeyValueArrayOutput) Index(i pulumi.IntInput) IndexUserInnerKeyValueOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IndexUserInnerKeyValue {
		return vs[0].([]IndexUserInnerKeyValue)[vs[1].(int)]
	}).(IndexUserInnerKeyValueOutput)
}

type IndexUserInnerKeyValueJsonKey struct {
	// The key of the subfield key value index.
	Key string `pulumi:"key"`
	// The type of value. Valid values: `long`, `double`, `text`.
	ValueType string `pulumi:"valueType"`
}

// IndexUserInnerKeyValueJsonKeyInput is an input type that accepts IndexUserInnerKeyValueJsonKeyArgs and IndexUserInnerKeyValueJsonKeyOutput values.
// You can construct a concrete instance of `IndexUserInnerKeyValueJsonKeyInput` via:
//
//	IndexUserInnerKeyValueJsonKeyArgs{...}
type IndexUserInnerKeyValueJsonKeyInput interface {
	pulumi.Input

	ToIndexUserInnerKeyValueJsonKeyOutput() IndexUserInnerKeyValueJsonKeyOutput
	ToIndexUserInnerKeyValueJsonKeyOutputWithContext(context.Context) IndexUserInnerKeyValueJsonKeyOutput
}

type IndexUserInnerKeyValueJsonKeyArgs struct {
	// The key of the subfield key value index.
	Key pulumi.StringInput `pulumi:"key"`
	// The type of value. Valid values: `long`, `double`, `text`.
	ValueType pulumi.StringInput `pulumi:"valueType"`
}

func (IndexUserInnerKeyValueJsonKeyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexUserInnerKeyValueJsonKey)(nil)).Elem()
}

func (i IndexUserInnerKeyValueJsonKeyArgs) ToIndexUserInnerKeyValueJsonKeyOutput() IndexUserInnerKeyValueJsonKeyOutput {
	return i.ToIndexUserInnerKeyValueJsonKeyOutputWithContext(context.Background())
}

func (i IndexUserInnerKeyValueJsonKeyArgs) ToIndexUserInnerKeyValueJsonKeyOutputWithContext(ctx context.Context) IndexUserInnerKeyValueJsonKeyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexUserInnerKeyValueJsonKeyOutput)
}

// IndexUserInnerKeyValueJsonKeyArrayInput is an input type that accepts IndexUserInnerKeyValueJsonKeyArray and IndexUserInnerKeyValueJsonKeyArrayOutput values.
// You can construct a concrete instance of `IndexUserInnerKeyValueJsonKeyArrayInput` via:
//
//	IndexUserInnerKeyValueJsonKeyArray{ IndexUserInnerKeyValueJsonKeyArgs{...} }
type IndexUserInnerKeyValueJsonKeyArrayInput interface {
	pulumi.Input

	ToIndexUserInnerKeyValueJsonKeyArrayOutput() IndexUserInnerKeyValueJsonKeyArrayOutput
	ToIndexUserInnerKeyValueJsonKeyArrayOutputWithContext(context.Context) IndexUserInnerKeyValueJsonKeyArrayOutput
}

type IndexUserInnerKeyValueJsonKeyArray []IndexUserInnerKeyValueJsonKeyInput

func (IndexUserInnerKeyValueJsonKeyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexUserInnerKeyValueJsonKey)(nil)).Elem()
}

func (i IndexUserInnerKeyValueJsonKeyArray) ToIndexUserInnerKeyValueJsonKeyArrayOutput() IndexUserInnerKeyValueJsonKeyArrayOutput {
	return i.ToIndexUserInnerKeyValueJsonKeyArrayOutputWithContext(context.Background())
}

func (i IndexUserInnerKeyValueJsonKeyArray) ToIndexUserInnerKeyValueJsonKeyArrayOutputWithContext(ctx context.Context) IndexUserInnerKeyValueJsonKeyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexUserInnerKeyValueJsonKeyArrayOutput)
}

type IndexUserInnerKeyValueJsonKeyOutput struct{ *pulumi.OutputState }

func (IndexUserInnerKeyValueJsonKeyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexUserInnerKeyValueJsonKey)(nil)).Elem()
}

func (o IndexUserInnerKeyValueJsonKeyOutput) ToIndexUserInnerKeyValueJsonKeyOutput() IndexUserInnerKeyValueJsonKeyOutput {
	return o
}

func (o IndexUserInnerKeyValueJsonKeyOutput) ToIndexUserInnerKeyValueJsonKeyOutputWithContext(ctx context.Context) IndexUserInnerKeyValueJsonKeyOutput {
	return o
}

// The key of the subfield key value index.
func (o IndexUserInnerKeyValueJsonKeyOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v IndexUserInnerKeyValueJsonKey) string { return v.Key }).(pulumi.StringOutput)
}

// The type of value. Valid values: `long`, `double`, `text`.
func (o IndexUserInnerKeyValueJsonKeyOutput) ValueType() pulumi.StringOutput {
	return o.ApplyT(func(v IndexUserInnerKeyValueJsonKey) string { return v.ValueType }).(pulumi.StringOutput)
}

type IndexUserInnerKeyValueJsonKeyArrayOutput struct{ *pulumi.OutputState }

func (IndexUserInnerKeyValueJsonKeyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexUserInnerKeyValueJsonKey)(nil)).Elem()
}

func (o IndexUserInnerKeyValueJsonKeyArrayOutput) ToIndexUserInnerKeyValueJsonKeyArrayOutput() IndexUserInnerKeyValueJsonKeyArrayOutput {
	return o
}

func (o IndexUserInnerKeyValueJsonKeyArrayOutput) ToIndexUserInnerKeyValueJsonKeyArrayOutputWithContext(ctx context.Context) IndexUserInnerKeyValueJsonKeyArrayOutput {
	return o
}

func (o IndexUserInnerKeyValueJsonKeyArrayOutput) Index(i pulumi.IntInput) IndexUserInnerKeyValueJsonKeyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IndexUserInnerKeyValueJsonKey {
		return vs[0].([]IndexUserInnerKeyValueJsonKey)[vs[1].(int)]
	}).(IndexUserInnerKeyValueJsonKeyOutput)
}

type IndexesTlsIndex struct {
	// The create time of the tls index.
	CreateTime string `pulumi:"createTime"`
	// The FullText index of the tls topic.
	FullText IndexesTlsIndexFullText `pulumi:"fullText"`
	// The topic id of the tls index.
	Id string `pulumi:"id"`
	// The KeyValue index of the tls topic.
	KeyValues []IndexesTlsIndexKeyValue `pulumi:"keyValues"`
	// The modify time of the tls index.
	ModifyTime string `pulumi:"modifyTime"`
	// The topic id of the tls index.
	TopicId string `pulumi:"topicId"`
	// The reserved field index configuration of the tls topic.
	UserInnerKeyValues []IndexesTlsIndexUserInnerKeyValue `pulumi:"userInnerKeyValues"`
}

// IndexesTlsIndexInput is an input type that accepts IndexesTlsIndexArgs and IndexesTlsIndexOutput values.
// You can construct a concrete instance of `IndexesTlsIndexInput` via:
//
//	IndexesTlsIndexArgs{...}
type IndexesTlsIndexInput interface {
	pulumi.Input

	ToIndexesTlsIndexOutput() IndexesTlsIndexOutput
	ToIndexesTlsIndexOutputWithContext(context.Context) IndexesTlsIndexOutput
}

type IndexesTlsIndexArgs struct {
	// The create time of the tls index.
	CreateTime pulumi.StringInput `pulumi:"createTime"`
	// The FullText index of the tls topic.
	FullText IndexesTlsIndexFullTextInput `pulumi:"fullText"`
	// The topic id of the tls index.
	Id pulumi.StringInput `pulumi:"id"`
	// The KeyValue index of the tls topic.
	KeyValues IndexesTlsIndexKeyValueArrayInput `pulumi:"keyValues"`
	// The modify time of the tls index.
	ModifyTime pulumi.StringInput `pulumi:"modifyTime"`
	// The topic id of the tls index.
	TopicId pulumi.StringInput `pulumi:"topicId"`
	// The reserved field index configuration of the tls topic.
	UserInnerKeyValues IndexesTlsIndexUserInnerKeyValueArrayInput `pulumi:"userInnerKeyValues"`
}

func (IndexesTlsIndexArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexesTlsIndex)(nil)).Elem()
}

func (i IndexesTlsIndexArgs) ToIndexesTlsIndexOutput() IndexesTlsIndexOutput {
	return i.ToIndexesTlsIndexOutputWithContext(context.Background())
}

func (i IndexesTlsIndexArgs) ToIndexesTlsIndexOutputWithContext(ctx context.Context) IndexesTlsIndexOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexesTlsIndexOutput)
}

// IndexesTlsIndexArrayInput is an input type that accepts IndexesTlsIndexArray and IndexesTlsIndexArrayOutput values.
// You can construct a concrete instance of `IndexesTlsIndexArrayInput` via:
//
//	IndexesTlsIndexArray{ IndexesTlsIndexArgs{...} }
type IndexesTlsIndexArrayInput interface {
	pulumi.Input

	ToIndexesTlsIndexArrayOutput() IndexesTlsIndexArrayOutput
	ToIndexesTlsIndexArrayOutputWithContext(context.Context) IndexesTlsIndexArrayOutput
}

type IndexesTlsIndexArray []IndexesTlsIndexInput

func (IndexesTlsIndexArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexesTlsIndex)(nil)).Elem()
}

func (i IndexesTlsIndexArray) ToIndexesTlsIndexArrayOutput() IndexesTlsIndexArrayOutput {
	return i.ToIndexesTlsIndexArrayOutputWithContext(context.Background())
}

func (i IndexesTlsIndexArray) ToIndexesTlsIndexArrayOutputWithContext(ctx context.Context) IndexesTlsIndexArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexesTlsIndexArrayOutput)
}

type IndexesTlsIndexOutput struct{ *pulumi.OutputState }

func (IndexesTlsIndexOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexesTlsIndex)(nil)).Elem()
}

func (o IndexesTlsIndexOutput) ToIndexesTlsIndexOutput() IndexesTlsIndexOutput {
	return o
}

func (o IndexesTlsIndexOutput) ToIndexesTlsIndexOutputWithContext(ctx context.Context) IndexesTlsIndexOutput {
	return o
}

// The create time of the tls index.
func (o IndexesTlsIndexOutput) CreateTime() pulumi.StringOutput {
	return o.ApplyT(func(v IndexesTlsIndex) string { return v.CreateTime }).(pulumi.StringOutput)
}

// The FullText index of the tls topic.
func (o IndexesTlsIndexOutput) FullText() IndexesTlsIndexFullTextOutput {
	return o.ApplyT(func(v IndexesTlsIndex) IndexesTlsIndexFullText { return v.FullText }).(IndexesTlsIndexFullTextOutput)
}

// The topic id of the tls index.
func (o IndexesTlsIndexOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v IndexesTlsIndex) string { return v.Id }).(pulumi.StringOutput)
}

// The KeyValue index of the tls topic.
func (o IndexesTlsIndexOutput) KeyValues() IndexesTlsIndexKeyValueArrayOutput {
	return o.ApplyT(func(v IndexesTlsIndex) []IndexesTlsIndexKeyValue { return v.KeyValues }).(IndexesTlsIndexKeyValueArrayOutput)
}

// The modify time of the tls index.
func (o IndexesTlsIndexOutput) ModifyTime() pulumi.StringOutput {
	return o.ApplyT(func(v IndexesTlsIndex) string { return v.ModifyTime }).(pulumi.StringOutput)
}

// The topic id of the tls index.
func (o IndexesTlsIndexOutput) TopicId() pulumi.StringOutput {
	return o.ApplyT(func(v IndexesTlsIndex) string { return v.TopicId }).(pulumi.StringOutput)
}

// The reserved field index configuration of the tls topic.
func (o IndexesTlsIndexOutput) UserInnerKeyValues() IndexesTlsIndexUserInnerKeyValueArrayOutput {
	return o.ApplyT(func(v IndexesTlsIndex) []IndexesTlsIndexUserInnerKeyValue { return v.UserInnerKeyValues }).(IndexesTlsIndexUserInnerKeyValueArrayOutput)
}

type IndexesTlsIndexArrayOutput struct{ *pulumi.OutputState }

func (IndexesTlsIndexArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexesTlsIndex)(nil)).Elem()
}

func (o IndexesTlsIndexArrayOutput) ToIndexesTlsIndexArrayOutput() IndexesTlsIndexArrayOutput {
	return o
}

func (o IndexesTlsIndexArrayOutput) ToIndexesTlsIndexArrayOutputWithContext(ctx context.Context) IndexesTlsIndexArrayOutput {
	return o
}

func (o IndexesTlsIndexArrayOutput) Index(i pulumi.IntInput) IndexesTlsIndexOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IndexesTlsIndex {
		return vs[0].([]IndexesTlsIndex)[vs[1].(int)]
	}).(IndexesTlsIndexOutput)
}

type IndexesTlsIndexFullText struct {
	// Whether the value is case sensitive.
	CaseSensitive bool `pulumi:"caseSensitive"`
	// The delimiter of the value.
	Delimiter string `pulumi:"delimiter"`
	// Whether the value include chinese.
	IncludeChinese bool `pulumi:"includeChinese"`
}

// IndexesTlsIndexFullTextInput is an input type that accepts IndexesTlsIndexFullTextArgs and IndexesTlsIndexFullTextOutput values.
// You can construct a concrete instance of `IndexesTlsIndexFullTextInput` via:
//
//	IndexesTlsIndexFullTextArgs{...}
type IndexesTlsIndexFullTextInput interface {
	pulumi.Input

	ToIndexesTlsIndexFullTextOutput() IndexesTlsIndexFullTextOutput
	ToIndexesTlsIndexFullTextOutputWithContext(context.Context) IndexesTlsIndexFullTextOutput
}

type IndexesTlsIndexFullTextArgs struct {
	// Whether the value is case sensitive.
	CaseSensitive pulumi.BoolInput `pulumi:"caseSensitive"`
	// The delimiter of the value.
	Delimiter pulumi.StringInput `pulumi:"delimiter"`
	// Whether the value include chinese.
	IncludeChinese pulumi.BoolInput `pulumi:"includeChinese"`
}

func (IndexesTlsIndexFullTextArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexesTlsIndexFullText)(nil)).Elem()
}

func (i IndexesTlsIndexFullTextArgs) ToIndexesTlsIndexFullTextOutput() IndexesTlsIndexFullTextOutput {
	return i.ToIndexesTlsIndexFullTextOutputWithContext(context.Background())
}

func (i IndexesTlsIndexFullTextArgs) ToIndexesTlsIndexFullTextOutputWithContext(ctx context.Context) IndexesTlsIndexFullTextOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexesTlsIndexFullTextOutput)
}

type IndexesTlsIndexFullTextOutput struct{ *pulumi.OutputState }

func (IndexesTlsIndexFullTextOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexesTlsIndexFullText)(nil)).Elem()
}

func (o IndexesTlsIndexFullTextOutput) ToIndexesTlsIndexFullTextOutput() IndexesTlsIndexFullTextOutput {
	return o
}

func (o IndexesTlsIndexFullTextOutput) ToIndexesTlsIndexFullTextOutputWithContext(ctx context.Context) IndexesTlsIndexFullTextOutput {
	return o
}

// Whether the value is case sensitive.
func (o IndexesTlsIndexFullTextOutput) CaseSensitive() pulumi.BoolOutput {
	return o.ApplyT(func(v IndexesTlsIndexFullText) bool { return v.CaseSensitive }).(pulumi.BoolOutput)
}

// The delimiter of the value.
func (o IndexesTlsIndexFullTextOutput) Delimiter() pulumi.StringOutput {
	return o.ApplyT(func(v IndexesTlsIndexFullText) string { return v.Delimiter }).(pulumi.StringOutput)
}

// Whether the value include chinese.
func (o IndexesTlsIndexFullTextOutput) IncludeChinese() pulumi.BoolOutput {
	return o.ApplyT(func(v IndexesTlsIndexFullText) bool { return v.IncludeChinese }).(pulumi.BoolOutput)
}

type IndexesTlsIndexKeyValue struct {
	// Whether the value is case sensitive.
	CaseSensitive bool `pulumi:"caseSensitive"`
	// The delimiter of the value.
	Delimiter string `pulumi:"delimiter"`
	// Whether the value include chinese.
	IncludeChinese bool `pulumi:"includeChinese"`
	// Whether to create indexes for all fields in JSON fields with text values.
	IndexAll bool `pulumi:"indexAll"`
	// The JSON subfield key value index.
	JsonKeys []IndexesTlsIndexKeyValueJsonKey `pulumi:"jsonKeys"`
	// The key of the KeyValue index.
	Key string `pulumi:"key"`
	// Whether the filed is enabled for analysis.
	SqlFlag bool `pulumi:"sqlFlag"`
	// The type of value.
	ValueType string `pulumi:"valueType"`
}

// IndexesTlsIndexKeyValueInput is an input type that accepts IndexesTlsIndexKeyValueArgs and IndexesTlsIndexKeyValueOutput values.
// You can construct a concrete instance of `IndexesTlsIndexKeyValueInput` via:
//
//	IndexesTlsIndexKeyValueArgs{...}
type IndexesTlsIndexKeyValueInput interface {
	pulumi.Input

	ToIndexesTlsIndexKeyValueOutput() IndexesTlsIndexKeyValueOutput
	ToIndexesTlsIndexKeyValueOutputWithContext(context.Context) IndexesTlsIndexKeyValueOutput
}

type IndexesTlsIndexKeyValueArgs struct {
	// Whether the value is case sensitive.
	CaseSensitive pulumi.BoolInput `pulumi:"caseSensitive"`
	// The delimiter of the value.
	Delimiter pulumi.StringInput `pulumi:"delimiter"`
	// Whether the value include chinese.
	IncludeChinese pulumi.BoolInput `pulumi:"includeChinese"`
	// Whether to create indexes for all fields in JSON fields with text values.
	IndexAll pulumi.BoolInput `pulumi:"indexAll"`
	// The JSON subfield key value index.
	JsonKeys IndexesTlsIndexKeyValueJsonKeyArrayInput `pulumi:"jsonKeys"`
	// The key of the KeyValue index.
	Key pulumi.StringInput `pulumi:"key"`
	// Whether the filed is enabled for analysis.
	SqlFlag pulumi.BoolInput `pulumi:"sqlFlag"`
	// The type of value.
	ValueType pulumi.StringInput `pulumi:"valueType"`
}

func (IndexesTlsIndexKeyValueArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexesTlsIndexKeyValue)(nil)).Elem()
}

func (i IndexesTlsIndexKeyValueArgs) ToIndexesTlsIndexKeyValueOutput() IndexesTlsIndexKeyValueOutput {
	return i.ToIndexesTlsIndexKeyValueOutputWithContext(context.Background())
}

func (i IndexesTlsIndexKeyValueArgs) ToIndexesTlsIndexKeyValueOutputWithContext(ctx context.Context) IndexesTlsIndexKeyValueOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexesTlsIndexKeyValueOutput)
}

// IndexesTlsIndexKeyValueArrayInput is an input type that accepts IndexesTlsIndexKeyValueArray and IndexesTlsIndexKeyValueArrayOutput values.
// You can construct a concrete instance of `IndexesTlsIndexKeyValueArrayInput` via:
//
//	IndexesTlsIndexKeyValueArray{ IndexesTlsIndexKeyValueArgs{...} }
type IndexesTlsIndexKeyValueArrayInput interface {
	pulumi.Input

	ToIndexesTlsIndexKeyValueArrayOutput() IndexesTlsIndexKeyValueArrayOutput
	ToIndexesTlsIndexKeyValueArrayOutputWithContext(context.Context) IndexesTlsIndexKeyValueArrayOutput
}

type IndexesTlsIndexKeyValueArray []IndexesTlsIndexKeyValueInput

func (IndexesTlsIndexKeyValueArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexesTlsIndexKeyValue)(nil)).Elem()
}

func (i IndexesTlsIndexKeyValueArray) ToIndexesTlsIndexKeyValueArrayOutput() IndexesTlsIndexKeyValueArrayOutput {
	return i.ToIndexesTlsIndexKeyValueArrayOutputWithContext(context.Background())
}

func (i IndexesTlsIndexKeyValueArray) ToIndexesTlsIndexKeyValueArrayOutputWithContext(ctx context.Context) IndexesTlsIndexKeyValueArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexesTlsIndexKeyValueArrayOutput)
}

type IndexesTlsIndexKeyValueOutput struct{ *pulumi.OutputState }

func (IndexesTlsIndexKeyValueOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexesTlsIndexKeyValue)(nil)).Elem()
}

func (o IndexesTlsIndexKeyValueOutput) ToIndexesTlsIndexKeyValueOutput() IndexesTlsIndexKeyValueOutput {
	return o
}

func (o IndexesTlsIndexKeyValueOutput) ToIndexesTlsIndexKeyValueOutputWithContext(ctx context.Context) IndexesTlsIndexKeyValueOutput {
	return o
}

// Whether the value is case sensitive.
func (o IndexesTlsIndexKeyValueOutput) CaseSensitive() pulumi.BoolOutput {
	return o.ApplyT(func(v IndexesTlsIndexKeyValue) bool { return v.CaseSensitive }).(pulumi.BoolOutput)
}

// The delimiter of the value.
func (o IndexesTlsIndexKeyValueOutput) Delimiter() pulumi.StringOutput {
	return o.ApplyT(func(v IndexesTlsIndexKeyValue) string { return v.Delimiter }).(pulumi.StringOutput)
}

// Whether the value include chinese.
func (o IndexesTlsIndexKeyValueOutput) IncludeChinese() pulumi.BoolOutput {
	return o.ApplyT(func(v IndexesTlsIndexKeyValue) bool { return v.IncludeChinese }).(pulumi.BoolOutput)
}

// Whether to create indexes for all fields in JSON fields with text values.
func (o IndexesTlsIndexKeyValueOutput) IndexAll() pulumi.BoolOutput {
	return o.ApplyT(func(v IndexesTlsIndexKeyValue) bool { return v.IndexAll }).(pulumi.BoolOutput)
}

// The JSON subfield key value index.
func (o IndexesTlsIndexKeyValueOutput) JsonKeys() IndexesTlsIndexKeyValueJsonKeyArrayOutput {
	return o.ApplyT(func(v IndexesTlsIndexKeyValue) []IndexesTlsIndexKeyValueJsonKey { return v.JsonKeys }).(IndexesTlsIndexKeyValueJsonKeyArrayOutput)
}

// The key of the KeyValue index.
func (o IndexesTlsIndexKeyValueOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v IndexesTlsIndexKeyValue) string { return v.Key }).(pulumi.StringOutput)
}

// Whether the filed is enabled for analysis.
func (o IndexesTlsIndexKeyValueOutput) SqlFlag() pulumi.BoolOutput {
	return o.ApplyT(func(v IndexesTlsIndexKeyValue) bool { return v.SqlFlag }).(pulumi.BoolOutput)
}

// The type of value.
func (o IndexesTlsIndexKeyValueOutput) ValueType() pulumi.StringOutput {
	return o.ApplyT(func(v IndexesTlsIndexKeyValue) string { return v.ValueType }).(pulumi.StringOutput)
}

type IndexesTlsIndexKeyValueArrayOutput struct{ *pulumi.OutputState }

func (IndexesTlsIndexKeyValueArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexesTlsIndexKeyValue)(nil)).Elem()
}

func (o IndexesTlsIndexKeyValueArrayOutput) ToIndexesTlsIndexKeyValueArrayOutput() IndexesTlsIndexKeyValueArrayOutput {
	return o
}

func (o IndexesTlsIndexKeyValueArrayOutput) ToIndexesTlsIndexKeyValueArrayOutputWithContext(ctx context.Context) IndexesTlsIndexKeyValueArrayOutput {
	return o
}

func (o IndexesTlsIndexKeyValueArrayOutput) Index(i pulumi.IntInput) IndexesTlsIndexKeyValueOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IndexesTlsIndexKeyValue {
		return vs[0].([]IndexesTlsIndexKeyValue)[vs[1].(int)]
	}).(IndexesTlsIndexKeyValueOutput)
}

type IndexesTlsIndexKeyValueJsonKey struct {
	// Whether the value is case sensitive.
	CaseSensitive bool `pulumi:"caseSensitive"`
	// The delimiter of the value.
	Delimiter string `pulumi:"delimiter"`
	// Whether the value include chinese.
	IncludeChinese bool `pulumi:"includeChinese"`
	// The key of the KeyValue index.
	Key string `pulumi:"key"`
	// Whether the filed is enabled for analysis.
	SqlFlag bool `pulumi:"sqlFlag"`
	// The type of value.
	ValueType string `pulumi:"valueType"`
}

// IndexesTlsIndexKeyValueJsonKeyInput is an input type that accepts IndexesTlsIndexKeyValueJsonKeyArgs and IndexesTlsIndexKeyValueJsonKeyOutput values.
// You can construct a concrete instance of `IndexesTlsIndexKeyValueJsonKeyInput` via:
//
//	IndexesTlsIndexKeyValueJsonKeyArgs{...}
type IndexesTlsIndexKeyValueJsonKeyInput interface {
	pulumi.Input

	ToIndexesTlsIndexKeyValueJsonKeyOutput() IndexesTlsIndexKeyValueJsonKeyOutput
	ToIndexesTlsIndexKeyValueJsonKeyOutputWithContext(context.Context) IndexesTlsIndexKeyValueJsonKeyOutput
}

type IndexesTlsIndexKeyValueJsonKeyArgs struct {
	// Whether the value is case sensitive.
	CaseSensitive pulumi.BoolInput `pulumi:"caseSensitive"`
	// The delimiter of the value.
	Delimiter pulumi.StringInput `pulumi:"delimiter"`
	// Whether the value include chinese.
	IncludeChinese pulumi.BoolInput `pulumi:"includeChinese"`
	// The key of the KeyValue index.
	Key pulumi.StringInput `pulumi:"key"`
	// Whether the filed is enabled for analysis.
	SqlFlag pulumi.BoolInput `pulumi:"sqlFlag"`
	// The type of value.
	ValueType pulumi.StringInput `pulumi:"valueType"`
}

func (IndexesTlsIndexKeyValueJsonKeyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexesTlsIndexKeyValueJsonKey)(nil)).Elem()
}

func (i IndexesTlsIndexKeyValueJsonKeyArgs) ToIndexesTlsIndexKeyValueJsonKeyOutput() IndexesTlsIndexKeyValueJsonKeyOutput {
	return i.ToIndexesTlsIndexKeyValueJsonKeyOutputWithContext(context.Background())
}

func (i IndexesTlsIndexKeyValueJsonKeyArgs) ToIndexesTlsIndexKeyValueJsonKeyOutputWithContext(ctx context.Context) IndexesTlsIndexKeyValueJsonKeyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexesTlsIndexKeyValueJsonKeyOutput)
}

// IndexesTlsIndexKeyValueJsonKeyArrayInput is an input type that accepts IndexesTlsIndexKeyValueJsonKeyArray and IndexesTlsIndexKeyValueJsonKeyArrayOutput values.
// You can construct a concrete instance of `IndexesTlsIndexKeyValueJsonKeyArrayInput` via:
//
//	IndexesTlsIndexKeyValueJsonKeyArray{ IndexesTlsIndexKeyValueJsonKeyArgs{...} }
type IndexesTlsIndexKeyValueJsonKeyArrayInput interface {
	pulumi.Input

	ToIndexesTlsIndexKeyValueJsonKeyArrayOutput() IndexesTlsIndexKeyValueJsonKeyArrayOutput
	ToIndexesTlsIndexKeyValueJsonKeyArrayOutputWithContext(context.Context) IndexesTlsIndexKeyValueJsonKeyArrayOutput
}

type IndexesTlsIndexKeyValueJsonKeyArray []IndexesTlsIndexKeyValueJsonKeyInput

func (IndexesTlsIndexKeyValueJsonKeyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexesTlsIndexKeyValueJsonKey)(nil)).Elem()
}

func (i IndexesTlsIndexKeyValueJsonKeyArray) ToIndexesTlsIndexKeyValueJsonKeyArrayOutput() IndexesTlsIndexKeyValueJsonKeyArrayOutput {
	return i.ToIndexesTlsIndexKeyValueJsonKeyArrayOutputWithContext(context.Background())
}

func (i IndexesTlsIndexKeyValueJsonKeyArray) ToIndexesTlsIndexKeyValueJsonKeyArrayOutputWithContext(ctx context.Context) IndexesTlsIndexKeyValueJsonKeyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexesTlsIndexKeyValueJsonKeyArrayOutput)
}

type IndexesTlsIndexKeyValueJsonKeyOutput struct{ *pulumi.OutputState }

func (IndexesTlsIndexKeyValueJsonKeyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexesTlsIndexKeyValueJsonKey)(nil)).Elem()
}

func (o IndexesTlsIndexKeyValueJsonKeyOutput) ToIndexesTlsIndexKeyValueJsonKeyOutput() IndexesTlsIndexKeyValueJsonKeyOutput {
	return o
}

func (o IndexesTlsIndexKeyValueJsonKeyOutput) ToIndexesTlsIndexKeyValueJsonKeyOutputWithContext(ctx context.Context) IndexesTlsIndexKeyValueJsonKeyOutput {
	return o
}

// Whether the value is case sensitive.
func (o IndexesTlsIndexKeyValueJsonKeyOutput) CaseSensitive() pulumi.BoolOutput {
	return o.ApplyT(func(v IndexesTlsIndexKeyValueJsonKey) bool { return v.CaseSensitive }).(pulumi.BoolOutput)
}

// The delimiter of the value.
func (o IndexesTlsIndexKeyValueJsonKeyOutput) Delimiter() pulumi.StringOutput {
	return o.ApplyT(func(v IndexesTlsIndexKeyValueJsonKey) string { return v.Delimiter }).(pulumi.StringOutput)
}

// Whether the value include chinese.
func (o IndexesTlsIndexKeyValueJsonKeyOutput) IncludeChinese() pulumi.BoolOutput {
	return o.ApplyT(func(v IndexesTlsIndexKeyValueJsonKey) bool { return v.IncludeChinese }).(pulumi.BoolOutput)
}

// The key of the KeyValue index.
func (o IndexesTlsIndexKeyValueJsonKeyOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v IndexesTlsIndexKeyValueJsonKey) string { return v.Key }).(pulumi.StringOutput)
}

// Whether the filed is enabled for analysis.
func (o IndexesTlsIndexKeyValueJsonKeyOutput) SqlFlag() pulumi.BoolOutput {
	return o.ApplyT(func(v IndexesTlsIndexKeyValueJsonKey) bool { return v.SqlFlag }).(pulumi.BoolOutput)
}

// The type of value.
func (o IndexesTlsIndexKeyValueJsonKeyOutput) ValueType() pulumi.StringOutput {
	return o.ApplyT(func(v IndexesTlsIndexKeyValueJsonKey) string { return v.ValueType }).(pulumi.StringOutput)
}

type IndexesTlsIndexKeyValueJsonKeyArrayOutput struct{ *pulumi.OutputState }

func (IndexesTlsIndexKeyValueJsonKeyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexesTlsIndexKeyValueJsonKey)(nil)).Elem()
}

func (o IndexesTlsIndexKeyValueJsonKeyArrayOutput) ToIndexesTlsIndexKeyValueJsonKeyArrayOutput() IndexesTlsIndexKeyValueJsonKeyArrayOutput {
	return o
}

func (o IndexesTlsIndexKeyValueJsonKeyArrayOutput) ToIndexesTlsIndexKeyValueJsonKeyArrayOutputWithContext(ctx context.Context) IndexesTlsIndexKeyValueJsonKeyArrayOutput {
	return o
}

func (o IndexesTlsIndexKeyValueJsonKeyArrayOutput) Index(i pulumi.IntInput) IndexesTlsIndexKeyValueJsonKeyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IndexesTlsIndexKeyValueJsonKey {
		return vs[0].([]IndexesTlsIndexKeyValueJsonKey)[vs[1].(int)]
	}).(IndexesTlsIndexKeyValueJsonKeyOutput)
}

type IndexesTlsIndexUserInnerKeyValue struct {
	// Whether the value is case sensitive.
	CaseSensitive bool `pulumi:"caseSensitive"`
	// The delimiter of the value.
	Delimiter string `pulumi:"delimiter"`
	// Whether the value include chinese.
	IncludeChinese bool `pulumi:"includeChinese"`
	// The JSON subfield key value index.
	JsonKeys []IndexesTlsIndexUserInnerKeyValueJsonKey `pulumi:"jsonKeys"`
	// The key of the KeyValue index.
	Key string `pulumi:"key"`
	// Whether the filed is enabled for analysis.
	SqlFlag bool `pulumi:"sqlFlag"`
	// The type of value.
	ValueType string `pulumi:"valueType"`
}

// IndexesTlsIndexUserInnerKeyValueInput is an input type that accepts IndexesTlsIndexUserInnerKeyValueArgs and IndexesTlsIndexUserInnerKeyValueOutput values.
// You can construct a concrete instance of `IndexesTlsIndexUserInnerKeyValueInput` via:
//
//	IndexesTlsIndexUserInnerKeyValueArgs{...}
type IndexesTlsIndexUserInnerKeyValueInput interface {
	pulumi.Input

	ToIndexesTlsIndexUserInnerKeyValueOutput() IndexesTlsIndexUserInnerKeyValueOutput
	ToIndexesTlsIndexUserInnerKeyValueOutputWithContext(context.Context) IndexesTlsIndexUserInnerKeyValueOutput
}

type IndexesTlsIndexUserInnerKeyValueArgs struct {
	// Whether the value is case sensitive.
	CaseSensitive pulumi.BoolInput `pulumi:"caseSensitive"`
	// The delimiter of the value.
	Delimiter pulumi.StringInput `pulumi:"delimiter"`
	// Whether the value include chinese.
	IncludeChinese pulumi.BoolInput `pulumi:"includeChinese"`
	// The JSON subfield key value index.
	JsonKeys IndexesTlsIndexUserInnerKeyValueJsonKeyArrayInput `pulumi:"jsonKeys"`
	// The key of the KeyValue index.
	Key pulumi.StringInput `pulumi:"key"`
	// Whether the filed is enabled for analysis.
	SqlFlag pulumi.BoolInput `pulumi:"sqlFlag"`
	// The type of value.
	ValueType pulumi.StringInput `pulumi:"valueType"`
}

func (IndexesTlsIndexUserInnerKeyValueArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexesTlsIndexUserInnerKeyValue)(nil)).Elem()
}

func (i IndexesTlsIndexUserInnerKeyValueArgs) ToIndexesTlsIndexUserInnerKeyValueOutput() IndexesTlsIndexUserInnerKeyValueOutput {
	return i.ToIndexesTlsIndexUserInnerKeyValueOutputWithContext(context.Background())
}

func (i IndexesTlsIndexUserInnerKeyValueArgs) ToIndexesTlsIndexUserInnerKeyValueOutputWithContext(ctx context.Context) IndexesTlsIndexUserInnerKeyValueOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexesTlsIndexUserInnerKeyValueOutput)
}

// IndexesTlsIndexUserInnerKeyValueArrayInput is an input type that accepts IndexesTlsIndexUserInnerKeyValueArray and IndexesTlsIndexUserInnerKeyValueArrayOutput values.
// You can construct a concrete instance of `IndexesTlsIndexUserInnerKeyValueArrayInput` via:
//
//	IndexesTlsIndexUserInnerKeyValueArray{ IndexesTlsIndexUserInnerKeyValueArgs{...} }
type IndexesTlsIndexUserInnerKeyValueArrayInput interface {
	pulumi.Input

	ToIndexesTlsIndexUserInnerKeyValueArrayOutput() IndexesTlsIndexUserInnerKeyValueArrayOutput
	ToIndexesTlsIndexUserInnerKeyValueArrayOutputWithContext(context.Context) IndexesTlsIndexUserInnerKeyValueArrayOutput
}

type IndexesTlsIndexUserInnerKeyValueArray []IndexesTlsIndexUserInnerKeyValueInput

func (IndexesTlsIndexUserInnerKeyValueArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexesTlsIndexUserInnerKeyValue)(nil)).Elem()
}

func (i IndexesTlsIndexUserInnerKeyValueArray) ToIndexesTlsIndexUserInnerKeyValueArrayOutput() IndexesTlsIndexUserInnerKeyValueArrayOutput {
	return i.ToIndexesTlsIndexUserInnerKeyValueArrayOutputWithContext(context.Background())
}

func (i IndexesTlsIndexUserInnerKeyValueArray) ToIndexesTlsIndexUserInnerKeyValueArrayOutputWithContext(ctx context.Context) IndexesTlsIndexUserInnerKeyValueArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexesTlsIndexUserInnerKeyValueArrayOutput)
}

type IndexesTlsIndexUserInnerKeyValueOutput struct{ *pulumi.OutputState }

func (IndexesTlsIndexUserInnerKeyValueOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexesTlsIndexUserInnerKeyValue)(nil)).Elem()
}

func (o IndexesTlsIndexUserInnerKeyValueOutput) ToIndexesTlsIndexUserInnerKeyValueOutput() IndexesTlsIndexUserInnerKeyValueOutput {
	return o
}

func (o IndexesTlsIndexUserInnerKeyValueOutput) ToIndexesTlsIndexUserInnerKeyValueOutputWithContext(ctx context.Context) IndexesTlsIndexUserInnerKeyValueOutput {
	return o
}

// Whether the value is case sensitive.
func (o IndexesTlsIndexUserInnerKeyValueOutput) CaseSensitive() pulumi.BoolOutput {
	return o.ApplyT(func(v IndexesTlsIndexUserInnerKeyValue) bool { return v.CaseSensitive }).(pulumi.BoolOutput)
}

// The delimiter of the value.
func (o IndexesTlsIndexUserInnerKeyValueOutput) Delimiter() pulumi.StringOutput {
	return o.ApplyT(func(v IndexesTlsIndexUserInnerKeyValue) string { return v.Delimiter }).(pulumi.StringOutput)
}

// Whether the value include chinese.
func (o IndexesTlsIndexUserInnerKeyValueOutput) IncludeChinese() pulumi.BoolOutput {
	return o.ApplyT(func(v IndexesTlsIndexUserInnerKeyValue) bool { return v.IncludeChinese }).(pulumi.BoolOutput)
}

// The JSON subfield key value index.
func (o IndexesTlsIndexUserInnerKeyValueOutput) JsonKeys() IndexesTlsIndexUserInnerKeyValueJsonKeyArrayOutput {
	return o.ApplyT(func(v IndexesTlsIndexUserInnerKeyValue) []IndexesTlsIndexUserInnerKeyValueJsonKey { return v.JsonKeys }).(IndexesTlsIndexUserInnerKeyValueJsonKeyArrayOutput)
}

// The key of the KeyValue index.
func (o IndexesTlsIndexUserInnerKeyValueOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v IndexesTlsIndexUserInnerKeyValue) string { return v.Key }).(pulumi.StringOutput)
}

// Whether the filed is enabled for analysis.
func (o IndexesTlsIndexUserInnerKeyValueOutput) SqlFlag() pulumi.BoolOutput {
	return o.ApplyT(func(v IndexesTlsIndexUserInnerKeyValue) bool { return v.SqlFlag }).(pulumi.BoolOutput)
}

// The type of value.
func (o IndexesTlsIndexUserInnerKeyValueOutput) ValueType() pulumi.StringOutput {
	return o.ApplyT(func(v IndexesTlsIndexUserInnerKeyValue) string { return v.ValueType }).(pulumi.StringOutput)
}

type IndexesTlsIndexUserInnerKeyValueArrayOutput struct{ *pulumi.OutputState }

func (IndexesTlsIndexUserInnerKeyValueArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexesTlsIndexUserInnerKeyValue)(nil)).Elem()
}

func (o IndexesTlsIndexUserInnerKeyValueArrayOutput) ToIndexesTlsIndexUserInnerKeyValueArrayOutput() IndexesTlsIndexUserInnerKeyValueArrayOutput {
	return o
}

func (o IndexesTlsIndexUserInnerKeyValueArrayOutput) ToIndexesTlsIndexUserInnerKeyValueArrayOutputWithContext(ctx context.Context) IndexesTlsIndexUserInnerKeyValueArrayOutput {
	return o
}

func (o IndexesTlsIndexUserInnerKeyValueArrayOutput) Index(i pulumi.IntInput) IndexesTlsIndexUserInnerKeyValueOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IndexesTlsIndexUserInnerKeyValue {
		return vs[0].([]IndexesTlsIndexUserInnerKeyValue)[vs[1].(int)]
	}).(IndexesTlsIndexUserInnerKeyValueOutput)
}

type IndexesTlsIndexUserInnerKeyValueJsonKey struct {
	// Whether the value is case sensitive.
	CaseSensitive bool `pulumi:"caseSensitive"`
	// The delimiter of the value.
	Delimiter string `pulumi:"delimiter"`
	// Whether the value include chinese.
	IncludeChinese bool `pulumi:"includeChinese"`
	// The key of the KeyValue index.
	Key string `pulumi:"key"`
	// Whether the filed is enabled for analysis.
	SqlFlag bool `pulumi:"sqlFlag"`
	// The type of value.
	ValueType string `pulumi:"valueType"`
}

// IndexesTlsIndexUserInnerKeyValueJsonKeyInput is an input type that accepts IndexesTlsIndexUserInnerKeyValueJsonKeyArgs and IndexesTlsIndexUserInnerKeyValueJsonKeyOutput values.
// You can construct a concrete instance of `IndexesTlsIndexUserInnerKeyValueJsonKeyInput` via:
//
//	IndexesTlsIndexUserInnerKeyValueJsonKeyArgs{...}
type IndexesTlsIndexUserInnerKeyValueJsonKeyInput interface {
	pulumi.Input

	ToIndexesTlsIndexUserInnerKeyValueJsonKeyOutput() IndexesTlsIndexUserInnerKeyValueJsonKeyOutput
	ToIndexesTlsIndexUserInnerKeyValueJsonKeyOutputWithContext(context.Context) IndexesTlsIndexUserInnerKeyValueJsonKeyOutput
}

type IndexesTlsIndexUserInnerKeyValueJsonKeyArgs struct {
	// Whether the value is case sensitive.
	CaseSensitive pulumi.BoolInput `pulumi:"caseSensitive"`
	// The delimiter of the value.
	Delimiter pulumi.StringInput `pulumi:"delimiter"`
	// Whether the value include chinese.
	IncludeChinese pulumi.BoolInput `pulumi:"includeChinese"`
	// The key of the KeyValue index.
	Key pulumi.StringInput `pulumi:"key"`
	// Whether the filed is enabled for analysis.
	SqlFlag pulumi.BoolInput `pulumi:"sqlFlag"`
	// The type of value.
	ValueType pulumi.StringInput `pulumi:"valueType"`
}

func (IndexesTlsIndexUserInnerKeyValueJsonKeyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexesTlsIndexUserInnerKeyValueJsonKey)(nil)).Elem()
}

func (i IndexesTlsIndexUserInnerKeyValueJsonKeyArgs) ToIndexesTlsIndexUserInnerKeyValueJsonKeyOutput() IndexesTlsIndexUserInnerKeyValueJsonKeyOutput {
	return i.ToIndexesTlsIndexUserInnerKeyValueJsonKeyOutputWithContext(context.Background())
}

func (i IndexesTlsIndexUserInnerKeyValueJsonKeyArgs) ToIndexesTlsIndexUserInnerKeyValueJsonKeyOutputWithContext(ctx context.Context) IndexesTlsIndexUserInnerKeyValueJsonKeyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexesTlsIndexUserInnerKeyValueJsonKeyOutput)
}

// IndexesTlsIndexUserInnerKeyValueJsonKeyArrayInput is an input type that accepts IndexesTlsIndexUserInnerKeyValueJsonKeyArray and IndexesTlsIndexUserInnerKeyValueJsonKeyArrayOutput values.
// You can construct a concrete instance of `IndexesTlsIndexUserInnerKeyValueJsonKeyArrayInput` via:
//
//	IndexesTlsIndexUserInnerKeyValueJsonKeyArray{ IndexesTlsIndexUserInnerKeyValueJsonKeyArgs{...} }
type IndexesTlsIndexUserInnerKeyValueJsonKeyArrayInput interface {
	pulumi.Input

	ToIndexesTlsIndexUserInnerKeyValueJsonKeyArrayOutput() IndexesTlsIndexUserInnerKeyValueJsonKeyArrayOutput
	ToIndexesTlsIndexUserInnerKeyValueJsonKeyArrayOutputWithContext(context.Context) IndexesTlsIndexUserInnerKeyValueJsonKeyArrayOutput
}

type IndexesTlsIndexUserInnerKeyValueJsonKeyArray []IndexesTlsIndexUserInnerKeyValueJsonKeyInput

func (IndexesTlsIndexUserInnerKeyValueJsonKeyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexesTlsIndexUserInnerKeyValueJsonKey)(nil)).Elem()
}

func (i IndexesTlsIndexUserInnerKeyValueJsonKeyArray) ToIndexesTlsIndexUserInnerKeyValueJsonKeyArrayOutput() IndexesTlsIndexUserInnerKeyValueJsonKeyArrayOutput {
	return i.ToIndexesTlsIndexUserInnerKeyValueJsonKeyArrayOutputWithContext(context.Background())
}

func (i IndexesTlsIndexUserInnerKeyValueJsonKeyArray) ToIndexesTlsIndexUserInnerKeyValueJsonKeyArrayOutputWithContext(ctx context.Context) IndexesTlsIndexUserInnerKeyValueJsonKeyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IndexesTlsIndexUserInnerKeyValueJsonKeyArrayOutput)
}

type IndexesTlsIndexUserInnerKeyValueJsonKeyOutput struct{ *pulumi.OutputState }

func (IndexesTlsIndexUserInnerKeyValueJsonKeyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*IndexesTlsIndexUserInnerKeyValueJsonKey)(nil)).Elem()
}

func (o IndexesTlsIndexUserInnerKeyValueJsonKeyOutput) ToIndexesTlsIndexUserInnerKeyValueJsonKeyOutput() IndexesTlsIndexUserInnerKeyValueJsonKeyOutput {
	return o
}

func (o IndexesTlsIndexUserInnerKeyValueJsonKeyOutput) ToIndexesTlsIndexUserInnerKeyValueJsonKeyOutputWithContext(ctx context.Context) IndexesTlsIndexUserInnerKeyValueJsonKeyOutput {
	return o
}

// Whether the value is case sensitive.
func (o IndexesTlsIndexUserInnerKeyValueJsonKeyOutput) CaseSensitive() pulumi.BoolOutput {
	return o.ApplyT(func(v IndexesTlsIndexUserInnerKeyValueJsonKey) bool { return v.CaseSensitive }).(pulumi.BoolOutput)
}

// The delimiter of the value.
func (o IndexesTlsIndexUserInnerKeyValueJsonKeyOutput) Delimiter() pulumi.StringOutput {
	return o.ApplyT(func(v IndexesTlsIndexUserInnerKeyValueJsonKey) string { return v.Delimiter }).(pulumi.StringOutput)
}

// Whether the value include chinese.
func (o IndexesTlsIndexUserInnerKeyValueJsonKeyOutput) IncludeChinese() pulumi.BoolOutput {
	return o.ApplyT(func(v IndexesTlsIndexUserInnerKeyValueJsonKey) bool { return v.IncludeChinese }).(pulumi.BoolOutput)
}

// The key of the KeyValue index.
func (o IndexesTlsIndexUserInnerKeyValueJsonKeyOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v IndexesTlsIndexUserInnerKeyValueJsonKey) string { return v.Key }).(pulumi.StringOutput)
}

// Whether the filed is enabled for analysis.
func (o IndexesTlsIndexUserInnerKeyValueJsonKeyOutput) SqlFlag() pulumi.BoolOutput {
	return o.ApplyT(func(v IndexesTlsIndexUserInnerKeyValueJsonKey) bool { return v.SqlFlag }).(pulumi.BoolOutput)
}

// The type of value.
func (o IndexesTlsIndexUserInnerKeyValueJsonKeyOutput) ValueType() pulumi.StringOutput {
	return o.ApplyT(func(v IndexesTlsIndexUserInnerKeyValueJsonKey) string { return v.ValueType }).(pulumi.StringOutput)
}

type IndexesTlsIndexUserInnerKeyValueJsonKeyArrayOutput struct{ *pulumi.OutputState }

func (IndexesTlsIndexUserInnerKeyValueJsonKeyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]IndexesTlsIndexUserInnerKeyValueJsonKey)(nil)).Elem()
}

func (o IndexesTlsIndexUserInnerKeyValueJsonKeyArrayOutput) ToIndexesTlsIndexUserInnerKeyValueJsonKeyArrayOutput() IndexesTlsIndexUserInnerKeyValueJsonKeyArrayOutput {
	return o
}

func (o IndexesTlsIndexUserInnerKeyValueJsonKeyArrayOutput) ToIndexesTlsIndexUserInnerKeyValueJsonKeyArrayOutputWithContext(ctx context.Context) IndexesTlsIndexUserInnerKeyValueJsonKeyArrayOutput {
	return o
}

func (o IndexesTlsIndexUserInnerKeyValueJsonKeyArrayOutput) Index(i pulumi.IntInput) IndexesTlsIndexUserInnerKeyValueJsonKeyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) IndexesTlsIndexUserInnerKeyValueJsonKey {
		return vs[0].([]IndexesTlsIndexUserInnerKeyValueJsonKey)[vs[1].(int)]
	}).(IndexesTlsIndexUserInnerKeyValueJsonKeyOutput)
}

type KafkaConsumersData struct {
	// Whether allow consume.
	AllowConsume bool `pulumi:"allowConsume"`
	// The topic of consume.
	ConsumeTopic string `pulumi:"consumeTopic"`
	// The ID of Topic.
	TopicId string `pulumi:"topicId"`
}

// KafkaConsumersDataInput is an input type that accepts KafkaConsumersDataArgs and KafkaConsumersDataOutput values.
// You can construct a concrete instance of `KafkaConsumersDataInput` via:
//
//	KafkaConsumersDataArgs{...}
type KafkaConsumersDataInput interface {
	pulumi.Input

	ToKafkaConsumersDataOutput() KafkaConsumersDataOutput
	ToKafkaConsumersDataOutputWithContext(context.Context) KafkaConsumersDataOutput
}

type KafkaConsumersDataArgs struct {
	// Whether allow consume.
	AllowConsume pulumi.BoolInput `pulumi:"allowConsume"`
	// The topic of consume.
	ConsumeTopic pulumi.StringInput `pulumi:"consumeTopic"`
	// The ID of Topic.
	TopicId pulumi.StringInput `pulumi:"topicId"`
}

func (KafkaConsumersDataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*KafkaConsumersData)(nil)).Elem()
}

func (i KafkaConsumersDataArgs) ToKafkaConsumersDataOutput() KafkaConsumersDataOutput {
	return i.ToKafkaConsumersDataOutputWithContext(context.Background())
}

func (i KafkaConsumersDataArgs) ToKafkaConsumersDataOutputWithContext(ctx context.Context) KafkaConsumersDataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KafkaConsumersDataOutput)
}

// KafkaConsumersDataArrayInput is an input type that accepts KafkaConsumersDataArray and KafkaConsumersDataArrayOutput values.
// You can construct a concrete instance of `KafkaConsumersDataArrayInput` via:
//
//	KafkaConsumersDataArray{ KafkaConsumersDataArgs{...} }
type KafkaConsumersDataArrayInput interface {
	pulumi.Input

	ToKafkaConsumersDataArrayOutput() KafkaConsumersDataArrayOutput
	ToKafkaConsumersDataArrayOutputWithContext(context.Context) KafkaConsumersDataArrayOutput
}

type KafkaConsumersDataArray []KafkaConsumersDataInput

func (KafkaConsumersDataArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]KafkaConsumersData)(nil)).Elem()
}

func (i KafkaConsumersDataArray) ToKafkaConsumersDataArrayOutput() KafkaConsumersDataArrayOutput {
	return i.ToKafkaConsumersDataArrayOutputWithContext(context.Background())
}

func (i KafkaConsumersDataArray) ToKafkaConsumersDataArrayOutputWithContext(ctx context.Context) KafkaConsumersDataArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KafkaConsumersDataArrayOutput)
}

type KafkaConsumersDataOutput struct{ *pulumi.OutputState }

func (KafkaConsumersDataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*KafkaConsumersData)(nil)).Elem()
}

func (o KafkaConsumersDataOutput) ToKafkaConsumersDataOutput() KafkaConsumersDataOutput {
	return o
}

func (o KafkaConsumersDataOutput) ToKafkaConsumersDataOutputWithContext(ctx context.Context) KafkaConsumersDataOutput {
	return o
}

// Whether allow consume.
func (o KafkaConsumersDataOutput) AllowConsume() pulumi.BoolOutput {
	return o.ApplyT(func(v KafkaConsumersData) bool { return v.AllowConsume }).(pulumi.BoolOutput)
}

// The topic of consume.
func (o KafkaConsumersDataOutput) ConsumeTopic() pulumi.StringOutput {
	return o.ApplyT(func(v KafkaConsumersData) string { return v.ConsumeTopic }).(pulumi.StringOutput)
}

// The ID of Topic.
func (o KafkaConsumersDataOutput) TopicId() pulumi.StringOutput {
	return o.ApplyT(func(v KafkaConsumersData) string { return v.TopicId }).(pulumi.StringOutput)
}

type KafkaConsumersDataArrayOutput struct{ *pulumi.OutputState }

func (KafkaConsumersDataArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]KafkaConsumersData)(nil)).Elem()
}

func (o KafkaConsumersDataArrayOutput) ToKafkaConsumersDataArrayOutput() KafkaConsumersDataArrayOutput {
	return o
}

func (o KafkaConsumersDataArrayOutput) ToKafkaConsumersDataArrayOutputWithContext(ctx context.Context) KafkaConsumersDataArrayOutput {
	return o
}

func (o KafkaConsumersDataArrayOutput) Index(i pulumi.IntInput) KafkaConsumersDataOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) KafkaConsumersData {
		return vs[0].([]KafkaConsumersData)[vs[1].(int)]
	}).(KafkaConsumersDataOutput)
}

type ProjectTag struct {
	// The Key of Tags.
	Key string `pulumi:"key"`
	// The Value of Tags.
	Value string `pulumi:"value"`
}

// ProjectTagInput is an input type that accepts ProjectTagArgs and ProjectTagOutput values.
// You can construct a concrete instance of `ProjectTagInput` via:
//
//	ProjectTagArgs{...}
type ProjectTagInput interface {
	pulumi.Input

	ToProjectTagOutput() ProjectTagOutput
	ToProjectTagOutputWithContext(context.Context) ProjectTagOutput
}

type ProjectTagArgs struct {
	// The Key of Tags.
	Key pulumi.StringInput `pulumi:"key"`
	// The Value of Tags.
	Value pulumi.StringInput `pulumi:"value"`
}

func (ProjectTagArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ProjectTag)(nil)).Elem()
}

func (i ProjectTagArgs) ToProjectTagOutput() ProjectTagOutput {
	return i.ToProjectTagOutputWithContext(context.Background())
}

func (i ProjectTagArgs) ToProjectTagOutputWithContext(ctx context.Context) ProjectTagOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProjectTagOutput)
}

// ProjectTagArrayInput is an input type that accepts ProjectTagArray and ProjectTagArrayOutput values.
// You can construct a concrete instance of `ProjectTagArrayInput` via:
//
//	ProjectTagArray{ ProjectTagArgs{...} }
type ProjectTagArrayInput interface {
	pulumi.Input

	ToProjectTagArrayOutput() ProjectTagArrayOutput
	ToProjectTagArrayOutputWithContext(context.Context) ProjectTagArrayOutput
}

type ProjectTagArray []ProjectTagInput

func (ProjectTagArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ProjectTag)(nil)).Elem()
}

func (i ProjectTagArray) ToProjectTagArrayOutput() ProjectTagArrayOutput {
	return i.ToProjectTagArrayOutputWithContext(context.Background())
}

func (i ProjectTagArray) ToProjectTagArrayOutputWithContext(ctx context.Context) ProjectTagArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProjectTagArrayOutput)
}

type ProjectTagOutput struct{ *pulumi.OutputState }

func (ProjectTagOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ProjectTag)(nil)).Elem()
}

func (o ProjectTagOutput) ToProjectTagOutput() ProjectTagOutput {
	return o
}

func (o ProjectTagOutput) ToProjectTagOutputWithContext(ctx context.Context) ProjectTagOutput {
	return o
}

// The Key of Tags.
func (o ProjectTagOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ProjectTag) string { return v.Key }).(pulumi.StringOutput)
}

// The Value of Tags.
func (o ProjectTagOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v ProjectTag) string { return v.Value }).(pulumi.StringOutput)
}

type ProjectTagArrayOutput struct{ *pulumi.OutputState }

func (ProjectTagArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ProjectTag)(nil)).Elem()
}

func (o ProjectTagArrayOutput) ToProjectTagArrayOutput() ProjectTagArrayOutput {
	return o
}

func (o ProjectTagArrayOutput) ToProjectTagArrayOutputWithContext(ctx context.Context) ProjectTagArrayOutput {
	return o
}

func (o ProjectTagArrayOutput) Index(i pulumi.IntInput) ProjectTagOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ProjectTag {
		return vs[0].([]ProjectTag)[vs[1].(int)]
	}).(ProjectTagOutput)
}

type ProjectsTag struct {
	// The Key of Tags.
	Key string `pulumi:"key"`
	// The Value of Tags.
	Value string `pulumi:"value"`
}

// ProjectsTagInput is an input type that accepts ProjectsTagArgs and ProjectsTagOutput values.
// You can construct a concrete instance of `ProjectsTagInput` via:
//
//	ProjectsTagArgs{...}
type ProjectsTagInput interface {
	pulumi.Input

	ToProjectsTagOutput() ProjectsTagOutput
	ToProjectsTagOutputWithContext(context.Context) ProjectsTagOutput
}

type ProjectsTagArgs struct {
	// The Key of Tags.
	Key pulumi.StringInput `pulumi:"key"`
	// The Value of Tags.
	Value pulumi.StringInput `pulumi:"value"`
}

func (ProjectsTagArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ProjectsTag)(nil)).Elem()
}

func (i ProjectsTagArgs) ToProjectsTagOutput() ProjectsTagOutput {
	return i.ToProjectsTagOutputWithContext(context.Background())
}

func (i ProjectsTagArgs) ToProjectsTagOutputWithContext(ctx context.Context) ProjectsTagOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProjectsTagOutput)
}

// ProjectsTagArrayInput is an input type that accepts ProjectsTagArray and ProjectsTagArrayOutput values.
// You can construct a concrete instance of `ProjectsTagArrayInput` via:
//
//	ProjectsTagArray{ ProjectsTagArgs{...} }
type ProjectsTagArrayInput interface {
	pulumi.Input

	ToProjectsTagArrayOutput() ProjectsTagArrayOutput
	ToProjectsTagArrayOutputWithContext(context.Context) ProjectsTagArrayOutput
}

type ProjectsTagArray []ProjectsTagInput

func (ProjectsTagArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ProjectsTag)(nil)).Elem()
}

func (i ProjectsTagArray) ToProjectsTagArrayOutput() ProjectsTagArrayOutput {
	return i.ToProjectsTagArrayOutputWithContext(context.Background())
}

func (i ProjectsTagArray) ToProjectsTagArrayOutputWithContext(ctx context.Context) ProjectsTagArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProjectsTagArrayOutput)
}

type ProjectsTagOutput struct{ *pulumi.OutputState }

func (ProjectsTagOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ProjectsTag)(nil)).Elem()
}

func (o ProjectsTagOutput) ToProjectsTagOutput() ProjectsTagOutput {
	return o
}

func (o ProjectsTagOutput) ToProjectsTagOutputWithContext(ctx context.Context) ProjectsTagOutput {
	return o
}

// The Key of Tags.
func (o ProjectsTagOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ProjectsTag) string { return v.Key }).(pulumi.StringOutput)
}

// The Value of Tags.
func (o ProjectsTagOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v ProjectsTag) string { return v.Value }).(pulumi.StringOutput)
}

type ProjectsTagArrayOutput struct{ *pulumi.OutputState }

func (ProjectsTagArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ProjectsTag)(nil)).Elem()
}

func (o ProjectsTagArrayOutput) ToProjectsTagArrayOutput() ProjectsTagArrayOutput {
	return o
}

func (o ProjectsTagArrayOutput) ToProjectsTagArrayOutputWithContext(ctx context.Context) ProjectsTagArrayOutput {
	return o
}

func (o ProjectsTagArrayOutput) Index(i pulumi.IntInput) ProjectsTagOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ProjectsTag {
		return vs[0].([]ProjectsTag)[vs[1].(int)]
	}).(ProjectsTagOutput)
}

type ProjectsTlsProject struct {
	// The create time of the tls project.
	CreateTime string `pulumi:"createTime"`
	// The description of the tls project.
	Description string `pulumi:"description"`
	// The IAM project name of the tls project.
	IamProjectName string `pulumi:"iamProjectName"`
	// The ID of the tls project.
	Id string `pulumi:"id"`
	// The inner net domain of the tls project.
	InnerNetDomain string `pulumi:"innerNetDomain"`
	// The id of tls project. This field supports fuzzy queries. It is not supported to specify both ProjectName and ProjectId at the same time.
	ProjectId string `pulumi:"projectId"`
	// The name of tls project. This field supports fuzzy queries. It is not supported to specify both ProjectName and ProjectId at the same time.
	ProjectName string `pulumi:"projectName"`
	// Tags.
	Tags []ProjectsTlsProjectTag `pulumi:"tags"`
	// The count of topics in the tls project.
	TopicCount int `pulumi:"topicCount"`
}

// ProjectsTlsProjectInput is an input type that accepts ProjectsTlsProjectArgs and ProjectsTlsProjectOutput values.
// You can construct a concrete instance of `ProjectsTlsProjectInput` via:
//
//	ProjectsTlsProjectArgs{...}
type ProjectsTlsProjectInput interface {
	pulumi.Input

	ToProjectsTlsProjectOutput() ProjectsTlsProjectOutput
	ToProjectsTlsProjectOutputWithContext(context.Context) ProjectsTlsProjectOutput
}

type ProjectsTlsProjectArgs struct {
	// The create time of the tls project.
	CreateTime pulumi.StringInput `pulumi:"createTime"`
	// The description of the tls project.
	Description pulumi.StringInput `pulumi:"description"`
	// The IAM project name of the tls project.
	IamProjectName pulumi.StringInput `pulumi:"iamProjectName"`
	// The ID of the tls project.
	Id pulumi.StringInput `pulumi:"id"`
	// The inner net domain of the tls project.
	InnerNetDomain pulumi.StringInput `pulumi:"innerNetDomain"`
	// The id of tls project. This field supports fuzzy queries. It is not supported to specify both ProjectName and ProjectId at the same time.
	ProjectId pulumi.StringInput `pulumi:"projectId"`
	// The name of tls project. This field supports fuzzy queries. It is not supported to specify both ProjectName and ProjectId at the same time.
	ProjectName pulumi.StringInput `pulumi:"projectName"`
	// Tags.
	Tags ProjectsTlsProjectTagArrayInput `pulumi:"tags"`
	// The count of topics in the tls project.
	TopicCount pulumi.IntInput `pulumi:"topicCount"`
}

func (ProjectsTlsProjectArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ProjectsTlsProject)(nil)).Elem()
}

func (i ProjectsTlsProjectArgs) ToProjectsTlsProjectOutput() ProjectsTlsProjectOutput {
	return i.ToProjectsTlsProjectOutputWithContext(context.Background())
}

func (i ProjectsTlsProjectArgs) ToProjectsTlsProjectOutputWithContext(ctx context.Context) ProjectsTlsProjectOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProjectsTlsProjectOutput)
}

// ProjectsTlsProjectArrayInput is an input type that accepts ProjectsTlsProjectArray and ProjectsTlsProjectArrayOutput values.
// You can construct a concrete instance of `ProjectsTlsProjectArrayInput` via:
//
//	ProjectsTlsProjectArray{ ProjectsTlsProjectArgs{...} }
type ProjectsTlsProjectArrayInput interface {
	pulumi.Input

	ToProjectsTlsProjectArrayOutput() ProjectsTlsProjectArrayOutput
	ToProjectsTlsProjectArrayOutputWithContext(context.Context) ProjectsTlsProjectArrayOutput
}

type ProjectsTlsProjectArray []ProjectsTlsProjectInput

func (ProjectsTlsProjectArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ProjectsTlsProject)(nil)).Elem()
}

func (i ProjectsTlsProjectArray) ToProjectsTlsProjectArrayOutput() ProjectsTlsProjectArrayOutput {
	return i.ToProjectsTlsProjectArrayOutputWithContext(context.Background())
}

func (i ProjectsTlsProjectArray) ToProjectsTlsProjectArrayOutputWithContext(ctx context.Context) ProjectsTlsProjectArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProjectsTlsProjectArrayOutput)
}

type ProjectsTlsProjectOutput struct{ *pulumi.OutputState }

func (ProjectsTlsProjectOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ProjectsTlsProject)(nil)).Elem()
}

func (o ProjectsTlsProjectOutput) ToProjectsTlsProjectOutput() ProjectsTlsProjectOutput {
	return o
}

func (o ProjectsTlsProjectOutput) ToProjectsTlsProjectOutputWithContext(ctx context.Context) ProjectsTlsProjectOutput {
	return o
}

// The create time of the tls project.
func (o ProjectsTlsProjectOutput) CreateTime() pulumi.StringOutput {
	return o.ApplyT(func(v ProjectsTlsProject) string { return v.CreateTime }).(pulumi.StringOutput)
}

// The description of the tls project.
func (o ProjectsTlsProjectOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v ProjectsTlsProject) string { return v.Description }).(pulumi.StringOutput)
}

// The IAM project name of the tls project.
func (o ProjectsTlsProjectOutput) IamProjectName() pulumi.StringOutput {
	return o.ApplyT(func(v ProjectsTlsProject) string { return v.IamProjectName }).(pulumi.StringOutput)
}

// The ID of the tls project.
func (o ProjectsTlsProjectOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v ProjectsTlsProject) string { return v.Id }).(pulumi.StringOutput)
}

// The inner net domain of the tls project.
func (o ProjectsTlsProjectOutput) InnerNetDomain() pulumi.StringOutput {
	return o.ApplyT(func(v ProjectsTlsProject) string { return v.InnerNetDomain }).(pulumi.StringOutput)
}

// The id of tls project. This field supports fuzzy queries. It is not supported to specify both ProjectName and ProjectId at the same time.
func (o ProjectsTlsProjectOutput) ProjectId() pulumi.StringOutput {
	return o.ApplyT(func(v ProjectsTlsProject) string { return v.ProjectId }).(pulumi.StringOutput)
}

// The name of tls project. This field supports fuzzy queries. It is not supported to specify both ProjectName and ProjectId at the same time.
func (o ProjectsTlsProjectOutput) ProjectName() pulumi.StringOutput {
	return o.ApplyT(func(v ProjectsTlsProject) string { return v.ProjectName }).(pulumi.StringOutput)
}

// Tags.
func (o ProjectsTlsProjectOutput) Tags() ProjectsTlsProjectTagArrayOutput {
	return o.ApplyT(func(v ProjectsTlsProject) []ProjectsTlsProjectTag { return v.Tags }).(ProjectsTlsProjectTagArrayOutput)
}

// The count of topics in the tls project.
func (o ProjectsTlsProjectOutput) TopicCount() pulumi.IntOutput {
	return o.ApplyT(func(v ProjectsTlsProject) int { return v.TopicCount }).(pulumi.IntOutput)
}

type ProjectsTlsProjectArrayOutput struct{ *pulumi.OutputState }

func (ProjectsTlsProjectArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ProjectsTlsProject)(nil)).Elem()
}

func (o ProjectsTlsProjectArrayOutput) ToProjectsTlsProjectArrayOutput() ProjectsTlsProjectArrayOutput {
	return o
}

func (o ProjectsTlsProjectArrayOutput) ToProjectsTlsProjectArrayOutputWithContext(ctx context.Context) ProjectsTlsProjectArrayOutput {
	return o
}

func (o ProjectsTlsProjectArrayOutput) Index(i pulumi.IntInput) ProjectsTlsProjectOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ProjectsTlsProject {
		return vs[0].([]ProjectsTlsProject)[vs[1].(int)]
	}).(ProjectsTlsProjectOutput)
}

type ProjectsTlsProjectTag struct {
	// The Key of Tags.
	Key string `pulumi:"key"`
	// The Value of Tags.
	Value string `pulumi:"value"`
}

// ProjectsTlsProjectTagInput is an input type that accepts ProjectsTlsProjectTagArgs and ProjectsTlsProjectTagOutput values.
// You can construct a concrete instance of `ProjectsTlsProjectTagInput` via:
//
//	ProjectsTlsProjectTagArgs{...}
type ProjectsTlsProjectTagInput interface {
	pulumi.Input

	ToProjectsTlsProjectTagOutput() ProjectsTlsProjectTagOutput
	ToProjectsTlsProjectTagOutputWithContext(context.Context) ProjectsTlsProjectTagOutput
}

type ProjectsTlsProjectTagArgs struct {
	// The Key of Tags.
	Key pulumi.StringInput `pulumi:"key"`
	// The Value of Tags.
	Value pulumi.StringInput `pulumi:"value"`
}

func (ProjectsTlsProjectTagArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ProjectsTlsProjectTag)(nil)).Elem()
}

func (i ProjectsTlsProjectTagArgs) ToProjectsTlsProjectTagOutput() ProjectsTlsProjectTagOutput {
	return i.ToProjectsTlsProjectTagOutputWithContext(context.Background())
}

func (i ProjectsTlsProjectTagArgs) ToProjectsTlsProjectTagOutputWithContext(ctx context.Context) ProjectsTlsProjectTagOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProjectsTlsProjectTagOutput)
}

// ProjectsTlsProjectTagArrayInput is an input type that accepts ProjectsTlsProjectTagArray and ProjectsTlsProjectTagArrayOutput values.
// You can construct a concrete instance of `ProjectsTlsProjectTagArrayInput` via:
//
//	ProjectsTlsProjectTagArray{ ProjectsTlsProjectTagArgs{...} }
type ProjectsTlsProjectTagArrayInput interface {
	pulumi.Input

	ToProjectsTlsProjectTagArrayOutput() ProjectsTlsProjectTagArrayOutput
	ToProjectsTlsProjectTagArrayOutputWithContext(context.Context) ProjectsTlsProjectTagArrayOutput
}

type ProjectsTlsProjectTagArray []ProjectsTlsProjectTagInput

func (ProjectsTlsProjectTagArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ProjectsTlsProjectTag)(nil)).Elem()
}

func (i ProjectsTlsProjectTagArray) ToProjectsTlsProjectTagArrayOutput() ProjectsTlsProjectTagArrayOutput {
	return i.ToProjectsTlsProjectTagArrayOutputWithContext(context.Background())
}

func (i ProjectsTlsProjectTagArray) ToProjectsTlsProjectTagArrayOutputWithContext(ctx context.Context) ProjectsTlsProjectTagArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ProjectsTlsProjectTagArrayOutput)
}

type ProjectsTlsProjectTagOutput struct{ *pulumi.OutputState }

func (ProjectsTlsProjectTagOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ProjectsTlsProjectTag)(nil)).Elem()
}

func (o ProjectsTlsProjectTagOutput) ToProjectsTlsProjectTagOutput() ProjectsTlsProjectTagOutput {
	return o
}

func (o ProjectsTlsProjectTagOutput) ToProjectsTlsProjectTagOutputWithContext(ctx context.Context) ProjectsTlsProjectTagOutput {
	return o
}

// The Key of Tags.
func (o ProjectsTlsProjectTagOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ProjectsTlsProjectTag) string { return v.Key }).(pulumi.StringOutput)
}

// The Value of Tags.
func (o ProjectsTlsProjectTagOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v ProjectsTlsProjectTag) string { return v.Value }).(pulumi.StringOutput)
}

type ProjectsTlsProjectTagArrayOutput struct{ *pulumi.OutputState }

func (ProjectsTlsProjectTagArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ProjectsTlsProjectTag)(nil)).Elem()
}

func (o ProjectsTlsProjectTagArrayOutput) ToProjectsTlsProjectTagArrayOutput() ProjectsTlsProjectTagArrayOutput {
	return o
}

func (o ProjectsTlsProjectTagArrayOutput) ToProjectsTlsProjectTagArrayOutputWithContext(ctx context.Context) ProjectsTlsProjectTagArrayOutput {
	return o
}

func (o ProjectsTlsProjectTagArrayOutput) Index(i pulumi.IntInput) ProjectsTlsProjectTagOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ProjectsTlsProjectTag {
		return vs[0].([]ProjectsTlsProjectTag)[vs[1].(int)]
	}).(ProjectsTlsProjectTagOutput)
}

type RuleAppliersRule struct {
	// Container collection rules.
	ContainerRules []RuleAppliersRuleContainerRule `pulumi:"containerRules"`
	// The creation time.
	CreateTime string `pulumi:"createTime"`
	// Collect the blacklist list.
	ExcludePaths []RuleAppliersRuleExcludePath `pulumi:"excludePaths"`
	// The extract rule.
	ExtractRules []RuleAppliersRuleExtractRule `pulumi:"extractRules"`
	// The collection type.
	InputType int `pulumi:"inputType"`
	// Log sample.
	LogSample string `pulumi:"logSample"`
	// The log type.
	LogType string `pulumi:"logType"`
	// The modification time.
	ModifyTime string `pulumi:"modifyTime"`
	// Collection path list.
	Paths []string `pulumi:"paths"`
	// The rule id.
	RuleId string `pulumi:"ruleId"`
	// The rule name.
	RuleName string `pulumi:"ruleName"`
	// The topic id.
	TopicId string `pulumi:"topicId"`
	// The topic name.
	TopicName string `pulumi:"topicName"`
	// User-defined collection rules.
	UserDefineRules []RuleAppliersRuleUserDefineRule `pulumi:"userDefineRules"`
}

// RuleAppliersRuleInput is an input type that accepts RuleAppliersRuleArgs and RuleAppliersRuleOutput values.
// You can construct a concrete instance of `RuleAppliersRuleInput` via:
//
//	RuleAppliersRuleArgs{...}
type RuleAppliersRuleInput interface {
	pulumi.Input

	ToRuleAppliersRuleOutput() RuleAppliersRuleOutput
	ToRuleAppliersRuleOutputWithContext(context.Context) RuleAppliersRuleOutput
}

type RuleAppliersRuleArgs struct {
	// Container collection rules.
	ContainerRules RuleAppliersRuleContainerRuleArrayInput `pulumi:"containerRules"`
	// The creation time.
	CreateTime pulumi.StringInput `pulumi:"createTime"`
	// Collect the blacklist list.
	ExcludePaths RuleAppliersRuleExcludePathArrayInput `pulumi:"excludePaths"`
	// The extract rule.
	ExtractRules RuleAppliersRuleExtractRuleArrayInput `pulumi:"extractRules"`
	// The collection type.
	InputType pulumi.IntInput `pulumi:"inputType"`
	// Log sample.
	LogSample pulumi.StringInput `pulumi:"logSample"`
	// The log type.
	LogType pulumi.StringInput `pulumi:"logType"`
	// The modification time.
	ModifyTime pulumi.StringInput `pulumi:"modifyTime"`
	// Collection path list.
	Paths pulumi.StringArrayInput `pulumi:"paths"`
	// The rule id.
	RuleId pulumi.StringInput `pulumi:"ruleId"`
	// The rule name.
	RuleName pulumi.StringInput `pulumi:"ruleName"`
	// The topic id.
	TopicId pulumi.StringInput `pulumi:"topicId"`
	// The topic name.
	TopicName pulumi.StringInput `pulumi:"topicName"`
	// User-defined collection rules.
	UserDefineRules RuleAppliersRuleUserDefineRuleArrayInput `pulumi:"userDefineRules"`
}

func (RuleAppliersRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleAppliersRule)(nil)).Elem()
}

func (i RuleAppliersRuleArgs) ToRuleAppliersRuleOutput() RuleAppliersRuleOutput {
	return i.ToRuleAppliersRuleOutputWithContext(context.Background())
}

func (i RuleAppliersRuleArgs) ToRuleAppliersRuleOutputWithContext(ctx context.Context) RuleAppliersRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleAppliersRuleOutput)
}

// RuleAppliersRuleArrayInput is an input type that accepts RuleAppliersRuleArray and RuleAppliersRuleArrayOutput values.
// You can construct a concrete instance of `RuleAppliersRuleArrayInput` via:
//
//	RuleAppliersRuleArray{ RuleAppliersRuleArgs{...} }
type RuleAppliersRuleArrayInput interface {
	pulumi.Input

	ToRuleAppliersRuleArrayOutput() RuleAppliersRuleArrayOutput
	ToRuleAppliersRuleArrayOutputWithContext(context.Context) RuleAppliersRuleArrayOutput
}

type RuleAppliersRuleArray []RuleAppliersRuleInput

func (RuleAppliersRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleAppliersRule)(nil)).Elem()
}

func (i RuleAppliersRuleArray) ToRuleAppliersRuleArrayOutput() RuleAppliersRuleArrayOutput {
	return i.ToRuleAppliersRuleArrayOutputWithContext(context.Background())
}

func (i RuleAppliersRuleArray) ToRuleAppliersRuleArrayOutputWithContext(ctx context.Context) RuleAppliersRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleAppliersRuleArrayOutput)
}

type RuleAppliersRuleOutput struct{ *pulumi.OutputState }

func (RuleAppliersRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleAppliersRule)(nil)).Elem()
}

func (o RuleAppliersRuleOutput) ToRuleAppliersRuleOutput() RuleAppliersRuleOutput {
	return o
}

func (o RuleAppliersRuleOutput) ToRuleAppliersRuleOutputWithContext(ctx context.Context) RuleAppliersRuleOutput {
	return o
}

// Container collection rules.
func (o RuleAppliersRuleOutput) ContainerRules() RuleAppliersRuleContainerRuleArrayOutput {
	return o.ApplyT(func(v RuleAppliersRule) []RuleAppliersRuleContainerRule { return v.ContainerRules }).(RuleAppliersRuleContainerRuleArrayOutput)
}

// The creation time.
func (o RuleAppliersRuleOutput) CreateTime() pulumi.StringOutput {
	return o.ApplyT(func(v RuleAppliersRule) string { return v.CreateTime }).(pulumi.StringOutput)
}

// Collect the blacklist list.
func (o RuleAppliersRuleOutput) ExcludePaths() RuleAppliersRuleExcludePathArrayOutput {
	return o.ApplyT(func(v RuleAppliersRule) []RuleAppliersRuleExcludePath { return v.ExcludePaths }).(RuleAppliersRuleExcludePathArrayOutput)
}

// The extract rule.
func (o RuleAppliersRuleOutput) ExtractRules() RuleAppliersRuleExtractRuleArrayOutput {
	return o.ApplyT(func(v RuleAppliersRule) []RuleAppliersRuleExtractRule { return v.ExtractRules }).(RuleAppliersRuleExtractRuleArrayOutput)
}

// The collection type.
func (o RuleAppliersRuleOutput) InputType() pulumi.IntOutput {
	return o.ApplyT(func(v RuleAppliersRule) int { return v.InputType }).(pulumi.IntOutput)
}

// Log sample.
func (o RuleAppliersRuleOutput) LogSample() pulumi.StringOutput {
	return o.ApplyT(func(v RuleAppliersRule) string { return v.LogSample }).(pulumi.StringOutput)
}

// The log type.
func (o RuleAppliersRuleOutput) LogType() pulumi.StringOutput {
	return o.ApplyT(func(v RuleAppliersRule) string { return v.LogType }).(pulumi.StringOutput)
}

// The modification time.
func (o RuleAppliersRuleOutput) ModifyTime() pulumi.StringOutput {
	return o.ApplyT(func(v RuleAppliersRule) string { return v.ModifyTime }).(pulumi.StringOutput)
}

// Collection path list.
func (o RuleAppliersRuleOutput) Paths() pulumi.StringArrayOutput {
	return o.ApplyT(func(v RuleAppliersRule) []string { return v.Paths }).(pulumi.StringArrayOutput)
}

// The rule id.
func (o RuleAppliersRuleOutput) RuleId() pulumi.StringOutput {
	return o.ApplyT(func(v RuleAppliersRule) string { return v.RuleId }).(pulumi.StringOutput)
}

// The rule name.
func (o RuleAppliersRuleOutput) RuleName() pulumi.StringOutput {
	return o.ApplyT(func(v RuleAppliersRule) string { return v.RuleName }).(pulumi.StringOutput)
}

// The topic id.
func (o RuleAppliersRuleOutput) TopicId() pulumi.StringOutput {
	return o.ApplyT(func(v RuleAppliersRule) string { return v.TopicId }).(pulumi.StringOutput)
}

// The topic name.
func (o RuleAppliersRuleOutput) TopicName() pulumi.StringOutput {
	return o.ApplyT(func(v RuleAppliersRule) string { return v.TopicName }).(pulumi.StringOutput)
}

// User-defined collection rules.
func (o RuleAppliersRuleOutput) UserDefineRules() RuleAppliersRuleUserDefineRuleArrayOutput {
	return o.ApplyT(func(v RuleAppliersRule) []RuleAppliersRuleUserDefineRule { return v.UserDefineRules }).(RuleAppliersRuleUserDefineRuleArrayOutput)
}

type RuleAppliersRuleArrayOutput struct{ *pulumi.OutputState }

func (RuleAppliersRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleAppliersRule)(nil)).Elem()
}

func (o RuleAppliersRuleArrayOutput) ToRuleAppliersRuleArrayOutput() RuleAppliersRuleArrayOutput {
	return o
}

func (o RuleAppliersRuleArrayOutput) ToRuleAppliersRuleArrayOutputWithContext(ctx context.Context) RuleAppliersRuleArrayOutput {
	return o
}

func (o RuleAppliersRuleArrayOutput) Index(i pulumi.IntInput) RuleAppliersRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RuleAppliersRule {
		return vs[0].([]RuleAppliersRule)[vs[1].(int)]
	}).(RuleAppliersRuleOutput)
}

type RuleAppliersRuleContainerRule struct {
	// The name of the container to be collected.
	ContainerNameRegex string `pulumi:"containerNameRegex"`
	// Whether to add environment variables as log tags to raw log data.
	EnvTag map[string]interface{} `pulumi:"envTag"`
	// The container environment variable blacklist is used to specify the range of containers not to be collected.
	ExcludeContainerEnvRegex map[string]interface{} `pulumi:"excludeContainerEnvRegex"`
	// The container Label blacklist is used to specify the range of containers not to be collected.
	ExcludeContainerLabelRegex map[string]interface{} `pulumi:"excludeContainerLabelRegex"`
	// The container environment variable whitelist specifies the container to be collected through the container environment variable. If the whitelist is not enabled, it means that all containers are specified to be collected.
	IncludeContainerEnvRegex map[string]interface{} `pulumi:"includeContainerEnvRegex"`
	// The container label whitelist specifies the containers to be collected through the container label. If the whitelist is not enabled, all containers are specified to be collected.
	IncludeContainerLabelRegex map[string]interface{} `pulumi:"includeContainerLabelRegex"`
	// Collection rules for Kubernetes containers.
	KubernetesRules []RuleAppliersRuleContainerRuleKubernetesRule `pulumi:"kubernetesRules"`
	// The collection mode.
	Stream string `pulumi:"stream"`
}

// RuleAppliersRuleContainerRuleInput is an input type that accepts RuleAppliersRuleContainerRuleArgs and RuleAppliersRuleContainerRuleOutput values.
// You can construct a concrete instance of `RuleAppliersRuleContainerRuleInput` via:
//
//	RuleAppliersRuleContainerRuleArgs{...}
type RuleAppliersRuleContainerRuleInput interface {
	pulumi.Input

	ToRuleAppliersRuleContainerRuleOutput() RuleAppliersRuleContainerRuleOutput
	ToRuleAppliersRuleContainerRuleOutputWithContext(context.Context) RuleAppliersRuleContainerRuleOutput
}

type RuleAppliersRuleContainerRuleArgs struct {
	// The name of the container to be collected.
	ContainerNameRegex pulumi.StringInput `pulumi:"containerNameRegex"`
	// Whether to add environment variables as log tags to raw log data.
	EnvTag pulumi.MapInput `pulumi:"envTag"`
	// The container environment variable blacklist is used to specify the range of containers not to be collected.
	ExcludeContainerEnvRegex pulumi.MapInput `pulumi:"excludeContainerEnvRegex"`
	// The container Label blacklist is used to specify the range of containers not to be collected.
	ExcludeContainerLabelRegex pulumi.MapInput `pulumi:"excludeContainerLabelRegex"`
	// The container environment variable whitelist specifies the container to be collected through the container environment variable. If the whitelist is not enabled, it means that all containers are specified to be collected.
	IncludeContainerEnvRegex pulumi.MapInput `pulumi:"includeContainerEnvRegex"`
	// The container label whitelist specifies the containers to be collected through the container label. If the whitelist is not enabled, all containers are specified to be collected.
	IncludeContainerLabelRegex pulumi.MapInput `pulumi:"includeContainerLabelRegex"`
	// Collection rules for Kubernetes containers.
	KubernetesRules RuleAppliersRuleContainerRuleKubernetesRuleArrayInput `pulumi:"kubernetesRules"`
	// The collection mode.
	Stream pulumi.StringInput `pulumi:"stream"`
}

func (RuleAppliersRuleContainerRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleAppliersRuleContainerRule)(nil)).Elem()
}

func (i RuleAppliersRuleContainerRuleArgs) ToRuleAppliersRuleContainerRuleOutput() RuleAppliersRuleContainerRuleOutput {
	return i.ToRuleAppliersRuleContainerRuleOutputWithContext(context.Background())
}

func (i RuleAppliersRuleContainerRuleArgs) ToRuleAppliersRuleContainerRuleOutputWithContext(ctx context.Context) RuleAppliersRuleContainerRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleAppliersRuleContainerRuleOutput)
}

// RuleAppliersRuleContainerRuleArrayInput is an input type that accepts RuleAppliersRuleContainerRuleArray and RuleAppliersRuleContainerRuleArrayOutput values.
// You can construct a concrete instance of `RuleAppliersRuleContainerRuleArrayInput` via:
//
//	RuleAppliersRuleContainerRuleArray{ RuleAppliersRuleContainerRuleArgs{...} }
type RuleAppliersRuleContainerRuleArrayInput interface {
	pulumi.Input

	ToRuleAppliersRuleContainerRuleArrayOutput() RuleAppliersRuleContainerRuleArrayOutput
	ToRuleAppliersRuleContainerRuleArrayOutputWithContext(context.Context) RuleAppliersRuleContainerRuleArrayOutput
}

type RuleAppliersRuleContainerRuleArray []RuleAppliersRuleContainerRuleInput

func (RuleAppliersRuleContainerRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleAppliersRuleContainerRule)(nil)).Elem()
}

func (i RuleAppliersRuleContainerRuleArray) ToRuleAppliersRuleContainerRuleArrayOutput() RuleAppliersRuleContainerRuleArrayOutput {
	return i.ToRuleAppliersRuleContainerRuleArrayOutputWithContext(context.Background())
}

func (i RuleAppliersRuleContainerRuleArray) ToRuleAppliersRuleContainerRuleArrayOutputWithContext(ctx context.Context) RuleAppliersRuleContainerRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleAppliersRuleContainerRuleArrayOutput)
}

type RuleAppliersRuleContainerRuleOutput struct{ *pulumi.OutputState }

func (RuleAppliersRuleContainerRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleAppliersRuleContainerRule)(nil)).Elem()
}

func (o RuleAppliersRuleContainerRuleOutput) ToRuleAppliersRuleContainerRuleOutput() RuleAppliersRuleContainerRuleOutput {
	return o
}

func (o RuleAppliersRuleContainerRuleOutput) ToRuleAppliersRuleContainerRuleOutputWithContext(ctx context.Context) RuleAppliersRuleContainerRuleOutput {
	return o
}

// The name of the container to be collected.
func (o RuleAppliersRuleContainerRuleOutput) ContainerNameRegex() pulumi.StringOutput {
	return o.ApplyT(func(v RuleAppliersRuleContainerRule) string { return v.ContainerNameRegex }).(pulumi.StringOutput)
}

// Whether to add environment variables as log tags to raw log data.
func (o RuleAppliersRuleContainerRuleOutput) EnvTag() pulumi.MapOutput {
	return o.ApplyT(func(v RuleAppliersRuleContainerRule) map[string]interface{} { return v.EnvTag }).(pulumi.MapOutput)
}

// The container environment variable blacklist is used to specify the range of containers not to be collected.
func (o RuleAppliersRuleContainerRuleOutput) ExcludeContainerEnvRegex() pulumi.MapOutput {
	return o.ApplyT(func(v RuleAppliersRuleContainerRule) map[string]interface{} { return v.ExcludeContainerEnvRegex }).(pulumi.MapOutput)
}

// The container Label blacklist is used to specify the range of containers not to be collected.
func (o RuleAppliersRuleContainerRuleOutput) ExcludeContainerLabelRegex() pulumi.MapOutput {
	return o.ApplyT(func(v RuleAppliersRuleContainerRule) map[string]interface{} { return v.ExcludeContainerLabelRegex }).(pulumi.MapOutput)
}

// The container environment variable whitelist specifies the container to be collected through the container environment variable. If the whitelist is not enabled, it means that all containers are specified to be collected.
func (o RuleAppliersRuleContainerRuleOutput) IncludeContainerEnvRegex() pulumi.MapOutput {
	return o.ApplyT(func(v RuleAppliersRuleContainerRule) map[string]interface{} { return v.IncludeContainerEnvRegex }).(pulumi.MapOutput)
}

// The container label whitelist specifies the containers to be collected through the container label. If the whitelist is not enabled, all containers are specified to be collected.
func (o RuleAppliersRuleContainerRuleOutput) IncludeContainerLabelRegex() pulumi.MapOutput {
	return o.ApplyT(func(v RuleAppliersRuleContainerRule) map[string]interface{} { return v.IncludeContainerLabelRegex }).(pulumi.MapOutput)
}

// Collection rules for Kubernetes containers.
func (o RuleAppliersRuleContainerRuleOutput) KubernetesRules() RuleAppliersRuleContainerRuleKubernetesRuleArrayOutput {
	return o.ApplyT(func(v RuleAppliersRuleContainerRule) []RuleAppliersRuleContainerRuleKubernetesRule {
		return v.KubernetesRules
	}).(RuleAppliersRuleContainerRuleKubernetesRuleArrayOutput)
}

// The collection mode.
func (o RuleAppliersRuleContainerRuleOutput) Stream() pulumi.StringOutput {
	return o.ApplyT(func(v RuleAppliersRuleContainerRule) string { return v.Stream }).(pulumi.StringOutput)
}

type RuleAppliersRuleContainerRuleArrayOutput struct{ *pulumi.OutputState }

func (RuleAppliersRuleContainerRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleAppliersRuleContainerRule)(nil)).Elem()
}

func (o RuleAppliersRuleContainerRuleArrayOutput) ToRuleAppliersRuleContainerRuleArrayOutput() RuleAppliersRuleContainerRuleArrayOutput {
	return o
}

func (o RuleAppliersRuleContainerRuleArrayOutput) ToRuleAppliersRuleContainerRuleArrayOutputWithContext(ctx context.Context) RuleAppliersRuleContainerRuleArrayOutput {
	return o
}

func (o RuleAppliersRuleContainerRuleArrayOutput) Index(i pulumi.IntInput) RuleAppliersRuleContainerRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RuleAppliersRuleContainerRule {
		return vs[0].([]RuleAppliersRuleContainerRule)[vs[1].(int)]
	}).(RuleAppliersRuleContainerRuleOutput)
}

type RuleAppliersRuleContainerRuleKubernetesRule struct {
	// Whether to add Kubernetes Annotation as a log tag to the raw log data.
	AnnotationTag map[string]interface{} `pulumi:"annotationTag"`
	// Specify the containers not to be collected through the Pod Label blacklist, and not enable means to collect all containers.
	ExcludePodLabelRegex map[string]interface{} `pulumi:"excludePodLabelRegex"`
	// The Pod Label whitelist is used to specify containers to be collected. When the Pod Label whitelist is not enabled, it means that all containers are collected.
	IncludePodLabelRegex map[string]interface{} `pulumi:"includePodLabelRegex"`
	// Whether to add Kubernetes Label as a log label to the original log data.
	LabelTag map[string]interface{} `pulumi:"labelTag"`
	// The name of the Kubernetes Namespace to be collected. If no Namespace name is specified, all containers will be collected. Namespace names support regular matching.
	NamespaceNameRegex string `pulumi:"namespaceNameRegex"`
	// The Pod name is used to specify the container to be collected. When no Pod name is specified, it means to collect all containers.
	PodNameRegex string `pulumi:"podNameRegex"`
	// Specify the container to be collected by the name of the workload. When no workload name is specified, all containers are collected. The workload name supports regular matching.
	WorkloadNameRegex string `pulumi:"workloadNameRegex"`
	// Specify the container to be collected by the type of workload. Only one type can be selected. When no type is specified, it means to collect all types of containers.
	WorkloadType string `pulumi:"workloadType"`
}

// RuleAppliersRuleContainerRuleKubernetesRuleInput is an input type that accepts RuleAppliersRuleContainerRuleKubernetesRuleArgs and RuleAppliersRuleContainerRuleKubernetesRuleOutput values.
// You can construct a concrete instance of `RuleAppliersRuleContainerRuleKubernetesRuleInput` via:
//
//	RuleAppliersRuleContainerRuleKubernetesRuleArgs{...}
type RuleAppliersRuleContainerRuleKubernetesRuleInput interface {
	pulumi.Input

	ToRuleAppliersRuleContainerRuleKubernetesRuleOutput() RuleAppliersRuleContainerRuleKubernetesRuleOutput
	ToRuleAppliersRuleContainerRuleKubernetesRuleOutputWithContext(context.Context) RuleAppliersRuleContainerRuleKubernetesRuleOutput
}

type RuleAppliersRuleContainerRuleKubernetesRuleArgs struct {
	// Whether to add Kubernetes Annotation as a log tag to the raw log data.
	AnnotationTag pulumi.MapInput `pulumi:"annotationTag"`
	// Specify the containers not to be collected through the Pod Label blacklist, and not enable means to collect all containers.
	ExcludePodLabelRegex pulumi.MapInput `pulumi:"excludePodLabelRegex"`
	// The Pod Label whitelist is used to specify containers to be collected. When the Pod Label whitelist is not enabled, it means that all containers are collected.
	IncludePodLabelRegex pulumi.MapInput `pulumi:"includePodLabelRegex"`
	// Whether to add Kubernetes Label as a log label to the original log data.
	LabelTag pulumi.MapInput `pulumi:"labelTag"`
	// The name of the Kubernetes Namespace to be collected. If no Namespace name is specified, all containers will be collected. Namespace names support regular matching.
	NamespaceNameRegex pulumi.StringInput `pulumi:"namespaceNameRegex"`
	// The Pod name is used to specify the container to be collected. When no Pod name is specified, it means to collect all containers.
	PodNameRegex pulumi.StringInput `pulumi:"podNameRegex"`
	// Specify the container to be collected by the name of the workload. When no workload name is specified, all containers are collected. The workload name supports regular matching.
	WorkloadNameRegex pulumi.StringInput `pulumi:"workloadNameRegex"`
	// Specify the container to be collected by the type of workload. Only one type can be selected. When no type is specified, it means to collect all types of containers.
	WorkloadType pulumi.StringInput `pulumi:"workloadType"`
}

func (RuleAppliersRuleContainerRuleKubernetesRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleAppliersRuleContainerRuleKubernetesRule)(nil)).Elem()
}

func (i RuleAppliersRuleContainerRuleKubernetesRuleArgs) ToRuleAppliersRuleContainerRuleKubernetesRuleOutput() RuleAppliersRuleContainerRuleKubernetesRuleOutput {
	return i.ToRuleAppliersRuleContainerRuleKubernetesRuleOutputWithContext(context.Background())
}

func (i RuleAppliersRuleContainerRuleKubernetesRuleArgs) ToRuleAppliersRuleContainerRuleKubernetesRuleOutputWithContext(ctx context.Context) RuleAppliersRuleContainerRuleKubernetesRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleAppliersRuleContainerRuleKubernetesRuleOutput)
}

// RuleAppliersRuleContainerRuleKubernetesRuleArrayInput is an input type that accepts RuleAppliersRuleContainerRuleKubernetesRuleArray and RuleAppliersRuleContainerRuleKubernetesRuleArrayOutput values.
// You can construct a concrete instance of `RuleAppliersRuleContainerRuleKubernetesRuleArrayInput` via:
//
//	RuleAppliersRuleContainerRuleKubernetesRuleArray{ RuleAppliersRuleContainerRuleKubernetesRuleArgs{...} }
type RuleAppliersRuleContainerRuleKubernetesRuleArrayInput interface {
	pulumi.Input

	ToRuleAppliersRuleContainerRuleKubernetesRuleArrayOutput() RuleAppliersRuleContainerRuleKubernetesRuleArrayOutput
	ToRuleAppliersRuleContainerRuleKubernetesRuleArrayOutputWithContext(context.Context) RuleAppliersRuleContainerRuleKubernetesRuleArrayOutput
}

type RuleAppliersRuleContainerRuleKubernetesRuleArray []RuleAppliersRuleContainerRuleKubernetesRuleInput

func (RuleAppliersRuleContainerRuleKubernetesRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleAppliersRuleContainerRuleKubernetesRule)(nil)).Elem()
}

func (i RuleAppliersRuleContainerRuleKubernetesRuleArray) ToRuleAppliersRuleContainerRuleKubernetesRuleArrayOutput() RuleAppliersRuleContainerRuleKubernetesRuleArrayOutput {
	return i.ToRuleAppliersRuleContainerRuleKubernetesRuleArrayOutputWithContext(context.Background())
}

func (i RuleAppliersRuleContainerRuleKubernetesRuleArray) ToRuleAppliersRuleContainerRuleKubernetesRuleArrayOutputWithContext(ctx context.Context) RuleAppliersRuleContainerRuleKubernetesRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleAppliersRuleContainerRuleKubernetesRuleArrayOutput)
}

type RuleAppliersRuleContainerRuleKubernetesRuleOutput struct{ *pulumi.OutputState }

func (RuleAppliersRuleContainerRuleKubernetesRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleAppliersRuleContainerRuleKubernetesRule)(nil)).Elem()
}

func (o RuleAppliersRuleContainerRuleKubernetesRuleOutput) ToRuleAppliersRuleContainerRuleKubernetesRuleOutput() RuleAppliersRuleContainerRuleKubernetesRuleOutput {
	return o
}

func (o RuleAppliersRuleContainerRuleKubernetesRuleOutput) ToRuleAppliersRuleContainerRuleKubernetesRuleOutputWithContext(ctx context.Context) RuleAppliersRuleContainerRuleKubernetesRuleOutput {
	return o
}

// Whether to add Kubernetes Annotation as a log tag to the raw log data.
func (o RuleAppliersRuleContainerRuleKubernetesRuleOutput) AnnotationTag() pulumi.MapOutput {
	return o.ApplyT(func(v RuleAppliersRuleContainerRuleKubernetesRule) map[string]interface{} { return v.AnnotationTag }).(pulumi.MapOutput)
}

// Specify the containers not to be collected through the Pod Label blacklist, and not enable means to collect all containers.
func (o RuleAppliersRuleContainerRuleKubernetesRuleOutput) ExcludePodLabelRegex() pulumi.MapOutput {
	return o.ApplyT(func(v RuleAppliersRuleContainerRuleKubernetesRule) map[string]interface{} {
		return v.ExcludePodLabelRegex
	}).(pulumi.MapOutput)
}

// The Pod Label whitelist is used to specify containers to be collected. When the Pod Label whitelist is not enabled, it means that all containers are collected.
func (o RuleAppliersRuleContainerRuleKubernetesRuleOutput) IncludePodLabelRegex() pulumi.MapOutput {
	return o.ApplyT(func(v RuleAppliersRuleContainerRuleKubernetesRule) map[string]interface{} {
		return v.IncludePodLabelRegex
	}).(pulumi.MapOutput)
}

// Whether to add Kubernetes Label as a log label to the original log data.
func (o RuleAppliersRuleContainerRuleKubernetesRuleOutput) LabelTag() pulumi.MapOutput {
	return o.ApplyT(func(v RuleAppliersRuleContainerRuleKubernetesRule) map[string]interface{} { return v.LabelTag }).(pulumi.MapOutput)
}

// The name of the Kubernetes Namespace to be collected. If no Namespace name is specified, all containers will be collected. Namespace names support regular matching.
func (o RuleAppliersRuleContainerRuleKubernetesRuleOutput) NamespaceNameRegex() pulumi.StringOutput {
	return o.ApplyT(func(v RuleAppliersRuleContainerRuleKubernetesRule) string { return v.NamespaceNameRegex }).(pulumi.StringOutput)
}

// The Pod name is used to specify the container to be collected. When no Pod name is specified, it means to collect all containers.
func (o RuleAppliersRuleContainerRuleKubernetesRuleOutput) PodNameRegex() pulumi.StringOutput {
	return o.ApplyT(func(v RuleAppliersRuleContainerRuleKubernetesRule) string { return v.PodNameRegex }).(pulumi.StringOutput)
}

// Specify the container to be collected by the name of the workload. When no workload name is specified, all containers are collected. The workload name supports regular matching.
func (o RuleAppliersRuleContainerRuleKubernetesRuleOutput) WorkloadNameRegex() pulumi.StringOutput {
	return o.ApplyT(func(v RuleAppliersRuleContainerRuleKubernetesRule) string { return v.WorkloadNameRegex }).(pulumi.StringOutput)
}

// Specify the container to be collected by the type of workload. Only one type can be selected. When no type is specified, it means to collect all types of containers.
func (o RuleAppliersRuleContainerRuleKubernetesRuleOutput) WorkloadType() pulumi.StringOutput {
	return o.ApplyT(func(v RuleAppliersRuleContainerRuleKubernetesRule) string { return v.WorkloadType }).(pulumi.StringOutput)
}

type RuleAppliersRuleContainerRuleKubernetesRuleArrayOutput struct{ *pulumi.OutputState }

func (RuleAppliersRuleContainerRuleKubernetesRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleAppliersRuleContainerRuleKubernetesRule)(nil)).Elem()
}

func (o RuleAppliersRuleContainerRuleKubernetesRuleArrayOutput) ToRuleAppliersRuleContainerRuleKubernetesRuleArrayOutput() RuleAppliersRuleContainerRuleKubernetesRuleArrayOutput {
	return o
}

func (o RuleAppliersRuleContainerRuleKubernetesRuleArrayOutput) ToRuleAppliersRuleContainerRuleKubernetesRuleArrayOutputWithContext(ctx context.Context) RuleAppliersRuleContainerRuleKubernetesRuleArrayOutput {
	return o
}

func (o RuleAppliersRuleContainerRuleKubernetesRuleArrayOutput) Index(i pulumi.IntInput) RuleAppliersRuleContainerRuleKubernetesRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RuleAppliersRuleContainerRuleKubernetesRule {
		return vs[0].([]RuleAppliersRuleContainerRuleKubernetesRule)[vs[1].(int)]
	}).(RuleAppliersRuleContainerRuleKubernetesRuleOutput)
}

type RuleAppliersRuleExcludePath struct {
	// The type of the log template.
	Type string `pulumi:"type"`
	// Collection path.
	Value string `pulumi:"value"`
}

// RuleAppliersRuleExcludePathInput is an input type that accepts RuleAppliersRuleExcludePathArgs and RuleAppliersRuleExcludePathOutput values.
// You can construct a concrete instance of `RuleAppliersRuleExcludePathInput` via:
//
//	RuleAppliersRuleExcludePathArgs{...}
type RuleAppliersRuleExcludePathInput interface {
	pulumi.Input

	ToRuleAppliersRuleExcludePathOutput() RuleAppliersRuleExcludePathOutput
	ToRuleAppliersRuleExcludePathOutputWithContext(context.Context) RuleAppliersRuleExcludePathOutput
}

type RuleAppliersRuleExcludePathArgs struct {
	// The type of the log template.
	Type pulumi.StringInput `pulumi:"type"`
	// Collection path.
	Value pulumi.StringInput `pulumi:"value"`
}

func (RuleAppliersRuleExcludePathArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleAppliersRuleExcludePath)(nil)).Elem()
}

func (i RuleAppliersRuleExcludePathArgs) ToRuleAppliersRuleExcludePathOutput() RuleAppliersRuleExcludePathOutput {
	return i.ToRuleAppliersRuleExcludePathOutputWithContext(context.Background())
}

func (i RuleAppliersRuleExcludePathArgs) ToRuleAppliersRuleExcludePathOutputWithContext(ctx context.Context) RuleAppliersRuleExcludePathOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleAppliersRuleExcludePathOutput)
}

// RuleAppliersRuleExcludePathArrayInput is an input type that accepts RuleAppliersRuleExcludePathArray and RuleAppliersRuleExcludePathArrayOutput values.
// You can construct a concrete instance of `RuleAppliersRuleExcludePathArrayInput` via:
//
//	RuleAppliersRuleExcludePathArray{ RuleAppliersRuleExcludePathArgs{...} }
type RuleAppliersRuleExcludePathArrayInput interface {
	pulumi.Input

	ToRuleAppliersRuleExcludePathArrayOutput() RuleAppliersRuleExcludePathArrayOutput
	ToRuleAppliersRuleExcludePathArrayOutputWithContext(context.Context) RuleAppliersRuleExcludePathArrayOutput
}

type RuleAppliersRuleExcludePathArray []RuleAppliersRuleExcludePathInput

func (RuleAppliersRuleExcludePathArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleAppliersRuleExcludePath)(nil)).Elem()
}

func (i RuleAppliersRuleExcludePathArray) ToRuleAppliersRuleExcludePathArrayOutput() RuleAppliersRuleExcludePathArrayOutput {
	return i.ToRuleAppliersRuleExcludePathArrayOutputWithContext(context.Background())
}

func (i RuleAppliersRuleExcludePathArray) ToRuleAppliersRuleExcludePathArrayOutputWithContext(ctx context.Context) RuleAppliersRuleExcludePathArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleAppliersRuleExcludePathArrayOutput)
}

type RuleAppliersRuleExcludePathOutput struct{ *pulumi.OutputState }

func (RuleAppliersRuleExcludePathOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleAppliersRuleExcludePath)(nil)).Elem()
}

func (o RuleAppliersRuleExcludePathOutput) ToRuleAppliersRuleExcludePathOutput() RuleAppliersRuleExcludePathOutput {
	return o
}

func (o RuleAppliersRuleExcludePathOutput) ToRuleAppliersRuleExcludePathOutputWithContext(ctx context.Context) RuleAppliersRuleExcludePathOutput {
	return o
}

// The type of the log template.
func (o RuleAppliersRuleExcludePathOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v RuleAppliersRuleExcludePath) string { return v.Type }).(pulumi.StringOutput)
}

// Collection path.
func (o RuleAppliersRuleExcludePathOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v RuleAppliersRuleExcludePath) string { return v.Value }).(pulumi.StringOutput)
}

type RuleAppliersRuleExcludePathArrayOutput struct{ *pulumi.OutputState }

func (RuleAppliersRuleExcludePathArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleAppliersRuleExcludePath)(nil)).Elem()
}

func (o RuleAppliersRuleExcludePathArrayOutput) ToRuleAppliersRuleExcludePathArrayOutput() RuleAppliersRuleExcludePathArrayOutput {
	return o
}

func (o RuleAppliersRuleExcludePathArrayOutput) ToRuleAppliersRuleExcludePathArrayOutputWithContext(ctx context.Context) RuleAppliersRuleExcludePathArrayOutput {
	return o
}

func (o RuleAppliersRuleExcludePathArrayOutput) Index(i pulumi.IntInput) RuleAppliersRuleExcludePathOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RuleAppliersRuleExcludePath {
		return vs[0].([]RuleAppliersRuleExcludePath)[vs[1].(int)]
	}).(RuleAppliersRuleExcludePathOutput)
}

type RuleAppliersRuleExtractRule struct {
	// The first log line needs to match the regular expression.
	BeginRegex string `pulumi:"beginRegex"`
	// The delimiter of the log.
	Delimiter string `pulumi:"delimiter"`
	// The filter key list.
	FilterKeyRegexes []RuleAppliersRuleExtractRuleFilterKeyRegex `pulumi:"filterKeyRegexes"`
	// A list of field names. Log Service will parse the path sample (PathSample) into multiple fields according to the regular expression (Regex), and Keys is used to specify the field name of each field.
	Keys []string `pulumi:"keys"`
	// The entire log needs to match the regular expression.
	LogRegex string `pulumi:"logRegex"`
	// Automatically extract log fields according to the specified log template.
	LogTemplates []RuleAppliersRuleExtractRuleLogTemplate `pulumi:"logTemplates"`
	// Parsing format of the time field.
	TimeFormat string `pulumi:"timeFormat"`
	// The field name of the log time field.
	TimeKey string `pulumi:"timeKey"`
	// When uploading the failed log, the key name of the failed log.
	UnMatchLogKey string `pulumi:"unMatchLogKey"`
	// Whether to upload the log of parsing failure.
	UnMatchUpLoadSwitch bool `pulumi:"unMatchUpLoadSwitch"`
}

// RuleAppliersRuleExtractRuleInput is an input type that accepts RuleAppliersRuleExtractRuleArgs and RuleAppliersRuleExtractRuleOutput values.
// You can construct a concrete instance of `RuleAppliersRuleExtractRuleInput` via:
//
//	RuleAppliersRuleExtractRuleArgs{...}
type RuleAppliersRuleExtractRuleInput interface {
	pulumi.Input

	ToRuleAppliersRuleExtractRuleOutput() RuleAppliersRuleExtractRuleOutput
	ToRuleAppliersRuleExtractRuleOutputWithContext(context.Context) RuleAppliersRuleExtractRuleOutput
}

type RuleAppliersRuleExtractRuleArgs struct {
	// The first log line needs to match the regular expression.
	BeginRegex pulumi.StringInput `pulumi:"beginRegex"`
	// The delimiter of the log.
	Delimiter pulumi.StringInput `pulumi:"delimiter"`
	// The filter key list.
	FilterKeyRegexes RuleAppliersRuleExtractRuleFilterKeyRegexArrayInput `pulumi:"filterKeyRegexes"`
	// A list of field names. Log Service will parse the path sample (PathSample) into multiple fields according to the regular expression (Regex), and Keys is used to specify the field name of each field.
	Keys pulumi.StringArrayInput `pulumi:"keys"`
	// The entire log needs to match the regular expression.
	LogRegex pulumi.StringInput `pulumi:"logRegex"`
	// Automatically extract log fields according to the specified log template.
	LogTemplates RuleAppliersRuleExtractRuleLogTemplateArrayInput `pulumi:"logTemplates"`
	// Parsing format of the time field.
	TimeFormat pulumi.StringInput `pulumi:"timeFormat"`
	// The field name of the log time field.
	TimeKey pulumi.StringInput `pulumi:"timeKey"`
	// When uploading the failed log, the key name of the failed log.
	UnMatchLogKey pulumi.StringInput `pulumi:"unMatchLogKey"`
	// Whether to upload the log of parsing failure.
	UnMatchUpLoadSwitch pulumi.BoolInput `pulumi:"unMatchUpLoadSwitch"`
}

func (RuleAppliersRuleExtractRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleAppliersRuleExtractRule)(nil)).Elem()
}

func (i RuleAppliersRuleExtractRuleArgs) ToRuleAppliersRuleExtractRuleOutput() RuleAppliersRuleExtractRuleOutput {
	return i.ToRuleAppliersRuleExtractRuleOutputWithContext(context.Background())
}

func (i RuleAppliersRuleExtractRuleArgs) ToRuleAppliersRuleExtractRuleOutputWithContext(ctx context.Context) RuleAppliersRuleExtractRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleAppliersRuleExtractRuleOutput)
}

// RuleAppliersRuleExtractRuleArrayInput is an input type that accepts RuleAppliersRuleExtractRuleArray and RuleAppliersRuleExtractRuleArrayOutput values.
// You can construct a concrete instance of `RuleAppliersRuleExtractRuleArrayInput` via:
//
//	RuleAppliersRuleExtractRuleArray{ RuleAppliersRuleExtractRuleArgs{...} }
type RuleAppliersRuleExtractRuleArrayInput interface {
	pulumi.Input

	ToRuleAppliersRuleExtractRuleArrayOutput() RuleAppliersRuleExtractRuleArrayOutput
	ToRuleAppliersRuleExtractRuleArrayOutputWithContext(context.Context) RuleAppliersRuleExtractRuleArrayOutput
}

type RuleAppliersRuleExtractRuleArray []RuleAppliersRuleExtractRuleInput

func (RuleAppliersRuleExtractRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleAppliersRuleExtractRule)(nil)).Elem()
}

func (i RuleAppliersRuleExtractRuleArray) ToRuleAppliersRuleExtractRuleArrayOutput() RuleAppliersRuleExtractRuleArrayOutput {
	return i.ToRuleAppliersRuleExtractRuleArrayOutputWithContext(context.Background())
}

func (i RuleAppliersRuleExtractRuleArray) ToRuleAppliersRuleExtractRuleArrayOutputWithContext(ctx context.Context) RuleAppliersRuleExtractRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleAppliersRuleExtractRuleArrayOutput)
}

type RuleAppliersRuleExtractRuleOutput struct{ *pulumi.OutputState }

func (RuleAppliersRuleExtractRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleAppliersRuleExtractRule)(nil)).Elem()
}

func (o RuleAppliersRuleExtractRuleOutput) ToRuleAppliersRuleExtractRuleOutput() RuleAppliersRuleExtractRuleOutput {
	return o
}

func (o RuleAppliersRuleExtractRuleOutput) ToRuleAppliersRuleExtractRuleOutputWithContext(ctx context.Context) RuleAppliersRuleExtractRuleOutput {
	return o
}

// The first log line needs to match the regular expression.
func (o RuleAppliersRuleExtractRuleOutput) BeginRegex() pulumi.StringOutput {
	return o.ApplyT(func(v RuleAppliersRuleExtractRule) string { return v.BeginRegex }).(pulumi.StringOutput)
}

// The delimiter of the log.
func (o RuleAppliersRuleExtractRuleOutput) Delimiter() pulumi.StringOutput {
	return o.ApplyT(func(v RuleAppliersRuleExtractRule) string { return v.Delimiter }).(pulumi.StringOutput)
}

// The filter key list.
func (o RuleAppliersRuleExtractRuleOutput) FilterKeyRegexes() RuleAppliersRuleExtractRuleFilterKeyRegexArrayOutput {
	return o.ApplyT(func(v RuleAppliersRuleExtractRule) []RuleAppliersRuleExtractRuleFilterKeyRegex {
		return v.FilterKeyRegexes
	}).(RuleAppliersRuleExtractRuleFilterKeyRegexArrayOutput)
}

// A list of field names. Log Service will parse the path sample (PathSample) into multiple fields according to the regular expression (Regex), and Keys is used to specify the field name of each field.
func (o RuleAppliersRuleExtractRuleOutput) Keys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v RuleAppliersRuleExtractRule) []string { return v.Keys }).(pulumi.StringArrayOutput)
}

// The entire log needs to match the regular expression.
func (o RuleAppliersRuleExtractRuleOutput) LogRegex() pulumi.StringOutput {
	return o.ApplyT(func(v RuleAppliersRuleExtractRule) string { return v.LogRegex }).(pulumi.StringOutput)
}

// Automatically extract log fields according to the specified log template.
func (o RuleAppliersRuleExtractRuleOutput) LogTemplates() RuleAppliersRuleExtractRuleLogTemplateArrayOutput {
	return o.ApplyT(func(v RuleAppliersRuleExtractRule) []RuleAppliersRuleExtractRuleLogTemplate { return v.LogTemplates }).(RuleAppliersRuleExtractRuleLogTemplateArrayOutput)
}

// Parsing format of the time field.
func (o RuleAppliersRuleExtractRuleOutput) TimeFormat() pulumi.StringOutput {
	return o.ApplyT(func(v RuleAppliersRuleExtractRule) string { return v.TimeFormat }).(pulumi.StringOutput)
}

// The field name of the log time field.
func (o RuleAppliersRuleExtractRuleOutput) TimeKey() pulumi.StringOutput {
	return o.ApplyT(func(v RuleAppliersRuleExtractRule) string { return v.TimeKey }).(pulumi.StringOutput)
}

// When uploading the failed log, the key name of the failed log.
func (o RuleAppliersRuleExtractRuleOutput) UnMatchLogKey() pulumi.StringOutput {
	return o.ApplyT(func(v RuleAppliersRuleExtractRule) string { return v.UnMatchLogKey }).(pulumi.StringOutput)
}

// Whether to upload the log of parsing failure.
func (o RuleAppliersRuleExtractRuleOutput) UnMatchUpLoadSwitch() pulumi.BoolOutput {
	return o.ApplyT(func(v RuleAppliersRuleExtractRule) bool { return v.UnMatchUpLoadSwitch }).(pulumi.BoolOutput)
}

type RuleAppliersRuleExtractRuleArrayOutput struct{ *pulumi.OutputState }

func (RuleAppliersRuleExtractRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleAppliersRuleExtractRule)(nil)).Elem()
}

func (o RuleAppliersRuleExtractRuleArrayOutput) ToRuleAppliersRuleExtractRuleArrayOutput() RuleAppliersRuleExtractRuleArrayOutput {
	return o
}

func (o RuleAppliersRuleExtractRuleArrayOutput) ToRuleAppliersRuleExtractRuleArrayOutputWithContext(ctx context.Context) RuleAppliersRuleExtractRuleArrayOutput {
	return o
}

func (o RuleAppliersRuleExtractRuleArrayOutput) Index(i pulumi.IntInput) RuleAppliersRuleExtractRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RuleAppliersRuleExtractRule {
		return vs[0].([]RuleAppliersRuleExtractRule)[vs[1].(int)]
	}).(RuleAppliersRuleExtractRuleOutput)
}

type RuleAppliersRuleExtractRuleFilterKeyRegex struct {
	// The name of the filter key.
	Key string `pulumi:"key"`
	// Regular expression for extracting path fields. It must match the collection path sample, otherwise it cannot be extracted successfully.
	Regex string `pulumi:"regex"`
}

// RuleAppliersRuleExtractRuleFilterKeyRegexInput is an input type that accepts RuleAppliersRuleExtractRuleFilterKeyRegexArgs and RuleAppliersRuleExtractRuleFilterKeyRegexOutput values.
// You can construct a concrete instance of `RuleAppliersRuleExtractRuleFilterKeyRegexInput` via:
//
//	RuleAppliersRuleExtractRuleFilterKeyRegexArgs{...}
type RuleAppliersRuleExtractRuleFilterKeyRegexInput interface {
	pulumi.Input

	ToRuleAppliersRuleExtractRuleFilterKeyRegexOutput() RuleAppliersRuleExtractRuleFilterKeyRegexOutput
	ToRuleAppliersRuleExtractRuleFilterKeyRegexOutputWithContext(context.Context) RuleAppliersRuleExtractRuleFilterKeyRegexOutput
}

type RuleAppliersRuleExtractRuleFilterKeyRegexArgs struct {
	// The name of the filter key.
	Key pulumi.StringInput `pulumi:"key"`
	// Regular expression for extracting path fields. It must match the collection path sample, otherwise it cannot be extracted successfully.
	Regex pulumi.StringInput `pulumi:"regex"`
}

func (RuleAppliersRuleExtractRuleFilterKeyRegexArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleAppliersRuleExtractRuleFilterKeyRegex)(nil)).Elem()
}

func (i RuleAppliersRuleExtractRuleFilterKeyRegexArgs) ToRuleAppliersRuleExtractRuleFilterKeyRegexOutput() RuleAppliersRuleExtractRuleFilterKeyRegexOutput {
	return i.ToRuleAppliersRuleExtractRuleFilterKeyRegexOutputWithContext(context.Background())
}

func (i RuleAppliersRuleExtractRuleFilterKeyRegexArgs) ToRuleAppliersRuleExtractRuleFilterKeyRegexOutputWithContext(ctx context.Context) RuleAppliersRuleExtractRuleFilterKeyRegexOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleAppliersRuleExtractRuleFilterKeyRegexOutput)
}

// RuleAppliersRuleExtractRuleFilterKeyRegexArrayInput is an input type that accepts RuleAppliersRuleExtractRuleFilterKeyRegexArray and RuleAppliersRuleExtractRuleFilterKeyRegexArrayOutput values.
// You can construct a concrete instance of `RuleAppliersRuleExtractRuleFilterKeyRegexArrayInput` via:
//
//	RuleAppliersRuleExtractRuleFilterKeyRegexArray{ RuleAppliersRuleExtractRuleFilterKeyRegexArgs{...} }
type RuleAppliersRuleExtractRuleFilterKeyRegexArrayInput interface {
	pulumi.Input

	ToRuleAppliersRuleExtractRuleFilterKeyRegexArrayOutput() RuleAppliersRuleExtractRuleFilterKeyRegexArrayOutput
	ToRuleAppliersRuleExtractRuleFilterKeyRegexArrayOutputWithContext(context.Context) RuleAppliersRuleExtractRuleFilterKeyRegexArrayOutput
}

type RuleAppliersRuleExtractRuleFilterKeyRegexArray []RuleAppliersRuleExtractRuleFilterKeyRegexInput

func (RuleAppliersRuleExtractRuleFilterKeyRegexArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleAppliersRuleExtractRuleFilterKeyRegex)(nil)).Elem()
}

func (i RuleAppliersRuleExtractRuleFilterKeyRegexArray) ToRuleAppliersRuleExtractRuleFilterKeyRegexArrayOutput() RuleAppliersRuleExtractRuleFilterKeyRegexArrayOutput {
	return i.ToRuleAppliersRuleExtractRuleFilterKeyRegexArrayOutputWithContext(context.Background())
}

func (i RuleAppliersRuleExtractRuleFilterKeyRegexArray) ToRuleAppliersRuleExtractRuleFilterKeyRegexArrayOutputWithContext(ctx context.Context) RuleAppliersRuleExtractRuleFilterKeyRegexArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleAppliersRuleExtractRuleFilterKeyRegexArrayOutput)
}

type RuleAppliersRuleExtractRuleFilterKeyRegexOutput struct{ *pulumi.OutputState }

func (RuleAppliersRuleExtractRuleFilterKeyRegexOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleAppliersRuleExtractRuleFilterKeyRegex)(nil)).Elem()
}

func (o RuleAppliersRuleExtractRuleFilterKeyRegexOutput) ToRuleAppliersRuleExtractRuleFilterKeyRegexOutput() RuleAppliersRuleExtractRuleFilterKeyRegexOutput {
	return o
}

func (o RuleAppliersRuleExtractRuleFilterKeyRegexOutput) ToRuleAppliersRuleExtractRuleFilterKeyRegexOutputWithContext(ctx context.Context) RuleAppliersRuleExtractRuleFilterKeyRegexOutput {
	return o
}

// The name of the filter key.
func (o RuleAppliersRuleExtractRuleFilterKeyRegexOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v RuleAppliersRuleExtractRuleFilterKeyRegex) string { return v.Key }).(pulumi.StringOutput)
}

// Regular expression for extracting path fields. It must match the collection path sample, otherwise it cannot be extracted successfully.
func (o RuleAppliersRuleExtractRuleFilterKeyRegexOutput) Regex() pulumi.StringOutput {
	return o.ApplyT(func(v RuleAppliersRuleExtractRuleFilterKeyRegex) string { return v.Regex }).(pulumi.StringOutput)
}

type RuleAppliersRuleExtractRuleFilterKeyRegexArrayOutput struct{ *pulumi.OutputState }

func (RuleAppliersRuleExtractRuleFilterKeyRegexArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleAppliersRuleExtractRuleFilterKeyRegex)(nil)).Elem()
}

func (o RuleAppliersRuleExtractRuleFilterKeyRegexArrayOutput) ToRuleAppliersRuleExtractRuleFilterKeyRegexArrayOutput() RuleAppliersRuleExtractRuleFilterKeyRegexArrayOutput {
	return o
}

func (o RuleAppliersRuleExtractRuleFilterKeyRegexArrayOutput) ToRuleAppliersRuleExtractRuleFilterKeyRegexArrayOutputWithContext(ctx context.Context) RuleAppliersRuleExtractRuleFilterKeyRegexArrayOutput {
	return o
}

func (o RuleAppliersRuleExtractRuleFilterKeyRegexArrayOutput) Index(i pulumi.IntInput) RuleAppliersRuleExtractRuleFilterKeyRegexOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RuleAppliersRuleExtractRuleFilterKeyRegex {
		return vs[0].([]RuleAppliersRuleExtractRuleFilterKeyRegex)[vs[1].(int)]
	}).(RuleAppliersRuleExtractRuleFilterKeyRegexOutput)
}

type RuleAppliersRuleExtractRuleLogTemplate struct {
	// Log template content.
	Format string `pulumi:"format"`
	// The type of the log template.
	Type string `pulumi:"type"`
}

// RuleAppliersRuleExtractRuleLogTemplateInput is an input type that accepts RuleAppliersRuleExtractRuleLogTemplateArgs and RuleAppliersRuleExtractRuleLogTemplateOutput values.
// You can construct a concrete instance of `RuleAppliersRuleExtractRuleLogTemplateInput` via:
//
//	RuleAppliersRuleExtractRuleLogTemplateArgs{...}
type RuleAppliersRuleExtractRuleLogTemplateInput interface {
	pulumi.Input

	ToRuleAppliersRuleExtractRuleLogTemplateOutput() RuleAppliersRuleExtractRuleLogTemplateOutput
	ToRuleAppliersRuleExtractRuleLogTemplateOutputWithContext(context.Context) RuleAppliersRuleExtractRuleLogTemplateOutput
}

type RuleAppliersRuleExtractRuleLogTemplateArgs struct {
	// Log template content.
	Format pulumi.StringInput `pulumi:"format"`
	// The type of the log template.
	Type pulumi.StringInput `pulumi:"type"`
}

func (RuleAppliersRuleExtractRuleLogTemplateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleAppliersRuleExtractRuleLogTemplate)(nil)).Elem()
}

func (i RuleAppliersRuleExtractRuleLogTemplateArgs) ToRuleAppliersRuleExtractRuleLogTemplateOutput() RuleAppliersRuleExtractRuleLogTemplateOutput {
	return i.ToRuleAppliersRuleExtractRuleLogTemplateOutputWithContext(context.Background())
}

func (i RuleAppliersRuleExtractRuleLogTemplateArgs) ToRuleAppliersRuleExtractRuleLogTemplateOutputWithContext(ctx context.Context) RuleAppliersRuleExtractRuleLogTemplateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleAppliersRuleExtractRuleLogTemplateOutput)
}

// RuleAppliersRuleExtractRuleLogTemplateArrayInput is an input type that accepts RuleAppliersRuleExtractRuleLogTemplateArray and RuleAppliersRuleExtractRuleLogTemplateArrayOutput values.
// You can construct a concrete instance of `RuleAppliersRuleExtractRuleLogTemplateArrayInput` via:
//
//	RuleAppliersRuleExtractRuleLogTemplateArray{ RuleAppliersRuleExtractRuleLogTemplateArgs{...} }
type RuleAppliersRuleExtractRuleLogTemplateArrayInput interface {
	pulumi.Input

	ToRuleAppliersRuleExtractRuleLogTemplateArrayOutput() RuleAppliersRuleExtractRuleLogTemplateArrayOutput
	ToRuleAppliersRuleExtractRuleLogTemplateArrayOutputWithContext(context.Context) RuleAppliersRuleExtractRuleLogTemplateArrayOutput
}

type RuleAppliersRuleExtractRuleLogTemplateArray []RuleAppliersRuleExtractRuleLogTemplateInput

func (RuleAppliersRuleExtractRuleLogTemplateArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleAppliersRuleExtractRuleLogTemplate)(nil)).Elem()
}

func (i RuleAppliersRuleExtractRuleLogTemplateArray) ToRuleAppliersRuleExtractRuleLogTemplateArrayOutput() RuleAppliersRuleExtractRuleLogTemplateArrayOutput {
	return i.ToRuleAppliersRuleExtractRuleLogTemplateArrayOutputWithContext(context.Background())
}

func (i RuleAppliersRuleExtractRuleLogTemplateArray) ToRuleAppliersRuleExtractRuleLogTemplateArrayOutputWithContext(ctx context.Context) RuleAppliersRuleExtractRuleLogTemplateArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleAppliersRuleExtractRuleLogTemplateArrayOutput)
}

type RuleAppliersRuleExtractRuleLogTemplateOutput struct{ *pulumi.OutputState }

func (RuleAppliersRuleExtractRuleLogTemplateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleAppliersRuleExtractRuleLogTemplate)(nil)).Elem()
}

func (o RuleAppliersRuleExtractRuleLogTemplateOutput) ToRuleAppliersRuleExtractRuleLogTemplateOutput() RuleAppliersRuleExtractRuleLogTemplateOutput {
	return o
}

func (o RuleAppliersRuleExtractRuleLogTemplateOutput) ToRuleAppliersRuleExtractRuleLogTemplateOutputWithContext(ctx context.Context) RuleAppliersRuleExtractRuleLogTemplateOutput {
	return o
}

// Log template content.
func (o RuleAppliersRuleExtractRuleLogTemplateOutput) Format() pulumi.StringOutput {
	return o.ApplyT(func(v RuleAppliersRuleExtractRuleLogTemplate) string { return v.Format }).(pulumi.StringOutput)
}

// The type of the log template.
func (o RuleAppliersRuleExtractRuleLogTemplateOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v RuleAppliersRuleExtractRuleLogTemplate) string { return v.Type }).(pulumi.StringOutput)
}

type RuleAppliersRuleExtractRuleLogTemplateArrayOutput struct{ *pulumi.OutputState }

func (RuleAppliersRuleExtractRuleLogTemplateArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleAppliersRuleExtractRuleLogTemplate)(nil)).Elem()
}

func (o RuleAppliersRuleExtractRuleLogTemplateArrayOutput) ToRuleAppliersRuleExtractRuleLogTemplateArrayOutput() RuleAppliersRuleExtractRuleLogTemplateArrayOutput {
	return o
}

func (o RuleAppliersRuleExtractRuleLogTemplateArrayOutput) ToRuleAppliersRuleExtractRuleLogTemplateArrayOutputWithContext(ctx context.Context) RuleAppliersRuleExtractRuleLogTemplateArrayOutput {
	return o
}

func (o RuleAppliersRuleExtractRuleLogTemplateArrayOutput) Index(i pulumi.IntInput) RuleAppliersRuleExtractRuleLogTemplateOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RuleAppliersRuleExtractRuleLogTemplate {
		return vs[0].([]RuleAppliersRuleExtractRuleLogTemplate)[vs[1].(int)]
	}).(RuleAppliersRuleExtractRuleLogTemplateOutput)
}

type RuleAppliersRuleUserDefineRule struct {
	// LogCollector extension configuration.
	Advanceds []RuleAppliersRuleUserDefineRuleAdvanced `pulumi:"advanceds"`
	// Whether to upload raw logs.
	EnableRawLog bool `pulumi:"enableRawLog"`
	// Add constant fields to logs.
	Fields map[string]interface{} `pulumi:"fields"`
	// Rules for parsing collection paths. After the rules are set, the fields in the collection path will be extracted through the regular expressions specified in the rules, and added to the log data as metadata.
	ParsePathRules []RuleAppliersRuleUserDefineRuleParsePathRule `pulumi:"parsePathRules"`
	// Plugin configuration. After the plugin configuration is enabled, one or more LogCollector processor plugins can be added to parse logs with complex or variable structures.
	Plugins []RuleAppliersRuleUserDefineRulePlugin `pulumi:"plugins"`
	// Rules for routing log partitions. Setting this parameter indicates that the HashKey routing shard mode is used when collecting logs, and Log Service will write the data to the shard containing the specified Key value.
	ShardHashKeys []RuleAppliersRuleUserDefineRuleShardHashKey `pulumi:"shardHashKeys"`
	// LogCollector collection strategy, which specifies whether LogCollector collects incremental logs or full logs. The default is false, which means to collect all logs.
	TailFiles bool `pulumi:"tailFiles"`
}

// RuleAppliersRuleUserDefineRuleInput is an input type that accepts RuleAppliersRuleUserDefineRuleArgs and RuleAppliersRuleUserDefineRuleOutput values.
// You can construct a concrete instance of `RuleAppliersRuleUserDefineRuleInput` via:
//
//	RuleAppliersRuleUserDefineRuleArgs{...}
type RuleAppliersRuleUserDefineRuleInput interface {
	pulumi.Input

	ToRuleAppliersRuleUserDefineRuleOutput() RuleAppliersRuleUserDefineRuleOutput
	ToRuleAppliersRuleUserDefineRuleOutputWithContext(context.Context) RuleAppliersRuleUserDefineRuleOutput
}

type RuleAppliersRuleUserDefineRuleArgs struct {
	// LogCollector extension configuration.
	Advanceds RuleAppliersRuleUserDefineRuleAdvancedArrayInput `pulumi:"advanceds"`
	// Whether to upload raw logs.
	EnableRawLog pulumi.BoolInput `pulumi:"enableRawLog"`
	// Add constant fields to logs.
	Fields pulumi.MapInput `pulumi:"fields"`
	// Rules for parsing collection paths. After the rules are set, the fields in the collection path will be extracted through the regular expressions specified in the rules, and added to the log data as metadata.
	ParsePathRules RuleAppliersRuleUserDefineRuleParsePathRuleArrayInput `pulumi:"parsePathRules"`
	// Plugin configuration. After the plugin configuration is enabled, one or more LogCollector processor plugins can be added to parse logs with complex or variable structures.
	Plugins RuleAppliersRuleUserDefineRulePluginArrayInput `pulumi:"plugins"`
	// Rules for routing log partitions. Setting this parameter indicates that the HashKey routing shard mode is used when collecting logs, and Log Service will write the data to the shard containing the specified Key value.
	ShardHashKeys RuleAppliersRuleUserDefineRuleShardHashKeyArrayInput `pulumi:"shardHashKeys"`
	// LogCollector collection strategy, which specifies whether LogCollector collects incremental logs or full logs. The default is false, which means to collect all logs.
	TailFiles pulumi.BoolInput `pulumi:"tailFiles"`
}

func (RuleAppliersRuleUserDefineRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleAppliersRuleUserDefineRule)(nil)).Elem()
}

func (i RuleAppliersRuleUserDefineRuleArgs) ToRuleAppliersRuleUserDefineRuleOutput() RuleAppliersRuleUserDefineRuleOutput {
	return i.ToRuleAppliersRuleUserDefineRuleOutputWithContext(context.Background())
}

func (i RuleAppliersRuleUserDefineRuleArgs) ToRuleAppliersRuleUserDefineRuleOutputWithContext(ctx context.Context) RuleAppliersRuleUserDefineRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleAppliersRuleUserDefineRuleOutput)
}

// RuleAppliersRuleUserDefineRuleArrayInput is an input type that accepts RuleAppliersRuleUserDefineRuleArray and RuleAppliersRuleUserDefineRuleArrayOutput values.
// You can construct a concrete instance of `RuleAppliersRuleUserDefineRuleArrayInput` via:
//
//	RuleAppliersRuleUserDefineRuleArray{ RuleAppliersRuleUserDefineRuleArgs{...} }
type RuleAppliersRuleUserDefineRuleArrayInput interface {
	pulumi.Input

	ToRuleAppliersRuleUserDefineRuleArrayOutput() RuleAppliersRuleUserDefineRuleArrayOutput
	ToRuleAppliersRuleUserDefineRuleArrayOutputWithContext(context.Context) RuleAppliersRuleUserDefineRuleArrayOutput
}

type RuleAppliersRuleUserDefineRuleArray []RuleAppliersRuleUserDefineRuleInput

func (RuleAppliersRuleUserDefineRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleAppliersRuleUserDefineRule)(nil)).Elem()
}

func (i RuleAppliersRuleUserDefineRuleArray) ToRuleAppliersRuleUserDefineRuleArrayOutput() RuleAppliersRuleUserDefineRuleArrayOutput {
	return i.ToRuleAppliersRuleUserDefineRuleArrayOutputWithContext(context.Background())
}

func (i RuleAppliersRuleUserDefineRuleArray) ToRuleAppliersRuleUserDefineRuleArrayOutputWithContext(ctx context.Context) RuleAppliersRuleUserDefineRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleAppliersRuleUserDefineRuleArrayOutput)
}

type RuleAppliersRuleUserDefineRuleOutput struct{ *pulumi.OutputState }

func (RuleAppliersRuleUserDefineRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleAppliersRuleUserDefineRule)(nil)).Elem()
}

func (o RuleAppliersRuleUserDefineRuleOutput) ToRuleAppliersRuleUserDefineRuleOutput() RuleAppliersRuleUserDefineRuleOutput {
	return o
}

func (o RuleAppliersRuleUserDefineRuleOutput) ToRuleAppliersRuleUserDefineRuleOutputWithContext(ctx context.Context) RuleAppliersRuleUserDefineRuleOutput {
	return o
}

// LogCollector extension configuration.
func (o RuleAppliersRuleUserDefineRuleOutput) Advanceds() RuleAppliersRuleUserDefineRuleAdvancedArrayOutput {
	return o.ApplyT(func(v RuleAppliersRuleUserDefineRule) []RuleAppliersRuleUserDefineRuleAdvanced { return v.Advanceds }).(RuleAppliersRuleUserDefineRuleAdvancedArrayOutput)
}

// Whether to upload raw logs.
func (o RuleAppliersRuleUserDefineRuleOutput) EnableRawLog() pulumi.BoolOutput {
	return o.ApplyT(func(v RuleAppliersRuleUserDefineRule) bool { return v.EnableRawLog }).(pulumi.BoolOutput)
}

// Add constant fields to logs.
func (o RuleAppliersRuleUserDefineRuleOutput) Fields() pulumi.MapOutput {
	return o.ApplyT(func(v RuleAppliersRuleUserDefineRule) map[string]interface{} { return v.Fields }).(pulumi.MapOutput)
}

// Rules for parsing collection paths. After the rules are set, the fields in the collection path will be extracted through the regular expressions specified in the rules, and added to the log data as metadata.
func (o RuleAppliersRuleUserDefineRuleOutput) ParsePathRules() RuleAppliersRuleUserDefineRuleParsePathRuleArrayOutput {
	return o.ApplyT(func(v RuleAppliersRuleUserDefineRule) []RuleAppliersRuleUserDefineRuleParsePathRule {
		return v.ParsePathRules
	}).(RuleAppliersRuleUserDefineRuleParsePathRuleArrayOutput)
}

// Plugin configuration. After the plugin configuration is enabled, one or more LogCollector processor plugins can be added to parse logs with complex or variable structures.
func (o RuleAppliersRuleUserDefineRuleOutput) Plugins() RuleAppliersRuleUserDefineRulePluginArrayOutput {
	return o.ApplyT(func(v RuleAppliersRuleUserDefineRule) []RuleAppliersRuleUserDefineRulePlugin { return v.Plugins }).(RuleAppliersRuleUserDefineRulePluginArrayOutput)
}

// Rules for routing log partitions. Setting this parameter indicates that the HashKey routing shard mode is used when collecting logs, and Log Service will write the data to the shard containing the specified Key value.
func (o RuleAppliersRuleUserDefineRuleOutput) ShardHashKeys() RuleAppliersRuleUserDefineRuleShardHashKeyArrayOutput {
	return o.ApplyT(func(v RuleAppliersRuleUserDefineRule) []RuleAppliersRuleUserDefineRuleShardHashKey {
		return v.ShardHashKeys
	}).(RuleAppliersRuleUserDefineRuleShardHashKeyArrayOutput)
}

// LogCollector collection strategy, which specifies whether LogCollector collects incremental logs or full logs. The default is false, which means to collect all logs.
func (o RuleAppliersRuleUserDefineRuleOutput) TailFiles() pulumi.BoolOutput {
	return o.ApplyT(func(v RuleAppliersRuleUserDefineRule) bool { return v.TailFiles }).(pulumi.BoolOutput)
}

type RuleAppliersRuleUserDefineRuleArrayOutput struct{ *pulumi.OutputState }

func (RuleAppliersRuleUserDefineRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleAppliersRuleUserDefineRule)(nil)).Elem()
}

func (o RuleAppliersRuleUserDefineRuleArrayOutput) ToRuleAppliersRuleUserDefineRuleArrayOutput() RuleAppliersRuleUserDefineRuleArrayOutput {
	return o
}

func (o RuleAppliersRuleUserDefineRuleArrayOutput) ToRuleAppliersRuleUserDefineRuleArrayOutputWithContext(ctx context.Context) RuleAppliersRuleUserDefineRuleArrayOutput {
	return o
}

func (o RuleAppliersRuleUserDefineRuleArrayOutput) Index(i pulumi.IntInput) RuleAppliersRuleUserDefineRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RuleAppliersRuleUserDefineRule {
		return vs[0].([]RuleAppliersRuleUserDefineRule)[vs[1].(int)]
	}).(RuleAppliersRuleUserDefineRuleOutput)
}

type RuleAppliersRuleUserDefineRuleAdvanced struct {
	// Whether to release the log file handle after reading to the end of the log file. The default is false.
	CloseEof bool `pulumi:"closeEof"`
	// The wait time to release the log file handle. When the log file has not written a new log for more than the specified time, release the handle of the log file.
	CloseInactive int `pulumi:"closeInactive"`
	// After the log file is removed, whether to release the handle of the log file. The default is false.
	CloseRemoved bool `pulumi:"closeRemoved"`
	// After the log file is renamed, whether to release the handle of the log file. The default is false.
	CloseRenamed bool `pulumi:"closeRenamed"`
	// The maximum length of time that LogCollector monitors log files. The unit is seconds, and the default is 0 seconds, which means that there is no limit to the length of time LogCollector monitors log files.
	CloseTimeout int `pulumi:"closeTimeout"`
}

// RuleAppliersRuleUserDefineRuleAdvancedInput is an input type that accepts RuleAppliersRuleUserDefineRuleAdvancedArgs and RuleAppliersRuleUserDefineRuleAdvancedOutput values.
// You can construct a concrete instance of `RuleAppliersRuleUserDefineRuleAdvancedInput` via:
//
//	RuleAppliersRuleUserDefineRuleAdvancedArgs{...}
type RuleAppliersRuleUserDefineRuleAdvancedInput interface {
	pulumi.Input

	ToRuleAppliersRuleUserDefineRuleAdvancedOutput() RuleAppliersRuleUserDefineRuleAdvancedOutput
	ToRuleAppliersRuleUserDefineRuleAdvancedOutputWithContext(context.Context) RuleAppliersRuleUserDefineRuleAdvancedOutput
}

type RuleAppliersRuleUserDefineRuleAdvancedArgs struct {
	// Whether to release the log file handle after reading to the end of the log file. The default is false.
	CloseEof pulumi.BoolInput `pulumi:"closeEof"`
	// The wait time to release the log file handle. When the log file has not written a new log for more than the specified time, release the handle of the log file.
	CloseInactive pulumi.IntInput `pulumi:"closeInactive"`
	// After the log file is removed, whether to release the handle of the log file. The default is false.
	CloseRemoved pulumi.BoolInput `pulumi:"closeRemoved"`
	// After the log file is renamed, whether to release the handle of the log file. The default is false.
	CloseRenamed pulumi.BoolInput `pulumi:"closeRenamed"`
	// The maximum length of time that LogCollector monitors log files. The unit is seconds, and the default is 0 seconds, which means that there is no limit to the length of time LogCollector monitors log files.
	CloseTimeout pulumi.IntInput `pulumi:"closeTimeout"`
}

func (RuleAppliersRuleUserDefineRuleAdvancedArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleAppliersRuleUserDefineRuleAdvanced)(nil)).Elem()
}

func (i RuleAppliersRuleUserDefineRuleAdvancedArgs) ToRuleAppliersRuleUserDefineRuleAdvancedOutput() RuleAppliersRuleUserDefineRuleAdvancedOutput {
	return i.ToRuleAppliersRuleUserDefineRuleAdvancedOutputWithContext(context.Background())
}

func (i RuleAppliersRuleUserDefineRuleAdvancedArgs) ToRuleAppliersRuleUserDefineRuleAdvancedOutputWithContext(ctx context.Context) RuleAppliersRuleUserDefineRuleAdvancedOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleAppliersRuleUserDefineRuleAdvancedOutput)
}

// RuleAppliersRuleUserDefineRuleAdvancedArrayInput is an input type that accepts RuleAppliersRuleUserDefineRuleAdvancedArray and RuleAppliersRuleUserDefineRuleAdvancedArrayOutput values.
// You can construct a concrete instance of `RuleAppliersRuleUserDefineRuleAdvancedArrayInput` via:
//
//	RuleAppliersRuleUserDefineRuleAdvancedArray{ RuleAppliersRuleUserDefineRuleAdvancedArgs{...} }
type RuleAppliersRuleUserDefineRuleAdvancedArrayInput interface {
	pulumi.Input

	ToRuleAppliersRuleUserDefineRuleAdvancedArrayOutput() RuleAppliersRuleUserDefineRuleAdvancedArrayOutput
	ToRuleAppliersRuleUserDefineRuleAdvancedArrayOutputWithContext(context.Context) RuleAppliersRuleUserDefineRuleAdvancedArrayOutput
}

type RuleAppliersRuleUserDefineRuleAdvancedArray []RuleAppliersRuleUserDefineRuleAdvancedInput

func (RuleAppliersRuleUserDefineRuleAdvancedArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleAppliersRuleUserDefineRuleAdvanced)(nil)).Elem()
}

func (i RuleAppliersRuleUserDefineRuleAdvancedArray) ToRuleAppliersRuleUserDefineRuleAdvancedArrayOutput() RuleAppliersRuleUserDefineRuleAdvancedArrayOutput {
	return i.ToRuleAppliersRuleUserDefineRuleAdvancedArrayOutputWithContext(context.Background())
}

func (i RuleAppliersRuleUserDefineRuleAdvancedArray) ToRuleAppliersRuleUserDefineRuleAdvancedArrayOutputWithContext(ctx context.Context) RuleAppliersRuleUserDefineRuleAdvancedArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleAppliersRuleUserDefineRuleAdvancedArrayOutput)
}

type RuleAppliersRuleUserDefineRuleAdvancedOutput struct{ *pulumi.OutputState }

func (RuleAppliersRuleUserDefineRuleAdvancedOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleAppliersRuleUserDefineRuleAdvanced)(nil)).Elem()
}

func (o RuleAppliersRuleUserDefineRuleAdvancedOutput) ToRuleAppliersRuleUserDefineRuleAdvancedOutput() RuleAppliersRuleUserDefineRuleAdvancedOutput {
	return o
}

func (o RuleAppliersRuleUserDefineRuleAdvancedOutput) ToRuleAppliersRuleUserDefineRuleAdvancedOutputWithContext(ctx context.Context) RuleAppliersRuleUserDefineRuleAdvancedOutput {
	return o
}

// Whether to release the log file handle after reading to the end of the log file. The default is false.
func (o RuleAppliersRuleUserDefineRuleAdvancedOutput) CloseEof() pulumi.BoolOutput {
	return o.ApplyT(func(v RuleAppliersRuleUserDefineRuleAdvanced) bool { return v.CloseEof }).(pulumi.BoolOutput)
}

// The wait time to release the log file handle. When the log file has not written a new log for more than the specified time, release the handle of the log file.
func (o RuleAppliersRuleUserDefineRuleAdvancedOutput) CloseInactive() pulumi.IntOutput {
	return o.ApplyT(func(v RuleAppliersRuleUserDefineRuleAdvanced) int { return v.CloseInactive }).(pulumi.IntOutput)
}

// After the log file is removed, whether to release the handle of the log file. The default is false.
func (o RuleAppliersRuleUserDefineRuleAdvancedOutput) CloseRemoved() pulumi.BoolOutput {
	return o.ApplyT(func(v RuleAppliersRuleUserDefineRuleAdvanced) bool { return v.CloseRemoved }).(pulumi.BoolOutput)
}

// After the log file is renamed, whether to release the handle of the log file. The default is false.
func (o RuleAppliersRuleUserDefineRuleAdvancedOutput) CloseRenamed() pulumi.BoolOutput {
	return o.ApplyT(func(v RuleAppliersRuleUserDefineRuleAdvanced) bool { return v.CloseRenamed }).(pulumi.BoolOutput)
}

// The maximum length of time that LogCollector monitors log files. The unit is seconds, and the default is 0 seconds, which means that there is no limit to the length of time LogCollector monitors log files.
func (o RuleAppliersRuleUserDefineRuleAdvancedOutput) CloseTimeout() pulumi.IntOutput {
	return o.ApplyT(func(v RuleAppliersRuleUserDefineRuleAdvanced) int { return v.CloseTimeout }).(pulumi.IntOutput)
}

type RuleAppliersRuleUserDefineRuleAdvancedArrayOutput struct{ *pulumi.OutputState }

func (RuleAppliersRuleUserDefineRuleAdvancedArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleAppliersRuleUserDefineRuleAdvanced)(nil)).Elem()
}

func (o RuleAppliersRuleUserDefineRuleAdvancedArrayOutput) ToRuleAppliersRuleUserDefineRuleAdvancedArrayOutput() RuleAppliersRuleUserDefineRuleAdvancedArrayOutput {
	return o
}

func (o RuleAppliersRuleUserDefineRuleAdvancedArrayOutput) ToRuleAppliersRuleUserDefineRuleAdvancedArrayOutputWithContext(ctx context.Context) RuleAppliersRuleUserDefineRuleAdvancedArrayOutput {
	return o
}

func (o RuleAppliersRuleUserDefineRuleAdvancedArrayOutput) Index(i pulumi.IntInput) RuleAppliersRuleUserDefineRuleAdvancedOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RuleAppliersRuleUserDefineRuleAdvanced {
		return vs[0].([]RuleAppliersRuleUserDefineRuleAdvanced)[vs[1].(int)]
	}).(RuleAppliersRuleUserDefineRuleAdvancedOutput)
}

type RuleAppliersRuleUserDefineRuleParsePathRule struct {
	// A list of field names. Log Service will parse the path sample (PathSample) into multiple fields according to the regular expression (Regex), and Keys is used to specify the field name of each field.
	Keys []string `pulumi:"keys"`
	// Sample capture path for a real scene.
	PathSample string `pulumi:"pathSample"`
	// Regular expression for extracting path fields. It must match the collection path sample, otherwise it cannot be extracted successfully.
	Regex string `pulumi:"regex"`
}

// RuleAppliersRuleUserDefineRuleParsePathRuleInput is an input type that accepts RuleAppliersRuleUserDefineRuleParsePathRuleArgs and RuleAppliersRuleUserDefineRuleParsePathRuleOutput values.
// You can construct a concrete instance of `RuleAppliersRuleUserDefineRuleParsePathRuleInput` via:
//
//	RuleAppliersRuleUserDefineRuleParsePathRuleArgs{...}
type RuleAppliersRuleUserDefineRuleParsePathRuleInput interface {
	pulumi.Input

	ToRuleAppliersRuleUserDefineRuleParsePathRuleOutput() RuleAppliersRuleUserDefineRuleParsePathRuleOutput
	ToRuleAppliersRuleUserDefineRuleParsePathRuleOutputWithContext(context.Context) RuleAppliersRuleUserDefineRuleParsePathRuleOutput
}

type RuleAppliersRuleUserDefineRuleParsePathRuleArgs struct {
	// A list of field names. Log Service will parse the path sample (PathSample) into multiple fields according to the regular expression (Regex), and Keys is used to specify the field name of each field.
	Keys pulumi.StringArrayInput `pulumi:"keys"`
	// Sample capture path for a real scene.
	PathSample pulumi.StringInput `pulumi:"pathSample"`
	// Regular expression for extracting path fields. It must match the collection path sample, otherwise it cannot be extracted successfully.
	Regex pulumi.StringInput `pulumi:"regex"`
}

func (RuleAppliersRuleUserDefineRuleParsePathRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleAppliersRuleUserDefineRuleParsePathRule)(nil)).Elem()
}

func (i RuleAppliersRuleUserDefineRuleParsePathRuleArgs) ToRuleAppliersRuleUserDefineRuleParsePathRuleOutput() RuleAppliersRuleUserDefineRuleParsePathRuleOutput {
	return i.ToRuleAppliersRuleUserDefineRuleParsePathRuleOutputWithContext(context.Background())
}

func (i RuleAppliersRuleUserDefineRuleParsePathRuleArgs) ToRuleAppliersRuleUserDefineRuleParsePathRuleOutputWithContext(ctx context.Context) RuleAppliersRuleUserDefineRuleParsePathRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleAppliersRuleUserDefineRuleParsePathRuleOutput)
}

// RuleAppliersRuleUserDefineRuleParsePathRuleArrayInput is an input type that accepts RuleAppliersRuleUserDefineRuleParsePathRuleArray and RuleAppliersRuleUserDefineRuleParsePathRuleArrayOutput values.
// You can construct a concrete instance of `RuleAppliersRuleUserDefineRuleParsePathRuleArrayInput` via:
//
//	RuleAppliersRuleUserDefineRuleParsePathRuleArray{ RuleAppliersRuleUserDefineRuleParsePathRuleArgs{...} }
type RuleAppliersRuleUserDefineRuleParsePathRuleArrayInput interface {
	pulumi.Input

	ToRuleAppliersRuleUserDefineRuleParsePathRuleArrayOutput() RuleAppliersRuleUserDefineRuleParsePathRuleArrayOutput
	ToRuleAppliersRuleUserDefineRuleParsePathRuleArrayOutputWithContext(context.Context) RuleAppliersRuleUserDefineRuleParsePathRuleArrayOutput
}

type RuleAppliersRuleUserDefineRuleParsePathRuleArray []RuleAppliersRuleUserDefineRuleParsePathRuleInput

func (RuleAppliersRuleUserDefineRuleParsePathRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleAppliersRuleUserDefineRuleParsePathRule)(nil)).Elem()
}

func (i RuleAppliersRuleUserDefineRuleParsePathRuleArray) ToRuleAppliersRuleUserDefineRuleParsePathRuleArrayOutput() RuleAppliersRuleUserDefineRuleParsePathRuleArrayOutput {
	return i.ToRuleAppliersRuleUserDefineRuleParsePathRuleArrayOutputWithContext(context.Background())
}

func (i RuleAppliersRuleUserDefineRuleParsePathRuleArray) ToRuleAppliersRuleUserDefineRuleParsePathRuleArrayOutputWithContext(ctx context.Context) RuleAppliersRuleUserDefineRuleParsePathRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleAppliersRuleUserDefineRuleParsePathRuleArrayOutput)
}

type RuleAppliersRuleUserDefineRuleParsePathRuleOutput struct{ *pulumi.OutputState }

func (RuleAppliersRuleUserDefineRuleParsePathRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleAppliersRuleUserDefineRuleParsePathRule)(nil)).Elem()
}

func (o RuleAppliersRuleUserDefineRuleParsePathRuleOutput) ToRuleAppliersRuleUserDefineRuleParsePathRuleOutput() RuleAppliersRuleUserDefineRuleParsePathRuleOutput {
	return o
}

func (o RuleAppliersRuleUserDefineRuleParsePathRuleOutput) ToRuleAppliersRuleUserDefineRuleParsePathRuleOutputWithContext(ctx context.Context) RuleAppliersRuleUserDefineRuleParsePathRuleOutput {
	return o
}

// A list of field names. Log Service will parse the path sample (PathSample) into multiple fields according to the regular expression (Regex), and Keys is used to specify the field name of each field.
func (o RuleAppliersRuleUserDefineRuleParsePathRuleOutput) Keys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v RuleAppliersRuleUserDefineRuleParsePathRule) []string { return v.Keys }).(pulumi.StringArrayOutput)
}

// Sample capture path for a real scene.
func (o RuleAppliersRuleUserDefineRuleParsePathRuleOutput) PathSample() pulumi.StringOutput {
	return o.ApplyT(func(v RuleAppliersRuleUserDefineRuleParsePathRule) string { return v.PathSample }).(pulumi.StringOutput)
}

// Regular expression for extracting path fields. It must match the collection path sample, otherwise it cannot be extracted successfully.
func (o RuleAppliersRuleUserDefineRuleParsePathRuleOutput) Regex() pulumi.StringOutput {
	return o.ApplyT(func(v RuleAppliersRuleUserDefineRuleParsePathRule) string { return v.Regex }).(pulumi.StringOutput)
}

type RuleAppliersRuleUserDefineRuleParsePathRuleArrayOutput struct{ *pulumi.OutputState }

func (RuleAppliersRuleUserDefineRuleParsePathRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleAppliersRuleUserDefineRuleParsePathRule)(nil)).Elem()
}

func (o RuleAppliersRuleUserDefineRuleParsePathRuleArrayOutput) ToRuleAppliersRuleUserDefineRuleParsePathRuleArrayOutput() RuleAppliersRuleUserDefineRuleParsePathRuleArrayOutput {
	return o
}

func (o RuleAppliersRuleUserDefineRuleParsePathRuleArrayOutput) ToRuleAppliersRuleUserDefineRuleParsePathRuleArrayOutputWithContext(ctx context.Context) RuleAppliersRuleUserDefineRuleParsePathRuleArrayOutput {
	return o
}

func (o RuleAppliersRuleUserDefineRuleParsePathRuleArrayOutput) Index(i pulumi.IntInput) RuleAppliersRuleUserDefineRuleParsePathRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RuleAppliersRuleUserDefineRuleParsePathRule {
		return vs[0].([]RuleAppliersRuleUserDefineRuleParsePathRule)[vs[1].(int)]
	}).(RuleAppliersRuleUserDefineRuleParsePathRuleOutput)
}

type RuleAppliersRuleUserDefineRulePlugin struct {
	// LogCollector plugin.
	Processors string `pulumi:"processors"`
}

// RuleAppliersRuleUserDefineRulePluginInput is an input type that accepts RuleAppliersRuleUserDefineRulePluginArgs and RuleAppliersRuleUserDefineRulePluginOutput values.
// You can construct a concrete instance of `RuleAppliersRuleUserDefineRulePluginInput` via:
//
//	RuleAppliersRuleUserDefineRulePluginArgs{...}
type RuleAppliersRuleUserDefineRulePluginInput interface {
	pulumi.Input

	ToRuleAppliersRuleUserDefineRulePluginOutput() RuleAppliersRuleUserDefineRulePluginOutput
	ToRuleAppliersRuleUserDefineRulePluginOutputWithContext(context.Context) RuleAppliersRuleUserDefineRulePluginOutput
}

type RuleAppliersRuleUserDefineRulePluginArgs struct {
	// LogCollector plugin.
	Processors pulumi.StringInput `pulumi:"processors"`
}

func (RuleAppliersRuleUserDefineRulePluginArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleAppliersRuleUserDefineRulePlugin)(nil)).Elem()
}

func (i RuleAppliersRuleUserDefineRulePluginArgs) ToRuleAppliersRuleUserDefineRulePluginOutput() RuleAppliersRuleUserDefineRulePluginOutput {
	return i.ToRuleAppliersRuleUserDefineRulePluginOutputWithContext(context.Background())
}

func (i RuleAppliersRuleUserDefineRulePluginArgs) ToRuleAppliersRuleUserDefineRulePluginOutputWithContext(ctx context.Context) RuleAppliersRuleUserDefineRulePluginOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleAppliersRuleUserDefineRulePluginOutput)
}

// RuleAppliersRuleUserDefineRulePluginArrayInput is an input type that accepts RuleAppliersRuleUserDefineRulePluginArray and RuleAppliersRuleUserDefineRulePluginArrayOutput values.
// You can construct a concrete instance of `RuleAppliersRuleUserDefineRulePluginArrayInput` via:
//
//	RuleAppliersRuleUserDefineRulePluginArray{ RuleAppliersRuleUserDefineRulePluginArgs{...} }
type RuleAppliersRuleUserDefineRulePluginArrayInput interface {
	pulumi.Input

	ToRuleAppliersRuleUserDefineRulePluginArrayOutput() RuleAppliersRuleUserDefineRulePluginArrayOutput
	ToRuleAppliersRuleUserDefineRulePluginArrayOutputWithContext(context.Context) RuleAppliersRuleUserDefineRulePluginArrayOutput
}

type RuleAppliersRuleUserDefineRulePluginArray []RuleAppliersRuleUserDefineRulePluginInput

func (RuleAppliersRuleUserDefineRulePluginArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleAppliersRuleUserDefineRulePlugin)(nil)).Elem()
}

func (i RuleAppliersRuleUserDefineRulePluginArray) ToRuleAppliersRuleUserDefineRulePluginArrayOutput() RuleAppliersRuleUserDefineRulePluginArrayOutput {
	return i.ToRuleAppliersRuleUserDefineRulePluginArrayOutputWithContext(context.Background())
}

func (i RuleAppliersRuleUserDefineRulePluginArray) ToRuleAppliersRuleUserDefineRulePluginArrayOutputWithContext(ctx context.Context) RuleAppliersRuleUserDefineRulePluginArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleAppliersRuleUserDefineRulePluginArrayOutput)
}

type RuleAppliersRuleUserDefineRulePluginOutput struct{ *pulumi.OutputState }

func (RuleAppliersRuleUserDefineRulePluginOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleAppliersRuleUserDefineRulePlugin)(nil)).Elem()
}

func (o RuleAppliersRuleUserDefineRulePluginOutput) ToRuleAppliersRuleUserDefineRulePluginOutput() RuleAppliersRuleUserDefineRulePluginOutput {
	return o
}

func (o RuleAppliersRuleUserDefineRulePluginOutput) ToRuleAppliersRuleUserDefineRulePluginOutputWithContext(ctx context.Context) RuleAppliersRuleUserDefineRulePluginOutput {
	return o
}

// LogCollector plugin.
func (o RuleAppliersRuleUserDefineRulePluginOutput) Processors() pulumi.StringOutput {
	return o.ApplyT(func(v RuleAppliersRuleUserDefineRulePlugin) string { return v.Processors }).(pulumi.StringOutput)
}

type RuleAppliersRuleUserDefineRulePluginArrayOutput struct{ *pulumi.OutputState }

func (RuleAppliersRuleUserDefineRulePluginArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleAppliersRuleUserDefineRulePlugin)(nil)).Elem()
}

func (o RuleAppliersRuleUserDefineRulePluginArrayOutput) ToRuleAppliersRuleUserDefineRulePluginArrayOutput() RuleAppliersRuleUserDefineRulePluginArrayOutput {
	return o
}

func (o RuleAppliersRuleUserDefineRulePluginArrayOutput) ToRuleAppliersRuleUserDefineRulePluginArrayOutputWithContext(ctx context.Context) RuleAppliersRuleUserDefineRulePluginArrayOutput {
	return o
}

func (o RuleAppliersRuleUserDefineRulePluginArrayOutput) Index(i pulumi.IntInput) RuleAppliersRuleUserDefineRulePluginOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RuleAppliersRuleUserDefineRulePlugin {
		return vs[0].([]RuleAppliersRuleUserDefineRulePlugin)[vs[1].(int)]
	}).(RuleAppliersRuleUserDefineRulePluginOutput)
}

type RuleAppliersRuleUserDefineRuleShardHashKey struct {
	// The HashKey of the log group is used to specify the partition (shard) to be written to by the current log group.
	HashKey string `pulumi:"hashKey"`
}

// RuleAppliersRuleUserDefineRuleShardHashKeyInput is an input type that accepts RuleAppliersRuleUserDefineRuleShardHashKeyArgs and RuleAppliersRuleUserDefineRuleShardHashKeyOutput values.
// You can construct a concrete instance of `RuleAppliersRuleUserDefineRuleShardHashKeyInput` via:
//
//	RuleAppliersRuleUserDefineRuleShardHashKeyArgs{...}
type RuleAppliersRuleUserDefineRuleShardHashKeyInput interface {
	pulumi.Input

	ToRuleAppliersRuleUserDefineRuleShardHashKeyOutput() RuleAppliersRuleUserDefineRuleShardHashKeyOutput
	ToRuleAppliersRuleUserDefineRuleShardHashKeyOutputWithContext(context.Context) RuleAppliersRuleUserDefineRuleShardHashKeyOutput
}

type RuleAppliersRuleUserDefineRuleShardHashKeyArgs struct {
	// The HashKey of the log group is used to specify the partition (shard) to be written to by the current log group.
	HashKey pulumi.StringInput `pulumi:"hashKey"`
}

func (RuleAppliersRuleUserDefineRuleShardHashKeyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleAppliersRuleUserDefineRuleShardHashKey)(nil)).Elem()
}

func (i RuleAppliersRuleUserDefineRuleShardHashKeyArgs) ToRuleAppliersRuleUserDefineRuleShardHashKeyOutput() RuleAppliersRuleUserDefineRuleShardHashKeyOutput {
	return i.ToRuleAppliersRuleUserDefineRuleShardHashKeyOutputWithContext(context.Background())
}

func (i RuleAppliersRuleUserDefineRuleShardHashKeyArgs) ToRuleAppliersRuleUserDefineRuleShardHashKeyOutputWithContext(ctx context.Context) RuleAppliersRuleUserDefineRuleShardHashKeyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleAppliersRuleUserDefineRuleShardHashKeyOutput)
}

// RuleAppliersRuleUserDefineRuleShardHashKeyArrayInput is an input type that accepts RuleAppliersRuleUserDefineRuleShardHashKeyArray and RuleAppliersRuleUserDefineRuleShardHashKeyArrayOutput values.
// You can construct a concrete instance of `RuleAppliersRuleUserDefineRuleShardHashKeyArrayInput` via:
//
//	RuleAppliersRuleUserDefineRuleShardHashKeyArray{ RuleAppliersRuleUserDefineRuleShardHashKeyArgs{...} }
type RuleAppliersRuleUserDefineRuleShardHashKeyArrayInput interface {
	pulumi.Input

	ToRuleAppliersRuleUserDefineRuleShardHashKeyArrayOutput() RuleAppliersRuleUserDefineRuleShardHashKeyArrayOutput
	ToRuleAppliersRuleUserDefineRuleShardHashKeyArrayOutputWithContext(context.Context) RuleAppliersRuleUserDefineRuleShardHashKeyArrayOutput
}

type RuleAppliersRuleUserDefineRuleShardHashKeyArray []RuleAppliersRuleUserDefineRuleShardHashKeyInput

func (RuleAppliersRuleUserDefineRuleShardHashKeyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleAppliersRuleUserDefineRuleShardHashKey)(nil)).Elem()
}

func (i RuleAppliersRuleUserDefineRuleShardHashKeyArray) ToRuleAppliersRuleUserDefineRuleShardHashKeyArrayOutput() RuleAppliersRuleUserDefineRuleShardHashKeyArrayOutput {
	return i.ToRuleAppliersRuleUserDefineRuleShardHashKeyArrayOutputWithContext(context.Background())
}

func (i RuleAppliersRuleUserDefineRuleShardHashKeyArray) ToRuleAppliersRuleUserDefineRuleShardHashKeyArrayOutputWithContext(ctx context.Context) RuleAppliersRuleUserDefineRuleShardHashKeyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleAppliersRuleUserDefineRuleShardHashKeyArrayOutput)
}

type RuleAppliersRuleUserDefineRuleShardHashKeyOutput struct{ *pulumi.OutputState }

func (RuleAppliersRuleUserDefineRuleShardHashKeyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleAppliersRuleUserDefineRuleShardHashKey)(nil)).Elem()
}

func (o RuleAppliersRuleUserDefineRuleShardHashKeyOutput) ToRuleAppliersRuleUserDefineRuleShardHashKeyOutput() RuleAppliersRuleUserDefineRuleShardHashKeyOutput {
	return o
}

func (o RuleAppliersRuleUserDefineRuleShardHashKeyOutput) ToRuleAppliersRuleUserDefineRuleShardHashKeyOutputWithContext(ctx context.Context) RuleAppliersRuleUserDefineRuleShardHashKeyOutput {
	return o
}

// The HashKey of the log group is used to specify the partition (shard) to be written to by the current log group.
func (o RuleAppliersRuleUserDefineRuleShardHashKeyOutput) HashKey() pulumi.StringOutput {
	return o.ApplyT(func(v RuleAppliersRuleUserDefineRuleShardHashKey) string { return v.HashKey }).(pulumi.StringOutput)
}

type RuleAppliersRuleUserDefineRuleShardHashKeyArrayOutput struct{ *pulumi.OutputState }

func (RuleAppliersRuleUserDefineRuleShardHashKeyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleAppliersRuleUserDefineRuleShardHashKey)(nil)).Elem()
}

func (o RuleAppliersRuleUserDefineRuleShardHashKeyArrayOutput) ToRuleAppliersRuleUserDefineRuleShardHashKeyArrayOutput() RuleAppliersRuleUserDefineRuleShardHashKeyArrayOutput {
	return o
}

func (o RuleAppliersRuleUserDefineRuleShardHashKeyArrayOutput) ToRuleAppliersRuleUserDefineRuleShardHashKeyArrayOutputWithContext(ctx context.Context) RuleAppliersRuleUserDefineRuleShardHashKeyArrayOutput {
	return o
}

func (o RuleAppliersRuleUserDefineRuleShardHashKeyArrayOutput) Index(i pulumi.IntInput) RuleAppliersRuleUserDefineRuleShardHashKeyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RuleAppliersRuleUserDefineRuleShardHashKey {
		return vs[0].([]RuleAppliersRuleUserDefineRuleShardHashKey)[vs[1].(int)]
	}).(RuleAppliersRuleUserDefineRuleShardHashKeyOutput)
}

type RuleContainerRule struct {
	// The name of the container to be collected.
	ContainerNameRegex *string `pulumi:"containerNameRegex"`
	// Whether to add environment variables as log tags to raw log data.
	EnvTag map[string]string `pulumi:"envTag"`
	// The container environment variable blacklist is used to specify the range of containers not to be collected.
	ExcludeContainerEnvRegex map[string]string `pulumi:"excludeContainerEnvRegex"`
	// The container Label blacklist is used to specify the range of containers not to be collected.
	ExcludeContainerLabelRegex map[string]string `pulumi:"excludeContainerLabelRegex"`
	// The container environment variable whitelist specifies the container to be collected through the container environment variable. If the whitelist is not enabled, it means that all containers are specified to be collected.
	IncludeContainerEnvRegex map[string]string `pulumi:"includeContainerEnvRegex"`
	// The container label whitelist specifies the containers to be collected through the container label. If the whitelist is not enabled, all containers are specified to be collected.
	IncludeContainerLabelRegex map[string]string `pulumi:"includeContainerLabelRegex"`
	// Collection rules for Kubernetes containers.
	KubernetesRule *RuleContainerRuleKubernetesRule `pulumi:"kubernetesRule"`
	// The collection mode.
	Stream string `pulumi:"stream"`
}

// RuleContainerRuleInput is an input type that accepts RuleContainerRuleArgs and RuleContainerRuleOutput values.
// You can construct a concrete instance of `RuleContainerRuleInput` via:
//
//	RuleContainerRuleArgs{...}
type RuleContainerRuleInput interface {
	pulumi.Input

	ToRuleContainerRuleOutput() RuleContainerRuleOutput
	ToRuleContainerRuleOutputWithContext(context.Context) RuleContainerRuleOutput
}

type RuleContainerRuleArgs struct {
	// The name of the container to be collected.
	ContainerNameRegex pulumi.StringPtrInput `pulumi:"containerNameRegex"`
	// Whether to add environment variables as log tags to raw log data.
	EnvTag pulumi.StringMapInput `pulumi:"envTag"`
	// The container environment variable blacklist is used to specify the range of containers not to be collected.
	ExcludeContainerEnvRegex pulumi.StringMapInput `pulumi:"excludeContainerEnvRegex"`
	// The container Label blacklist is used to specify the range of containers not to be collected.
	ExcludeContainerLabelRegex pulumi.StringMapInput `pulumi:"excludeContainerLabelRegex"`
	// The container environment variable whitelist specifies the container to be collected through the container environment variable. If the whitelist is not enabled, it means that all containers are specified to be collected.
	IncludeContainerEnvRegex pulumi.StringMapInput `pulumi:"includeContainerEnvRegex"`
	// The container label whitelist specifies the containers to be collected through the container label. If the whitelist is not enabled, all containers are specified to be collected.
	IncludeContainerLabelRegex pulumi.StringMapInput `pulumi:"includeContainerLabelRegex"`
	// Collection rules for Kubernetes containers.
	KubernetesRule RuleContainerRuleKubernetesRulePtrInput `pulumi:"kubernetesRule"`
	// The collection mode.
	Stream pulumi.StringInput `pulumi:"stream"`
}

func (RuleContainerRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleContainerRule)(nil)).Elem()
}

func (i RuleContainerRuleArgs) ToRuleContainerRuleOutput() RuleContainerRuleOutput {
	return i.ToRuleContainerRuleOutputWithContext(context.Background())
}

func (i RuleContainerRuleArgs) ToRuleContainerRuleOutputWithContext(ctx context.Context) RuleContainerRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleContainerRuleOutput)
}

func (i RuleContainerRuleArgs) ToRuleContainerRulePtrOutput() RuleContainerRulePtrOutput {
	return i.ToRuleContainerRulePtrOutputWithContext(context.Background())
}

func (i RuleContainerRuleArgs) ToRuleContainerRulePtrOutputWithContext(ctx context.Context) RuleContainerRulePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleContainerRuleOutput).ToRuleContainerRulePtrOutputWithContext(ctx)
}

// RuleContainerRulePtrInput is an input type that accepts RuleContainerRuleArgs, RuleContainerRulePtr and RuleContainerRulePtrOutput values.
// You can construct a concrete instance of `RuleContainerRulePtrInput` via:
//
//	        RuleContainerRuleArgs{...}
//
//	or:
//
//	        nil
type RuleContainerRulePtrInput interface {
	pulumi.Input

	ToRuleContainerRulePtrOutput() RuleContainerRulePtrOutput
	ToRuleContainerRulePtrOutputWithContext(context.Context) RuleContainerRulePtrOutput
}

type ruleContainerRulePtrType RuleContainerRuleArgs

func RuleContainerRulePtr(v *RuleContainerRuleArgs) RuleContainerRulePtrInput {
	return (*ruleContainerRulePtrType)(v)
}

func (*ruleContainerRulePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleContainerRule)(nil)).Elem()
}

func (i *ruleContainerRulePtrType) ToRuleContainerRulePtrOutput() RuleContainerRulePtrOutput {
	return i.ToRuleContainerRulePtrOutputWithContext(context.Background())
}

func (i *ruleContainerRulePtrType) ToRuleContainerRulePtrOutputWithContext(ctx context.Context) RuleContainerRulePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleContainerRulePtrOutput)
}

type RuleContainerRuleOutput struct{ *pulumi.OutputState }

func (RuleContainerRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleContainerRule)(nil)).Elem()
}

func (o RuleContainerRuleOutput) ToRuleContainerRuleOutput() RuleContainerRuleOutput {
	return o
}

func (o RuleContainerRuleOutput) ToRuleContainerRuleOutputWithContext(ctx context.Context) RuleContainerRuleOutput {
	return o
}

func (o RuleContainerRuleOutput) ToRuleContainerRulePtrOutput() RuleContainerRulePtrOutput {
	return o.ToRuleContainerRulePtrOutputWithContext(context.Background())
}

func (o RuleContainerRuleOutput) ToRuleContainerRulePtrOutputWithContext(ctx context.Context) RuleContainerRulePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleContainerRule) *RuleContainerRule {
		return &v
	}).(RuleContainerRulePtrOutput)
}

// The name of the container to be collected.
func (o RuleContainerRuleOutput) ContainerNameRegex() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleContainerRule) *string { return v.ContainerNameRegex }).(pulumi.StringPtrOutput)
}

// Whether to add environment variables as log tags to raw log data.
func (o RuleContainerRuleOutput) EnvTag() pulumi.StringMapOutput {
	return o.ApplyT(func(v RuleContainerRule) map[string]string { return v.EnvTag }).(pulumi.StringMapOutput)
}

// The container environment variable blacklist is used to specify the range of containers not to be collected.
func (o RuleContainerRuleOutput) ExcludeContainerEnvRegex() pulumi.StringMapOutput {
	return o.ApplyT(func(v RuleContainerRule) map[string]string { return v.ExcludeContainerEnvRegex }).(pulumi.StringMapOutput)
}

// The container Label blacklist is used to specify the range of containers not to be collected.
func (o RuleContainerRuleOutput) ExcludeContainerLabelRegex() pulumi.StringMapOutput {
	return o.ApplyT(func(v RuleContainerRule) map[string]string { return v.ExcludeContainerLabelRegex }).(pulumi.StringMapOutput)
}

// The container environment variable whitelist specifies the container to be collected through the container environment variable. If the whitelist is not enabled, it means that all containers are specified to be collected.
func (o RuleContainerRuleOutput) IncludeContainerEnvRegex() pulumi.StringMapOutput {
	return o.ApplyT(func(v RuleContainerRule) map[string]string { return v.IncludeContainerEnvRegex }).(pulumi.StringMapOutput)
}

// The container label whitelist specifies the containers to be collected through the container label. If the whitelist is not enabled, all containers are specified to be collected.
func (o RuleContainerRuleOutput) IncludeContainerLabelRegex() pulumi.StringMapOutput {
	return o.ApplyT(func(v RuleContainerRule) map[string]string { return v.IncludeContainerLabelRegex }).(pulumi.StringMapOutput)
}

// Collection rules for Kubernetes containers.
func (o RuleContainerRuleOutput) KubernetesRule() RuleContainerRuleKubernetesRulePtrOutput {
	return o.ApplyT(func(v RuleContainerRule) *RuleContainerRuleKubernetesRule { return v.KubernetesRule }).(RuleContainerRuleKubernetesRulePtrOutput)
}

// The collection mode.
func (o RuleContainerRuleOutput) Stream() pulumi.StringOutput {
	return o.ApplyT(func(v RuleContainerRule) string { return v.Stream }).(pulumi.StringOutput)
}

type RuleContainerRulePtrOutput struct{ *pulumi.OutputState }

func (RuleContainerRulePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleContainerRule)(nil)).Elem()
}

func (o RuleContainerRulePtrOutput) ToRuleContainerRulePtrOutput() RuleContainerRulePtrOutput {
	return o
}

func (o RuleContainerRulePtrOutput) ToRuleContainerRulePtrOutputWithContext(ctx context.Context) RuleContainerRulePtrOutput {
	return o
}

func (o RuleContainerRulePtrOutput) Elem() RuleContainerRuleOutput {
	return o.ApplyT(func(v *RuleContainerRule) RuleContainerRule {
		if v != nil {
			return *v
		}
		var ret RuleContainerRule
		return ret
	}).(RuleContainerRuleOutput)
}

// The name of the container to be collected.
func (o RuleContainerRulePtrOutput) ContainerNameRegex() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RuleContainerRule) *string {
		if v == nil {
			return nil
		}
		return v.ContainerNameRegex
	}).(pulumi.StringPtrOutput)
}

// Whether to add environment variables as log tags to raw log data.
func (o RuleContainerRulePtrOutput) EnvTag() pulumi.StringMapOutput {
	return o.ApplyT(func(v *RuleContainerRule) map[string]string {
		if v == nil {
			return nil
		}
		return v.EnvTag
	}).(pulumi.StringMapOutput)
}

// The container environment variable blacklist is used to specify the range of containers not to be collected.
func (o RuleContainerRulePtrOutput) ExcludeContainerEnvRegex() pulumi.StringMapOutput {
	return o.ApplyT(func(v *RuleContainerRule) map[string]string {
		if v == nil {
			return nil
		}
		return v.ExcludeContainerEnvRegex
	}).(pulumi.StringMapOutput)
}

// The container Label blacklist is used to specify the range of containers not to be collected.
func (o RuleContainerRulePtrOutput) ExcludeContainerLabelRegex() pulumi.StringMapOutput {
	return o.ApplyT(func(v *RuleContainerRule) map[string]string {
		if v == nil {
			return nil
		}
		return v.ExcludeContainerLabelRegex
	}).(pulumi.StringMapOutput)
}

// The container environment variable whitelist specifies the container to be collected through the container environment variable. If the whitelist is not enabled, it means that all containers are specified to be collected.
func (o RuleContainerRulePtrOutput) IncludeContainerEnvRegex() pulumi.StringMapOutput {
	return o.ApplyT(func(v *RuleContainerRule) map[string]string {
		if v == nil {
			return nil
		}
		return v.IncludeContainerEnvRegex
	}).(pulumi.StringMapOutput)
}

// The container label whitelist specifies the containers to be collected through the container label. If the whitelist is not enabled, all containers are specified to be collected.
func (o RuleContainerRulePtrOutput) IncludeContainerLabelRegex() pulumi.StringMapOutput {
	return o.ApplyT(func(v *RuleContainerRule) map[string]string {
		if v == nil {
			return nil
		}
		return v.IncludeContainerLabelRegex
	}).(pulumi.StringMapOutput)
}

// Collection rules for Kubernetes containers.
func (o RuleContainerRulePtrOutput) KubernetesRule() RuleContainerRuleKubernetesRulePtrOutput {
	return o.ApplyT(func(v *RuleContainerRule) *RuleContainerRuleKubernetesRule {
		if v == nil {
			return nil
		}
		return v.KubernetesRule
	}).(RuleContainerRuleKubernetesRulePtrOutput)
}

// The collection mode.
func (o RuleContainerRulePtrOutput) Stream() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RuleContainerRule) *string {
		if v == nil {
			return nil
		}
		return &v.Stream
	}).(pulumi.StringPtrOutput)
}

type RuleContainerRuleKubernetesRule struct {
	// Whether to add Kubernetes Annotation as a log tag to the raw log data.
	AnnotationTag map[string]string `pulumi:"annotationTag"`
	// Specify the containers not to be collected through the Pod Label blacklist, and not enable means to collect all containers.
	ExcludePodLabelRegex map[string]string `pulumi:"excludePodLabelRegex"`
	// The Pod Label whitelist is used to specify containers to be collected. When the Pod Label whitelist is not enabled, it means that all containers are collected.
	IncludePodLabelRegex map[string]string `pulumi:"includePodLabelRegex"`
	// Whether to add Kubernetes Label as a log label to the original log data.
	LabelTag map[string]string `pulumi:"labelTag"`
	// The name of the Kubernetes Namespace to be collected. If no Namespace name is specified, all containers will be collected. Namespace names support regular matching.
	NamespaceNameRegex *string `pulumi:"namespaceNameRegex"`
	// The Pod name is used to specify the container to be collected. When no Pod name is specified, it means to collect all containers.
	PodNameRegex *string `pulumi:"podNameRegex"`
	// Specify the container to be collected by the name of the workload. When no workload name is specified, all containers are collected. The workload name supports regular matching.
	WorkloadNameRegex *string `pulumi:"workloadNameRegex"`
	// Specify the containers to be collected by the type of workload, only one type can be selected. When no type is specified, it means all types of containers are collected. The supported types of workloads are:
	// Deployment: stateless workload.
	// StatefulSet: stateful workload.
	// DaemonSet: daemon process.
	// Job: task.
	// CronJob: scheduled task.
	WorkloadType *string `pulumi:"workloadType"`
}

// RuleContainerRuleKubernetesRuleInput is an input type that accepts RuleContainerRuleKubernetesRuleArgs and RuleContainerRuleKubernetesRuleOutput values.
// You can construct a concrete instance of `RuleContainerRuleKubernetesRuleInput` via:
//
//	RuleContainerRuleKubernetesRuleArgs{...}
type RuleContainerRuleKubernetesRuleInput interface {
	pulumi.Input

	ToRuleContainerRuleKubernetesRuleOutput() RuleContainerRuleKubernetesRuleOutput
	ToRuleContainerRuleKubernetesRuleOutputWithContext(context.Context) RuleContainerRuleKubernetesRuleOutput
}

type RuleContainerRuleKubernetesRuleArgs struct {
	// Whether to add Kubernetes Annotation as a log tag to the raw log data.
	AnnotationTag pulumi.StringMapInput `pulumi:"annotationTag"`
	// Specify the containers not to be collected through the Pod Label blacklist, and not enable means to collect all containers.
	ExcludePodLabelRegex pulumi.StringMapInput `pulumi:"excludePodLabelRegex"`
	// The Pod Label whitelist is used to specify containers to be collected. When the Pod Label whitelist is not enabled, it means that all containers are collected.
	IncludePodLabelRegex pulumi.StringMapInput `pulumi:"includePodLabelRegex"`
	// Whether to add Kubernetes Label as a log label to the original log data.
	LabelTag pulumi.StringMapInput `pulumi:"labelTag"`
	// The name of the Kubernetes Namespace to be collected. If no Namespace name is specified, all containers will be collected. Namespace names support regular matching.
	NamespaceNameRegex pulumi.StringPtrInput `pulumi:"namespaceNameRegex"`
	// The Pod name is used to specify the container to be collected. When no Pod name is specified, it means to collect all containers.
	PodNameRegex pulumi.StringPtrInput `pulumi:"podNameRegex"`
	// Specify the container to be collected by the name of the workload. When no workload name is specified, all containers are collected. The workload name supports regular matching.
	WorkloadNameRegex pulumi.StringPtrInput `pulumi:"workloadNameRegex"`
	// Specify the containers to be collected by the type of workload, only one type can be selected. When no type is specified, it means all types of containers are collected. The supported types of workloads are:
	// Deployment: stateless workload.
	// StatefulSet: stateful workload.
	// DaemonSet: daemon process.
	// Job: task.
	// CronJob: scheduled task.
	WorkloadType pulumi.StringPtrInput `pulumi:"workloadType"`
}

func (RuleContainerRuleKubernetesRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleContainerRuleKubernetesRule)(nil)).Elem()
}

func (i RuleContainerRuleKubernetesRuleArgs) ToRuleContainerRuleKubernetesRuleOutput() RuleContainerRuleKubernetesRuleOutput {
	return i.ToRuleContainerRuleKubernetesRuleOutputWithContext(context.Background())
}

func (i RuleContainerRuleKubernetesRuleArgs) ToRuleContainerRuleKubernetesRuleOutputWithContext(ctx context.Context) RuleContainerRuleKubernetesRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleContainerRuleKubernetesRuleOutput)
}

func (i RuleContainerRuleKubernetesRuleArgs) ToRuleContainerRuleKubernetesRulePtrOutput() RuleContainerRuleKubernetesRulePtrOutput {
	return i.ToRuleContainerRuleKubernetesRulePtrOutputWithContext(context.Background())
}

func (i RuleContainerRuleKubernetesRuleArgs) ToRuleContainerRuleKubernetesRulePtrOutputWithContext(ctx context.Context) RuleContainerRuleKubernetesRulePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleContainerRuleKubernetesRuleOutput).ToRuleContainerRuleKubernetesRulePtrOutputWithContext(ctx)
}

// RuleContainerRuleKubernetesRulePtrInput is an input type that accepts RuleContainerRuleKubernetesRuleArgs, RuleContainerRuleKubernetesRulePtr and RuleContainerRuleKubernetesRulePtrOutput values.
// You can construct a concrete instance of `RuleContainerRuleKubernetesRulePtrInput` via:
//
//	        RuleContainerRuleKubernetesRuleArgs{...}
//
//	or:
//
//	        nil
type RuleContainerRuleKubernetesRulePtrInput interface {
	pulumi.Input

	ToRuleContainerRuleKubernetesRulePtrOutput() RuleContainerRuleKubernetesRulePtrOutput
	ToRuleContainerRuleKubernetesRulePtrOutputWithContext(context.Context) RuleContainerRuleKubernetesRulePtrOutput
}

type ruleContainerRuleKubernetesRulePtrType RuleContainerRuleKubernetesRuleArgs

func RuleContainerRuleKubernetesRulePtr(v *RuleContainerRuleKubernetesRuleArgs) RuleContainerRuleKubernetesRulePtrInput {
	return (*ruleContainerRuleKubernetesRulePtrType)(v)
}

func (*ruleContainerRuleKubernetesRulePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleContainerRuleKubernetesRule)(nil)).Elem()
}

func (i *ruleContainerRuleKubernetesRulePtrType) ToRuleContainerRuleKubernetesRulePtrOutput() RuleContainerRuleKubernetesRulePtrOutput {
	return i.ToRuleContainerRuleKubernetesRulePtrOutputWithContext(context.Background())
}

func (i *ruleContainerRuleKubernetesRulePtrType) ToRuleContainerRuleKubernetesRulePtrOutputWithContext(ctx context.Context) RuleContainerRuleKubernetesRulePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleContainerRuleKubernetesRulePtrOutput)
}

type RuleContainerRuleKubernetesRuleOutput struct{ *pulumi.OutputState }

func (RuleContainerRuleKubernetesRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleContainerRuleKubernetesRule)(nil)).Elem()
}

func (o RuleContainerRuleKubernetesRuleOutput) ToRuleContainerRuleKubernetesRuleOutput() RuleContainerRuleKubernetesRuleOutput {
	return o
}

func (o RuleContainerRuleKubernetesRuleOutput) ToRuleContainerRuleKubernetesRuleOutputWithContext(ctx context.Context) RuleContainerRuleKubernetesRuleOutput {
	return o
}

func (o RuleContainerRuleKubernetesRuleOutput) ToRuleContainerRuleKubernetesRulePtrOutput() RuleContainerRuleKubernetesRulePtrOutput {
	return o.ToRuleContainerRuleKubernetesRulePtrOutputWithContext(context.Background())
}

func (o RuleContainerRuleKubernetesRuleOutput) ToRuleContainerRuleKubernetesRulePtrOutputWithContext(ctx context.Context) RuleContainerRuleKubernetesRulePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleContainerRuleKubernetesRule) *RuleContainerRuleKubernetesRule {
		return &v
	}).(RuleContainerRuleKubernetesRulePtrOutput)
}

// Whether to add Kubernetes Annotation as a log tag to the raw log data.
func (o RuleContainerRuleKubernetesRuleOutput) AnnotationTag() pulumi.StringMapOutput {
	return o.ApplyT(func(v RuleContainerRuleKubernetesRule) map[string]string { return v.AnnotationTag }).(pulumi.StringMapOutput)
}

// Specify the containers not to be collected through the Pod Label blacklist, and not enable means to collect all containers.
func (o RuleContainerRuleKubernetesRuleOutput) ExcludePodLabelRegex() pulumi.StringMapOutput {
	return o.ApplyT(func(v RuleContainerRuleKubernetesRule) map[string]string { return v.ExcludePodLabelRegex }).(pulumi.StringMapOutput)
}

// The Pod Label whitelist is used to specify containers to be collected. When the Pod Label whitelist is not enabled, it means that all containers are collected.
func (o RuleContainerRuleKubernetesRuleOutput) IncludePodLabelRegex() pulumi.StringMapOutput {
	return o.ApplyT(func(v RuleContainerRuleKubernetesRule) map[string]string { return v.IncludePodLabelRegex }).(pulumi.StringMapOutput)
}

// Whether to add Kubernetes Label as a log label to the original log data.
func (o RuleContainerRuleKubernetesRuleOutput) LabelTag() pulumi.StringMapOutput {
	return o.ApplyT(func(v RuleContainerRuleKubernetesRule) map[string]string { return v.LabelTag }).(pulumi.StringMapOutput)
}

// The name of the Kubernetes Namespace to be collected. If no Namespace name is specified, all containers will be collected. Namespace names support regular matching.
func (o RuleContainerRuleKubernetesRuleOutput) NamespaceNameRegex() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleContainerRuleKubernetesRule) *string { return v.NamespaceNameRegex }).(pulumi.StringPtrOutput)
}

// The Pod name is used to specify the container to be collected. When no Pod name is specified, it means to collect all containers.
func (o RuleContainerRuleKubernetesRuleOutput) PodNameRegex() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleContainerRuleKubernetesRule) *string { return v.PodNameRegex }).(pulumi.StringPtrOutput)
}

// Specify the container to be collected by the name of the workload. When no workload name is specified, all containers are collected. The workload name supports regular matching.
func (o RuleContainerRuleKubernetesRuleOutput) WorkloadNameRegex() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleContainerRuleKubernetesRule) *string { return v.WorkloadNameRegex }).(pulumi.StringPtrOutput)
}

// Specify the containers to be collected by the type of workload, only one type can be selected. When no type is specified, it means all types of containers are collected. The supported types of workloads are:
// Deployment: stateless workload.
// StatefulSet: stateful workload.
// DaemonSet: daemon process.
// Job: task.
// CronJob: scheduled task.
func (o RuleContainerRuleKubernetesRuleOutput) WorkloadType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleContainerRuleKubernetesRule) *string { return v.WorkloadType }).(pulumi.StringPtrOutput)
}

type RuleContainerRuleKubernetesRulePtrOutput struct{ *pulumi.OutputState }

func (RuleContainerRuleKubernetesRulePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleContainerRuleKubernetesRule)(nil)).Elem()
}

func (o RuleContainerRuleKubernetesRulePtrOutput) ToRuleContainerRuleKubernetesRulePtrOutput() RuleContainerRuleKubernetesRulePtrOutput {
	return o
}

func (o RuleContainerRuleKubernetesRulePtrOutput) ToRuleContainerRuleKubernetesRulePtrOutputWithContext(ctx context.Context) RuleContainerRuleKubernetesRulePtrOutput {
	return o
}

func (o RuleContainerRuleKubernetesRulePtrOutput) Elem() RuleContainerRuleKubernetesRuleOutput {
	return o.ApplyT(func(v *RuleContainerRuleKubernetesRule) RuleContainerRuleKubernetesRule {
		if v != nil {
			return *v
		}
		var ret RuleContainerRuleKubernetesRule
		return ret
	}).(RuleContainerRuleKubernetesRuleOutput)
}

// Whether to add Kubernetes Annotation as a log tag to the raw log data.
func (o RuleContainerRuleKubernetesRulePtrOutput) AnnotationTag() pulumi.StringMapOutput {
	return o.ApplyT(func(v *RuleContainerRuleKubernetesRule) map[string]string {
		if v == nil {
			return nil
		}
		return v.AnnotationTag
	}).(pulumi.StringMapOutput)
}

// Specify the containers not to be collected through the Pod Label blacklist, and not enable means to collect all containers.
func (o RuleContainerRuleKubernetesRulePtrOutput) ExcludePodLabelRegex() pulumi.StringMapOutput {
	return o.ApplyT(func(v *RuleContainerRuleKubernetesRule) map[string]string {
		if v == nil {
			return nil
		}
		return v.ExcludePodLabelRegex
	}).(pulumi.StringMapOutput)
}

// The Pod Label whitelist is used to specify containers to be collected. When the Pod Label whitelist is not enabled, it means that all containers are collected.
func (o RuleContainerRuleKubernetesRulePtrOutput) IncludePodLabelRegex() pulumi.StringMapOutput {
	return o.ApplyT(func(v *RuleContainerRuleKubernetesRule) map[string]string {
		if v == nil {
			return nil
		}
		return v.IncludePodLabelRegex
	}).(pulumi.StringMapOutput)
}

// Whether to add Kubernetes Label as a log label to the original log data.
func (o RuleContainerRuleKubernetesRulePtrOutput) LabelTag() pulumi.StringMapOutput {
	return o.ApplyT(func(v *RuleContainerRuleKubernetesRule) map[string]string {
		if v == nil {
			return nil
		}
		return v.LabelTag
	}).(pulumi.StringMapOutput)
}

// The name of the Kubernetes Namespace to be collected. If no Namespace name is specified, all containers will be collected. Namespace names support regular matching.
func (o RuleContainerRuleKubernetesRulePtrOutput) NamespaceNameRegex() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RuleContainerRuleKubernetesRule) *string {
		if v == nil {
			return nil
		}
		return v.NamespaceNameRegex
	}).(pulumi.StringPtrOutput)
}

// The Pod name is used to specify the container to be collected. When no Pod name is specified, it means to collect all containers.
func (o RuleContainerRuleKubernetesRulePtrOutput) PodNameRegex() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RuleContainerRuleKubernetesRule) *string {
		if v == nil {
			return nil
		}
		return v.PodNameRegex
	}).(pulumi.StringPtrOutput)
}

// Specify the container to be collected by the name of the workload. When no workload name is specified, all containers are collected. The workload name supports regular matching.
func (o RuleContainerRuleKubernetesRulePtrOutput) WorkloadNameRegex() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RuleContainerRuleKubernetesRule) *string {
		if v == nil {
			return nil
		}
		return v.WorkloadNameRegex
	}).(pulumi.StringPtrOutput)
}

// Specify the containers to be collected by the type of workload, only one type can be selected. When no type is specified, it means all types of containers are collected. The supported types of workloads are:
// Deployment: stateless workload.
// StatefulSet: stateful workload.
// DaemonSet: daemon process.
// Job: task.
// CronJob: scheduled task.
func (o RuleContainerRuleKubernetesRulePtrOutput) WorkloadType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RuleContainerRuleKubernetesRule) *string {
		if v == nil {
			return nil
		}
		return v.WorkloadType
	}).(pulumi.StringPtrOutput)
}

type RuleExcludePath struct {
	// Collection path type. The path type can be `File` or `Path`.
	Type string `pulumi:"type"`
	// Collection path.
	Value string `pulumi:"value"`
}

// RuleExcludePathInput is an input type that accepts RuleExcludePathArgs and RuleExcludePathOutput values.
// You can construct a concrete instance of `RuleExcludePathInput` via:
//
//	RuleExcludePathArgs{...}
type RuleExcludePathInput interface {
	pulumi.Input

	ToRuleExcludePathOutput() RuleExcludePathOutput
	ToRuleExcludePathOutputWithContext(context.Context) RuleExcludePathOutput
}

type RuleExcludePathArgs struct {
	// Collection path type. The path type can be `File` or `Path`.
	Type pulumi.StringInput `pulumi:"type"`
	// Collection path.
	Value pulumi.StringInput `pulumi:"value"`
}

func (RuleExcludePathArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleExcludePath)(nil)).Elem()
}

func (i RuleExcludePathArgs) ToRuleExcludePathOutput() RuleExcludePathOutput {
	return i.ToRuleExcludePathOutputWithContext(context.Background())
}

func (i RuleExcludePathArgs) ToRuleExcludePathOutputWithContext(ctx context.Context) RuleExcludePathOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleExcludePathOutput)
}

// RuleExcludePathArrayInput is an input type that accepts RuleExcludePathArray and RuleExcludePathArrayOutput values.
// You can construct a concrete instance of `RuleExcludePathArrayInput` via:
//
//	RuleExcludePathArray{ RuleExcludePathArgs{...} }
type RuleExcludePathArrayInput interface {
	pulumi.Input

	ToRuleExcludePathArrayOutput() RuleExcludePathArrayOutput
	ToRuleExcludePathArrayOutputWithContext(context.Context) RuleExcludePathArrayOutput
}

type RuleExcludePathArray []RuleExcludePathInput

func (RuleExcludePathArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleExcludePath)(nil)).Elem()
}

func (i RuleExcludePathArray) ToRuleExcludePathArrayOutput() RuleExcludePathArrayOutput {
	return i.ToRuleExcludePathArrayOutputWithContext(context.Background())
}

func (i RuleExcludePathArray) ToRuleExcludePathArrayOutputWithContext(ctx context.Context) RuleExcludePathArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleExcludePathArrayOutput)
}

type RuleExcludePathOutput struct{ *pulumi.OutputState }

func (RuleExcludePathOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleExcludePath)(nil)).Elem()
}

func (o RuleExcludePathOutput) ToRuleExcludePathOutput() RuleExcludePathOutput {
	return o
}

func (o RuleExcludePathOutput) ToRuleExcludePathOutputWithContext(ctx context.Context) RuleExcludePathOutput {
	return o
}

// Collection path type. The path type can be `File` or `Path`.
func (o RuleExcludePathOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v RuleExcludePath) string { return v.Type }).(pulumi.StringOutput)
}

// Collection path.
func (o RuleExcludePathOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v RuleExcludePath) string { return v.Value }).(pulumi.StringOutput)
}

type RuleExcludePathArrayOutput struct{ *pulumi.OutputState }

func (RuleExcludePathArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleExcludePath)(nil)).Elem()
}

func (o RuleExcludePathArrayOutput) ToRuleExcludePathArrayOutput() RuleExcludePathArrayOutput {
	return o
}

func (o RuleExcludePathArrayOutput) ToRuleExcludePathArrayOutputWithContext(ctx context.Context) RuleExcludePathArrayOutput {
	return o
}

func (o RuleExcludePathArrayOutput) Index(i pulumi.IntInput) RuleExcludePathOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RuleExcludePath {
		return vs[0].([]RuleExcludePath)[vs[1].(int)]
	}).(RuleExcludePathOutput)
}

type RuleExtractRule struct {
	// The first log line needs to match the regular expression.
	BeginRegex *string `pulumi:"beginRegex"`
	// The delimiter of the log.
	Delimiter *string `pulumi:"delimiter"`
	// The filter key list.
	FilterKeyRegexes []RuleExtractRuleFilterKeyRegex `pulumi:"filterKeyRegexes"`
	// A list of log field names (Key).
	Keys []string `pulumi:"keys"`
	// The entire log needs to match the regular expression.
	LogRegex *string `pulumi:"logRegex"`
	// Automatically extract log fields according to the specified log template.
	LogTemplate *RuleExtractRuleLogTemplate `pulumi:"logTemplate"`
	// Parsing format of the time field.
	TimeFormat *string `pulumi:"timeFormat"`
	// The field name of the log time field.
	TimeKey *string `pulumi:"timeKey"`
	// When uploading the failed log, the key name of the failed log.
	UnMatchLogKey *string `pulumi:"unMatchLogKey"`
	// Whether to upload the log of parsing failure.
	UnMatchUpLoadSwitch *bool `pulumi:"unMatchUpLoadSwitch"`
}

// RuleExtractRuleInput is an input type that accepts RuleExtractRuleArgs and RuleExtractRuleOutput values.
// You can construct a concrete instance of `RuleExtractRuleInput` via:
//
//	RuleExtractRuleArgs{...}
type RuleExtractRuleInput interface {
	pulumi.Input

	ToRuleExtractRuleOutput() RuleExtractRuleOutput
	ToRuleExtractRuleOutputWithContext(context.Context) RuleExtractRuleOutput
}

type RuleExtractRuleArgs struct {
	// The first log line needs to match the regular expression.
	BeginRegex pulumi.StringPtrInput `pulumi:"beginRegex"`
	// The delimiter of the log.
	Delimiter pulumi.StringPtrInput `pulumi:"delimiter"`
	// The filter key list.
	FilterKeyRegexes RuleExtractRuleFilterKeyRegexArrayInput `pulumi:"filterKeyRegexes"`
	// A list of log field names (Key).
	Keys pulumi.StringArrayInput `pulumi:"keys"`
	// The entire log needs to match the regular expression.
	LogRegex pulumi.StringPtrInput `pulumi:"logRegex"`
	// Automatically extract log fields according to the specified log template.
	LogTemplate RuleExtractRuleLogTemplatePtrInput `pulumi:"logTemplate"`
	// Parsing format of the time field.
	TimeFormat pulumi.StringPtrInput `pulumi:"timeFormat"`
	// The field name of the log time field.
	TimeKey pulumi.StringPtrInput `pulumi:"timeKey"`
	// When uploading the failed log, the key name of the failed log.
	UnMatchLogKey pulumi.StringPtrInput `pulumi:"unMatchLogKey"`
	// Whether to upload the log of parsing failure.
	UnMatchUpLoadSwitch pulumi.BoolPtrInput `pulumi:"unMatchUpLoadSwitch"`
}

func (RuleExtractRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleExtractRule)(nil)).Elem()
}

func (i RuleExtractRuleArgs) ToRuleExtractRuleOutput() RuleExtractRuleOutput {
	return i.ToRuleExtractRuleOutputWithContext(context.Background())
}

func (i RuleExtractRuleArgs) ToRuleExtractRuleOutputWithContext(ctx context.Context) RuleExtractRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleExtractRuleOutput)
}

func (i RuleExtractRuleArgs) ToRuleExtractRulePtrOutput() RuleExtractRulePtrOutput {
	return i.ToRuleExtractRulePtrOutputWithContext(context.Background())
}

func (i RuleExtractRuleArgs) ToRuleExtractRulePtrOutputWithContext(ctx context.Context) RuleExtractRulePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleExtractRuleOutput).ToRuleExtractRulePtrOutputWithContext(ctx)
}

// RuleExtractRulePtrInput is an input type that accepts RuleExtractRuleArgs, RuleExtractRulePtr and RuleExtractRulePtrOutput values.
// You can construct a concrete instance of `RuleExtractRulePtrInput` via:
//
//	        RuleExtractRuleArgs{...}
//
//	or:
//
//	        nil
type RuleExtractRulePtrInput interface {
	pulumi.Input

	ToRuleExtractRulePtrOutput() RuleExtractRulePtrOutput
	ToRuleExtractRulePtrOutputWithContext(context.Context) RuleExtractRulePtrOutput
}

type ruleExtractRulePtrType RuleExtractRuleArgs

func RuleExtractRulePtr(v *RuleExtractRuleArgs) RuleExtractRulePtrInput {
	return (*ruleExtractRulePtrType)(v)
}

func (*ruleExtractRulePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleExtractRule)(nil)).Elem()
}

func (i *ruleExtractRulePtrType) ToRuleExtractRulePtrOutput() RuleExtractRulePtrOutput {
	return i.ToRuleExtractRulePtrOutputWithContext(context.Background())
}

func (i *ruleExtractRulePtrType) ToRuleExtractRulePtrOutputWithContext(ctx context.Context) RuleExtractRulePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleExtractRulePtrOutput)
}

type RuleExtractRuleOutput struct{ *pulumi.OutputState }

func (RuleExtractRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleExtractRule)(nil)).Elem()
}

func (o RuleExtractRuleOutput) ToRuleExtractRuleOutput() RuleExtractRuleOutput {
	return o
}

func (o RuleExtractRuleOutput) ToRuleExtractRuleOutputWithContext(ctx context.Context) RuleExtractRuleOutput {
	return o
}

func (o RuleExtractRuleOutput) ToRuleExtractRulePtrOutput() RuleExtractRulePtrOutput {
	return o.ToRuleExtractRulePtrOutputWithContext(context.Background())
}

func (o RuleExtractRuleOutput) ToRuleExtractRulePtrOutputWithContext(ctx context.Context) RuleExtractRulePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleExtractRule) *RuleExtractRule {
		return &v
	}).(RuleExtractRulePtrOutput)
}

// The first log line needs to match the regular expression.
func (o RuleExtractRuleOutput) BeginRegex() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleExtractRule) *string { return v.BeginRegex }).(pulumi.StringPtrOutput)
}

// The delimiter of the log.
func (o RuleExtractRuleOutput) Delimiter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleExtractRule) *string { return v.Delimiter }).(pulumi.StringPtrOutput)
}

// The filter key list.
func (o RuleExtractRuleOutput) FilterKeyRegexes() RuleExtractRuleFilterKeyRegexArrayOutput {
	return o.ApplyT(func(v RuleExtractRule) []RuleExtractRuleFilterKeyRegex { return v.FilterKeyRegexes }).(RuleExtractRuleFilterKeyRegexArrayOutput)
}

// A list of log field names (Key).
func (o RuleExtractRuleOutput) Keys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v RuleExtractRule) []string { return v.Keys }).(pulumi.StringArrayOutput)
}

// The entire log needs to match the regular expression.
func (o RuleExtractRuleOutput) LogRegex() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleExtractRule) *string { return v.LogRegex }).(pulumi.StringPtrOutput)
}

// Automatically extract log fields according to the specified log template.
func (o RuleExtractRuleOutput) LogTemplate() RuleExtractRuleLogTemplatePtrOutput {
	return o.ApplyT(func(v RuleExtractRule) *RuleExtractRuleLogTemplate { return v.LogTemplate }).(RuleExtractRuleLogTemplatePtrOutput)
}

// Parsing format of the time field.
func (o RuleExtractRuleOutput) TimeFormat() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleExtractRule) *string { return v.TimeFormat }).(pulumi.StringPtrOutput)
}

// The field name of the log time field.
func (o RuleExtractRuleOutput) TimeKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleExtractRule) *string { return v.TimeKey }).(pulumi.StringPtrOutput)
}

// When uploading the failed log, the key name of the failed log.
func (o RuleExtractRuleOutput) UnMatchLogKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleExtractRule) *string { return v.UnMatchLogKey }).(pulumi.StringPtrOutput)
}

// Whether to upload the log of parsing failure.
func (o RuleExtractRuleOutput) UnMatchUpLoadSwitch() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v RuleExtractRule) *bool { return v.UnMatchUpLoadSwitch }).(pulumi.BoolPtrOutput)
}

type RuleExtractRulePtrOutput struct{ *pulumi.OutputState }

func (RuleExtractRulePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleExtractRule)(nil)).Elem()
}

func (o RuleExtractRulePtrOutput) ToRuleExtractRulePtrOutput() RuleExtractRulePtrOutput {
	return o
}

func (o RuleExtractRulePtrOutput) ToRuleExtractRulePtrOutputWithContext(ctx context.Context) RuleExtractRulePtrOutput {
	return o
}

func (o RuleExtractRulePtrOutput) Elem() RuleExtractRuleOutput {
	return o.ApplyT(func(v *RuleExtractRule) RuleExtractRule {
		if v != nil {
			return *v
		}
		var ret RuleExtractRule
		return ret
	}).(RuleExtractRuleOutput)
}

// The first log line needs to match the regular expression.
func (o RuleExtractRulePtrOutput) BeginRegex() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RuleExtractRule) *string {
		if v == nil {
			return nil
		}
		return v.BeginRegex
	}).(pulumi.StringPtrOutput)
}

// The delimiter of the log.
func (o RuleExtractRulePtrOutput) Delimiter() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RuleExtractRule) *string {
		if v == nil {
			return nil
		}
		return v.Delimiter
	}).(pulumi.StringPtrOutput)
}

// The filter key list.
func (o RuleExtractRulePtrOutput) FilterKeyRegexes() RuleExtractRuleFilterKeyRegexArrayOutput {
	return o.ApplyT(func(v *RuleExtractRule) []RuleExtractRuleFilterKeyRegex {
		if v == nil {
			return nil
		}
		return v.FilterKeyRegexes
	}).(RuleExtractRuleFilterKeyRegexArrayOutput)
}

// A list of log field names (Key).
func (o RuleExtractRulePtrOutput) Keys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *RuleExtractRule) []string {
		if v == nil {
			return nil
		}
		return v.Keys
	}).(pulumi.StringArrayOutput)
}

// The entire log needs to match the regular expression.
func (o RuleExtractRulePtrOutput) LogRegex() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RuleExtractRule) *string {
		if v == nil {
			return nil
		}
		return v.LogRegex
	}).(pulumi.StringPtrOutput)
}

// Automatically extract log fields according to the specified log template.
func (o RuleExtractRulePtrOutput) LogTemplate() RuleExtractRuleLogTemplatePtrOutput {
	return o.ApplyT(func(v *RuleExtractRule) *RuleExtractRuleLogTemplate {
		if v == nil {
			return nil
		}
		return v.LogTemplate
	}).(RuleExtractRuleLogTemplatePtrOutput)
}

// Parsing format of the time field.
func (o RuleExtractRulePtrOutput) TimeFormat() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RuleExtractRule) *string {
		if v == nil {
			return nil
		}
		return v.TimeFormat
	}).(pulumi.StringPtrOutput)
}

// The field name of the log time field.
func (o RuleExtractRulePtrOutput) TimeKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RuleExtractRule) *string {
		if v == nil {
			return nil
		}
		return v.TimeKey
	}).(pulumi.StringPtrOutput)
}

// When uploading the failed log, the key name of the failed log.
func (o RuleExtractRulePtrOutput) UnMatchLogKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RuleExtractRule) *string {
		if v == nil {
			return nil
		}
		return v.UnMatchLogKey
	}).(pulumi.StringPtrOutput)
}

// Whether to upload the log of parsing failure.
func (o RuleExtractRulePtrOutput) UnMatchUpLoadSwitch() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *RuleExtractRule) *bool {
		if v == nil {
			return nil
		}
		return v.UnMatchUpLoadSwitch
	}).(pulumi.BoolPtrOutput)
}

type RuleExtractRuleFilterKeyRegex struct {
	// The name of the filter key.
	Key string `pulumi:"key"`
	// The log content of the filter field needs to match the regular expression.
	Regex string `pulumi:"regex"`
}

// RuleExtractRuleFilterKeyRegexInput is an input type that accepts RuleExtractRuleFilterKeyRegexArgs and RuleExtractRuleFilterKeyRegexOutput values.
// You can construct a concrete instance of `RuleExtractRuleFilterKeyRegexInput` via:
//
//	RuleExtractRuleFilterKeyRegexArgs{...}
type RuleExtractRuleFilterKeyRegexInput interface {
	pulumi.Input

	ToRuleExtractRuleFilterKeyRegexOutput() RuleExtractRuleFilterKeyRegexOutput
	ToRuleExtractRuleFilterKeyRegexOutputWithContext(context.Context) RuleExtractRuleFilterKeyRegexOutput
}

type RuleExtractRuleFilterKeyRegexArgs struct {
	// The name of the filter key.
	Key pulumi.StringInput `pulumi:"key"`
	// The log content of the filter field needs to match the regular expression.
	Regex pulumi.StringInput `pulumi:"regex"`
}

func (RuleExtractRuleFilterKeyRegexArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleExtractRuleFilterKeyRegex)(nil)).Elem()
}

func (i RuleExtractRuleFilterKeyRegexArgs) ToRuleExtractRuleFilterKeyRegexOutput() RuleExtractRuleFilterKeyRegexOutput {
	return i.ToRuleExtractRuleFilterKeyRegexOutputWithContext(context.Background())
}

func (i RuleExtractRuleFilterKeyRegexArgs) ToRuleExtractRuleFilterKeyRegexOutputWithContext(ctx context.Context) RuleExtractRuleFilterKeyRegexOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleExtractRuleFilterKeyRegexOutput)
}

// RuleExtractRuleFilterKeyRegexArrayInput is an input type that accepts RuleExtractRuleFilterKeyRegexArray and RuleExtractRuleFilterKeyRegexArrayOutput values.
// You can construct a concrete instance of `RuleExtractRuleFilterKeyRegexArrayInput` via:
//
//	RuleExtractRuleFilterKeyRegexArray{ RuleExtractRuleFilterKeyRegexArgs{...} }
type RuleExtractRuleFilterKeyRegexArrayInput interface {
	pulumi.Input

	ToRuleExtractRuleFilterKeyRegexArrayOutput() RuleExtractRuleFilterKeyRegexArrayOutput
	ToRuleExtractRuleFilterKeyRegexArrayOutputWithContext(context.Context) RuleExtractRuleFilterKeyRegexArrayOutput
}

type RuleExtractRuleFilterKeyRegexArray []RuleExtractRuleFilterKeyRegexInput

func (RuleExtractRuleFilterKeyRegexArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleExtractRuleFilterKeyRegex)(nil)).Elem()
}

func (i RuleExtractRuleFilterKeyRegexArray) ToRuleExtractRuleFilterKeyRegexArrayOutput() RuleExtractRuleFilterKeyRegexArrayOutput {
	return i.ToRuleExtractRuleFilterKeyRegexArrayOutputWithContext(context.Background())
}

func (i RuleExtractRuleFilterKeyRegexArray) ToRuleExtractRuleFilterKeyRegexArrayOutputWithContext(ctx context.Context) RuleExtractRuleFilterKeyRegexArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleExtractRuleFilterKeyRegexArrayOutput)
}

type RuleExtractRuleFilterKeyRegexOutput struct{ *pulumi.OutputState }

func (RuleExtractRuleFilterKeyRegexOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleExtractRuleFilterKeyRegex)(nil)).Elem()
}

func (o RuleExtractRuleFilterKeyRegexOutput) ToRuleExtractRuleFilterKeyRegexOutput() RuleExtractRuleFilterKeyRegexOutput {
	return o
}

func (o RuleExtractRuleFilterKeyRegexOutput) ToRuleExtractRuleFilterKeyRegexOutputWithContext(ctx context.Context) RuleExtractRuleFilterKeyRegexOutput {
	return o
}

// The name of the filter key.
func (o RuleExtractRuleFilterKeyRegexOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v RuleExtractRuleFilterKeyRegex) string { return v.Key }).(pulumi.StringOutput)
}

// The log content of the filter field needs to match the regular expression.
func (o RuleExtractRuleFilterKeyRegexOutput) Regex() pulumi.StringOutput {
	return o.ApplyT(func(v RuleExtractRuleFilterKeyRegex) string { return v.Regex }).(pulumi.StringOutput)
}

type RuleExtractRuleFilterKeyRegexArrayOutput struct{ *pulumi.OutputState }

func (RuleExtractRuleFilterKeyRegexArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleExtractRuleFilterKeyRegex)(nil)).Elem()
}

func (o RuleExtractRuleFilterKeyRegexArrayOutput) ToRuleExtractRuleFilterKeyRegexArrayOutput() RuleExtractRuleFilterKeyRegexArrayOutput {
	return o
}

func (o RuleExtractRuleFilterKeyRegexArrayOutput) ToRuleExtractRuleFilterKeyRegexArrayOutputWithContext(ctx context.Context) RuleExtractRuleFilterKeyRegexArrayOutput {
	return o
}

func (o RuleExtractRuleFilterKeyRegexArrayOutput) Index(i pulumi.IntInput) RuleExtractRuleFilterKeyRegexOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RuleExtractRuleFilterKeyRegex {
		return vs[0].([]RuleExtractRuleFilterKeyRegex)[vs[1].(int)]
	}).(RuleExtractRuleFilterKeyRegexOutput)
}

type RuleExtractRuleLogTemplate struct {
	// Log template content.
	Format string `pulumi:"format"`
	// The type of the log template.
	Type string `pulumi:"type"`
}

// RuleExtractRuleLogTemplateInput is an input type that accepts RuleExtractRuleLogTemplateArgs and RuleExtractRuleLogTemplateOutput values.
// You can construct a concrete instance of `RuleExtractRuleLogTemplateInput` via:
//
//	RuleExtractRuleLogTemplateArgs{...}
type RuleExtractRuleLogTemplateInput interface {
	pulumi.Input

	ToRuleExtractRuleLogTemplateOutput() RuleExtractRuleLogTemplateOutput
	ToRuleExtractRuleLogTemplateOutputWithContext(context.Context) RuleExtractRuleLogTemplateOutput
}

type RuleExtractRuleLogTemplateArgs struct {
	// Log template content.
	Format pulumi.StringInput `pulumi:"format"`
	// The type of the log template.
	Type pulumi.StringInput `pulumi:"type"`
}

func (RuleExtractRuleLogTemplateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleExtractRuleLogTemplate)(nil)).Elem()
}

func (i RuleExtractRuleLogTemplateArgs) ToRuleExtractRuleLogTemplateOutput() RuleExtractRuleLogTemplateOutput {
	return i.ToRuleExtractRuleLogTemplateOutputWithContext(context.Background())
}

func (i RuleExtractRuleLogTemplateArgs) ToRuleExtractRuleLogTemplateOutputWithContext(ctx context.Context) RuleExtractRuleLogTemplateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleExtractRuleLogTemplateOutput)
}

func (i RuleExtractRuleLogTemplateArgs) ToRuleExtractRuleLogTemplatePtrOutput() RuleExtractRuleLogTemplatePtrOutput {
	return i.ToRuleExtractRuleLogTemplatePtrOutputWithContext(context.Background())
}

func (i RuleExtractRuleLogTemplateArgs) ToRuleExtractRuleLogTemplatePtrOutputWithContext(ctx context.Context) RuleExtractRuleLogTemplatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleExtractRuleLogTemplateOutput).ToRuleExtractRuleLogTemplatePtrOutputWithContext(ctx)
}

// RuleExtractRuleLogTemplatePtrInput is an input type that accepts RuleExtractRuleLogTemplateArgs, RuleExtractRuleLogTemplatePtr and RuleExtractRuleLogTemplatePtrOutput values.
// You can construct a concrete instance of `RuleExtractRuleLogTemplatePtrInput` via:
//
//	        RuleExtractRuleLogTemplateArgs{...}
//
//	or:
//
//	        nil
type RuleExtractRuleLogTemplatePtrInput interface {
	pulumi.Input

	ToRuleExtractRuleLogTemplatePtrOutput() RuleExtractRuleLogTemplatePtrOutput
	ToRuleExtractRuleLogTemplatePtrOutputWithContext(context.Context) RuleExtractRuleLogTemplatePtrOutput
}

type ruleExtractRuleLogTemplatePtrType RuleExtractRuleLogTemplateArgs

func RuleExtractRuleLogTemplatePtr(v *RuleExtractRuleLogTemplateArgs) RuleExtractRuleLogTemplatePtrInput {
	return (*ruleExtractRuleLogTemplatePtrType)(v)
}

func (*ruleExtractRuleLogTemplatePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleExtractRuleLogTemplate)(nil)).Elem()
}

func (i *ruleExtractRuleLogTemplatePtrType) ToRuleExtractRuleLogTemplatePtrOutput() RuleExtractRuleLogTemplatePtrOutput {
	return i.ToRuleExtractRuleLogTemplatePtrOutputWithContext(context.Background())
}

func (i *ruleExtractRuleLogTemplatePtrType) ToRuleExtractRuleLogTemplatePtrOutputWithContext(ctx context.Context) RuleExtractRuleLogTemplatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleExtractRuleLogTemplatePtrOutput)
}

type RuleExtractRuleLogTemplateOutput struct{ *pulumi.OutputState }

func (RuleExtractRuleLogTemplateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleExtractRuleLogTemplate)(nil)).Elem()
}

func (o RuleExtractRuleLogTemplateOutput) ToRuleExtractRuleLogTemplateOutput() RuleExtractRuleLogTemplateOutput {
	return o
}

func (o RuleExtractRuleLogTemplateOutput) ToRuleExtractRuleLogTemplateOutputWithContext(ctx context.Context) RuleExtractRuleLogTemplateOutput {
	return o
}

func (o RuleExtractRuleLogTemplateOutput) ToRuleExtractRuleLogTemplatePtrOutput() RuleExtractRuleLogTemplatePtrOutput {
	return o.ToRuleExtractRuleLogTemplatePtrOutputWithContext(context.Background())
}

func (o RuleExtractRuleLogTemplateOutput) ToRuleExtractRuleLogTemplatePtrOutputWithContext(ctx context.Context) RuleExtractRuleLogTemplatePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleExtractRuleLogTemplate) *RuleExtractRuleLogTemplate {
		return &v
	}).(RuleExtractRuleLogTemplatePtrOutput)
}

// Log template content.
func (o RuleExtractRuleLogTemplateOutput) Format() pulumi.StringOutput {
	return o.ApplyT(func(v RuleExtractRuleLogTemplate) string { return v.Format }).(pulumi.StringOutput)
}

// The type of the log template.
func (o RuleExtractRuleLogTemplateOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v RuleExtractRuleLogTemplate) string { return v.Type }).(pulumi.StringOutput)
}

type RuleExtractRuleLogTemplatePtrOutput struct{ *pulumi.OutputState }

func (RuleExtractRuleLogTemplatePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleExtractRuleLogTemplate)(nil)).Elem()
}

func (o RuleExtractRuleLogTemplatePtrOutput) ToRuleExtractRuleLogTemplatePtrOutput() RuleExtractRuleLogTemplatePtrOutput {
	return o
}

func (o RuleExtractRuleLogTemplatePtrOutput) ToRuleExtractRuleLogTemplatePtrOutputWithContext(ctx context.Context) RuleExtractRuleLogTemplatePtrOutput {
	return o
}

func (o RuleExtractRuleLogTemplatePtrOutput) Elem() RuleExtractRuleLogTemplateOutput {
	return o.ApplyT(func(v *RuleExtractRuleLogTemplate) RuleExtractRuleLogTemplate {
		if v != nil {
			return *v
		}
		var ret RuleExtractRuleLogTemplate
		return ret
	}).(RuleExtractRuleLogTemplateOutput)
}

// Log template content.
func (o RuleExtractRuleLogTemplatePtrOutput) Format() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RuleExtractRuleLogTemplate) *string {
		if v == nil {
			return nil
		}
		return &v.Format
	}).(pulumi.StringPtrOutput)
}

// The type of the log template.
func (o RuleExtractRuleLogTemplatePtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RuleExtractRuleLogTemplate) *string {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(pulumi.StringPtrOutput)
}

type RuleUserDefineRule struct {
	// LogCollector extension configuration.
	Advanced *RuleUserDefineRuleAdvanced `pulumi:"advanced"`
	// Whether to upload raw logs.
	EnableRawLog *bool `pulumi:"enableRawLog"`
	// Add constant fields to logs.
	Fields map[string]string `pulumi:"fields"`
	// Rules for parsing collection paths. After the rules are set, the fields in the collection path will be extracted through the regular expressions specified in the rules, and added to the log data as metadata.
	ParsePathRule *RuleUserDefineRuleParsePathRule `pulumi:"parsePathRule"`
	// Plugin configuration. After the plugin configuration is enabled, one or more LogCollector processor plugins can be added to parse logs with complex or variable structures.
	Plugin *RuleUserDefineRulePlugin `pulumi:"plugin"`
	// Rules for routing log partitions. Setting this parameter indicates that the HashKey routing shard mode is used when collecting logs, and Log Service will write the data to the shard containing the specified Key value.
	ShardHashKey *RuleUserDefineRuleShardHashKey `pulumi:"shardHashKey"`
	// LogCollector collection strategy, which specifies whether LogCollector collects incremental logs or full logs. The default is false, which means to collect all logs.
	TailFiles *bool `pulumi:"tailFiles"`
}

// RuleUserDefineRuleInput is an input type that accepts RuleUserDefineRuleArgs and RuleUserDefineRuleOutput values.
// You can construct a concrete instance of `RuleUserDefineRuleInput` via:
//
//	RuleUserDefineRuleArgs{...}
type RuleUserDefineRuleInput interface {
	pulumi.Input

	ToRuleUserDefineRuleOutput() RuleUserDefineRuleOutput
	ToRuleUserDefineRuleOutputWithContext(context.Context) RuleUserDefineRuleOutput
}

type RuleUserDefineRuleArgs struct {
	// LogCollector extension configuration.
	Advanced RuleUserDefineRuleAdvancedPtrInput `pulumi:"advanced"`
	// Whether to upload raw logs.
	EnableRawLog pulumi.BoolPtrInput `pulumi:"enableRawLog"`
	// Add constant fields to logs.
	Fields pulumi.StringMapInput `pulumi:"fields"`
	// Rules for parsing collection paths. After the rules are set, the fields in the collection path will be extracted through the regular expressions specified in the rules, and added to the log data as metadata.
	ParsePathRule RuleUserDefineRuleParsePathRulePtrInput `pulumi:"parsePathRule"`
	// Plugin configuration. After the plugin configuration is enabled, one or more LogCollector processor plugins can be added to parse logs with complex or variable structures.
	Plugin RuleUserDefineRulePluginPtrInput `pulumi:"plugin"`
	// Rules for routing log partitions. Setting this parameter indicates that the HashKey routing shard mode is used when collecting logs, and Log Service will write the data to the shard containing the specified Key value.
	ShardHashKey RuleUserDefineRuleShardHashKeyPtrInput `pulumi:"shardHashKey"`
	// LogCollector collection strategy, which specifies whether LogCollector collects incremental logs or full logs. The default is false, which means to collect all logs.
	TailFiles pulumi.BoolPtrInput `pulumi:"tailFiles"`
}

func (RuleUserDefineRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleUserDefineRule)(nil)).Elem()
}

func (i RuleUserDefineRuleArgs) ToRuleUserDefineRuleOutput() RuleUserDefineRuleOutput {
	return i.ToRuleUserDefineRuleOutputWithContext(context.Background())
}

func (i RuleUserDefineRuleArgs) ToRuleUserDefineRuleOutputWithContext(ctx context.Context) RuleUserDefineRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleUserDefineRuleOutput)
}

func (i RuleUserDefineRuleArgs) ToRuleUserDefineRulePtrOutput() RuleUserDefineRulePtrOutput {
	return i.ToRuleUserDefineRulePtrOutputWithContext(context.Background())
}

func (i RuleUserDefineRuleArgs) ToRuleUserDefineRulePtrOutputWithContext(ctx context.Context) RuleUserDefineRulePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleUserDefineRuleOutput).ToRuleUserDefineRulePtrOutputWithContext(ctx)
}

// RuleUserDefineRulePtrInput is an input type that accepts RuleUserDefineRuleArgs, RuleUserDefineRulePtr and RuleUserDefineRulePtrOutput values.
// You can construct a concrete instance of `RuleUserDefineRulePtrInput` via:
//
//	        RuleUserDefineRuleArgs{...}
//
//	or:
//
//	        nil
type RuleUserDefineRulePtrInput interface {
	pulumi.Input

	ToRuleUserDefineRulePtrOutput() RuleUserDefineRulePtrOutput
	ToRuleUserDefineRulePtrOutputWithContext(context.Context) RuleUserDefineRulePtrOutput
}

type ruleUserDefineRulePtrType RuleUserDefineRuleArgs

func RuleUserDefineRulePtr(v *RuleUserDefineRuleArgs) RuleUserDefineRulePtrInput {
	return (*ruleUserDefineRulePtrType)(v)
}

func (*ruleUserDefineRulePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleUserDefineRule)(nil)).Elem()
}

func (i *ruleUserDefineRulePtrType) ToRuleUserDefineRulePtrOutput() RuleUserDefineRulePtrOutput {
	return i.ToRuleUserDefineRulePtrOutputWithContext(context.Background())
}

func (i *ruleUserDefineRulePtrType) ToRuleUserDefineRulePtrOutputWithContext(ctx context.Context) RuleUserDefineRulePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleUserDefineRulePtrOutput)
}

type RuleUserDefineRuleOutput struct{ *pulumi.OutputState }

func (RuleUserDefineRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleUserDefineRule)(nil)).Elem()
}

func (o RuleUserDefineRuleOutput) ToRuleUserDefineRuleOutput() RuleUserDefineRuleOutput {
	return o
}

func (o RuleUserDefineRuleOutput) ToRuleUserDefineRuleOutputWithContext(ctx context.Context) RuleUserDefineRuleOutput {
	return o
}

func (o RuleUserDefineRuleOutput) ToRuleUserDefineRulePtrOutput() RuleUserDefineRulePtrOutput {
	return o.ToRuleUserDefineRulePtrOutputWithContext(context.Background())
}

func (o RuleUserDefineRuleOutput) ToRuleUserDefineRulePtrOutputWithContext(ctx context.Context) RuleUserDefineRulePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleUserDefineRule) *RuleUserDefineRule {
		return &v
	}).(RuleUserDefineRulePtrOutput)
}

// LogCollector extension configuration.
func (o RuleUserDefineRuleOutput) Advanced() RuleUserDefineRuleAdvancedPtrOutput {
	return o.ApplyT(func(v RuleUserDefineRule) *RuleUserDefineRuleAdvanced { return v.Advanced }).(RuleUserDefineRuleAdvancedPtrOutput)
}

// Whether to upload raw logs.
func (o RuleUserDefineRuleOutput) EnableRawLog() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v RuleUserDefineRule) *bool { return v.EnableRawLog }).(pulumi.BoolPtrOutput)
}

// Add constant fields to logs.
func (o RuleUserDefineRuleOutput) Fields() pulumi.StringMapOutput {
	return o.ApplyT(func(v RuleUserDefineRule) map[string]string { return v.Fields }).(pulumi.StringMapOutput)
}

// Rules for parsing collection paths. After the rules are set, the fields in the collection path will be extracted through the regular expressions specified in the rules, and added to the log data as metadata.
func (o RuleUserDefineRuleOutput) ParsePathRule() RuleUserDefineRuleParsePathRulePtrOutput {
	return o.ApplyT(func(v RuleUserDefineRule) *RuleUserDefineRuleParsePathRule { return v.ParsePathRule }).(RuleUserDefineRuleParsePathRulePtrOutput)
}

// Plugin configuration. After the plugin configuration is enabled, one or more LogCollector processor plugins can be added to parse logs with complex or variable structures.
func (o RuleUserDefineRuleOutput) Plugin() RuleUserDefineRulePluginPtrOutput {
	return o.ApplyT(func(v RuleUserDefineRule) *RuleUserDefineRulePlugin { return v.Plugin }).(RuleUserDefineRulePluginPtrOutput)
}

// Rules for routing log partitions. Setting this parameter indicates that the HashKey routing shard mode is used when collecting logs, and Log Service will write the data to the shard containing the specified Key value.
func (o RuleUserDefineRuleOutput) ShardHashKey() RuleUserDefineRuleShardHashKeyPtrOutput {
	return o.ApplyT(func(v RuleUserDefineRule) *RuleUserDefineRuleShardHashKey { return v.ShardHashKey }).(RuleUserDefineRuleShardHashKeyPtrOutput)
}

// LogCollector collection strategy, which specifies whether LogCollector collects incremental logs or full logs. The default is false, which means to collect all logs.
func (o RuleUserDefineRuleOutput) TailFiles() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v RuleUserDefineRule) *bool { return v.TailFiles }).(pulumi.BoolPtrOutput)
}

type RuleUserDefineRulePtrOutput struct{ *pulumi.OutputState }

func (RuleUserDefineRulePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleUserDefineRule)(nil)).Elem()
}

func (o RuleUserDefineRulePtrOutput) ToRuleUserDefineRulePtrOutput() RuleUserDefineRulePtrOutput {
	return o
}

func (o RuleUserDefineRulePtrOutput) ToRuleUserDefineRulePtrOutputWithContext(ctx context.Context) RuleUserDefineRulePtrOutput {
	return o
}

func (o RuleUserDefineRulePtrOutput) Elem() RuleUserDefineRuleOutput {
	return o.ApplyT(func(v *RuleUserDefineRule) RuleUserDefineRule {
		if v != nil {
			return *v
		}
		var ret RuleUserDefineRule
		return ret
	}).(RuleUserDefineRuleOutput)
}

// LogCollector extension configuration.
func (o RuleUserDefineRulePtrOutput) Advanced() RuleUserDefineRuleAdvancedPtrOutput {
	return o.ApplyT(func(v *RuleUserDefineRule) *RuleUserDefineRuleAdvanced {
		if v == nil {
			return nil
		}
		return v.Advanced
	}).(RuleUserDefineRuleAdvancedPtrOutput)
}

// Whether to upload raw logs.
func (o RuleUserDefineRulePtrOutput) EnableRawLog() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *RuleUserDefineRule) *bool {
		if v == nil {
			return nil
		}
		return v.EnableRawLog
	}).(pulumi.BoolPtrOutput)
}

// Add constant fields to logs.
func (o RuleUserDefineRulePtrOutput) Fields() pulumi.StringMapOutput {
	return o.ApplyT(func(v *RuleUserDefineRule) map[string]string {
		if v == nil {
			return nil
		}
		return v.Fields
	}).(pulumi.StringMapOutput)
}

// Rules for parsing collection paths. After the rules are set, the fields in the collection path will be extracted through the regular expressions specified in the rules, and added to the log data as metadata.
func (o RuleUserDefineRulePtrOutput) ParsePathRule() RuleUserDefineRuleParsePathRulePtrOutput {
	return o.ApplyT(func(v *RuleUserDefineRule) *RuleUserDefineRuleParsePathRule {
		if v == nil {
			return nil
		}
		return v.ParsePathRule
	}).(RuleUserDefineRuleParsePathRulePtrOutput)
}

// Plugin configuration. After the plugin configuration is enabled, one or more LogCollector processor plugins can be added to parse logs with complex or variable structures.
func (o RuleUserDefineRulePtrOutput) Plugin() RuleUserDefineRulePluginPtrOutput {
	return o.ApplyT(func(v *RuleUserDefineRule) *RuleUserDefineRulePlugin {
		if v == nil {
			return nil
		}
		return v.Plugin
	}).(RuleUserDefineRulePluginPtrOutput)
}

// Rules for routing log partitions. Setting this parameter indicates that the HashKey routing shard mode is used when collecting logs, and Log Service will write the data to the shard containing the specified Key value.
func (o RuleUserDefineRulePtrOutput) ShardHashKey() RuleUserDefineRuleShardHashKeyPtrOutput {
	return o.ApplyT(func(v *RuleUserDefineRule) *RuleUserDefineRuleShardHashKey {
		if v == nil {
			return nil
		}
		return v.ShardHashKey
	}).(RuleUserDefineRuleShardHashKeyPtrOutput)
}

// LogCollector collection strategy, which specifies whether LogCollector collects incremental logs or full logs. The default is false, which means to collect all logs.
func (o RuleUserDefineRulePtrOutput) TailFiles() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *RuleUserDefineRule) *bool {
		if v == nil {
			return nil
		}
		return v.TailFiles
	}).(pulumi.BoolPtrOutput)
}

type RuleUserDefineRuleAdvanced struct {
	// Whether to release the log file handle after reading to the end of the log file. The default is false.
	CloseEof *bool `pulumi:"closeEof"`
	// The wait time to release the log file handle. When the log file has not written a new log for more than the specified time, release the handle of the log file.
	CloseInactive *int `pulumi:"closeInactive"`
	// After the log file is removed, whether to release the handle of the log file. The default is false.
	CloseRemoved *bool `pulumi:"closeRemoved"`
	// After the log file is renamed, whether to release the handle of the log file. The default is false.
	CloseRenamed *bool `pulumi:"closeRenamed"`
	// The maximum length of time that LogCollector monitors log files. The unit is seconds, and the default is 0 seconds, which means that there is no limit to the length of time LogCollector monitors log files.
	CloseTimeout *int `pulumi:"closeTimeout"`
}

// RuleUserDefineRuleAdvancedInput is an input type that accepts RuleUserDefineRuleAdvancedArgs and RuleUserDefineRuleAdvancedOutput values.
// You can construct a concrete instance of `RuleUserDefineRuleAdvancedInput` via:
//
//	RuleUserDefineRuleAdvancedArgs{...}
type RuleUserDefineRuleAdvancedInput interface {
	pulumi.Input

	ToRuleUserDefineRuleAdvancedOutput() RuleUserDefineRuleAdvancedOutput
	ToRuleUserDefineRuleAdvancedOutputWithContext(context.Context) RuleUserDefineRuleAdvancedOutput
}

type RuleUserDefineRuleAdvancedArgs struct {
	// Whether to release the log file handle after reading to the end of the log file. The default is false.
	CloseEof pulumi.BoolPtrInput `pulumi:"closeEof"`
	// The wait time to release the log file handle. When the log file has not written a new log for more than the specified time, release the handle of the log file.
	CloseInactive pulumi.IntPtrInput `pulumi:"closeInactive"`
	// After the log file is removed, whether to release the handle of the log file. The default is false.
	CloseRemoved pulumi.BoolPtrInput `pulumi:"closeRemoved"`
	// After the log file is renamed, whether to release the handle of the log file. The default is false.
	CloseRenamed pulumi.BoolPtrInput `pulumi:"closeRenamed"`
	// The maximum length of time that LogCollector monitors log files. The unit is seconds, and the default is 0 seconds, which means that there is no limit to the length of time LogCollector monitors log files.
	CloseTimeout pulumi.IntPtrInput `pulumi:"closeTimeout"`
}

func (RuleUserDefineRuleAdvancedArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleUserDefineRuleAdvanced)(nil)).Elem()
}

func (i RuleUserDefineRuleAdvancedArgs) ToRuleUserDefineRuleAdvancedOutput() RuleUserDefineRuleAdvancedOutput {
	return i.ToRuleUserDefineRuleAdvancedOutputWithContext(context.Background())
}

func (i RuleUserDefineRuleAdvancedArgs) ToRuleUserDefineRuleAdvancedOutputWithContext(ctx context.Context) RuleUserDefineRuleAdvancedOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleUserDefineRuleAdvancedOutput)
}

func (i RuleUserDefineRuleAdvancedArgs) ToRuleUserDefineRuleAdvancedPtrOutput() RuleUserDefineRuleAdvancedPtrOutput {
	return i.ToRuleUserDefineRuleAdvancedPtrOutputWithContext(context.Background())
}

func (i RuleUserDefineRuleAdvancedArgs) ToRuleUserDefineRuleAdvancedPtrOutputWithContext(ctx context.Context) RuleUserDefineRuleAdvancedPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleUserDefineRuleAdvancedOutput).ToRuleUserDefineRuleAdvancedPtrOutputWithContext(ctx)
}

// RuleUserDefineRuleAdvancedPtrInput is an input type that accepts RuleUserDefineRuleAdvancedArgs, RuleUserDefineRuleAdvancedPtr and RuleUserDefineRuleAdvancedPtrOutput values.
// You can construct a concrete instance of `RuleUserDefineRuleAdvancedPtrInput` via:
//
//	        RuleUserDefineRuleAdvancedArgs{...}
//
//	or:
//
//	        nil
type RuleUserDefineRuleAdvancedPtrInput interface {
	pulumi.Input

	ToRuleUserDefineRuleAdvancedPtrOutput() RuleUserDefineRuleAdvancedPtrOutput
	ToRuleUserDefineRuleAdvancedPtrOutputWithContext(context.Context) RuleUserDefineRuleAdvancedPtrOutput
}

type ruleUserDefineRuleAdvancedPtrType RuleUserDefineRuleAdvancedArgs

func RuleUserDefineRuleAdvancedPtr(v *RuleUserDefineRuleAdvancedArgs) RuleUserDefineRuleAdvancedPtrInput {
	return (*ruleUserDefineRuleAdvancedPtrType)(v)
}

func (*ruleUserDefineRuleAdvancedPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleUserDefineRuleAdvanced)(nil)).Elem()
}

func (i *ruleUserDefineRuleAdvancedPtrType) ToRuleUserDefineRuleAdvancedPtrOutput() RuleUserDefineRuleAdvancedPtrOutput {
	return i.ToRuleUserDefineRuleAdvancedPtrOutputWithContext(context.Background())
}

func (i *ruleUserDefineRuleAdvancedPtrType) ToRuleUserDefineRuleAdvancedPtrOutputWithContext(ctx context.Context) RuleUserDefineRuleAdvancedPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleUserDefineRuleAdvancedPtrOutput)
}

type RuleUserDefineRuleAdvancedOutput struct{ *pulumi.OutputState }

func (RuleUserDefineRuleAdvancedOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleUserDefineRuleAdvanced)(nil)).Elem()
}

func (o RuleUserDefineRuleAdvancedOutput) ToRuleUserDefineRuleAdvancedOutput() RuleUserDefineRuleAdvancedOutput {
	return o
}

func (o RuleUserDefineRuleAdvancedOutput) ToRuleUserDefineRuleAdvancedOutputWithContext(ctx context.Context) RuleUserDefineRuleAdvancedOutput {
	return o
}

func (o RuleUserDefineRuleAdvancedOutput) ToRuleUserDefineRuleAdvancedPtrOutput() RuleUserDefineRuleAdvancedPtrOutput {
	return o.ToRuleUserDefineRuleAdvancedPtrOutputWithContext(context.Background())
}

func (o RuleUserDefineRuleAdvancedOutput) ToRuleUserDefineRuleAdvancedPtrOutputWithContext(ctx context.Context) RuleUserDefineRuleAdvancedPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleUserDefineRuleAdvanced) *RuleUserDefineRuleAdvanced {
		return &v
	}).(RuleUserDefineRuleAdvancedPtrOutput)
}

// Whether to release the log file handle after reading to the end of the log file. The default is false.
func (o RuleUserDefineRuleAdvancedOutput) CloseEof() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v RuleUserDefineRuleAdvanced) *bool { return v.CloseEof }).(pulumi.BoolPtrOutput)
}

// The wait time to release the log file handle. When the log file has not written a new log for more than the specified time, release the handle of the log file.
func (o RuleUserDefineRuleAdvancedOutput) CloseInactive() pulumi.IntPtrOutput {
	return o.ApplyT(func(v RuleUserDefineRuleAdvanced) *int { return v.CloseInactive }).(pulumi.IntPtrOutput)
}

// After the log file is removed, whether to release the handle of the log file. The default is false.
func (o RuleUserDefineRuleAdvancedOutput) CloseRemoved() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v RuleUserDefineRuleAdvanced) *bool { return v.CloseRemoved }).(pulumi.BoolPtrOutput)
}

// After the log file is renamed, whether to release the handle of the log file. The default is false.
func (o RuleUserDefineRuleAdvancedOutput) CloseRenamed() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v RuleUserDefineRuleAdvanced) *bool { return v.CloseRenamed }).(pulumi.BoolPtrOutput)
}

// The maximum length of time that LogCollector monitors log files. The unit is seconds, and the default is 0 seconds, which means that there is no limit to the length of time LogCollector monitors log files.
func (o RuleUserDefineRuleAdvancedOutput) CloseTimeout() pulumi.IntPtrOutput {
	return o.ApplyT(func(v RuleUserDefineRuleAdvanced) *int { return v.CloseTimeout }).(pulumi.IntPtrOutput)
}

type RuleUserDefineRuleAdvancedPtrOutput struct{ *pulumi.OutputState }

func (RuleUserDefineRuleAdvancedPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleUserDefineRuleAdvanced)(nil)).Elem()
}

func (o RuleUserDefineRuleAdvancedPtrOutput) ToRuleUserDefineRuleAdvancedPtrOutput() RuleUserDefineRuleAdvancedPtrOutput {
	return o
}

func (o RuleUserDefineRuleAdvancedPtrOutput) ToRuleUserDefineRuleAdvancedPtrOutputWithContext(ctx context.Context) RuleUserDefineRuleAdvancedPtrOutput {
	return o
}

func (o RuleUserDefineRuleAdvancedPtrOutput) Elem() RuleUserDefineRuleAdvancedOutput {
	return o.ApplyT(func(v *RuleUserDefineRuleAdvanced) RuleUserDefineRuleAdvanced {
		if v != nil {
			return *v
		}
		var ret RuleUserDefineRuleAdvanced
		return ret
	}).(RuleUserDefineRuleAdvancedOutput)
}

// Whether to release the log file handle after reading to the end of the log file. The default is false.
func (o RuleUserDefineRuleAdvancedPtrOutput) CloseEof() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *RuleUserDefineRuleAdvanced) *bool {
		if v == nil {
			return nil
		}
		return v.CloseEof
	}).(pulumi.BoolPtrOutput)
}

// The wait time to release the log file handle. When the log file has not written a new log for more than the specified time, release the handle of the log file.
func (o RuleUserDefineRuleAdvancedPtrOutput) CloseInactive() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *RuleUserDefineRuleAdvanced) *int {
		if v == nil {
			return nil
		}
		return v.CloseInactive
	}).(pulumi.IntPtrOutput)
}

// After the log file is removed, whether to release the handle of the log file. The default is false.
func (o RuleUserDefineRuleAdvancedPtrOutput) CloseRemoved() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *RuleUserDefineRuleAdvanced) *bool {
		if v == nil {
			return nil
		}
		return v.CloseRemoved
	}).(pulumi.BoolPtrOutput)
}

// After the log file is renamed, whether to release the handle of the log file. The default is false.
func (o RuleUserDefineRuleAdvancedPtrOutput) CloseRenamed() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *RuleUserDefineRuleAdvanced) *bool {
		if v == nil {
			return nil
		}
		return v.CloseRenamed
	}).(pulumi.BoolPtrOutput)
}

// The maximum length of time that LogCollector monitors log files. The unit is seconds, and the default is 0 seconds, which means that there is no limit to the length of time LogCollector monitors log files.
func (o RuleUserDefineRuleAdvancedPtrOutput) CloseTimeout() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *RuleUserDefineRuleAdvanced) *int {
		if v == nil {
			return nil
		}
		return v.CloseTimeout
	}).(pulumi.IntPtrOutput)
}

type RuleUserDefineRuleParsePathRule struct {
	// A list of field names. Log Service will parse the path sample (PathSample) into multiple fields according to the regular expression (Regex), and Keys is used to specify the field name of each field.
	Keys []string `pulumi:"keys"`
	// Sample capture path for a real scene.
	PathSample *string `pulumi:"pathSample"`
	// Regular expression for extracting path fields. It must match the collection path sample, otherwise it cannot be extracted successfully.
	Regex *string `pulumi:"regex"`
}

// RuleUserDefineRuleParsePathRuleInput is an input type that accepts RuleUserDefineRuleParsePathRuleArgs and RuleUserDefineRuleParsePathRuleOutput values.
// You can construct a concrete instance of `RuleUserDefineRuleParsePathRuleInput` via:
//
//	RuleUserDefineRuleParsePathRuleArgs{...}
type RuleUserDefineRuleParsePathRuleInput interface {
	pulumi.Input

	ToRuleUserDefineRuleParsePathRuleOutput() RuleUserDefineRuleParsePathRuleOutput
	ToRuleUserDefineRuleParsePathRuleOutputWithContext(context.Context) RuleUserDefineRuleParsePathRuleOutput
}

type RuleUserDefineRuleParsePathRuleArgs struct {
	// A list of field names. Log Service will parse the path sample (PathSample) into multiple fields according to the regular expression (Regex), and Keys is used to specify the field name of each field.
	Keys pulumi.StringArrayInput `pulumi:"keys"`
	// Sample capture path for a real scene.
	PathSample pulumi.StringPtrInput `pulumi:"pathSample"`
	// Regular expression for extracting path fields. It must match the collection path sample, otherwise it cannot be extracted successfully.
	Regex pulumi.StringPtrInput `pulumi:"regex"`
}

func (RuleUserDefineRuleParsePathRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleUserDefineRuleParsePathRule)(nil)).Elem()
}

func (i RuleUserDefineRuleParsePathRuleArgs) ToRuleUserDefineRuleParsePathRuleOutput() RuleUserDefineRuleParsePathRuleOutput {
	return i.ToRuleUserDefineRuleParsePathRuleOutputWithContext(context.Background())
}

func (i RuleUserDefineRuleParsePathRuleArgs) ToRuleUserDefineRuleParsePathRuleOutputWithContext(ctx context.Context) RuleUserDefineRuleParsePathRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleUserDefineRuleParsePathRuleOutput)
}

func (i RuleUserDefineRuleParsePathRuleArgs) ToRuleUserDefineRuleParsePathRulePtrOutput() RuleUserDefineRuleParsePathRulePtrOutput {
	return i.ToRuleUserDefineRuleParsePathRulePtrOutputWithContext(context.Background())
}

func (i RuleUserDefineRuleParsePathRuleArgs) ToRuleUserDefineRuleParsePathRulePtrOutputWithContext(ctx context.Context) RuleUserDefineRuleParsePathRulePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleUserDefineRuleParsePathRuleOutput).ToRuleUserDefineRuleParsePathRulePtrOutputWithContext(ctx)
}

// RuleUserDefineRuleParsePathRulePtrInput is an input type that accepts RuleUserDefineRuleParsePathRuleArgs, RuleUserDefineRuleParsePathRulePtr and RuleUserDefineRuleParsePathRulePtrOutput values.
// You can construct a concrete instance of `RuleUserDefineRuleParsePathRulePtrInput` via:
//
//	        RuleUserDefineRuleParsePathRuleArgs{...}
//
//	or:
//
//	        nil
type RuleUserDefineRuleParsePathRulePtrInput interface {
	pulumi.Input

	ToRuleUserDefineRuleParsePathRulePtrOutput() RuleUserDefineRuleParsePathRulePtrOutput
	ToRuleUserDefineRuleParsePathRulePtrOutputWithContext(context.Context) RuleUserDefineRuleParsePathRulePtrOutput
}

type ruleUserDefineRuleParsePathRulePtrType RuleUserDefineRuleParsePathRuleArgs

func RuleUserDefineRuleParsePathRulePtr(v *RuleUserDefineRuleParsePathRuleArgs) RuleUserDefineRuleParsePathRulePtrInput {
	return (*ruleUserDefineRuleParsePathRulePtrType)(v)
}

func (*ruleUserDefineRuleParsePathRulePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleUserDefineRuleParsePathRule)(nil)).Elem()
}

func (i *ruleUserDefineRuleParsePathRulePtrType) ToRuleUserDefineRuleParsePathRulePtrOutput() RuleUserDefineRuleParsePathRulePtrOutput {
	return i.ToRuleUserDefineRuleParsePathRulePtrOutputWithContext(context.Background())
}

func (i *ruleUserDefineRuleParsePathRulePtrType) ToRuleUserDefineRuleParsePathRulePtrOutputWithContext(ctx context.Context) RuleUserDefineRuleParsePathRulePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleUserDefineRuleParsePathRulePtrOutput)
}

type RuleUserDefineRuleParsePathRuleOutput struct{ *pulumi.OutputState }

func (RuleUserDefineRuleParsePathRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleUserDefineRuleParsePathRule)(nil)).Elem()
}

func (o RuleUserDefineRuleParsePathRuleOutput) ToRuleUserDefineRuleParsePathRuleOutput() RuleUserDefineRuleParsePathRuleOutput {
	return o
}

func (o RuleUserDefineRuleParsePathRuleOutput) ToRuleUserDefineRuleParsePathRuleOutputWithContext(ctx context.Context) RuleUserDefineRuleParsePathRuleOutput {
	return o
}

func (o RuleUserDefineRuleParsePathRuleOutput) ToRuleUserDefineRuleParsePathRulePtrOutput() RuleUserDefineRuleParsePathRulePtrOutput {
	return o.ToRuleUserDefineRuleParsePathRulePtrOutputWithContext(context.Background())
}

func (o RuleUserDefineRuleParsePathRuleOutput) ToRuleUserDefineRuleParsePathRulePtrOutputWithContext(ctx context.Context) RuleUserDefineRuleParsePathRulePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleUserDefineRuleParsePathRule) *RuleUserDefineRuleParsePathRule {
		return &v
	}).(RuleUserDefineRuleParsePathRulePtrOutput)
}

// A list of field names. Log Service will parse the path sample (PathSample) into multiple fields according to the regular expression (Regex), and Keys is used to specify the field name of each field.
func (o RuleUserDefineRuleParsePathRuleOutput) Keys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v RuleUserDefineRuleParsePathRule) []string { return v.Keys }).(pulumi.StringArrayOutput)
}

// Sample capture path for a real scene.
func (o RuleUserDefineRuleParsePathRuleOutput) PathSample() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleUserDefineRuleParsePathRule) *string { return v.PathSample }).(pulumi.StringPtrOutput)
}

// Regular expression for extracting path fields. It must match the collection path sample, otherwise it cannot be extracted successfully.
func (o RuleUserDefineRuleParsePathRuleOutput) Regex() pulumi.StringPtrOutput {
	return o.ApplyT(func(v RuleUserDefineRuleParsePathRule) *string { return v.Regex }).(pulumi.StringPtrOutput)
}

type RuleUserDefineRuleParsePathRulePtrOutput struct{ *pulumi.OutputState }

func (RuleUserDefineRuleParsePathRulePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleUserDefineRuleParsePathRule)(nil)).Elem()
}

func (o RuleUserDefineRuleParsePathRulePtrOutput) ToRuleUserDefineRuleParsePathRulePtrOutput() RuleUserDefineRuleParsePathRulePtrOutput {
	return o
}

func (o RuleUserDefineRuleParsePathRulePtrOutput) ToRuleUserDefineRuleParsePathRulePtrOutputWithContext(ctx context.Context) RuleUserDefineRuleParsePathRulePtrOutput {
	return o
}

func (o RuleUserDefineRuleParsePathRulePtrOutput) Elem() RuleUserDefineRuleParsePathRuleOutput {
	return o.ApplyT(func(v *RuleUserDefineRuleParsePathRule) RuleUserDefineRuleParsePathRule {
		if v != nil {
			return *v
		}
		var ret RuleUserDefineRuleParsePathRule
		return ret
	}).(RuleUserDefineRuleParsePathRuleOutput)
}

// A list of field names. Log Service will parse the path sample (PathSample) into multiple fields according to the regular expression (Regex), and Keys is used to specify the field name of each field.
func (o RuleUserDefineRuleParsePathRulePtrOutput) Keys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *RuleUserDefineRuleParsePathRule) []string {
		if v == nil {
			return nil
		}
		return v.Keys
	}).(pulumi.StringArrayOutput)
}

// Sample capture path for a real scene.
func (o RuleUserDefineRuleParsePathRulePtrOutput) PathSample() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RuleUserDefineRuleParsePathRule) *string {
		if v == nil {
			return nil
		}
		return v.PathSample
	}).(pulumi.StringPtrOutput)
}

// Regular expression for extracting path fields. It must match the collection path sample, otherwise it cannot be extracted successfully.
func (o RuleUserDefineRuleParsePathRulePtrOutput) Regex() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RuleUserDefineRuleParsePathRule) *string {
		if v == nil {
			return nil
		}
		return v.Regex
	}).(pulumi.StringPtrOutput)
}

type RuleUserDefineRulePlugin struct {
	// LogCollector plugin.
	Processors []string `pulumi:"processors"`
}

// RuleUserDefineRulePluginInput is an input type that accepts RuleUserDefineRulePluginArgs and RuleUserDefineRulePluginOutput values.
// You can construct a concrete instance of `RuleUserDefineRulePluginInput` via:
//
//	RuleUserDefineRulePluginArgs{...}
type RuleUserDefineRulePluginInput interface {
	pulumi.Input

	ToRuleUserDefineRulePluginOutput() RuleUserDefineRulePluginOutput
	ToRuleUserDefineRulePluginOutputWithContext(context.Context) RuleUserDefineRulePluginOutput
}

type RuleUserDefineRulePluginArgs struct {
	// LogCollector plugin.
	Processors pulumi.StringArrayInput `pulumi:"processors"`
}

func (RuleUserDefineRulePluginArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleUserDefineRulePlugin)(nil)).Elem()
}

func (i RuleUserDefineRulePluginArgs) ToRuleUserDefineRulePluginOutput() RuleUserDefineRulePluginOutput {
	return i.ToRuleUserDefineRulePluginOutputWithContext(context.Background())
}

func (i RuleUserDefineRulePluginArgs) ToRuleUserDefineRulePluginOutputWithContext(ctx context.Context) RuleUserDefineRulePluginOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleUserDefineRulePluginOutput)
}

func (i RuleUserDefineRulePluginArgs) ToRuleUserDefineRulePluginPtrOutput() RuleUserDefineRulePluginPtrOutput {
	return i.ToRuleUserDefineRulePluginPtrOutputWithContext(context.Background())
}

func (i RuleUserDefineRulePluginArgs) ToRuleUserDefineRulePluginPtrOutputWithContext(ctx context.Context) RuleUserDefineRulePluginPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleUserDefineRulePluginOutput).ToRuleUserDefineRulePluginPtrOutputWithContext(ctx)
}

// RuleUserDefineRulePluginPtrInput is an input type that accepts RuleUserDefineRulePluginArgs, RuleUserDefineRulePluginPtr and RuleUserDefineRulePluginPtrOutput values.
// You can construct a concrete instance of `RuleUserDefineRulePluginPtrInput` via:
//
//	        RuleUserDefineRulePluginArgs{...}
//
//	or:
//
//	        nil
type RuleUserDefineRulePluginPtrInput interface {
	pulumi.Input

	ToRuleUserDefineRulePluginPtrOutput() RuleUserDefineRulePluginPtrOutput
	ToRuleUserDefineRulePluginPtrOutputWithContext(context.Context) RuleUserDefineRulePluginPtrOutput
}

type ruleUserDefineRulePluginPtrType RuleUserDefineRulePluginArgs

func RuleUserDefineRulePluginPtr(v *RuleUserDefineRulePluginArgs) RuleUserDefineRulePluginPtrInput {
	return (*ruleUserDefineRulePluginPtrType)(v)
}

func (*ruleUserDefineRulePluginPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleUserDefineRulePlugin)(nil)).Elem()
}

func (i *ruleUserDefineRulePluginPtrType) ToRuleUserDefineRulePluginPtrOutput() RuleUserDefineRulePluginPtrOutput {
	return i.ToRuleUserDefineRulePluginPtrOutputWithContext(context.Background())
}

func (i *ruleUserDefineRulePluginPtrType) ToRuleUserDefineRulePluginPtrOutputWithContext(ctx context.Context) RuleUserDefineRulePluginPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleUserDefineRulePluginPtrOutput)
}

type RuleUserDefineRulePluginOutput struct{ *pulumi.OutputState }

func (RuleUserDefineRulePluginOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleUserDefineRulePlugin)(nil)).Elem()
}

func (o RuleUserDefineRulePluginOutput) ToRuleUserDefineRulePluginOutput() RuleUserDefineRulePluginOutput {
	return o
}

func (o RuleUserDefineRulePluginOutput) ToRuleUserDefineRulePluginOutputWithContext(ctx context.Context) RuleUserDefineRulePluginOutput {
	return o
}

func (o RuleUserDefineRulePluginOutput) ToRuleUserDefineRulePluginPtrOutput() RuleUserDefineRulePluginPtrOutput {
	return o.ToRuleUserDefineRulePluginPtrOutputWithContext(context.Background())
}

func (o RuleUserDefineRulePluginOutput) ToRuleUserDefineRulePluginPtrOutputWithContext(ctx context.Context) RuleUserDefineRulePluginPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleUserDefineRulePlugin) *RuleUserDefineRulePlugin {
		return &v
	}).(RuleUserDefineRulePluginPtrOutput)
}

// LogCollector plugin.
func (o RuleUserDefineRulePluginOutput) Processors() pulumi.StringArrayOutput {
	return o.ApplyT(func(v RuleUserDefineRulePlugin) []string { return v.Processors }).(pulumi.StringArrayOutput)
}

type RuleUserDefineRulePluginPtrOutput struct{ *pulumi.OutputState }

func (RuleUserDefineRulePluginPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleUserDefineRulePlugin)(nil)).Elem()
}

func (o RuleUserDefineRulePluginPtrOutput) ToRuleUserDefineRulePluginPtrOutput() RuleUserDefineRulePluginPtrOutput {
	return o
}

func (o RuleUserDefineRulePluginPtrOutput) ToRuleUserDefineRulePluginPtrOutputWithContext(ctx context.Context) RuleUserDefineRulePluginPtrOutput {
	return o
}

func (o RuleUserDefineRulePluginPtrOutput) Elem() RuleUserDefineRulePluginOutput {
	return o.ApplyT(func(v *RuleUserDefineRulePlugin) RuleUserDefineRulePlugin {
		if v != nil {
			return *v
		}
		var ret RuleUserDefineRulePlugin
		return ret
	}).(RuleUserDefineRulePluginOutput)
}

// LogCollector plugin.
func (o RuleUserDefineRulePluginPtrOutput) Processors() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *RuleUserDefineRulePlugin) []string {
		if v == nil {
			return nil
		}
		return v.Processors
	}).(pulumi.StringArrayOutput)
}

type RuleUserDefineRuleShardHashKey struct {
	// The HashKey of the log group is used to specify the partition (shard) to be written to by the current log group.
	HashKey string `pulumi:"hashKey"`
}

// RuleUserDefineRuleShardHashKeyInput is an input type that accepts RuleUserDefineRuleShardHashKeyArgs and RuleUserDefineRuleShardHashKeyOutput values.
// You can construct a concrete instance of `RuleUserDefineRuleShardHashKeyInput` via:
//
//	RuleUserDefineRuleShardHashKeyArgs{...}
type RuleUserDefineRuleShardHashKeyInput interface {
	pulumi.Input

	ToRuleUserDefineRuleShardHashKeyOutput() RuleUserDefineRuleShardHashKeyOutput
	ToRuleUserDefineRuleShardHashKeyOutputWithContext(context.Context) RuleUserDefineRuleShardHashKeyOutput
}

type RuleUserDefineRuleShardHashKeyArgs struct {
	// The HashKey of the log group is used to specify the partition (shard) to be written to by the current log group.
	HashKey pulumi.StringInput `pulumi:"hashKey"`
}

func (RuleUserDefineRuleShardHashKeyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleUserDefineRuleShardHashKey)(nil)).Elem()
}

func (i RuleUserDefineRuleShardHashKeyArgs) ToRuleUserDefineRuleShardHashKeyOutput() RuleUserDefineRuleShardHashKeyOutput {
	return i.ToRuleUserDefineRuleShardHashKeyOutputWithContext(context.Background())
}

func (i RuleUserDefineRuleShardHashKeyArgs) ToRuleUserDefineRuleShardHashKeyOutputWithContext(ctx context.Context) RuleUserDefineRuleShardHashKeyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleUserDefineRuleShardHashKeyOutput)
}

func (i RuleUserDefineRuleShardHashKeyArgs) ToRuleUserDefineRuleShardHashKeyPtrOutput() RuleUserDefineRuleShardHashKeyPtrOutput {
	return i.ToRuleUserDefineRuleShardHashKeyPtrOutputWithContext(context.Background())
}

func (i RuleUserDefineRuleShardHashKeyArgs) ToRuleUserDefineRuleShardHashKeyPtrOutputWithContext(ctx context.Context) RuleUserDefineRuleShardHashKeyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleUserDefineRuleShardHashKeyOutput).ToRuleUserDefineRuleShardHashKeyPtrOutputWithContext(ctx)
}

// RuleUserDefineRuleShardHashKeyPtrInput is an input type that accepts RuleUserDefineRuleShardHashKeyArgs, RuleUserDefineRuleShardHashKeyPtr and RuleUserDefineRuleShardHashKeyPtrOutput values.
// You can construct a concrete instance of `RuleUserDefineRuleShardHashKeyPtrInput` via:
//
//	        RuleUserDefineRuleShardHashKeyArgs{...}
//
//	or:
//
//	        nil
type RuleUserDefineRuleShardHashKeyPtrInput interface {
	pulumi.Input

	ToRuleUserDefineRuleShardHashKeyPtrOutput() RuleUserDefineRuleShardHashKeyPtrOutput
	ToRuleUserDefineRuleShardHashKeyPtrOutputWithContext(context.Context) RuleUserDefineRuleShardHashKeyPtrOutput
}

type ruleUserDefineRuleShardHashKeyPtrType RuleUserDefineRuleShardHashKeyArgs

func RuleUserDefineRuleShardHashKeyPtr(v *RuleUserDefineRuleShardHashKeyArgs) RuleUserDefineRuleShardHashKeyPtrInput {
	return (*ruleUserDefineRuleShardHashKeyPtrType)(v)
}

func (*ruleUserDefineRuleShardHashKeyPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleUserDefineRuleShardHashKey)(nil)).Elem()
}

func (i *ruleUserDefineRuleShardHashKeyPtrType) ToRuleUserDefineRuleShardHashKeyPtrOutput() RuleUserDefineRuleShardHashKeyPtrOutput {
	return i.ToRuleUserDefineRuleShardHashKeyPtrOutputWithContext(context.Background())
}

func (i *ruleUserDefineRuleShardHashKeyPtrType) ToRuleUserDefineRuleShardHashKeyPtrOutputWithContext(ctx context.Context) RuleUserDefineRuleShardHashKeyPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleUserDefineRuleShardHashKeyPtrOutput)
}

type RuleUserDefineRuleShardHashKeyOutput struct{ *pulumi.OutputState }

func (RuleUserDefineRuleShardHashKeyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleUserDefineRuleShardHashKey)(nil)).Elem()
}

func (o RuleUserDefineRuleShardHashKeyOutput) ToRuleUserDefineRuleShardHashKeyOutput() RuleUserDefineRuleShardHashKeyOutput {
	return o
}

func (o RuleUserDefineRuleShardHashKeyOutput) ToRuleUserDefineRuleShardHashKeyOutputWithContext(ctx context.Context) RuleUserDefineRuleShardHashKeyOutput {
	return o
}

func (o RuleUserDefineRuleShardHashKeyOutput) ToRuleUserDefineRuleShardHashKeyPtrOutput() RuleUserDefineRuleShardHashKeyPtrOutput {
	return o.ToRuleUserDefineRuleShardHashKeyPtrOutputWithContext(context.Background())
}

func (o RuleUserDefineRuleShardHashKeyOutput) ToRuleUserDefineRuleShardHashKeyPtrOutputWithContext(ctx context.Context) RuleUserDefineRuleShardHashKeyPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v RuleUserDefineRuleShardHashKey) *RuleUserDefineRuleShardHashKey {
		return &v
	}).(RuleUserDefineRuleShardHashKeyPtrOutput)
}

// The HashKey of the log group is used to specify the partition (shard) to be written to by the current log group.
func (o RuleUserDefineRuleShardHashKeyOutput) HashKey() pulumi.StringOutput {
	return o.ApplyT(func(v RuleUserDefineRuleShardHashKey) string { return v.HashKey }).(pulumi.StringOutput)
}

type RuleUserDefineRuleShardHashKeyPtrOutput struct{ *pulumi.OutputState }

func (RuleUserDefineRuleShardHashKeyPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleUserDefineRuleShardHashKey)(nil)).Elem()
}

func (o RuleUserDefineRuleShardHashKeyPtrOutput) ToRuleUserDefineRuleShardHashKeyPtrOutput() RuleUserDefineRuleShardHashKeyPtrOutput {
	return o
}

func (o RuleUserDefineRuleShardHashKeyPtrOutput) ToRuleUserDefineRuleShardHashKeyPtrOutputWithContext(ctx context.Context) RuleUserDefineRuleShardHashKeyPtrOutput {
	return o
}

func (o RuleUserDefineRuleShardHashKeyPtrOutput) Elem() RuleUserDefineRuleShardHashKeyOutput {
	return o.ApplyT(func(v *RuleUserDefineRuleShardHashKey) RuleUserDefineRuleShardHashKey {
		if v != nil {
			return *v
		}
		var ret RuleUserDefineRuleShardHashKey
		return ret
	}).(RuleUserDefineRuleShardHashKeyOutput)
}

// The HashKey of the log group is used to specify the partition (shard) to be written to by the current log group.
func (o RuleUserDefineRuleShardHashKeyPtrOutput) HashKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RuleUserDefineRuleShardHashKey) *string {
		if v == nil {
			return nil
		}
		return &v.HashKey
	}).(pulumi.StringPtrOutput)
}

type RulesRule struct {
	// Container collection rules.
	ContainerRules []RulesRuleContainerRule `pulumi:"containerRules"`
	// The creation time.
	CreateTime string `pulumi:"createTime"`
	// Collect the blacklist list.
	ExcludePaths []RulesRuleExcludePath `pulumi:"excludePaths"`
	// The extract rule.
	ExtractRules []RulesRuleExtractRule `pulumi:"extractRules"`
	// The collection type.
	InputType int `pulumi:"inputType"`
	// Log sample.
	LogSample string `pulumi:"logSample"`
	// The log type.
	LogType string `pulumi:"logType"`
	// The modification time.
	ModifyTime string `pulumi:"modifyTime"`
	// Collection path list.
	Paths []string `pulumi:"paths"`
	// The rule id.
	RuleId string `pulumi:"ruleId"`
	// The rule name.
	RuleName string `pulumi:"ruleName"`
	// The topic id.
	TopicId string `pulumi:"topicId"`
	// The topic name.
	TopicName string `pulumi:"topicName"`
	// User-defined collection rules.
	UserDefineRules []RulesRuleUserDefineRule `pulumi:"userDefineRules"`
}

// RulesRuleInput is an input type that accepts RulesRuleArgs and RulesRuleOutput values.
// You can construct a concrete instance of `RulesRuleInput` via:
//
//	RulesRuleArgs{...}
type RulesRuleInput interface {
	pulumi.Input

	ToRulesRuleOutput() RulesRuleOutput
	ToRulesRuleOutputWithContext(context.Context) RulesRuleOutput
}

type RulesRuleArgs struct {
	// Container collection rules.
	ContainerRules RulesRuleContainerRuleArrayInput `pulumi:"containerRules"`
	// The creation time.
	CreateTime pulumi.StringInput `pulumi:"createTime"`
	// Collect the blacklist list.
	ExcludePaths RulesRuleExcludePathArrayInput `pulumi:"excludePaths"`
	// The extract rule.
	ExtractRules RulesRuleExtractRuleArrayInput `pulumi:"extractRules"`
	// The collection type.
	InputType pulumi.IntInput `pulumi:"inputType"`
	// Log sample.
	LogSample pulumi.StringInput `pulumi:"logSample"`
	// The log type.
	LogType pulumi.StringInput `pulumi:"logType"`
	// The modification time.
	ModifyTime pulumi.StringInput `pulumi:"modifyTime"`
	// Collection path list.
	Paths pulumi.StringArrayInput `pulumi:"paths"`
	// The rule id.
	RuleId pulumi.StringInput `pulumi:"ruleId"`
	// The rule name.
	RuleName pulumi.StringInput `pulumi:"ruleName"`
	// The topic id.
	TopicId pulumi.StringInput `pulumi:"topicId"`
	// The topic name.
	TopicName pulumi.StringInput `pulumi:"topicName"`
	// User-defined collection rules.
	UserDefineRules RulesRuleUserDefineRuleArrayInput `pulumi:"userDefineRules"`
}

func (RulesRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RulesRule)(nil)).Elem()
}

func (i RulesRuleArgs) ToRulesRuleOutput() RulesRuleOutput {
	return i.ToRulesRuleOutputWithContext(context.Background())
}

func (i RulesRuleArgs) ToRulesRuleOutputWithContext(ctx context.Context) RulesRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RulesRuleOutput)
}

// RulesRuleArrayInput is an input type that accepts RulesRuleArray and RulesRuleArrayOutput values.
// You can construct a concrete instance of `RulesRuleArrayInput` via:
//
//	RulesRuleArray{ RulesRuleArgs{...} }
type RulesRuleArrayInput interface {
	pulumi.Input

	ToRulesRuleArrayOutput() RulesRuleArrayOutput
	ToRulesRuleArrayOutputWithContext(context.Context) RulesRuleArrayOutput
}

type RulesRuleArray []RulesRuleInput

func (RulesRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RulesRule)(nil)).Elem()
}

func (i RulesRuleArray) ToRulesRuleArrayOutput() RulesRuleArrayOutput {
	return i.ToRulesRuleArrayOutputWithContext(context.Background())
}

func (i RulesRuleArray) ToRulesRuleArrayOutputWithContext(ctx context.Context) RulesRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RulesRuleArrayOutput)
}

type RulesRuleOutput struct{ *pulumi.OutputState }

func (RulesRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RulesRule)(nil)).Elem()
}

func (o RulesRuleOutput) ToRulesRuleOutput() RulesRuleOutput {
	return o
}

func (o RulesRuleOutput) ToRulesRuleOutputWithContext(ctx context.Context) RulesRuleOutput {
	return o
}

// Container collection rules.
func (o RulesRuleOutput) ContainerRules() RulesRuleContainerRuleArrayOutput {
	return o.ApplyT(func(v RulesRule) []RulesRuleContainerRule { return v.ContainerRules }).(RulesRuleContainerRuleArrayOutput)
}

// The creation time.
func (o RulesRuleOutput) CreateTime() pulumi.StringOutput {
	return o.ApplyT(func(v RulesRule) string { return v.CreateTime }).(pulumi.StringOutput)
}

// Collect the blacklist list.
func (o RulesRuleOutput) ExcludePaths() RulesRuleExcludePathArrayOutput {
	return o.ApplyT(func(v RulesRule) []RulesRuleExcludePath { return v.ExcludePaths }).(RulesRuleExcludePathArrayOutput)
}

// The extract rule.
func (o RulesRuleOutput) ExtractRules() RulesRuleExtractRuleArrayOutput {
	return o.ApplyT(func(v RulesRule) []RulesRuleExtractRule { return v.ExtractRules }).(RulesRuleExtractRuleArrayOutput)
}

// The collection type.
func (o RulesRuleOutput) InputType() pulumi.IntOutput {
	return o.ApplyT(func(v RulesRule) int { return v.InputType }).(pulumi.IntOutput)
}

// Log sample.
func (o RulesRuleOutput) LogSample() pulumi.StringOutput {
	return o.ApplyT(func(v RulesRule) string { return v.LogSample }).(pulumi.StringOutput)
}

// The log type.
func (o RulesRuleOutput) LogType() pulumi.StringOutput {
	return o.ApplyT(func(v RulesRule) string { return v.LogType }).(pulumi.StringOutput)
}

// The modification time.
func (o RulesRuleOutput) ModifyTime() pulumi.StringOutput {
	return o.ApplyT(func(v RulesRule) string { return v.ModifyTime }).(pulumi.StringOutput)
}

// Collection path list.
func (o RulesRuleOutput) Paths() pulumi.StringArrayOutput {
	return o.ApplyT(func(v RulesRule) []string { return v.Paths }).(pulumi.StringArrayOutput)
}

// The rule id.
func (o RulesRuleOutput) RuleId() pulumi.StringOutput {
	return o.ApplyT(func(v RulesRule) string { return v.RuleId }).(pulumi.StringOutput)
}

// The rule name.
func (o RulesRuleOutput) RuleName() pulumi.StringOutput {
	return o.ApplyT(func(v RulesRule) string { return v.RuleName }).(pulumi.StringOutput)
}

// The topic id.
func (o RulesRuleOutput) TopicId() pulumi.StringOutput {
	return o.ApplyT(func(v RulesRule) string { return v.TopicId }).(pulumi.StringOutput)
}

// The topic name.
func (o RulesRuleOutput) TopicName() pulumi.StringOutput {
	return o.ApplyT(func(v RulesRule) string { return v.TopicName }).(pulumi.StringOutput)
}

// User-defined collection rules.
func (o RulesRuleOutput) UserDefineRules() RulesRuleUserDefineRuleArrayOutput {
	return o.ApplyT(func(v RulesRule) []RulesRuleUserDefineRule { return v.UserDefineRules }).(RulesRuleUserDefineRuleArrayOutput)
}

type RulesRuleArrayOutput struct{ *pulumi.OutputState }

func (RulesRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RulesRule)(nil)).Elem()
}

func (o RulesRuleArrayOutput) ToRulesRuleArrayOutput() RulesRuleArrayOutput {
	return o
}

func (o RulesRuleArrayOutput) ToRulesRuleArrayOutputWithContext(ctx context.Context) RulesRuleArrayOutput {
	return o
}

func (o RulesRuleArrayOutput) Index(i pulumi.IntInput) RulesRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RulesRule {
		return vs[0].([]RulesRule)[vs[1].(int)]
	}).(RulesRuleOutput)
}

type RulesRuleContainerRule struct {
	// The name of the container to be collected.
	ContainerNameRegex string `pulumi:"containerNameRegex"`
	// Whether to add environment variables as log tags to raw log data.
	EnvTag map[string]interface{} `pulumi:"envTag"`
	// The container environment variable blacklist is used to specify the range of containers not to be collected.
	ExcludeContainerEnvRegex map[string]interface{} `pulumi:"excludeContainerEnvRegex"`
	// The container Label blacklist is used to specify the range of containers not to be collected.
	ExcludeContainerLabelRegex map[string]interface{} `pulumi:"excludeContainerLabelRegex"`
	// The container environment variable whitelist specifies the container to be collected through the container environment variable. If the whitelist is not enabled, it means that all containers are specified to be collected.
	IncludeContainerEnvRegex map[string]interface{} `pulumi:"includeContainerEnvRegex"`
	// The container label whitelist specifies the containers to be collected through the container label. If the whitelist is not enabled, all containers are specified to be collected.
	IncludeContainerLabelRegex map[string]interface{} `pulumi:"includeContainerLabelRegex"`
	// Collection rules for Kubernetes containers.
	KubernetesRules []RulesRuleContainerRuleKubernetesRule `pulumi:"kubernetesRules"`
	// The collection mode.
	Stream string `pulumi:"stream"`
}

// RulesRuleContainerRuleInput is an input type that accepts RulesRuleContainerRuleArgs and RulesRuleContainerRuleOutput values.
// You can construct a concrete instance of `RulesRuleContainerRuleInput` via:
//
//	RulesRuleContainerRuleArgs{...}
type RulesRuleContainerRuleInput interface {
	pulumi.Input

	ToRulesRuleContainerRuleOutput() RulesRuleContainerRuleOutput
	ToRulesRuleContainerRuleOutputWithContext(context.Context) RulesRuleContainerRuleOutput
}

type RulesRuleContainerRuleArgs struct {
	// The name of the container to be collected.
	ContainerNameRegex pulumi.StringInput `pulumi:"containerNameRegex"`
	// Whether to add environment variables as log tags to raw log data.
	EnvTag pulumi.MapInput `pulumi:"envTag"`
	// The container environment variable blacklist is used to specify the range of containers not to be collected.
	ExcludeContainerEnvRegex pulumi.MapInput `pulumi:"excludeContainerEnvRegex"`
	// The container Label blacklist is used to specify the range of containers not to be collected.
	ExcludeContainerLabelRegex pulumi.MapInput `pulumi:"excludeContainerLabelRegex"`
	// The container environment variable whitelist specifies the container to be collected through the container environment variable. If the whitelist is not enabled, it means that all containers are specified to be collected.
	IncludeContainerEnvRegex pulumi.MapInput `pulumi:"includeContainerEnvRegex"`
	// The container label whitelist specifies the containers to be collected through the container label. If the whitelist is not enabled, all containers are specified to be collected.
	IncludeContainerLabelRegex pulumi.MapInput `pulumi:"includeContainerLabelRegex"`
	// Collection rules for Kubernetes containers.
	KubernetesRules RulesRuleContainerRuleKubernetesRuleArrayInput `pulumi:"kubernetesRules"`
	// The collection mode.
	Stream pulumi.StringInput `pulumi:"stream"`
}

func (RulesRuleContainerRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RulesRuleContainerRule)(nil)).Elem()
}

func (i RulesRuleContainerRuleArgs) ToRulesRuleContainerRuleOutput() RulesRuleContainerRuleOutput {
	return i.ToRulesRuleContainerRuleOutputWithContext(context.Background())
}

func (i RulesRuleContainerRuleArgs) ToRulesRuleContainerRuleOutputWithContext(ctx context.Context) RulesRuleContainerRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RulesRuleContainerRuleOutput)
}

// RulesRuleContainerRuleArrayInput is an input type that accepts RulesRuleContainerRuleArray and RulesRuleContainerRuleArrayOutput values.
// You can construct a concrete instance of `RulesRuleContainerRuleArrayInput` via:
//
//	RulesRuleContainerRuleArray{ RulesRuleContainerRuleArgs{...} }
type RulesRuleContainerRuleArrayInput interface {
	pulumi.Input

	ToRulesRuleContainerRuleArrayOutput() RulesRuleContainerRuleArrayOutput
	ToRulesRuleContainerRuleArrayOutputWithContext(context.Context) RulesRuleContainerRuleArrayOutput
}

type RulesRuleContainerRuleArray []RulesRuleContainerRuleInput

func (RulesRuleContainerRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RulesRuleContainerRule)(nil)).Elem()
}

func (i RulesRuleContainerRuleArray) ToRulesRuleContainerRuleArrayOutput() RulesRuleContainerRuleArrayOutput {
	return i.ToRulesRuleContainerRuleArrayOutputWithContext(context.Background())
}

func (i RulesRuleContainerRuleArray) ToRulesRuleContainerRuleArrayOutputWithContext(ctx context.Context) RulesRuleContainerRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RulesRuleContainerRuleArrayOutput)
}

type RulesRuleContainerRuleOutput struct{ *pulumi.OutputState }

func (RulesRuleContainerRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RulesRuleContainerRule)(nil)).Elem()
}

func (o RulesRuleContainerRuleOutput) ToRulesRuleContainerRuleOutput() RulesRuleContainerRuleOutput {
	return o
}

func (o RulesRuleContainerRuleOutput) ToRulesRuleContainerRuleOutputWithContext(ctx context.Context) RulesRuleContainerRuleOutput {
	return o
}

// The name of the container to be collected.
func (o RulesRuleContainerRuleOutput) ContainerNameRegex() pulumi.StringOutput {
	return o.ApplyT(func(v RulesRuleContainerRule) string { return v.ContainerNameRegex }).(pulumi.StringOutput)
}

// Whether to add environment variables as log tags to raw log data.
func (o RulesRuleContainerRuleOutput) EnvTag() pulumi.MapOutput {
	return o.ApplyT(func(v RulesRuleContainerRule) map[string]interface{} { return v.EnvTag }).(pulumi.MapOutput)
}

// The container environment variable blacklist is used to specify the range of containers not to be collected.
func (o RulesRuleContainerRuleOutput) ExcludeContainerEnvRegex() pulumi.MapOutput {
	return o.ApplyT(func(v RulesRuleContainerRule) map[string]interface{} { return v.ExcludeContainerEnvRegex }).(pulumi.MapOutput)
}

// The container Label blacklist is used to specify the range of containers not to be collected.
func (o RulesRuleContainerRuleOutput) ExcludeContainerLabelRegex() pulumi.MapOutput {
	return o.ApplyT(func(v RulesRuleContainerRule) map[string]interface{} { return v.ExcludeContainerLabelRegex }).(pulumi.MapOutput)
}

// The container environment variable whitelist specifies the container to be collected through the container environment variable. If the whitelist is not enabled, it means that all containers are specified to be collected.
func (o RulesRuleContainerRuleOutput) IncludeContainerEnvRegex() pulumi.MapOutput {
	return o.ApplyT(func(v RulesRuleContainerRule) map[string]interface{} { return v.IncludeContainerEnvRegex }).(pulumi.MapOutput)
}

// The container label whitelist specifies the containers to be collected through the container label. If the whitelist is not enabled, all containers are specified to be collected.
func (o RulesRuleContainerRuleOutput) IncludeContainerLabelRegex() pulumi.MapOutput {
	return o.ApplyT(func(v RulesRuleContainerRule) map[string]interface{} { return v.IncludeContainerLabelRegex }).(pulumi.MapOutput)
}

// Collection rules for Kubernetes containers.
func (o RulesRuleContainerRuleOutput) KubernetesRules() RulesRuleContainerRuleKubernetesRuleArrayOutput {
	return o.ApplyT(func(v RulesRuleContainerRule) []RulesRuleContainerRuleKubernetesRule { return v.KubernetesRules }).(RulesRuleContainerRuleKubernetesRuleArrayOutput)
}

// The collection mode.
func (o RulesRuleContainerRuleOutput) Stream() pulumi.StringOutput {
	return o.ApplyT(func(v RulesRuleContainerRule) string { return v.Stream }).(pulumi.StringOutput)
}

type RulesRuleContainerRuleArrayOutput struct{ *pulumi.OutputState }

func (RulesRuleContainerRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RulesRuleContainerRule)(nil)).Elem()
}

func (o RulesRuleContainerRuleArrayOutput) ToRulesRuleContainerRuleArrayOutput() RulesRuleContainerRuleArrayOutput {
	return o
}

func (o RulesRuleContainerRuleArrayOutput) ToRulesRuleContainerRuleArrayOutputWithContext(ctx context.Context) RulesRuleContainerRuleArrayOutput {
	return o
}

func (o RulesRuleContainerRuleArrayOutput) Index(i pulumi.IntInput) RulesRuleContainerRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RulesRuleContainerRule {
		return vs[0].([]RulesRuleContainerRule)[vs[1].(int)]
	}).(RulesRuleContainerRuleOutput)
}

type RulesRuleContainerRuleKubernetesRule struct {
	// Whether to add Kubernetes Annotation as a log tag to the raw log data.
	AnnotationTag map[string]interface{} `pulumi:"annotationTag"`
	// Specify the containers not to be collected through the Pod Label blacklist, and not enable means to collect all containers.
	ExcludePodLabelRegex map[string]interface{} `pulumi:"excludePodLabelRegex"`
	// The Pod Label whitelist is used to specify containers to be collected. When the Pod Label whitelist is not enabled, it means that all containers are collected.
	IncludePodLabelRegex map[string]interface{} `pulumi:"includePodLabelRegex"`
	// Whether to add Kubernetes Label as a log label to the original log data.
	LabelTag map[string]interface{} `pulumi:"labelTag"`
	// The name of the Kubernetes Namespace to be collected. If no Namespace name is specified, all containers will be collected. Namespace names support regular matching.
	NamespaceNameRegex string `pulumi:"namespaceNameRegex"`
	// The Pod name is used to specify the container to be collected. When no Pod name is specified, it means to collect all containers.
	PodNameRegex string `pulumi:"podNameRegex"`
	// Specify the container to be collected by the name of the workload. When no workload name is specified, all containers are collected. The workload name supports regular matching.
	WorkloadNameRegex string `pulumi:"workloadNameRegex"`
	// Specify the container to be collected by the type of workload. Only one type can be selected. When no type is specified, it means to collect all types of containers.
	WorkloadType string `pulumi:"workloadType"`
}

// RulesRuleContainerRuleKubernetesRuleInput is an input type that accepts RulesRuleContainerRuleKubernetesRuleArgs and RulesRuleContainerRuleKubernetesRuleOutput values.
// You can construct a concrete instance of `RulesRuleContainerRuleKubernetesRuleInput` via:
//
//	RulesRuleContainerRuleKubernetesRuleArgs{...}
type RulesRuleContainerRuleKubernetesRuleInput interface {
	pulumi.Input

	ToRulesRuleContainerRuleKubernetesRuleOutput() RulesRuleContainerRuleKubernetesRuleOutput
	ToRulesRuleContainerRuleKubernetesRuleOutputWithContext(context.Context) RulesRuleContainerRuleKubernetesRuleOutput
}

type RulesRuleContainerRuleKubernetesRuleArgs struct {
	// Whether to add Kubernetes Annotation as a log tag to the raw log data.
	AnnotationTag pulumi.MapInput `pulumi:"annotationTag"`
	// Specify the containers not to be collected through the Pod Label blacklist, and not enable means to collect all containers.
	ExcludePodLabelRegex pulumi.MapInput `pulumi:"excludePodLabelRegex"`
	// The Pod Label whitelist is used to specify containers to be collected. When the Pod Label whitelist is not enabled, it means that all containers are collected.
	IncludePodLabelRegex pulumi.MapInput `pulumi:"includePodLabelRegex"`
	// Whether to add Kubernetes Label as a log label to the original log data.
	LabelTag pulumi.MapInput `pulumi:"labelTag"`
	// The name of the Kubernetes Namespace to be collected. If no Namespace name is specified, all containers will be collected. Namespace names support regular matching.
	NamespaceNameRegex pulumi.StringInput `pulumi:"namespaceNameRegex"`
	// The Pod name is used to specify the container to be collected. When no Pod name is specified, it means to collect all containers.
	PodNameRegex pulumi.StringInput `pulumi:"podNameRegex"`
	// Specify the container to be collected by the name of the workload. When no workload name is specified, all containers are collected. The workload name supports regular matching.
	WorkloadNameRegex pulumi.StringInput `pulumi:"workloadNameRegex"`
	// Specify the container to be collected by the type of workload. Only one type can be selected. When no type is specified, it means to collect all types of containers.
	WorkloadType pulumi.StringInput `pulumi:"workloadType"`
}

func (RulesRuleContainerRuleKubernetesRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RulesRuleContainerRuleKubernetesRule)(nil)).Elem()
}

func (i RulesRuleContainerRuleKubernetesRuleArgs) ToRulesRuleContainerRuleKubernetesRuleOutput() RulesRuleContainerRuleKubernetesRuleOutput {
	return i.ToRulesRuleContainerRuleKubernetesRuleOutputWithContext(context.Background())
}

func (i RulesRuleContainerRuleKubernetesRuleArgs) ToRulesRuleContainerRuleKubernetesRuleOutputWithContext(ctx context.Context) RulesRuleContainerRuleKubernetesRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RulesRuleContainerRuleKubernetesRuleOutput)
}

// RulesRuleContainerRuleKubernetesRuleArrayInput is an input type that accepts RulesRuleContainerRuleKubernetesRuleArray and RulesRuleContainerRuleKubernetesRuleArrayOutput values.
// You can construct a concrete instance of `RulesRuleContainerRuleKubernetesRuleArrayInput` via:
//
//	RulesRuleContainerRuleKubernetesRuleArray{ RulesRuleContainerRuleKubernetesRuleArgs{...} }
type RulesRuleContainerRuleKubernetesRuleArrayInput interface {
	pulumi.Input

	ToRulesRuleContainerRuleKubernetesRuleArrayOutput() RulesRuleContainerRuleKubernetesRuleArrayOutput
	ToRulesRuleContainerRuleKubernetesRuleArrayOutputWithContext(context.Context) RulesRuleContainerRuleKubernetesRuleArrayOutput
}

type RulesRuleContainerRuleKubernetesRuleArray []RulesRuleContainerRuleKubernetesRuleInput

func (RulesRuleContainerRuleKubernetesRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RulesRuleContainerRuleKubernetesRule)(nil)).Elem()
}

func (i RulesRuleContainerRuleKubernetesRuleArray) ToRulesRuleContainerRuleKubernetesRuleArrayOutput() RulesRuleContainerRuleKubernetesRuleArrayOutput {
	return i.ToRulesRuleContainerRuleKubernetesRuleArrayOutputWithContext(context.Background())
}

func (i RulesRuleContainerRuleKubernetesRuleArray) ToRulesRuleContainerRuleKubernetesRuleArrayOutputWithContext(ctx context.Context) RulesRuleContainerRuleKubernetesRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RulesRuleContainerRuleKubernetesRuleArrayOutput)
}

type RulesRuleContainerRuleKubernetesRuleOutput struct{ *pulumi.OutputState }

func (RulesRuleContainerRuleKubernetesRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RulesRuleContainerRuleKubernetesRule)(nil)).Elem()
}

func (o RulesRuleContainerRuleKubernetesRuleOutput) ToRulesRuleContainerRuleKubernetesRuleOutput() RulesRuleContainerRuleKubernetesRuleOutput {
	return o
}

func (o RulesRuleContainerRuleKubernetesRuleOutput) ToRulesRuleContainerRuleKubernetesRuleOutputWithContext(ctx context.Context) RulesRuleContainerRuleKubernetesRuleOutput {
	return o
}

// Whether to add Kubernetes Annotation as a log tag to the raw log data.
func (o RulesRuleContainerRuleKubernetesRuleOutput) AnnotationTag() pulumi.MapOutput {
	return o.ApplyT(func(v RulesRuleContainerRuleKubernetesRule) map[string]interface{} { return v.AnnotationTag }).(pulumi.MapOutput)
}

// Specify the containers not to be collected through the Pod Label blacklist, and not enable means to collect all containers.
func (o RulesRuleContainerRuleKubernetesRuleOutput) ExcludePodLabelRegex() pulumi.MapOutput {
	return o.ApplyT(func(v RulesRuleContainerRuleKubernetesRule) map[string]interface{} { return v.ExcludePodLabelRegex }).(pulumi.MapOutput)
}

// The Pod Label whitelist is used to specify containers to be collected. When the Pod Label whitelist is not enabled, it means that all containers are collected.
func (o RulesRuleContainerRuleKubernetesRuleOutput) IncludePodLabelRegex() pulumi.MapOutput {
	return o.ApplyT(func(v RulesRuleContainerRuleKubernetesRule) map[string]interface{} { return v.IncludePodLabelRegex }).(pulumi.MapOutput)
}

// Whether to add Kubernetes Label as a log label to the original log data.
func (o RulesRuleContainerRuleKubernetesRuleOutput) LabelTag() pulumi.MapOutput {
	return o.ApplyT(func(v RulesRuleContainerRuleKubernetesRule) map[string]interface{} { return v.LabelTag }).(pulumi.MapOutput)
}

// The name of the Kubernetes Namespace to be collected. If no Namespace name is specified, all containers will be collected. Namespace names support regular matching.
func (o RulesRuleContainerRuleKubernetesRuleOutput) NamespaceNameRegex() pulumi.StringOutput {
	return o.ApplyT(func(v RulesRuleContainerRuleKubernetesRule) string { return v.NamespaceNameRegex }).(pulumi.StringOutput)
}

// The Pod name is used to specify the container to be collected. When no Pod name is specified, it means to collect all containers.
func (o RulesRuleContainerRuleKubernetesRuleOutput) PodNameRegex() pulumi.StringOutput {
	return o.ApplyT(func(v RulesRuleContainerRuleKubernetesRule) string { return v.PodNameRegex }).(pulumi.StringOutput)
}

// Specify the container to be collected by the name of the workload. When no workload name is specified, all containers are collected. The workload name supports regular matching.
func (o RulesRuleContainerRuleKubernetesRuleOutput) WorkloadNameRegex() pulumi.StringOutput {
	return o.ApplyT(func(v RulesRuleContainerRuleKubernetesRule) string { return v.WorkloadNameRegex }).(pulumi.StringOutput)
}

// Specify the container to be collected by the type of workload. Only one type can be selected. When no type is specified, it means to collect all types of containers.
func (o RulesRuleContainerRuleKubernetesRuleOutput) WorkloadType() pulumi.StringOutput {
	return o.ApplyT(func(v RulesRuleContainerRuleKubernetesRule) string { return v.WorkloadType }).(pulumi.StringOutput)
}

type RulesRuleContainerRuleKubernetesRuleArrayOutput struct{ *pulumi.OutputState }

func (RulesRuleContainerRuleKubernetesRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RulesRuleContainerRuleKubernetesRule)(nil)).Elem()
}

func (o RulesRuleContainerRuleKubernetesRuleArrayOutput) ToRulesRuleContainerRuleKubernetesRuleArrayOutput() RulesRuleContainerRuleKubernetesRuleArrayOutput {
	return o
}

func (o RulesRuleContainerRuleKubernetesRuleArrayOutput) ToRulesRuleContainerRuleKubernetesRuleArrayOutputWithContext(ctx context.Context) RulesRuleContainerRuleKubernetesRuleArrayOutput {
	return o
}

func (o RulesRuleContainerRuleKubernetesRuleArrayOutput) Index(i pulumi.IntInput) RulesRuleContainerRuleKubernetesRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RulesRuleContainerRuleKubernetesRule {
		return vs[0].([]RulesRuleContainerRuleKubernetesRule)[vs[1].(int)]
	}).(RulesRuleContainerRuleKubernetesRuleOutput)
}

type RulesRuleExcludePath struct {
	// The type of the log template.
	Type string `pulumi:"type"`
	// Collection path.
	Value string `pulumi:"value"`
}

// RulesRuleExcludePathInput is an input type that accepts RulesRuleExcludePathArgs and RulesRuleExcludePathOutput values.
// You can construct a concrete instance of `RulesRuleExcludePathInput` via:
//
//	RulesRuleExcludePathArgs{...}
type RulesRuleExcludePathInput interface {
	pulumi.Input

	ToRulesRuleExcludePathOutput() RulesRuleExcludePathOutput
	ToRulesRuleExcludePathOutputWithContext(context.Context) RulesRuleExcludePathOutput
}

type RulesRuleExcludePathArgs struct {
	// The type of the log template.
	Type pulumi.StringInput `pulumi:"type"`
	// Collection path.
	Value pulumi.StringInput `pulumi:"value"`
}

func (RulesRuleExcludePathArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RulesRuleExcludePath)(nil)).Elem()
}

func (i RulesRuleExcludePathArgs) ToRulesRuleExcludePathOutput() RulesRuleExcludePathOutput {
	return i.ToRulesRuleExcludePathOutputWithContext(context.Background())
}

func (i RulesRuleExcludePathArgs) ToRulesRuleExcludePathOutputWithContext(ctx context.Context) RulesRuleExcludePathOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RulesRuleExcludePathOutput)
}

// RulesRuleExcludePathArrayInput is an input type that accepts RulesRuleExcludePathArray and RulesRuleExcludePathArrayOutput values.
// You can construct a concrete instance of `RulesRuleExcludePathArrayInput` via:
//
//	RulesRuleExcludePathArray{ RulesRuleExcludePathArgs{...} }
type RulesRuleExcludePathArrayInput interface {
	pulumi.Input

	ToRulesRuleExcludePathArrayOutput() RulesRuleExcludePathArrayOutput
	ToRulesRuleExcludePathArrayOutputWithContext(context.Context) RulesRuleExcludePathArrayOutput
}

type RulesRuleExcludePathArray []RulesRuleExcludePathInput

func (RulesRuleExcludePathArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RulesRuleExcludePath)(nil)).Elem()
}

func (i RulesRuleExcludePathArray) ToRulesRuleExcludePathArrayOutput() RulesRuleExcludePathArrayOutput {
	return i.ToRulesRuleExcludePathArrayOutputWithContext(context.Background())
}

func (i RulesRuleExcludePathArray) ToRulesRuleExcludePathArrayOutputWithContext(ctx context.Context) RulesRuleExcludePathArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RulesRuleExcludePathArrayOutput)
}

type RulesRuleExcludePathOutput struct{ *pulumi.OutputState }

func (RulesRuleExcludePathOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RulesRuleExcludePath)(nil)).Elem()
}

func (o RulesRuleExcludePathOutput) ToRulesRuleExcludePathOutput() RulesRuleExcludePathOutput {
	return o
}

func (o RulesRuleExcludePathOutput) ToRulesRuleExcludePathOutputWithContext(ctx context.Context) RulesRuleExcludePathOutput {
	return o
}

// The type of the log template.
func (o RulesRuleExcludePathOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v RulesRuleExcludePath) string { return v.Type }).(pulumi.StringOutput)
}

// Collection path.
func (o RulesRuleExcludePathOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v RulesRuleExcludePath) string { return v.Value }).(pulumi.StringOutput)
}

type RulesRuleExcludePathArrayOutput struct{ *pulumi.OutputState }

func (RulesRuleExcludePathArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RulesRuleExcludePath)(nil)).Elem()
}

func (o RulesRuleExcludePathArrayOutput) ToRulesRuleExcludePathArrayOutput() RulesRuleExcludePathArrayOutput {
	return o
}

func (o RulesRuleExcludePathArrayOutput) ToRulesRuleExcludePathArrayOutputWithContext(ctx context.Context) RulesRuleExcludePathArrayOutput {
	return o
}

func (o RulesRuleExcludePathArrayOutput) Index(i pulumi.IntInput) RulesRuleExcludePathOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RulesRuleExcludePath {
		return vs[0].([]RulesRuleExcludePath)[vs[1].(int)]
	}).(RulesRuleExcludePathOutput)
}

type RulesRuleExtractRule struct {
	// The first log line needs to match the regular expression.
	BeginRegex string `pulumi:"beginRegex"`
	// The delimiter of the log.
	Delimiter string `pulumi:"delimiter"`
	// The filter key list.
	FilterKeyRegexes []RulesRuleExtractRuleFilterKeyRegex `pulumi:"filterKeyRegexes"`
	// A list of field names. Log Service will parse the path sample (PathSample) into multiple fields according to the regular expression (Regex), and Keys is used to specify the field name of each field.
	Keys []string `pulumi:"keys"`
	// The entire log needs to match the regular expression.
	LogRegex string `pulumi:"logRegex"`
	// Automatically extract log fields according to the specified log template.
	LogTemplates []RulesRuleExtractRuleLogTemplate `pulumi:"logTemplates"`
	// Parsing format of the time field.
	TimeFormat string `pulumi:"timeFormat"`
	// The field name of the log time field.
	TimeKey string `pulumi:"timeKey"`
	// When uploading the failed log, the key name of the failed log.
	UnMatchLogKey string `pulumi:"unMatchLogKey"`
	// Whether to upload the log of parsing failure.
	UnMatchUpLoadSwitch bool `pulumi:"unMatchUpLoadSwitch"`
}

// RulesRuleExtractRuleInput is an input type that accepts RulesRuleExtractRuleArgs and RulesRuleExtractRuleOutput values.
// You can construct a concrete instance of `RulesRuleExtractRuleInput` via:
//
//	RulesRuleExtractRuleArgs{...}
type RulesRuleExtractRuleInput interface {
	pulumi.Input

	ToRulesRuleExtractRuleOutput() RulesRuleExtractRuleOutput
	ToRulesRuleExtractRuleOutputWithContext(context.Context) RulesRuleExtractRuleOutput
}

type RulesRuleExtractRuleArgs struct {
	// The first log line needs to match the regular expression.
	BeginRegex pulumi.StringInput `pulumi:"beginRegex"`
	// The delimiter of the log.
	Delimiter pulumi.StringInput `pulumi:"delimiter"`
	// The filter key list.
	FilterKeyRegexes RulesRuleExtractRuleFilterKeyRegexArrayInput `pulumi:"filterKeyRegexes"`
	// A list of field names. Log Service will parse the path sample (PathSample) into multiple fields according to the regular expression (Regex), and Keys is used to specify the field name of each field.
	Keys pulumi.StringArrayInput `pulumi:"keys"`
	// The entire log needs to match the regular expression.
	LogRegex pulumi.StringInput `pulumi:"logRegex"`
	// Automatically extract log fields according to the specified log template.
	LogTemplates RulesRuleExtractRuleLogTemplateArrayInput `pulumi:"logTemplates"`
	// Parsing format of the time field.
	TimeFormat pulumi.StringInput `pulumi:"timeFormat"`
	// The field name of the log time field.
	TimeKey pulumi.StringInput `pulumi:"timeKey"`
	// When uploading the failed log, the key name of the failed log.
	UnMatchLogKey pulumi.StringInput `pulumi:"unMatchLogKey"`
	// Whether to upload the log of parsing failure.
	UnMatchUpLoadSwitch pulumi.BoolInput `pulumi:"unMatchUpLoadSwitch"`
}

func (RulesRuleExtractRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RulesRuleExtractRule)(nil)).Elem()
}

func (i RulesRuleExtractRuleArgs) ToRulesRuleExtractRuleOutput() RulesRuleExtractRuleOutput {
	return i.ToRulesRuleExtractRuleOutputWithContext(context.Background())
}

func (i RulesRuleExtractRuleArgs) ToRulesRuleExtractRuleOutputWithContext(ctx context.Context) RulesRuleExtractRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RulesRuleExtractRuleOutput)
}

// RulesRuleExtractRuleArrayInput is an input type that accepts RulesRuleExtractRuleArray and RulesRuleExtractRuleArrayOutput values.
// You can construct a concrete instance of `RulesRuleExtractRuleArrayInput` via:
//
//	RulesRuleExtractRuleArray{ RulesRuleExtractRuleArgs{...} }
type RulesRuleExtractRuleArrayInput interface {
	pulumi.Input

	ToRulesRuleExtractRuleArrayOutput() RulesRuleExtractRuleArrayOutput
	ToRulesRuleExtractRuleArrayOutputWithContext(context.Context) RulesRuleExtractRuleArrayOutput
}

type RulesRuleExtractRuleArray []RulesRuleExtractRuleInput

func (RulesRuleExtractRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RulesRuleExtractRule)(nil)).Elem()
}

func (i RulesRuleExtractRuleArray) ToRulesRuleExtractRuleArrayOutput() RulesRuleExtractRuleArrayOutput {
	return i.ToRulesRuleExtractRuleArrayOutputWithContext(context.Background())
}

func (i RulesRuleExtractRuleArray) ToRulesRuleExtractRuleArrayOutputWithContext(ctx context.Context) RulesRuleExtractRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RulesRuleExtractRuleArrayOutput)
}

type RulesRuleExtractRuleOutput struct{ *pulumi.OutputState }

func (RulesRuleExtractRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RulesRuleExtractRule)(nil)).Elem()
}

func (o RulesRuleExtractRuleOutput) ToRulesRuleExtractRuleOutput() RulesRuleExtractRuleOutput {
	return o
}

func (o RulesRuleExtractRuleOutput) ToRulesRuleExtractRuleOutputWithContext(ctx context.Context) RulesRuleExtractRuleOutput {
	return o
}

// The first log line needs to match the regular expression.
func (o RulesRuleExtractRuleOutput) BeginRegex() pulumi.StringOutput {
	return o.ApplyT(func(v RulesRuleExtractRule) string { return v.BeginRegex }).(pulumi.StringOutput)
}

// The delimiter of the log.
func (o RulesRuleExtractRuleOutput) Delimiter() pulumi.StringOutput {
	return o.ApplyT(func(v RulesRuleExtractRule) string { return v.Delimiter }).(pulumi.StringOutput)
}

// The filter key list.
func (o RulesRuleExtractRuleOutput) FilterKeyRegexes() RulesRuleExtractRuleFilterKeyRegexArrayOutput {
	return o.ApplyT(func(v RulesRuleExtractRule) []RulesRuleExtractRuleFilterKeyRegex { return v.FilterKeyRegexes }).(RulesRuleExtractRuleFilterKeyRegexArrayOutput)
}

// A list of field names. Log Service will parse the path sample (PathSample) into multiple fields according to the regular expression (Regex), and Keys is used to specify the field name of each field.
func (o RulesRuleExtractRuleOutput) Keys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v RulesRuleExtractRule) []string { return v.Keys }).(pulumi.StringArrayOutput)
}

// The entire log needs to match the regular expression.
func (o RulesRuleExtractRuleOutput) LogRegex() pulumi.StringOutput {
	return o.ApplyT(func(v RulesRuleExtractRule) string { return v.LogRegex }).(pulumi.StringOutput)
}

// Automatically extract log fields according to the specified log template.
func (o RulesRuleExtractRuleOutput) LogTemplates() RulesRuleExtractRuleLogTemplateArrayOutput {
	return o.ApplyT(func(v RulesRuleExtractRule) []RulesRuleExtractRuleLogTemplate { return v.LogTemplates }).(RulesRuleExtractRuleLogTemplateArrayOutput)
}

// Parsing format of the time field.
func (o RulesRuleExtractRuleOutput) TimeFormat() pulumi.StringOutput {
	return o.ApplyT(func(v RulesRuleExtractRule) string { return v.TimeFormat }).(pulumi.StringOutput)
}

// The field name of the log time field.
func (o RulesRuleExtractRuleOutput) TimeKey() pulumi.StringOutput {
	return o.ApplyT(func(v RulesRuleExtractRule) string { return v.TimeKey }).(pulumi.StringOutput)
}

// When uploading the failed log, the key name of the failed log.
func (o RulesRuleExtractRuleOutput) UnMatchLogKey() pulumi.StringOutput {
	return o.ApplyT(func(v RulesRuleExtractRule) string { return v.UnMatchLogKey }).(pulumi.StringOutput)
}

// Whether to upload the log of parsing failure.
func (o RulesRuleExtractRuleOutput) UnMatchUpLoadSwitch() pulumi.BoolOutput {
	return o.ApplyT(func(v RulesRuleExtractRule) bool { return v.UnMatchUpLoadSwitch }).(pulumi.BoolOutput)
}

type RulesRuleExtractRuleArrayOutput struct{ *pulumi.OutputState }

func (RulesRuleExtractRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RulesRuleExtractRule)(nil)).Elem()
}

func (o RulesRuleExtractRuleArrayOutput) ToRulesRuleExtractRuleArrayOutput() RulesRuleExtractRuleArrayOutput {
	return o
}

func (o RulesRuleExtractRuleArrayOutput) ToRulesRuleExtractRuleArrayOutputWithContext(ctx context.Context) RulesRuleExtractRuleArrayOutput {
	return o
}

func (o RulesRuleExtractRuleArrayOutput) Index(i pulumi.IntInput) RulesRuleExtractRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RulesRuleExtractRule {
		return vs[0].([]RulesRuleExtractRule)[vs[1].(int)]
	}).(RulesRuleExtractRuleOutput)
}

type RulesRuleExtractRuleFilterKeyRegex struct {
	// The name of the filter key.
	Key string `pulumi:"key"`
	// Regular expression for extracting path fields. It must match the collection path sample, otherwise it cannot be extracted successfully.
	Regex string `pulumi:"regex"`
}

// RulesRuleExtractRuleFilterKeyRegexInput is an input type that accepts RulesRuleExtractRuleFilterKeyRegexArgs and RulesRuleExtractRuleFilterKeyRegexOutput values.
// You can construct a concrete instance of `RulesRuleExtractRuleFilterKeyRegexInput` via:
//
//	RulesRuleExtractRuleFilterKeyRegexArgs{...}
type RulesRuleExtractRuleFilterKeyRegexInput interface {
	pulumi.Input

	ToRulesRuleExtractRuleFilterKeyRegexOutput() RulesRuleExtractRuleFilterKeyRegexOutput
	ToRulesRuleExtractRuleFilterKeyRegexOutputWithContext(context.Context) RulesRuleExtractRuleFilterKeyRegexOutput
}

type RulesRuleExtractRuleFilterKeyRegexArgs struct {
	// The name of the filter key.
	Key pulumi.StringInput `pulumi:"key"`
	// Regular expression for extracting path fields. It must match the collection path sample, otherwise it cannot be extracted successfully.
	Regex pulumi.StringInput `pulumi:"regex"`
}

func (RulesRuleExtractRuleFilterKeyRegexArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RulesRuleExtractRuleFilterKeyRegex)(nil)).Elem()
}

func (i RulesRuleExtractRuleFilterKeyRegexArgs) ToRulesRuleExtractRuleFilterKeyRegexOutput() RulesRuleExtractRuleFilterKeyRegexOutput {
	return i.ToRulesRuleExtractRuleFilterKeyRegexOutputWithContext(context.Background())
}

func (i RulesRuleExtractRuleFilterKeyRegexArgs) ToRulesRuleExtractRuleFilterKeyRegexOutputWithContext(ctx context.Context) RulesRuleExtractRuleFilterKeyRegexOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RulesRuleExtractRuleFilterKeyRegexOutput)
}

// RulesRuleExtractRuleFilterKeyRegexArrayInput is an input type that accepts RulesRuleExtractRuleFilterKeyRegexArray and RulesRuleExtractRuleFilterKeyRegexArrayOutput values.
// You can construct a concrete instance of `RulesRuleExtractRuleFilterKeyRegexArrayInput` via:
//
//	RulesRuleExtractRuleFilterKeyRegexArray{ RulesRuleExtractRuleFilterKeyRegexArgs{...} }
type RulesRuleExtractRuleFilterKeyRegexArrayInput interface {
	pulumi.Input

	ToRulesRuleExtractRuleFilterKeyRegexArrayOutput() RulesRuleExtractRuleFilterKeyRegexArrayOutput
	ToRulesRuleExtractRuleFilterKeyRegexArrayOutputWithContext(context.Context) RulesRuleExtractRuleFilterKeyRegexArrayOutput
}

type RulesRuleExtractRuleFilterKeyRegexArray []RulesRuleExtractRuleFilterKeyRegexInput

func (RulesRuleExtractRuleFilterKeyRegexArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RulesRuleExtractRuleFilterKeyRegex)(nil)).Elem()
}

func (i RulesRuleExtractRuleFilterKeyRegexArray) ToRulesRuleExtractRuleFilterKeyRegexArrayOutput() RulesRuleExtractRuleFilterKeyRegexArrayOutput {
	return i.ToRulesRuleExtractRuleFilterKeyRegexArrayOutputWithContext(context.Background())
}

func (i RulesRuleExtractRuleFilterKeyRegexArray) ToRulesRuleExtractRuleFilterKeyRegexArrayOutputWithContext(ctx context.Context) RulesRuleExtractRuleFilterKeyRegexArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RulesRuleExtractRuleFilterKeyRegexArrayOutput)
}

type RulesRuleExtractRuleFilterKeyRegexOutput struct{ *pulumi.OutputState }

func (RulesRuleExtractRuleFilterKeyRegexOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RulesRuleExtractRuleFilterKeyRegex)(nil)).Elem()
}

func (o RulesRuleExtractRuleFilterKeyRegexOutput) ToRulesRuleExtractRuleFilterKeyRegexOutput() RulesRuleExtractRuleFilterKeyRegexOutput {
	return o
}

func (o RulesRuleExtractRuleFilterKeyRegexOutput) ToRulesRuleExtractRuleFilterKeyRegexOutputWithContext(ctx context.Context) RulesRuleExtractRuleFilterKeyRegexOutput {
	return o
}

// The name of the filter key.
func (o RulesRuleExtractRuleFilterKeyRegexOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v RulesRuleExtractRuleFilterKeyRegex) string { return v.Key }).(pulumi.StringOutput)
}

// Regular expression for extracting path fields. It must match the collection path sample, otherwise it cannot be extracted successfully.
func (o RulesRuleExtractRuleFilterKeyRegexOutput) Regex() pulumi.StringOutput {
	return o.ApplyT(func(v RulesRuleExtractRuleFilterKeyRegex) string { return v.Regex }).(pulumi.StringOutput)
}

type RulesRuleExtractRuleFilterKeyRegexArrayOutput struct{ *pulumi.OutputState }

func (RulesRuleExtractRuleFilterKeyRegexArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RulesRuleExtractRuleFilterKeyRegex)(nil)).Elem()
}

func (o RulesRuleExtractRuleFilterKeyRegexArrayOutput) ToRulesRuleExtractRuleFilterKeyRegexArrayOutput() RulesRuleExtractRuleFilterKeyRegexArrayOutput {
	return o
}

func (o RulesRuleExtractRuleFilterKeyRegexArrayOutput) ToRulesRuleExtractRuleFilterKeyRegexArrayOutputWithContext(ctx context.Context) RulesRuleExtractRuleFilterKeyRegexArrayOutput {
	return o
}

func (o RulesRuleExtractRuleFilterKeyRegexArrayOutput) Index(i pulumi.IntInput) RulesRuleExtractRuleFilterKeyRegexOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RulesRuleExtractRuleFilterKeyRegex {
		return vs[0].([]RulesRuleExtractRuleFilterKeyRegex)[vs[1].(int)]
	}).(RulesRuleExtractRuleFilterKeyRegexOutput)
}

type RulesRuleExtractRuleLogTemplate struct {
	// Log template content.
	Format string `pulumi:"format"`
	// The type of the log template.
	Type string `pulumi:"type"`
}

// RulesRuleExtractRuleLogTemplateInput is an input type that accepts RulesRuleExtractRuleLogTemplateArgs and RulesRuleExtractRuleLogTemplateOutput values.
// You can construct a concrete instance of `RulesRuleExtractRuleLogTemplateInput` via:
//
//	RulesRuleExtractRuleLogTemplateArgs{...}
type RulesRuleExtractRuleLogTemplateInput interface {
	pulumi.Input

	ToRulesRuleExtractRuleLogTemplateOutput() RulesRuleExtractRuleLogTemplateOutput
	ToRulesRuleExtractRuleLogTemplateOutputWithContext(context.Context) RulesRuleExtractRuleLogTemplateOutput
}

type RulesRuleExtractRuleLogTemplateArgs struct {
	// Log template content.
	Format pulumi.StringInput `pulumi:"format"`
	// The type of the log template.
	Type pulumi.StringInput `pulumi:"type"`
}

func (RulesRuleExtractRuleLogTemplateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RulesRuleExtractRuleLogTemplate)(nil)).Elem()
}

func (i RulesRuleExtractRuleLogTemplateArgs) ToRulesRuleExtractRuleLogTemplateOutput() RulesRuleExtractRuleLogTemplateOutput {
	return i.ToRulesRuleExtractRuleLogTemplateOutputWithContext(context.Background())
}

func (i RulesRuleExtractRuleLogTemplateArgs) ToRulesRuleExtractRuleLogTemplateOutputWithContext(ctx context.Context) RulesRuleExtractRuleLogTemplateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RulesRuleExtractRuleLogTemplateOutput)
}

// RulesRuleExtractRuleLogTemplateArrayInput is an input type that accepts RulesRuleExtractRuleLogTemplateArray and RulesRuleExtractRuleLogTemplateArrayOutput values.
// You can construct a concrete instance of `RulesRuleExtractRuleLogTemplateArrayInput` via:
//
//	RulesRuleExtractRuleLogTemplateArray{ RulesRuleExtractRuleLogTemplateArgs{...} }
type RulesRuleExtractRuleLogTemplateArrayInput interface {
	pulumi.Input

	ToRulesRuleExtractRuleLogTemplateArrayOutput() RulesRuleExtractRuleLogTemplateArrayOutput
	ToRulesRuleExtractRuleLogTemplateArrayOutputWithContext(context.Context) RulesRuleExtractRuleLogTemplateArrayOutput
}

type RulesRuleExtractRuleLogTemplateArray []RulesRuleExtractRuleLogTemplateInput

func (RulesRuleExtractRuleLogTemplateArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RulesRuleExtractRuleLogTemplate)(nil)).Elem()
}

func (i RulesRuleExtractRuleLogTemplateArray) ToRulesRuleExtractRuleLogTemplateArrayOutput() RulesRuleExtractRuleLogTemplateArrayOutput {
	return i.ToRulesRuleExtractRuleLogTemplateArrayOutputWithContext(context.Background())
}

func (i RulesRuleExtractRuleLogTemplateArray) ToRulesRuleExtractRuleLogTemplateArrayOutputWithContext(ctx context.Context) RulesRuleExtractRuleLogTemplateArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RulesRuleExtractRuleLogTemplateArrayOutput)
}

type RulesRuleExtractRuleLogTemplateOutput struct{ *pulumi.OutputState }

func (RulesRuleExtractRuleLogTemplateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RulesRuleExtractRuleLogTemplate)(nil)).Elem()
}

func (o RulesRuleExtractRuleLogTemplateOutput) ToRulesRuleExtractRuleLogTemplateOutput() RulesRuleExtractRuleLogTemplateOutput {
	return o
}

func (o RulesRuleExtractRuleLogTemplateOutput) ToRulesRuleExtractRuleLogTemplateOutputWithContext(ctx context.Context) RulesRuleExtractRuleLogTemplateOutput {
	return o
}

// Log template content.
func (o RulesRuleExtractRuleLogTemplateOutput) Format() pulumi.StringOutput {
	return o.ApplyT(func(v RulesRuleExtractRuleLogTemplate) string { return v.Format }).(pulumi.StringOutput)
}

// The type of the log template.
func (o RulesRuleExtractRuleLogTemplateOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v RulesRuleExtractRuleLogTemplate) string { return v.Type }).(pulumi.StringOutput)
}

type RulesRuleExtractRuleLogTemplateArrayOutput struct{ *pulumi.OutputState }

func (RulesRuleExtractRuleLogTemplateArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RulesRuleExtractRuleLogTemplate)(nil)).Elem()
}

func (o RulesRuleExtractRuleLogTemplateArrayOutput) ToRulesRuleExtractRuleLogTemplateArrayOutput() RulesRuleExtractRuleLogTemplateArrayOutput {
	return o
}

func (o RulesRuleExtractRuleLogTemplateArrayOutput) ToRulesRuleExtractRuleLogTemplateArrayOutputWithContext(ctx context.Context) RulesRuleExtractRuleLogTemplateArrayOutput {
	return o
}

func (o RulesRuleExtractRuleLogTemplateArrayOutput) Index(i pulumi.IntInput) RulesRuleExtractRuleLogTemplateOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RulesRuleExtractRuleLogTemplate {
		return vs[0].([]RulesRuleExtractRuleLogTemplate)[vs[1].(int)]
	}).(RulesRuleExtractRuleLogTemplateOutput)
}

type RulesRuleUserDefineRule struct {
	// LogCollector extension configuration.
	Advanceds []RulesRuleUserDefineRuleAdvanced `pulumi:"advanceds"`
	// Whether to upload raw logs.
	EnableRawLog bool `pulumi:"enableRawLog"`
	// Add constant fields to logs.
	Fields map[string]interface{} `pulumi:"fields"`
	// Rules for parsing collection paths. After the rules are set, the fields in the collection path will be extracted through the regular expressions specified in the rules, and added to the log data as metadata.
	ParsePathRules []RulesRuleUserDefineRuleParsePathRule `pulumi:"parsePathRules"`
	// Plugin configuration. After the plugin configuration is enabled, one or more LogCollector processor plugins can be added to parse logs with complex or variable structures.
	Plugins []RulesRuleUserDefineRulePlugin `pulumi:"plugins"`
	// Rules for routing log partitions. Setting this parameter indicates that the HashKey routing shard mode is used when collecting logs, and Log Service will write the data to the shard containing the specified Key value.
	ShardHashKeys []RulesRuleUserDefineRuleShardHashKey `pulumi:"shardHashKeys"`
	// LogCollector collection strategy, which specifies whether LogCollector collects incremental logs or full logs. The default is false, which means to collect all logs.
	TailFiles bool `pulumi:"tailFiles"`
}

// RulesRuleUserDefineRuleInput is an input type that accepts RulesRuleUserDefineRuleArgs and RulesRuleUserDefineRuleOutput values.
// You can construct a concrete instance of `RulesRuleUserDefineRuleInput` via:
//
//	RulesRuleUserDefineRuleArgs{...}
type RulesRuleUserDefineRuleInput interface {
	pulumi.Input

	ToRulesRuleUserDefineRuleOutput() RulesRuleUserDefineRuleOutput
	ToRulesRuleUserDefineRuleOutputWithContext(context.Context) RulesRuleUserDefineRuleOutput
}

type RulesRuleUserDefineRuleArgs struct {
	// LogCollector extension configuration.
	Advanceds RulesRuleUserDefineRuleAdvancedArrayInput `pulumi:"advanceds"`
	// Whether to upload raw logs.
	EnableRawLog pulumi.BoolInput `pulumi:"enableRawLog"`
	// Add constant fields to logs.
	Fields pulumi.MapInput `pulumi:"fields"`
	// Rules for parsing collection paths. After the rules are set, the fields in the collection path will be extracted through the regular expressions specified in the rules, and added to the log data as metadata.
	ParsePathRules RulesRuleUserDefineRuleParsePathRuleArrayInput `pulumi:"parsePathRules"`
	// Plugin configuration. After the plugin configuration is enabled, one or more LogCollector processor plugins can be added to parse logs with complex or variable structures.
	Plugins RulesRuleUserDefineRulePluginArrayInput `pulumi:"plugins"`
	// Rules for routing log partitions. Setting this parameter indicates that the HashKey routing shard mode is used when collecting logs, and Log Service will write the data to the shard containing the specified Key value.
	ShardHashKeys RulesRuleUserDefineRuleShardHashKeyArrayInput `pulumi:"shardHashKeys"`
	// LogCollector collection strategy, which specifies whether LogCollector collects incremental logs or full logs. The default is false, which means to collect all logs.
	TailFiles pulumi.BoolInput `pulumi:"tailFiles"`
}

func (RulesRuleUserDefineRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RulesRuleUserDefineRule)(nil)).Elem()
}

func (i RulesRuleUserDefineRuleArgs) ToRulesRuleUserDefineRuleOutput() RulesRuleUserDefineRuleOutput {
	return i.ToRulesRuleUserDefineRuleOutputWithContext(context.Background())
}

func (i RulesRuleUserDefineRuleArgs) ToRulesRuleUserDefineRuleOutputWithContext(ctx context.Context) RulesRuleUserDefineRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RulesRuleUserDefineRuleOutput)
}

// RulesRuleUserDefineRuleArrayInput is an input type that accepts RulesRuleUserDefineRuleArray and RulesRuleUserDefineRuleArrayOutput values.
// You can construct a concrete instance of `RulesRuleUserDefineRuleArrayInput` via:
//
//	RulesRuleUserDefineRuleArray{ RulesRuleUserDefineRuleArgs{...} }
type RulesRuleUserDefineRuleArrayInput interface {
	pulumi.Input

	ToRulesRuleUserDefineRuleArrayOutput() RulesRuleUserDefineRuleArrayOutput
	ToRulesRuleUserDefineRuleArrayOutputWithContext(context.Context) RulesRuleUserDefineRuleArrayOutput
}

type RulesRuleUserDefineRuleArray []RulesRuleUserDefineRuleInput

func (RulesRuleUserDefineRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RulesRuleUserDefineRule)(nil)).Elem()
}

func (i RulesRuleUserDefineRuleArray) ToRulesRuleUserDefineRuleArrayOutput() RulesRuleUserDefineRuleArrayOutput {
	return i.ToRulesRuleUserDefineRuleArrayOutputWithContext(context.Background())
}

func (i RulesRuleUserDefineRuleArray) ToRulesRuleUserDefineRuleArrayOutputWithContext(ctx context.Context) RulesRuleUserDefineRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RulesRuleUserDefineRuleArrayOutput)
}

type RulesRuleUserDefineRuleOutput struct{ *pulumi.OutputState }

func (RulesRuleUserDefineRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RulesRuleUserDefineRule)(nil)).Elem()
}

func (o RulesRuleUserDefineRuleOutput) ToRulesRuleUserDefineRuleOutput() RulesRuleUserDefineRuleOutput {
	return o
}

func (o RulesRuleUserDefineRuleOutput) ToRulesRuleUserDefineRuleOutputWithContext(ctx context.Context) RulesRuleUserDefineRuleOutput {
	return o
}

// LogCollector extension configuration.
func (o RulesRuleUserDefineRuleOutput) Advanceds() RulesRuleUserDefineRuleAdvancedArrayOutput {
	return o.ApplyT(func(v RulesRuleUserDefineRule) []RulesRuleUserDefineRuleAdvanced { return v.Advanceds }).(RulesRuleUserDefineRuleAdvancedArrayOutput)
}

// Whether to upload raw logs.
func (o RulesRuleUserDefineRuleOutput) EnableRawLog() pulumi.BoolOutput {
	return o.ApplyT(func(v RulesRuleUserDefineRule) bool { return v.EnableRawLog }).(pulumi.BoolOutput)
}

// Add constant fields to logs.
func (o RulesRuleUserDefineRuleOutput) Fields() pulumi.MapOutput {
	return o.ApplyT(func(v RulesRuleUserDefineRule) map[string]interface{} { return v.Fields }).(pulumi.MapOutput)
}

// Rules for parsing collection paths. After the rules are set, the fields in the collection path will be extracted through the regular expressions specified in the rules, and added to the log data as metadata.
func (o RulesRuleUserDefineRuleOutput) ParsePathRules() RulesRuleUserDefineRuleParsePathRuleArrayOutput {
	return o.ApplyT(func(v RulesRuleUserDefineRule) []RulesRuleUserDefineRuleParsePathRule { return v.ParsePathRules }).(RulesRuleUserDefineRuleParsePathRuleArrayOutput)
}

// Plugin configuration. After the plugin configuration is enabled, one or more LogCollector processor plugins can be added to parse logs with complex or variable structures.
func (o RulesRuleUserDefineRuleOutput) Plugins() RulesRuleUserDefineRulePluginArrayOutput {
	return o.ApplyT(func(v RulesRuleUserDefineRule) []RulesRuleUserDefineRulePlugin { return v.Plugins }).(RulesRuleUserDefineRulePluginArrayOutput)
}

// Rules for routing log partitions. Setting this parameter indicates that the HashKey routing shard mode is used when collecting logs, and Log Service will write the data to the shard containing the specified Key value.
func (o RulesRuleUserDefineRuleOutput) ShardHashKeys() RulesRuleUserDefineRuleShardHashKeyArrayOutput {
	return o.ApplyT(func(v RulesRuleUserDefineRule) []RulesRuleUserDefineRuleShardHashKey { return v.ShardHashKeys }).(RulesRuleUserDefineRuleShardHashKeyArrayOutput)
}

// LogCollector collection strategy, which specifies whether LogCollector collects incremental logs or full logs. The default is false, which means to collect all logs.
func (o RulesRuleUserDefineRuleOutput) TailFiles() pulumi.BoolOutput {
	return o.ApplyT(func(v RulesRuleUserDefineRule) bool { return v.TailFiles }).(pulumi.BoolOutput)
}

type RulesRuleUserDefineRuleArrayOutput struct{ *pulumi.OutputState }

func (RulesRuleUserDefineRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RulesRuleUserDefineRule)(nil)).Elem()
}

func (o RulesRuleUserDefineRuleArrayOutput) ToRulesRuleUserDefineRuleArrayOutput() RulesRuleUserDefineRuleArrayOutput {
	return o
}

func (o RulesRuleUserDefineRuleArrayOutput) ToRulesRuleUserDefineRuleArrayOutputWithContext(ctx context.Context) RulesRuleUserDefineRuleArrayOutput {
	return o
}

func (o RulesRuleUserDefineRuleArrayOutput) Index(i pulumi.IntInput) RulesRuleUserDefineRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RulesRuleUserDefineRule {
		return vs[0].([]RulesRuleUserDefineRule)[vs[1].(int)]
	}).(RulesRuleUserDefineRuleOutput)
}

type RulesRuleUserDefineRuleAdvanced struct {
	// Whether to release the log file handle after reading to the end of the log file. The default is false.
	CloseEof bool `pulumi:"closeEof"`
	// The wait time to release the log file handle. When the log file has not written a new log for more than the specified time, release the handle of the log file.
	CloseInactive int `pulumi:"closeInactive"`
	// After the log file is removed, whether to release the handle of the log file. The default is false.
	CloseRemoved bool `pulumi:"closeRemoved"`
	// After the log file is renamed, whether to release the handle of the log file. The default is false.
	CloseRenamed bool `pulumi:"closeRenamed"`
	// The maximum length of time that LogCollector monitors log files. The unit is seconds, and the default is 0 seconds, which means that there is no limit to the length of time LogCollector monitors log files.
	CloseTimeout int `pulumi:"closeTimeout"`
}

// RulesRuleUserDefineRuleAdvancedInput is an input type that accepts RulesRuleUserDefineRuleAdvancedArgs and RulesRuleUserDefineRuleAdvancedOutput values.
// You can construct a concrete instance of `RulesRuleUserDefineRuleAdvancedInput` via:
//
//	RulesRuleUserDefineRuleAdvancedArgs{...}
type RulesRuleUserDefineRuleAdvancedInput interface {
	pulumi.Input

	ToRulesRuleUserDefineRuleAdvancedOutput() RulesRuleUserDefineRuleAdvancedOutput
	ToRulesRuleUserDefineRuleAdvancedOutputWithContext(context.Context) RulesRuleUserDefineRuleAdvancedOutput
}

type RulesRuleUserDefineRuleAdvancedArgs struct {
	// Whether to release the log file handle after reading to the end of the log file. The default is false.
	CloseEof pulumi.BoolInput `pulumi:"closeEof"`
	// The wait time to release the log file handle. When the log file has not written a new log for more than the specified time, release the handle of the log file.
	CloseInactive pulumi.IntInput `pulumi:"closeInactive"`
	// After the log file is removed, whether to release the handle of the log file. The default is false.
	CloseRemoved pulumi.BoolInput `pulumi:"closeRemoved"`
	// After the log file is renamed, whether to release the handle of the log file. The default is false.
	CloseRenamed pulumi.BoolInput `pulumi:"closeRenamed"`
	// The maximum length of time that LogCollector monitors log files. The unit is seconds, and the default is 0 seconds, which means that there is no limit to the length of time LogCollector monitors log files.
	CloseTimeout pulumi.IntInput `pulumi:"closeTimeout"`
}

func (RulesRuleUserDefineRuleAdvancedArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RulesRuleUserDefineRuleAdvanced)(nil)).Elem()
}

func (i RulesRuleUserDefineRuleAdvancedArgs) ToRulesRuleUserDefineRuleAdvancedOutput() RulesRuleUserDefineRuleAdvancedOutput {
	return i.ToRulesRuleUserDefineRuleAdvancedOutputWithContext(context.Background())
}

func (i RulesRuleUserDefineRuleAdvancedArgs) ToRulesRuleUserDefineRuleAdvancedOutputWithContext(ctx context.Context) RulesRuleUserDefineRuleAdvancedOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RulesRuleUserDefineRuleAdvancedOutput)
}

// RulesRuleUserDefineRuleAdvancedArrayInput is an input type that accepts RulesRuleUserDefineRuleAdvancedArray and RulesRuleUserDefineRuleAdvancedArrayOutput values.
// You can construct a concrete instance of `RulesRuleUserDefineRuleAdvancedArrayInput` via:
//
//	RulesRuleUserDefineRuleAdvancedArray{ RulesRuleUserDefineRuleAdvancedArgs{...} }
type RulesRuleUserDefineRuleAdvancedArrayInput interface {
	pulumi.Input

	ToRulesRuleUserDefineRuleAdvancedArrayOutput() RulesRuleUserDefineRuleAdvancedArrayOutput
	ToRulesRuleUserDefineRuleAdvancedArrayOutputWithContext(context.Context) RulesRuleUserDefineRuleAdvancedArrayOutput
}

type RulesRuleUserDefineRuleAdvancedArray []RulesRuleUserDefineRuleAdvancedInput

func (RulesRuleUserDefineRuleAdvancedArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RulesRuleUserDefineRuleAdvanced)(nil)).Elem()
}

func (i RulesRuleUserDefineRuleAdvancedArray) ToRulesRuleUserDefineRuleAdvancedArrayOutput() RulesRuleUserDefineRuleAdvancedArrayOutput {
	return i.ToRulesRuleUserDefineRuleAdvancedArrayOutputWithContext(context.Background())
}

func (i RulesRuleUserDefineRuleAdvancedArray) ToRulesRuleUserDefineRuleAdvancedArrayOutputWithContext(ctx context.Context) RulesRuleUserDefineRuleAdvancedArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RulesRuleUserDefineRuleAdvancedArrayOutput)
}

type RulesRuleUserDefineRuleAdvancedOutput struct{ *pulumi.OutputState }

func (RulesRuleUserDefineRuleAdvancedOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RulesRuleUserDefineRuleAdvanced)(nil)).Elem()
}

func (o RulesRuleUserDefineRuleAdvancedOutput) ToRulesRuleUserDefineRuleAdvancedOutput() RulesRuleUserDefineRuleAdvancedOutput {
	return o
}

func (o RulesRuleUserDefineRuleAdvancedOutput) ToRulesRuleUserDefineRuleAdvancedOutputWithContext(ctx context.Context) RulesRuleUserDefineRuleAdvancedOutput {
	return o
}

// Whether to release the log file handle after reading to the end of the log file. The default is false.
func (o RulesRuleUserDefineRuleAdvancedOutput) CloseEof() pulumi.BoolOutput {
	return o.ApplyT(func(v RulesRuleUserDefineRuleAdvanced) bool { return v.CloseEof }).(pulumi.BoolOutput)
}

// The wait time to release the log file handle. When the log file has not written a new log for more than the specified time, release the handle of the log file.
func (o RulesRuleUserDefineRuleAdvancedOutput) CloseInactive() pulumi.IntOutput {
	return o.ApplyT(func(v RulesRuleUserDefineRuleAdvanced) int { return v.CloseInactive }).(pulumi.IntOutput)
}

// After the log file is removed, whether to release the handle of the log file. The default is false.
func (o RulesRuleUserDefineRuleAdvancedOutput) CloseRemoved() pulumi.BoolOutput {
	return o.ApplyT(func(v RulesRuleUserDefineRuleAdvanced) bool { return v.CloseRemoved }).(pulumi.BoolOutput)
}

// After the log file is renamed, whether to release the handle of the log file. The default is false.
func (o RulesRuleUserDefineRuleAdvancedOutput) CloseRenamed() pulumi.BoolOutput {
	return o.ApplyT(func(v RulesRuleUserDefineRuleAdvanced) bool { return v.CloseRenamed }).(pulumi.BoolOutput)
}

// The maximum length of time that LogCollector monitors log files. The unit is seconds, and the default is 0 seconds, which means that there is no limit to the length of time LogCollector monitors log files.
func (o RulesRuleUserDefineRuleAdvancedOutput) CloseTimeout() pulumi.IntOutput {
	return o.ApplyT(func(v RulesRuleUserDefineRuleAdvanced) int { return v.CloseTimeout }).(pulumi.IntOutput)
}

type RulesRuleUserDefineRuleAdvancedArrayOutput struct{ *pulumi.OutputState }

func (RulesRuleUserDefineRuleAdvancedArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RulesRuleUserDefineRuleAdvanced)(nil)).Elem()
}

func (o RulesRuleUserDefineRuleAdvancedArrayOutput) ToRulesRuleUserDefineRuleAdvancedArrayOutput() RulesRuleUserDefineRuleAdvancedArrayOutput {
	return o
}

func (o RulesRuleUserDefineRuleAdvancedArrayOutput) ToRulesRuleUserDefineRuleAdvancedArrayOutputWithContext(ctx context.Context) RulesRuleUserDefineRuleAdvancedArrayOutput {
	return o
}

func (o RulesRuleUserDefineRuleAdvancedArrayOutput) Index(i pulumi.IntInput) RulesRuleUserDefineRuleAdvancedOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RulesRuleUserDefineRuleAdvanced {
		return vs[0].([]RulesRuleUserDefineRuleAdvanced)[vs[1].(int)]
	}).(RulesRuleUserDefineRuleAdvancedOutput)
}

type RulesRuleUserDefineRuleParsePathRule struct {
	// A list of field names. Log Service will parse the path sample (PathSample) into multiple fields according to the regular expression (Regex), and Keys is used to specify the field name of each field.
	Keys []string `pulumi:"keys"`
	// Sample capture path for a real scene.
	PathSample string `pulumi:"pathSample"`
	// Regular expression for extracting path fields. It must match the collection path sample, otherwise it cannot be extracted successfully.
	Regex string `pulumi:"regex"`
}

// RulesRuleUserDefineRuleParsePathRuleInput is an input type that accepts RulesRuleUserDefineRuleParsePathRuleArgs and RulesRuleUserDefineRuleParsePathRuleOutput values.
// You can construct a concrete instance of `RulesRuleUserDefineRuleParsePathRuleInput` via:
//
//	RulesRuleUserDefineRuleParsePathRuleArgs{...}
type RulesRuleUserDefineRuleParsePathRuleInput interface {
	pulumi.Input

	ToRulesRuleUserDefineRuleParsePathRuleOutput() RulesRuleUserDefineRuleParsePathRuleOutput
	ToRulesRuleUserDefineRuleParsePathRuleOutputWithContext(context.Context) RulesRuleUserDefineRuleParsePathRuleOutput
}

type RulesRuleUserDefineRuleParsePathRuleArgs struct {
	// A list of field names. Log Service will parse the path sample (PathSample) into multiple fields according to the regular expression (Regex), and Keys is used to specify the field name of each field.
	Keys pulumi.StringArrayInput `pulumi:"keys"`
	// Sample capture path for a real scene.
	PathSample pulumi.StringInput `pulumi:"pathSample"`
	// Regular expression for extracting path fields. It must match the collection path sample, otherwise it cannot be extracted successfully.
	Regex pulumi.StringInput `pulumi:"regex"`
}

func (RulesRuleUserDefineRuleParsePathRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RulesRuleUserDefineRuleParsePathRule)(nil)).Elem()
}

func (i RulesRuleUserDefineRuleParsePathRuleArgs) ToRulesRuleUserDefineRuleParsePathRuleOutput() RulesRuleUserDefineRuleParsePathRuleOutput {
	return i.ToRulesRuleUserDefineRuleParsePathRuleOutputWithContext(context.Background())
}

func (i RulesRuleUserDefineRuleParsePathRuleArgs) ToRulesRuleUserDefineRuleParsePathRuleOutputWithContext(ctx context.Context) RulesRuleUserDefineRuleParsePathRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RulesRuleUserDefineRuleParsePathRuleOutput)
}

// RulesRuleUserDefineRuleParsePathRuleArrayInput is an input type that accepts RulesRuleUserDefineRuleParsePathRuleArray and RulesRuleUserDefineRuleParsePathRuleArrayOutput values.
// You can construct a concrete instance of `RulesRuleUserDefineRuleParsePathRuleArrayInput` via:
//
//	RulesRuleUserDefineRuleParsePathRuleArray{ RulesRuleUserDefineRuleParsePathRuleArgs{...} }
type RulesRuleUserDefineRuleParsePathRuleArrayInput interface {
	pulumi.Input

	ToRulesRuleUserDefineRuleParsePathRuleArrayOutput() RulesRuleUserDefineRuleParsePathRuleArrayOutput
	ToRulesRuleUserDefineRuleParsePathRuleArrayOutputWithContext(context.Context) RulesRuleUserDefineRuleParsePathRuleArrayOutput
}

type RulesRuleUserDefineRuleParsePathRuleArray []RulesRuleUserDefineRuleParsePathRuleInput

func (RulesRuleUserDefineRuleParsePathRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RulesRuleUserDefineRuleParsePathRule)(nil)).Elem()
}

func (i RulesRuleUserDefineRuleParsePathRuleArray) ToRulesRuleUserDefineRuleParsePathRuleArrayOutput() RulesRuleUserDefineRuleParsePathRuleArrayOutput {
	return i.ToRulesRuleUserDefineRuleParsePathRuleArrayOutputWithContext(context.Background())
}

func (i RulesRuleUserDefineRuleParsePathRuleArray) ToRulesRuleUserDefineRuleParsePathRuleArrayOutputWithContext(ctx context.Context) RulesRuleUserDefineRuleParsePathRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RulesRuleUserDefineRuleParsePathRuleArrayOutput)
}

type RulesRuleUserDefineRuleParsePathRuleOutput struct{ *pulumi.OutputState }

func (RulesRuleUserDefineRuleParsePathRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RulesRuleUserDefineRuleParsePathRule)(nil)).Elem()
}

func (o RulesRuleUserDefineRuleParsePathRuleOutput) ToRulesRuleUserDefineRuleParsePathRuleOutput() RulesRuleUserDefineRuleParsePathRuleOutput {
	return o
}

func (o RulesRuleUserDefineRuleParsePathRuleOutput) ToRulesRuleUserDefineRuleParsePathRuleOutputWithContext(ctx context.Context) RulesRuleUserDefineRuleParsePathRuleOutput {
	return o
}

// A list of field names. Log Service will parse the path sample (PathSample) into multiple fields according to the regular expression (Regex), and Keys is used to specify the field name of each field.
func (o RulesRuleUserDefineRuleParsePathRuleOutput) Keys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v RulesRuleUserDefineRuleParsePathRule) []string { return v.Keys }).(pulumi.StringArrayOutput)
}

// Sample capture path for a real scene.
func (o RulesRuleUserDefineRuleParsePathRuleOutput) PathSample() pulumi.StringOutput {
	return o.ApplyT(func(v RulesRuleUserDefineRuleParsePathRule) string { return v.PathSample }).(pulumi.StringOutput)
}

// Regular expression for extracting path fields. It must match the collection path sample, otherwise it cannot be extracted successfully.
func (o RulesRuleUserDefineRuleParsePathRuleOutput) Regex() pulumi.StringOutput {
	return o.ApplyT(func(v RulesRuleUserDefineRuleParsePathRule) string { return v.Regex }).(pulumi.StringOutput)
}

type RulesRuleUserDefineRuleParsePathRuleArrayOutput struct{ *pulumi.OutputState }

func (RulesRuleUserDefineRuleParsePathRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RulesRuleUserDefineRuleParsePathRule)(nil)).Elem()
}

func (o RulesRuleUserDefineRuleParsePathRuleArrayOutput) ToRulesRuleUserDefineRuleParsePathRuleArrayOutput() RulesRuleUserDefineRuleParsePathRuleArrayOutput {
	return o
}

func (o RulesRuleUserDefineRuleParsePathRuleArrayOutput) ToRulesRuleUserDefineRuleParsePathRuleArrayOutputWithContext(ctx context.Context) RulesRuleUserDefineRuleParsePathRuleArrayOutput {
	return o
}

func (o RulesRuleUserDefineRuleParsePathRuleArrayOutput) Index(i pulumi.IntInput) RulesRuleUserDefineRuleParsePathRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RulesRuleUserDefineRuleParsePathRule {
		return vs[0].([]RulesRuleUserDefineRuleParsePathRule)[vs[1].(int)]
	}).(RulesRuleUserDefineRuleParsePathRuleOutput)
}

type RulesRuleUserDefineRulePlugin struct {
	// LogCollector plugin.
	Processors []string `pulumi:"processors"`
}

// RulesRuleUserDefineRulePluginInput is an input type that accepts RulesRuleUserDefineRulePluginArgs and RulesRuleUserDefineRulePluginOutput values.
// You can construct a concrete instance of `RulesRuleUserDefineRulePluginInput` via:
//
//	RulesRuleUserDefineRulePluginArgs{...}
type RulesRuleUserDefineRulePluginInput interface {
	pulumi.Input

	ToRulesRuleUserDefineRulePluginOutput() RulesRuleUserDefineRulePluginOutput
	ToRulesRuleUserDefineRulePluginOutputWithContext(context.Context) RulesRuleUserDefineRulePluginOutput
}

type RulesRuleUserDefineRulePluginArgs struct {
	// LogCollector plugin.
	Processors pulumi.StringArrayInput `pulumi:"processors"`
}

func (RulesRuleUserDefineRulePluginArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RulesRuleUserDefineRulePlugin)(nil)).Elem()
}

func (i RulesRuleUserDefineRulePluginArgs) ToRulesRuleUserDefineRulePluginOutput() RulesRuleUserDefineRulePluginOutput {
	return i.ToRulesRuleUserDefineRulePluginOutputWithContext(context.Background())
}

func (i RulesRuleUserDefineRulePluginArgs) ToRulesRuleUserDefineRulePluginOutputWithContext(ctx context.Context) RulesRuleUserDefineRulePluginOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RulesRuleUserDefineRulePluginOutput)
}

// RulesRuleUserDefineRulePluginArrayInput is an input type that accepts RulesRuleUserDefineRulePluginArray and RulesRuleUserDefineRulePluginArrayOutput values.
// You can construct a concrete instance of `RulesRuleUserDefineRulePluginArrayInput` via:
//
//	RulesRuleUserDefineRulePluginArray{ RulesRuleUserDefineRulePluginArgs{...} }
type RulesRuleUserDefineRulePluginArrayInput interface {
	pulumi.Input

	ToRulesRuleUserDefineRulePluginArrayOutput() RulesRuleUserDefineRulePluginArrayOutput
	ToRulesRuleUserDefineRulePluginArrayOutputWithContext(context.Context) RulesRuleUserDefineRulePluginArrayOutput
}

type RulesRuleUserDefineRulePluginArray []RulesRuleUserDefineRulePluginInput

func (RulesRuleUserDefineRulePluginArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RulesRuleUserDefineRulePlugin)(nil)).Elem()
}

func (i RulesRuleUserDefineRulePluginArray) ToRulesRuleUserDefineRulePluginArrayOutput() RulesRuleUserDefineRulePluginArrayOutput {
	return i.ToRulesRuleUserDefineRulePluginArrayOutputWithContext(context.Background())
}

func (i RulesRuleUserDefineRulePluginArray) ToRulesRuleUserDefineRulePluginArrayOutputWithContext(ctx context.Context) RulesRuleUserDefineRulePluginArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RulesRuleUserDefineRulePluginArrayOutput)
}

type RulesRuleUserDefineRulePluginOutput struct{ *pulumi.OutputState }

func (RulesRuleUserDefineRulePluginOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RulesRuleUserDefineRulePlugin)(nil)).Elem()
}

func (o RulesRuleUserDefineRulePluginOutput) ToRulesRuleUserDefineRulePluginOutput() RulesRuleUserDefineRulePluginOutput {
	return o
}

func (o RulesRuleUserDefineRulePluginOutput) ToRulesRuleUserDefineRulePluginOutputWithContext(ctx context.Context) RulesRuleUserDefineRulePluginOutput {
	return o
}

// LogCollector plugin.
func (o RulesRuleUserDefineRulePluginOutput) Processors() pulumi.StringArrayOutput {
	return o.ApplyT(func(v RulesRuleUserDefineRulePlugin) []string { return v.Processors }).(pulumi.StringArrayOutput)
}

type RulesRuleUserDefineRulePluginArrayOutput struct{ *pulumi.OutputState }

func (RulesRuleUserDefineRulePluginArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RulesRuleUserDefineRulePlugin)(nil)).Elem()
}

func (o RulesRuleUserDefineRulePluginArrayOutput) ToRulesRuleUserDefineRulePluginArrayOutput() RulesRuleUserDefineRulePluginArrayOutput {
	return o
}

func (o RulesRuleUserDefineRulePluginArrayOutput) ToRulesRuleUserDefineRulePluginArrayOutputWithContext(ctx context.Context) RulesRuleUserDefineRulePluginArrayOutput {
	return o
}

func (o RulesRuleUserDefineRulePluginArrayOutput) Index(i pulumi.IntInput) RulesRuleUserDefineRulePluginOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RulesRuleUserDefineRulePlugin {
		return vs[0].([]RulesRuleUserDefineRulePlugin)[vs[1].(int)]
	}).(RulesRuleUserDefineRulePluginOutput)
}

type RulesRuleUserDefineRuleShardHashKey struct {
	// The HashKey of the log group is used to specify the partition (shard) to be written to by the current log group.
	HashKey string `pulumi:"hashKey"`
}

// RulesRuleUserDefineRuleShardHashKeyInput is an input type that accepts RulesRuleUserDefineRuleShardHashKeyArgs and RulesRuleUserDefineRuleShardHashKeyOutput values.
// You can construct a concrete instance of `RulesRuleUserDefineRuleShardHashKeyInput` via:
//
//	RulesRuleUserDefineRuleShardHashKeyArgs{...}
type RulesRuleUserDefineRuleShardHashKeyInput interface {
	pulumi.Input

	ToRulesRuleUserDefineRuleShardHashKeyOutput() RulesRuleUserDefineRuleShardHashKeyOutput
	ToRulesRuleUserDefineRuleShardHashKeyOutputWithContext(context.Context) RulesRuleUserDefineRuleShardHashKeyOutput
}

type RulesRuleUserDefineRuleShardHashKeyArgs struct {
	// The HashKey of the log group is used to specify the partition (shard) to be written to by the current log group.
	HashKey pulumi.StringInput `pulumi:"hashKey"`
}

func (RulesRuleUserDefineRuleShardHashKeyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*RulesRuleUserDefineRuleShardHashKey)(nil)).Elem()
}

func (i RulesRuleUserDefineRuleShardHashKeyArgs) ToRulesRuleUserDefineRuleShardHashKeyOutput() RulesRuleUserDefineRuleShardHashKeyOutput {
	return i.ToRulesRuleUserDefineRuleShardHashKeyOutputWithContext(context.Background())
}

func (i RulesRuleUserDefineRuleShardHashKeyArgs) ToRulesRuleUserDefineRuleShardHashKeyOutputWithContext(ctx context.Context) RulesRuleUserDefineRuleShardHashKeyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RulesRuleUserDefineRuleShardHashKeyOutput)
}

// RulesRuleUserDefineRuleShardHashKeyArrayInput is an input type that accepts RulesRuleUserDefineRuleShardHashKeyArray and RulesRuleUserDefineRuleShardHashKeyArrayOutput values.
// You can construct a concrete instance of `RulesRuleUserDefineRuleShardHashKeyArrayInput` via:
//
//	RulesRuleUserDefineRuleShardHashKeyArray{ RulesRuleUserDefineRuleShardHashKeyArgs{...} }
type RulesRuleUserDefineRuleShardHashKeyArrayInput interface {
	pulumi.Input

	ToRulesRuleUserDefineRuleShardHashKeyArrayOutput() RulesRuleUserDefineRuleShardHashKeyArrayOutput
	ToRulesRuleUserDefineRuleShardHashKeyArrayOutputWithContext(context.Context) RulesRuleUserDefineRuleShardHashKeyArrayOutput
}

type RulesRuleUserDefineRuleShardHashKeyArray []RulesRuleUserDefineRuleShardHashKeyInput

func (RulesRuleUserDefineRuleShardHashKeyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RulesRuleUserDefineRuleShardHashKey)(nil)).Elem()
}

func (i RulesRuleUserDefineRuleShardHashKeyArray) ToRulesRuleUserDefineRuleShardHashKeyArrayOutput() RulesRuleUserDefineRuleShardHashKeyArrayOutput {
	return i.ToRulesRuleUserDefineRuleShardHashKeyArrayOutputWithContext(context.Background())
}

func (i RulesRuleUserDefineRuleShardHashKeyArray) ToRulesRuleUserDefineRuleShardHashKeyArrayOutputWithContext(ctx context.Context) RulesRuleUserDefineRuleShardHashKeyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RulesRuleUserDefineRuleShardHashKeyArrayOutput)
}

type RulesRuleUserDefineRuleShardHashKeyOutput struct{ *pulumi.OutputState }

func (RulesRuleUserDefineRuleShardHashKeyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RulesRuleUserDefineRuleShardHashKey)(nil)).Elem()
}

func (o RulesRuleUserDefineRuleShardHashKeyOutput) ToRulesRuleUserDefineRuleShardHashKeyOutput() RulesRuleUserDefineRuleShardHashKeyOutput {
	return o
}

func (o RulesRuleUserDefineRuleShardHashKeyOutput) ToRulesRuleUserDefineRuleShardHashKeyOutputWithContext(ctx context.Context) RulesRuleUserDefineRuleShardHashKeyOutput {
	return o
}

// The HashKey of the log group is used to specify the partition (shard) to be written to by the current log group.
func (o RulesRuleUserDefineRuleShardHashKeyOutput) HashKey() pulumi.StringOutput {
	return o.ApplyT(func(v RulesRuleUserDefineRuleShardHashKey) string { return v.HashKey }).(pulumi.StringOutput)
}

type RulesRuleUserDefineRuleShardHashKeyArrayOutput struct{ *pulumi.OutputState }

func (RulesRuleUserDefineRuleShardHashKeyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RulesRuleUserDefineRuleShardHashKey)(nil)).Elem()
}

func (o RulesRuleUserDefineRuleShardHashKeyArrayOutput) ToRulesRuleUserDefineRuleShardHashKeyArrayOutput() RulesRuleUserDefineRuleShardHashKeyArrayOutput {
	return o
}

func (o RulesRuleUserDefineRuleShardHashKeyArrayOutput) ToRulesRuleUserDefineRuleShardHashKeyArrayOutputWithContext(ctx context.Context) RulesRuleUserDefineRuleShardHashKeyArrayOutput {
	return o
}

func (o RulesRuleUserDefineRuleShardHashKeyArrayOutput) Index(i pulumi.IntInput) RulesRuleUserDefineRuleShardHashKeyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RulesRuleUserDefineRuleShardHashKey {
		return vs[0].([]RulesRuleUserDefineRuleShardHashKey)[vs[1].(int)]
	}).(RulesRuleUserDefineRuleShardHashKeyOutput)
}

type ShardsShard struct {
	// The end key info.
	ExclusiveEndKey string `pulumi:"exclusiveEndKey"`
	// The begin key info.
	InclusiveBeginKey string `pulumi:"inclusiveBeginKey"`
	// The modify time.
	ModifyTime string `pulumi:"modifyTime"`
	// The id of shard.
	ShardId int `pulumi:"shardId"`
	// The status of shard.
	Status string `pulumi:"status"`
	// The stop write time.
	StopWriteTime string `pulumi:"stopWriteTime"`
	// The id of topic.
	TopicId string `pulumi:"topicId"`
}

// ShardsShardInput is an input type that accepts ShardsShardArgs and ShardsShardOutput values.
// You can construct a concrete instance of `ShardsShardInput` via:
//
//	ShardsShardArgs{...}
type ShardsShardInput interface {
	pulumi.Input

	ToShardsShardOutput() ShardsShardOutput
	ToShardsShardOutputWithContext(context.Context) ShardsShardOutput
}

type ShardsShardArgs struct {
	// The end key info.
	ExclusiveEndKey pulumi.StringInput `pulumi:"exclusiveEndKey"`
	// The begin key info.
	InclusiveBeginKey pulumi.StringInput `pulumi:"inclusiveBeginKey"`
	// The modify time.
	ModifyTime pulumi.StringInput `pulumi:"modifyTime"`
	// The id of shard.
	ShardId pulumi.IntInput `pulumi:"shardId"`
	// The status of shard.
	Status pulumi.StringInput `pulumi:"status"`
	// The stop write time.
	StopWriteTime pulumi.StringInput `pulumi:"stopWriteTime"`
	// The id of topic.
	TopicId pulumi.StringInput `pulumi:"topicId"`
}

func (ShardsShardArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ShardsShard)(nil)).Elem()
}

func (i ShardsShardArgs) ToShardsShardOutput() ShardsShardOutput {
	return i.ToShardsShardOutputWithContext(context.Background())
}

func (i ShardsShardArgs) ToShardsShardOutputWithContext(ctx context.Context) ShardsShardOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ShardsShardOutput)
}

// ShardsShardArrayInput is an input type that accepts ShardsShardArray and ShardsShardArrayOutput values.
// You can construct a concrete instance of `ShardsShardArrayInput` via:
//
//	ShardsShardArray{ ShardsShardArgs{...} }
type ShardsShardArrayInput interface {
	pulumi.Input

	ToShardsShardArrayOutput() ShardsShardArrayOutput
	ToShardsShardArrayOutputWithContext(context.Context) ShardsShardArrayOutput
}

type ShardsShardArray []ShardsShardInput

func (ShardsShardArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ShardsShard)(nil)).Elem()
}

func (i ShardsShardArray) ToShardsShardArrayOutput() ShardsShardArrayOutput {
	return i.ToShardsShardArrayOutputWithContext(context.Background())
}

func (i ShardsShardArray) ToShardsShardArrayOutputWithContext(ctx context.Context) ShardsShardArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ShardsShardArrayOutput)
}

type ShardsShardOutput struct{ *pulumi.OutputState }

func (ShardsShardOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ShardsShard)(nil)).Elem()
}

func (o ShardsShardOutput) ToShardsShardOutput() ShardsShardOutput {
	return o
}

func (o ShardsShardOutput) ToShardsShardOutputWithContext(ctx context.Context) ShardsShardOutput {
	return o
}

// The end key info.
func (o ShardsShardOutput) ExclusiveEndKey() pulumi.StringOutput {
	return o.ApplyT(func(v ShardsShard) string { return v.ExclusiveEndKey }).(pulumi.StringOutput)
}

// The begin key info.
func (o ShardsShardOutput) InclusiveBeginKey() pulumi.StringOutput {
	return o.ApplyT(func(v ShardsShard) string { return v.InclusiveBeginKey }).(pulumi.StringOutput)
}

// The modify time.
func (o ShardsShardOutput) ModifyTime() pulumi.StringOutput {
	return o.ApplyT(func(v ShardsShard) string { return v.ModifyTime }).(pulumi.StringOutput)
}

// The id of shard.
func (o ShardsShardOutput) ShardId() pulumi.IntOutput {
	return o.ApplyT(func(v ShardsShard) int { return v.ShardId }).(pulumi.IntOutput)
}

// The status of shard.
func (o ShardsShardOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v ShardsShard) string { return v.Status }).(pulumi.StringOutput)
}

// The stop write time.
func (o ShardsShardOutput) StopWriteTime() pulumi.StringOutput {
	return o.ApplyT(func(v ShardsShard) string { return v.StopWriteTime }).(pulumi.StringOutput)
}

// The id of topic.
func (o ShardsShardOutput) TopicId() pulumi.StringOutput {
	return o.ApplyT(func(v ShardsShard) string { return v.TopicId }).(pulumi.StringOutput)
}

type ShardsShardArrayOutput struct{ *pulumi.OutputState }

func (ShardsShardArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ShardsShard)(nil)).Elem()
}

func (o ShardsShardArrayOutput) ToShardsShardArrayOutput() ShardsShardArrayOutput {
	return o
}

func (o ShardsShardArrayOutput) ToShardsShardArrayOutputWithContext(ctx context.Context) ShardsShardArrayOutput {
	return o
}

func (o ShardsShardArrayOutput) Index(i pulumi.IntInput) ShardsShardOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ShardsShard {
		return vs[0].([]ShardsShard)[vs[1].(int)]
	}).(ShardsShardOutput)
}

type TopicTag struct {
	// The Key of Tags.
	Key string `pulumi:"key"`
	// The Value of Tags.
	Value string `pulumi:"value"`
}

// TopicTagInput is an input type that accepts TopicTagArgs and TopicTagOutput values.
// You can construct a concrete instance of `TopicTagInput` via:
//
//	TopicTagArgs{...}
type TopicTagInput interface {
	pulumi.Input

	ToTopicTagOutput() TopicTagOutput
	ToTopicTagOutputWithContext(context.Context) TopicTagOutput
}

type TopicTagArgs struct {
	// The Key of Tags.
	Key pulumi.StringInput `pulumi:"key"`
	// The Value of Tags.
	Value pulumi.StringInput `pulumi:"value"`
}

func (TopicTagArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TopicTag)(nil)).Elem()
}

func (i TopicTagArgs) ToTopicTagOutput() TopicTagOutput {
	return i.ToTopicTagOutputWithContext(context.Background())
}

func (i TopicTagArgs) ToTopicTagOutputWithContext(ctx context.Context) TopicTagOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TopicTagOutput)
}

// TopicTagArrayInput is an input type that accepts TopicTagArray and TopicTagArrayOutput values.
// You can construct a concrete instance of `TopicTagArrayInput` via:
//
//	TopicTagArray{ TopicTagArgs{...} }
type TopicTagArrayInput interface {
	pulumi.Input

	ToTopicTagArrayOutput() TopicTagArrayOutput
	ToTopicTagArrayOutputWithContext(context.Context) TopicTagArrayOutput
}

type TopicTagArray []TopicTagInput

func (TopicTagArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TopicTag)(nil)).Elem()
}

func (i TopicTagArray) ToTopicTagArrayOutput() TopicTagArrayOutput {
	return i.ToTopicTagArrayOutputWithContext(context.Background())
}

func (i TopicTagArray) ToTopicTagArrayOutputWithContext(ctx context.Context) TopicTagArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TopicTagArrayOutput)
}

type TopicTagOutput struct{ *pulumi.OutputState }

func (TopicTagOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TopicTag)(nil)).Elem()
}

func (o TopicTagOutput) ToTopicTagOutput() TopicTagOutput {
	return o
}

func (o TopicTagOutput) ToTopicTagOutputWithContext(ctx context.Context) TopicTagOutput {
	return o
}

// The Key of Tags.
func (o TopicTagOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v TopicTag) string { return v.Key }).(pulumi.StringOutput)
}

// The Value of Tags.
func (o TopicTagOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v TopicTag) string { return v.Value }).(pulumi.StringOutput)
}

type TopicTagArrayOutput struct{ *pulumi.OutputState }

func (TopicTagArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TopicTag)(nil)).Elem()
}

func (o TopicTagArrayOutput) ToTopicTagArrayOutput() TopicTagArrayOutput {
	return o
}

func (o TopicTagArrayOutput) ToTopicTagArrayOutputWithContext(ctx context.Context) TopicTagArrayOutput {
	return o
}

func (o TopicTagArrayOutput) Index(i pulumi.IntInput) TopicTagOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TopicTag {
		return vs[0].([]TopicTag)[vs[1].(int)]
	}).(TopicTagOutput)
}

type TopicsTag struct {
	// The Key of Tags.
	Key string `pulumi:"key"`
	// The Value of Tags.
	Value string `pulumi:"value"`
}

// TopicsTagInput is an input type that accepts TopicsTagArgs and TopicsTagOutput values.
// You can construct a concrete instance of `TopicsTagInput` via:
//
//	TopicsTagArgs{...}
type TopicsTagInput interface {
	pulumi.Input

	ToTopicsTagOutput() TopicsTagOutput
	ToTopicsTagOutputWithContext(context.Context) TopicsTagOutput
}

type TopicsTagArgs struct {
	// The Key of Tags.
	Key pulumi.StringInput `pulumi:"key"`
	// The Value of Tags.
	Value pulumi.StringInput `pulumi:"value"`
}

func (TopicsTagArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TopicsTag)(nil)).Elem()
}

func (i TopicsTagArgs) ToTopicsTagOutput() TopicsTagOutput {
	return i.ToTopicsTagOutputWithContext(context.Background())
}

func (i TopicsTagArgs) ToTopicsTagOutputWithContext(ctx context.Context) TopicsTagOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TopicsTagOutput)
}

// TopicsTagArrayInput is an input type that accepts TopicsTagArray and TopicsTagArrayOutput values.
// You can construct a concrete instance of `TopicsTagArrayInput` via:
//
//	TopicsTagArray{ TopicsTagArgs{...} }
type TopicsTagArrayInput interface {
	pulumi.Input

	ToTopicsTagArrayOutput() TopicsTagArrayOutput
	ToTopicsTagArrayOutputWithContext(context.Context) TopicsTagArrayOutput
}

type TopicsTagArray []TopicsTagInput

func (TopicsTagArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TopicsTag)(nil)).Elem()
}

func (i TopicsTagArray) ToTopicsTagArrayOutput() TopicsTagArrayOutput {
	return i.ToTopicsTagArrayOutputWithContext(context.Background())
}

func (i TopicsTagArray) ToTopicsTagArrayOutputWithContext(ctx context.Context) TopicsTagArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TopicsTagArrayOutput)
}

type TopicsTagOutput struct{ *pulumi.OutputState }

func (TopicsTagOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TopicsTag)(nil)).Elem()
}

func (o TopicsTagOutput) ToTopicsTagOutput() TopicsTagOutput {
	return o
}

func (o TopicsTagOutput) ToTopicsTagOutputWithContext(ctx context.Context) TopicsTagOutput {
	return o
}

// The Key of Tags.
func (o TopicsTagOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v TopicsTag) string { return v.Key }).(pulumi.StringOutput)
}

// The Value of Tags.
func (o TopicsTagOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v TopicsTag) string { return v.Value }).(pulumi.StringOutput)
}

type TopicsTagArrayOutput struct{ *pulumi.OutputState }

func (TopicsTagArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TopicsTag)(nil)).Elem()
}

func (o TopicsTagArrayOutput) ToTopicsTagArrayOutput() TopicsTagArrayOutput {
	return o
}

func (o TopicsTagArrayOutput) ToTopicsTagArrayOutputWithContext(ctx context.Context) TopicsTagArrayOutput {
	return o
}

func (o TopicsTagArrayOutput) Index(i pulumi.IntInput) TopicsTagOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TopicsTag {
		return vs[0].([]TopicsTag)[vs[1].(int)]
	}).(TopicsTagOutput)
}

type TopicsTlsTopic struct {
	// Whether to enable automatic partition splitting function of the tls topic.
	AutoSplit bool `pulumi:"autoSplit"`
	// The create time of the tls topic.
	CreateTime string `pulumi:"createTime"`
	// The description of the tls topic.
	Description string `pulumi:"description"`
	// Whether to enable WebTracking function of the tls topic.
	EnableTracking bool `pulumi:"enableTracking"`
	// The ID of the tls topic.
	Id string `pulumi:"id"`
	// The max count of shards in the tls topic.
	MaxSplitShard int `pulumi:"maxSplitShard"`
	// The modify time of the tls topic.
	ModifyTime string `pulumi:"modifyTime"`
	// The project id of tls topic.
	ProjectId string `pulumi:"projectId"`
	// The count of shards in the tls topic.
	ShardCount int `pulumi:"shardCount"`
	// Tags.
	Tags []TopicsTlsTopicTag `pulumi:"tags"`
	// The format of the time field.
	TimeFormat string `pulumi:"timeFormat"`
	// The name of the time field.
	TimeKey string `pulumi:"timeKey"`
	// The id of tls topic. This field supports fuzzy queries. It is not supported to specify both TopicName and TopicId at the same time.
	TopicId string `pulumi:"topicId"`
	// The name of tls topic. This field supports fuzzy queries. It is not supported to specify both TopicName and TopicId at the same time.
	TopicName string `pulumi:"topicName"`
	// The data storage time of the tls topic. Unit: Day.
	Ttl int `pulumi:"ttl"`
}

// TopicsTlsTopicInput is an input type that accepts TopicsTlsTopicArgs and TopicsTlsTopicOutput values.
// You can construct a concrete instance of `TopicsTlsTopicInput` via:
//
//	TopicsTlsTopicArgs{...}
type TopicsTlsTopicInput interface {
	pulumi.Input

	ToTopicsTlsTopicOutput() TopicsTlsTopicOutput
	ToTopicsTlsTopicOutputWithContext(context.Context) TopicsTlsTopicOutput
}

type TopicsTlsTopicArgs struct {
	// Whether to enable automatic partition splitting function of the tls topic.
	AutoSplit pulumi.BoolInput `pulumi:"autoSplit"`
	// The create time of the tls topic.
	CreateTime pulumi.StringInput `pulumi:"createTime"`
	// The description of the tls topic.
	Description pulumi.StringInput `pulumi:"description"`
	// Whether to enable WebTracking function of the tls topic.
	EnableTracking pulumi.BoolInput `pulumi:"enableTracking"`
	// The ID of the tls topic.
	Id pulumi.StringInput `pulumi:"id"`
	// The max count of shards in the tls topic.
	MaxSplitShard pulumi.IntInput `pulumi:"maxSplitShard"`
	// The modify time of the tls topic.
	ModifyTime pulumi.StringInput `pulumi:"modifyTime"`
	// The project id of tls topic.
	ProjectId pulumi.StringInput `pulumi:"projectId"`
	// The count of shards in the tls topic.
	ShardCount pulumi.IntInput `pulumi:"shardCount"`
	// Tags.
	Tags TopicsTlsTopicTagArrayInput `pulumi:"tags"`
	// The format of the time field.
	TimeFormat pulumi.StringInput `pulumi:"timeFormat"`
	// The name of the time field.
	TimeKey pulumi.StringInput `pulumi:"timeKey"`
	// The id of tls topic. This field supports fuzzy queries. It is not supported to specify both TopicName and TopicId at the same time.
	TopicId pulumi.StringInput `pulumi:"topicId"`
	// The name of tls topic. This field supports fuzzy queries. It is not supported to specify both TopicName and TopicId at the same time.
	TopicName pulumi.StringInput `pulumi:"topicName"`
	// The data storage time of the tls topic. Unit: Day.
	Ttl pulumi.IntInput `pulumi:"ttl"`
}

func (TopicsTlsTopicArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TopicsTlsTopic)(nil)).Elem()
}

func (i TopicsTlsTopicArgs) ToTopicsTlsTopicOutput() TopicsTlsTopicOutput {
	return i.ToTopicsTlsTopicOutputWithContext(context.Background())
}

func (i TopicsTlsTopicArgs) ToTopicsTlsTopicOutputWithContext(ctx context.Context) TopicsTlsTopicOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TopicsTlsTopicOutput)
}

// TopicsTlsTopicArrayInput is an input type that accepts TopicsTlsTopicArray and TopicsTlsTopicArrayOutput values.
// You can construct a concrete instance of `TopicsTlsTopicArrayInput` via:
//
//	TopicsTlsTopicArray{ TopicsTlsTopicArgs{...} }
type TopicsTlsTopicArrayInput interface {
	pulumi.Input

	ToTopicsTlsTopicArrayOutput() TopicsTlsTopicArrayOutput
	ToTopicsTlsTopicArrayOutputWithContext(context.Context) TopicsTlsTopicArrayOutput
}

type TopicsTlsTopicArray []TopicsTlsTopicInput

func (TopicsTlsTopicArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TopicsTlsTopic)(nil)).Elem()
}

func (i TopicsTlsTopicArray) ToTopicsTlsTopicArrayOutput() TopicsTlsTopicArrayOutput {
	return i.ToTopicsTlsTopicArrayOutputWithContext(context.Background())
}

func (i TopicsTlsTopicArray) ToTopicsTlsTopicArrayOutputWithContext(ctx context.Context) TopicsTlsTopicArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TopicsTlsTopicArrayOutput)
}

type TopicsTlsTopicOutput struct{ *pulumi.OutputState }

func (TopicsTlsTopicOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TopicsTlsTopic)(nil)).Elem()
}

func (o TopicsTlsTopicOutput) ToTopicsTlsTopicOutput() TopicsTlsTopicOutput {
	return o
}

func (o TopicsTlsTopicOutput) ToTopicsTlsTopicOutputWithContext(ctx context.Context) TopicsTlsTopicOutput {
	return o
}

// Whether to enable automatic partition splitting function of the tls topic.
func (o TopicsTlsTopicOutput) AutoSplit() pulumi.BoolOutput {
	return o.ApplyT(func(v TopicsTlsTopic) bool { return v.AutoSplit }).(pulumi.BoolOutput)
}

// The create time of the tls topic.
func (o TopicsTlsTopicOutput) CreateTime() pulumi.StringOutput {
	return o.ApplyT(func(v TopicsTlsTopic) string { return v.CreateTime }).(pulumi.StringOutput)
}

// The description of the tls topic.
func (o TopicsTlsTopicOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v TopicsTlsTopic) string { return v.Description }).(pulumi.StringOutput)
}

// Whether to enable WebTracking function of the tls topic.
func (o TopicsTlsTopicOutput) EnableTracking() pulumi.BoolOutput {
	return o.ApplyT(func(v TopicsTlsTopic) bool { return v.EnableTracking }).(pulumi.BoolOutput)
}

// The ID of the tls topic.
func (o TopicsTlsTopicOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v TopicsTlsTopic) string { return v.Id }).(pulumi.StringOutput)
}

// The max count of shards in the tls topic.
func (o TopicsTlsTopicOutput) MaxSplitShard() pulumi.IntOutput {
	return o.ApplyT(func(v TopicsTlsTopic) int { return v.MaxSplitShard }).(pulumi.IntOutput)
}

// The modify time of the tls topic.
func (o TopicsTlsTopicOutput) ModifyTime() pulumi.StringOutput {
	return o.ApplyT(func(v TopicsTlsTopic) string { return v.ModifyTime }).(pulumi.StringOutput)
}

// The project id of tls topic.
func (o TopicsTlsTopicOutput) ProjectId() pulumi.StringOutput {
	return o.ApplyT(func(v TopicsTlsTopic) string { return v.ProjectId }).(pulumi.StringOutput)
}

// The count of shards in the tls topic.
func (o TopicsTlsTopicOutput) ShardCount() pulumi.IntOutput {
	return o.ApplyT(func(v TopicsTlsTopic) int { return v.ShardCount }).(pulumi.IntOutput)
}

// Tags.
func (o TopicsTlsTopicOutput) Tags() TopicsTlsTopicTagArrayOutput {
	return o.ApplyT(func(v TopicsTlsTopic) []TopicsTlsTopicTag { return v.Tags }).(TopicsTlsTopicTagArrayOutput)
}

// The format of the time field.
func (o TopicsTlsTopicOutput) TimeFormat() pulumi.StringOutput {
	return o.ApplyT(func(v TopicsTlsTopic) string { return v.TimeFormat }).(pulumi.StringOutput)
}

// The name of the time field.
func (o TopicsTlsTopicOutput) TimeKey() pulumi.StringOutput {
	return o.ApplyT(func(v TopicsTlsTopic) string { return v.TimeKey }).(pulumi.StringOutput)
}

// The id of tls topic. This field supports fuzzy queries. It is not supported to specify both TopicName and TopicId at the same time.
func (o TopicsTlsTopicOutput) TopicId() pulumi.StringOutput {
	return o.ApplyT(func(v TopicsTlsTopic) string { return v.TopicId }).(pulumi.StringOutput)
}

// The name of tls topic. This field supports fuzzy queries. It is not supported to specify both TopicName and TopicId at the same time.
func (o TopicsTlsTopicOutput) TopicName() pulumi.StringOutput {
	return o.ApplyT(func(v TopicsTlsTopic) string { return v.TopicName }).(pulumi.StringOutput)
}

// The data storage time of the tls topic. Unit: Day.
func (o TopicsTlsTopicOutput) Ttl() pulumi.IntOutput {
	return o.ApplyT(func(v TopicsTlsTopic) int { return v.Ttl }).(pulumi.IntOutput)
}

type TopicsTlsTopicArrayOutput struct{ *pulumi.OutputState }

func (TopicsTlsTopicArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TopicsTlsTopic)(nil)).Elem()
}

func (o TopicsTlsTopicArrayOutput) ToTopicsTlsTopicArrayOutput() TopicsTlsTopicArrayOutput {
	return o
}

func (o TopicsTlsTopicArrayOutput) ToTopicsTlsTopicArrayOutputWithContext(ctx context.Context) TopicsTlsTopicArrayOutput {
	return o
}

func (o TopicsTlsTopicArrayOutput) Index(i pulumi.IntInput) TopicsTlsTopicOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TopicsTlsTopic {
		return vs[0].([]TopicsTlsTopic)[vs[1].(int)]
	}).(TopicsTlsTopicOutput)
}

type TopicsTlsTopicTag struct {
	// The Key of Tags.
	Key string `pulumi:"key"`
	// The Value of Tags.
	Value string `pulumi:"value"`
}

// TopicsTlsTopicTagInput is an input type that accepts TopicsTlsTopicTagArgs and TopicsTlsTopicTagOutput values.
// You can construct a concrete instance of `TopicsTlsTopicTagInput` via:
//
//	TopicsTlsTopicTagArgs{...}
type TopicsTlsTopicTagInput interface {
	pulumi.Input

	ToTopicsTlsTopicTagOutput() TopicsTlsTopicTagOutput
	ToTopicsTlsTopicTagOutputWithContext(context.Context) TopicsTlsTopicTagOutput
}

type TopicsTlsTopicTagArgs struct {
	// The Key of Tags.
	Key pulumi.StringInput `pulumi:"key"`
	// The Value of Tags.
	Value pulumi.StringInput `pulumi:"value"`
}

func (TopicsTlsTopicTagArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TopicsTlsTopicTag)(nil)).Elem()
}

func (i TopicsTlsTopicTagArgs) ToTopicsTlsTopicTagOutput() TopicsTlsTopicTagOutput {
	return i.ToTopicsTlsTopicTagOutputWithContext(context.Background())
}

func (i TopicsTlsTopicTagArgs) ToTopicsTlsTopicTagOutputWithContext(ctx context.Context) TopicsTlsTopicTagOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TopicsTlsTopicTagOutput)
}

// TopicsTlsTopicTagArrayInput is an input type that accepts TopicsTlsTopicTagArray and TopicsTlsTopicTagArrayOutput values.
// You can construct a concrete instance of `TopicsTlsTopicTagArrayInput` via:
//
//	TopicsTlsTopicTagArray{ TopicsTlsTopicTagArgs{...} }
type TopicsTlsTopicTagArrayInput interface {
	pulumi.Input

	ToTopicsTlsTopicTagArrayOutput() TopicsTlsTopicTagArrayOutput
	ToTopicsTlsTopicTagArrayOutputWithContext(context.Context) TopicsTlsTopicTagArrayOutput
}

type TopicsTlsTopicTagArray []TopicsTlsTopicTagInput

func (TopicsTlsTopicTagArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TopicsTlsTopicTag)(nil)).Elem()
}

func (i TopicsTlsTopicTagArray) ToTopicsTlsTopicTagArrayOutput() TopicsTlsTopicTagArrayOutput {
	return i.ToTopicsTlsTopicTagArrayOutputWithContext(context.Background())
}

func (i TopicsTlsTopicTagArray) ToTopicsTlsTopicTagArrayOutputWithContext(ctx context.Context) TopicsTlsTopicTagArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TopicsTlsTopicTagArrayOutput)
}

type TopicsTlsTopicTagOutput struct{ *pulumi.OutputState }

func (TopicsTlsTopicTagOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TopicsTlsTopicTag)(nil)).Elem()
}

func (o TopicsTlsTopicTagOutput) ToTopicsTlsTopicTagOutput() TopicsTlsTopicTagOutput {
	return o
}

func (o TopicsTlsTopicTagOutput) ToTopicsTlsTopicTagOutputWithContext(ctx context.Context) TopicsTlsTopicTagOutput {
	return o
}

// The Key of Tags.
func (o TopicsTlsTopicTagOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v TopicsTlsTopicTag) string { return v.Key }).(pulumi.StringOutput)
}

// The Value of Tags.
func (o TopicsTlsTopicTagOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v TopicsTlsTopicTag) string { return v.Value }).(pulumi.StringOutput)
}

type TopicsTlsTopicTagArrayOutput struct{ *pulumi.OutputState }

func (TopicsTlsTopicTagArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TopicsTlsTopicTag)(nil)).Elem()
}

func (o TopicsTlsTopicTagArrayOutput) ToTopicsTlsTopicTagArrayOutput() TopicsTlsTopicTagArrayOutput {
	return o
}

func (o TopicsTlsTopicTagArrayOutput) ToTopicsTlsTopicTagArrayOutputWithContext(ctx context.Context) TopicsTlsTopicTagArrayOutput {
	return o
}

func (o TopicsTlsTopicTagArrayOutput) Index(i pulumi.IntInput) TopicsTlsTopicTagOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TopicsTlsTopicTag {
		return vs[0].([]TopicsTlsTopicTag)[vs[1].(int)]
	}).(TopicsTlsTopicTagOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AlarmAlarmPeriodDetailInput)(nil)).Elem(), AlarmAlarmPeriodDetailArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AlarmAlarmPeriodDetailPtrInput)(nil)).Elem(), AlarmAlarmPeriodDetailArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AlarmNotifyGroupReceiverInput)(nil)).Elem(), AlarmNotifyGroupReceiverArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AlarmNotifyGroupReceiverArrayInput)(nil)).Elem(), AlarmNotifyGroupReceiverArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AlarmNotifyGroupsGroupInput)(nil)).Elem(), AlarmNotifyGroupsGroupArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AlarmNotifyGroupsGroupArrayInput)(nil)).Elem(), AlarmNotifyGroupsGroupArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AlarmNotifyGroupsGroupReceiverInput)(nil)).Elem(), AlarmNotifyGroupsGroupReceiverArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AlarmNotifyGroupsGroupReceiverArrayInput)(nil)).Elem(), AlarmNotifyGroupsGroupReceiverArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AlarmQueryRequestInput)(nil)).Elem(), AlarmQueryRequestArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AlarmQueryRequestArrayInput)(nil)).Elem(), AlarmQueryRequestArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AlarmRequestCycleInput)(nil)).Elem(), AlarmRequestCycleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AlarmRequestCyclePtrInput)(nil)).Elem(), AlarmRequestCycleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AlarmsAlarmInput)(nil)).Elem(), AlarmsAlarmArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AlarmsAlarmArrayInput)(nil)).Elem(), AlarmsAlarmArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AlarmsAlarmAlarmNotifyGroupInput)(nil)).Elem(), AlarmsAlarmAlarmNotifyGroupArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AlarmsAlarmAlarmNotifyGroupArrayInput)(nil)).Elem(), AlarmsAlarmAlarmNotifyGroupArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AlarmsAlarmAlarmNotifyGroupReceiverInput)(nil)).Elem(), AlarmsAlarmAlarmNotifyGroupReceiverArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AlarmsAlarmAlarmNotifyGroupReceiverArrayInput)(nil)).Elem(), AlarmsAlarmAlarmNotifyGroupReceiverArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AlarmsAlarmAlarmPeriodDetailInput)(nil)).Elem(), AlarmsAlarmAlarmPeriodDetailArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AlarmsAlarmAlarmPeriodDetailArrayInput)(nil)).Elem(), AlarmsAlarmAlarmPeriodDetailArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AlarmsAlarmQueryRequestInput)(nil)).Elem(), AlarmsAlarmQueryRequestArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AlarmsAlarmQueryRequestArrayInput)(nil)).Elem(), AlarmsAlarmQueryRequestArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AlarmsAlarmRequestCycleInput)(nil)).Elem(), AlarmsAlarmRequestCycleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*AlarmsAlarmRequestCycleArrayInput)(nil)).Elem(), AlarmsAlarmRequestCycleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HostGroupsInfoInput)(nil)).Elem(), HostGroupsInfoArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HostGroupsInfoArrayInput)(nil)).Elem(), HostGroupsInfoArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HostsHostInfoInput)(nil)).Elem(), HostsHostInfoArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*HostsHostInfoArrayInput)(nil)).Elem(), HostsHostInfoArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*IndexFullTextInput)(nil)).Elem(), IndexFullTextArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*IndexFullTextPtrInput)(nil)).Elem(), IndexFullTextArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*IndexKeyValueInput)(nil)).Elem(), IndexKeyValueArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*IndexKeyValueArrayInput)(nil)).Elem(), IndexKeyValueArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*IndexKeyValueJsonKeyInput)(nil)).Elem(), IndexKeyValueJsonKeyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*IndexKeyValueJsonKeyArrayInput)(nil)).Elem(), IndexKeyValueJsonKeyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*IndexUserInnerKeyValueInput)(nil)).Elem(), IndexUserInnerKeyValueArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*IndexUserInnerKeyValueArrayInput)(nil)).Elem(), IndexUserInnerKeyValueArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*IndexUserInnerKeyValueJsonKeyInput)(nil)).Elem(), IndexUserInnerKeyValueJsonKeyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*IndexUserInnerKeyValueJsonKeyArrayInput)(nil)).Elem(), IndexUserInnerKeyValueJsonKeyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*IndexesTlsIndexInput)(nil)).Elem(), IndexesTlsIndexArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*IndexesTlsIndexArrayInput)(nil)).Elem(), IndexesTlsIndexArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*IndexesTlsIndexFullTextInput)(nil)).Elem(), IndexesTlsIndexFullTextArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*IndexesTlsIndexKeyValueInput)(nil)).Elem(), IndexesTlsIndexKeyValueArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*IndexesTlsIndexKeyValueArrayInput)(nil)).Elem(), IndexesTlsIndexKeyValueArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*IndexesTlsIndexKeyValueJsonKeyInput)(nil)).Elem(), IndexesTlsIndexKeyValueJsonKeyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*IndexesTlsIndexKeyValueJsonKeyArrayInput)(nil)).Elem(), IndexesTlsIndexKeyValueJsonKeyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*IndexesTlsIndexUserInnerKeyValueInput)(nil)).Elem(), IndexesTlsIndexUserInnerKeyValueArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*IndexesTlsIndexUserInnerKeyValueArrayInput)(nil)).Elem(), IndexesTlsIndexUserInnerKeyValueArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*IndexesTlsIndexUserInnerKeyValueJsonKeyInput)(nil)).Elem(), IndexesTlsIndexUserInnerKeyValueJsonKeyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*IndexesTlsIndexUserInnerKeyValueJsonKeyArrayInput)(nil)).Elem(), IndexesTlsIndexUserInnerKeyValueJsonKeyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*KafkaConsumersDataInput)(nil)).Elem(), KafkaConsumersDataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*KafkaConsumersDataArrayInput)(nil)).Elem(), KafkaConsumersDataArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ProjectTagInput)(nil)).Elem(), ProjectTagArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ProjectTagArrayInput)(nil)).Elem(), ProjectTagArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ProjectsTagInput)(nil)).Elem(), ProjectsTagArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ProjectsTagArrayInput)(nil)).Elem(), ProjectsTagArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ProjectsTlsProjectInput)(nil)).Elem(), ProjectsTlsProjectArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ProjectsTlsProjectArrayInput)(nil)).Elem(), ProjectsTlsProjectArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ProjectsTlsProjectTagInput)(nil)).Elem(), ProjectsTlsProjectTagArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ProjectsTlsProjectTagArrayInput)(nil)).Elem(), ProjectsTlsProjectTagArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleAppliersRuleInput)(nil)).Elem(), RuleAppliersRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleAppliersRuleArrayInput)(nil)).Elem(), RuleAppliersRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleAppliersRuleContainerRuleInput)(nil)).Elem(), RuleAppliersRuleContainerRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleAppliersRuleContainerRuleArrayInput)(nil)).Elem(), RuleAppliersRuleContainerRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleAppliersRuleContainerRuleKubernetesRuleInput)(nil)).Elem(), RuleAppliersRuleContainerRuleKubernetesRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleAppliersRuleContainerRuleKubernetesRuleArrayInput)(nil)).Elem(), RuleAppliersRuleContainerRuleKubernetesRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleAppliersRuleExcludePathInput)(nil)).Elem(), RuleAppliersRuleExcludePathArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleAppliersRuleExcludePathArrayInput)(nil)).Elem(), RuleAppliersRuleExcludePathArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleAppliersRuleExtractRuleInput)(nil)).Elem(), RuleAppliersRuleExtractRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleAppliersRuleExtractRuleArrayInput)(nil)).Elem(), RuleAppliersRuleExtractRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleAppliersRuleExtractRuleFilterKeyRegexInput)(nil)).Elem(), RuleAppliersRuleExtractRuleFilterKeyRegexArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleAppliersRuleExtractRuleFilterKeyRegexArrayInput)(nil)).Elem(), RuleAppliersRuleExtractRuleFilterKeyRegexArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleAppliersRuleExtractRuleLogTemplateInput)(nil)).Elem(), RuleAppliersRuleExtractRuleLogTemplateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleAppliersRuleExtractRuleLogTemplateArrayInput)(nil)).Elem(), RuleAppliersRuleExtractRuleLogTemplateArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleAppliersRuleUserDefineRuleInput)(nil)).Elem(), RuleAppliersRuleUserDefineRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleAppliersRuleUserDefineRuleArrayInput)(nil)).Elem(), RuleAppliersRuleUserDefineRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleAppliersRuleUserDefineRuleAdvancedInput)(nil)).Elem(), RuleAppliersRuleUserDefineRuleAdvancedArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleAppliersRuleUserDefineRuleAdvancedArrayInput)(nil)).Elem(), RuleAppliersRuleUserDefineRuleAdvancedArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleAppliersRuleUserDefineRuleParsePathRuleInput)(nil)).Elem(), RuleAppliersRuleUserDefineRuleParsePathRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleAppliersRuleUserDefineRuleParsePathRuleArrayInput)(nil)).Elem(), RuleAppliersRuleUserDefineRuleParsePathRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleAppliersRuleUserDefineRulePluginInput)(nil)).Elem(), RuleAppliersRuleUserDefineRulePluginArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleAppliersRuleUserDefineRulePluginArrayInput)(nil)).Elem(), RuleAppliersRuleUserDefineRulePluginArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleAppliersRuleUserDefineRuleShardHashKeyInput)(nil)).Elem(), RuleAppliersRuleUserDefineRuleShardHashKeyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleAppliersRuleUserDefineRuleShardHashKeyArrayInput)(nil)).Elem(), RuleAppliersRuleUserDefineRuleShardHashKeyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleContainerRuleInput)(nil)).Elem(), RuleContainerRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleContainerRulePtrInput)(nil)).Elem(), RuleContainerRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleContainerRuleKubernetesRuleInput)(nil)).Elem(), RuleContainerRuleKubernetesRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleContainerRuleKubernetesRulePtrInput)(nil)).Elem(), RuleContainerRuleKubernetesRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleExcludePathInput)(nil)).Elem(), RuleExcludePathArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleExcludePathArrayInput)(nil)).Elem(), RuleExcludePathArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleExtractRuleInput)(nil)).Elem(), RuleExtractRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleExtractRulePtrInput)(nil)).Elem(), RuleExtractRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleExtractRuleFilterKeyRegexInput)(nil)).Elem(), RuleExtractRuleFilterKeyRegexArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleExtractRuleFilterKeyRegexArrayInput)(nil)).Elem(), RuleExtractRuleFilterKeyRegexArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleExtractRuleLogTemplateInput)(nil)).Elem(), RuleExtractRuleLogTemplateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleExtractRuleLogTemplatePtrInput)(nil)).Elem(), RuleExtractRuleLogTemplateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleUserDefineRuleInput)(nil)).Elem(), RuleUserDefineRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleUserDefineRulePtrInput)(nil)).Elem(), RuleUserDefineRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleUserDefineRuleAdvancedInput)(nil)).Elem(), RuleUserDefineRuleAdvancedArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleUserDefineRuleAdvancedPtrInput)(nil)).Elem(), RuleUserDefineRuleAdvancedArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleUserDefineRuleParsePathRuleInput)(nil)).Elem(), RuleUserDefineRuleParsePathRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleUserDefineRuleParsePathRulePtrInput)(nil)).Elem(), RuleUserDefineRuleParsePathRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleUserDefineRulePluginInput)(nil)).Elem(), RuleUserDefineRulePluginArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleUserDefineRulePluginPtrInput)(nil)).Elem(), RuleUserDefineRulePluginArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleUserDefineRuleShardHashKeyInput)(nil)).Elem(), RuleUserDefineRuleShardHashKeyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleUserDefineRuleShardHashKeyPtrInput)(nil)).Elem(), RuleUserDefineRuleShardHashKeyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RulesRuleInput)(nil)).Elem(), RulesRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RulesRuleArrayInput)(nil)).Elem(), RulesRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RulesRuleContainerRuleInput)(nil)).Elem(), RulesRuleContainerRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RulesRuleContainerRuleArrayInput)(nil)).Elem(), RulesRuleContainerRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RulesRuleContainerRuleKubernetesRuleInput)(nil)).Elem(), RulesRuleContainerRuleKubernetesRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RulesRuleContainerRuleKubernetesRuleArrayInput)(nil)).Elem(), RulesRuleContainerRuleKubernetesRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RulesRuleExcludePathInput)(nil)).Elem(), RulesRuleExcludePathArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RulesRuleExcludePathArrayInput)(nil)).Elem(), RulesRuleExcludePathArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RulesRuleExtractRuleInput)(nil)).Elem(), RulesRuleExtractRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RulesRuleExtractRuleArrayInput)(nil)).Elem(), RulesRuleExtractRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RulesRuleExtractRuleFilterKeyRegexInput)(nil)).Elem(), RulesRuleExtractRuleFilterKeyRegexArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RulesRuleExtractRuleFilterKeyRegexArrayInput)(nil)).Elem(), RulesRuleExtractRuleFilterKeyRegexArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RulesRuleExtractRuleLogTemplateInput)(nil)).Elem(), RulesRuleExtractRuleLogTemplateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RulesRuleExtractRuleLogTemplateArrayInput)(nil)).Elem(), RulesRuleExtractRuleLogTemplateArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RulesRuleUserDefineRuleInput)(nil)).Elem(), RulesRuleUserDefineRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RulesRuleUserDefineRuleArrayInput)(nil)).Elem(), RulesRuleUserDefineRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RulesRuleUserDefineRuleAdvancedInput)(nil)).Elem(), RulesRuleUserDefineRuleAdvancedArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RulesRuleUserDefineRuleAdvancedArrayInput)(nil)).Elem(), RulesRuleUserDefineRuleAdvancedArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RulesRuleUserDefineRuleParsePathRuleInput)(nil)).Elem(), RulesRuleUserDefineRuleParsePathRuleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RulesRuleUserDefineRuleParsePathRuleArrayInput)(nil)).Elem(), RulesRuleUserDefineRuleParsePathRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RulesRuleUserDefineRulePluginInput)(nil)).Elem(), RulesRuleUserDefineRulePluginArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RulesRuleUserDefineRulePluginArrayInput)(nil)).Elem(), RulesRuleUserDefineRulePluginArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RulesRuleUserDefineRuleShardHashKeyInput)(nil)).Elem(), RulesRuleUserDefineRuleShardHashKeyArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*RulesRuleUserDefineRuleShardHashKeyArrayInput)(nil)).Elem(), RulesRuleUserDefineRuleShardHashKeyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ShardsShardInput)(nil)).Elem(), ShardsShardArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ShardsShardArrayInput)(nil)).Elem(), ShardsShardArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TopicTagInput)(nil)).Elem(), TopicTagArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TopicTagArrayInput)(nil)).Elem(), TopicTagArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TopicsTagInput)(nil)).Elem(), TopicsTagArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TopicsTagArrayInput)(nil)).Elem(), TopicsTagArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TopicsTlsTopicInput)(nil)).Elem(), TopicsTlsTopicArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TopicsTlsTopicArrayInput)(nil)).Elem(), TopicsTlsTopicArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TopicsTlsTopicTagInput)(nil)).Elem(), TopicsTlsTopicTagArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TopicsTlsTopicTagArrayInput)(nil)).Elem(), TopicsTlsTopicTagArray{})
	pulumi.RegisterOutputType(AlarmAlarmPeriodDetailOutput{})
	pulumi.RegisterOutputType(AlarmAlarmPeriodDetailPtrOutput{})
	pulumi.RegisterOutputType(AlarmNotifyGroupReceiverOutput{})
	pulumi.RegisterOutputType(AlarmNotifyGroupReceiverArrayOutput{})
	pulumi.RegisterOutputType(AlarmNotifyGroupsGroupOutput{})
	pulumi.RegisterOutputType(AlarmNotifyGroupsGroupArrayOutput{})
	pulumi.RegisterOutputType(AlarmNotifyGroupsGroupReceiverOutput{})
	pulumi.RegisterOutputType(AlarmNotifyGroupsGroupReceiverArrayOutput{})
	pulumi.RegisterOutputType(AlarmQueryRequestOutput{})
	pulumi.RegisterOutputType(AlarmQueryRequestArrayOutput{})
	pulumi.RegisterOutputType(AlarmRequestCycleOutput{})
	pulumi.RegisterOutputType(AlarmRequestCyclePtrOutput{})
	pulumi.RegisterOutputType(AlarmsAlarmOutput{})
	pulumi.RegisterOutputType(AlarmsAlarmArrayOutput{})
	pulumi.RegisterOutputType(AlarmsAlarmAlarmNotifyGroupOutput{})
	pulumi.RegisterOutputType(AlarmsAlarmAlarmNotifyGroupArrayOutput{})
	pulumi.RegisterOutputType(AlarmsAlarmAlarmNotifyGroupReceiverOutput{})
	pulumi.RegisterOutputType(AlarmsAlarmAlarmNotifyGroupReceiverArrayOutput{})
	pulumi.RegisterOutputType(AlarmsAlarmAlarmPeriodDetailOutput{})
	pulumi.RegisterOutputType(AlarmsAlarmAlarmPeriodDetailArrayOutput{})
	pulumi.RegisterOutputType(AlarmsAlarmQueryRequestOutput{})
	pulumi.RegisterOutputType(AlarmsAlarmQueryRequestArrayOutput{})
	pulumi.RegisterOutputType(AlarmsAlarmRequestCycleOutput{})
	pulumi.RegisterOutputType(AlarmsAlarmRequestCycleArrayOutput{})
	pulumi.RegisterOutputType(HostGroupsInfoOutput{})
	pulumi.RegisterOutputType(HostGroupsInfoArrayOutput{})
	pulumi.RegisterOutputType(HostsHostInfoOutput{})
	pulumi.RegisterOutputType(HostsHostInfoArrayOutput{})
	pulumi.RegisterOutputType(IndexFullTextOutput{})
	pulumi.RegisterOutputType(IndexFullTextPtrOutput{})
	pulumi.RegisterOutputType(IndexKeyValueOutput{})
	pulumi.RegisterOutputType(IndexKeyValueArrayOutput{})
	pulumi.RegisterOutputType(IndexKeyValueJsonKeyOutput{})
	pulumi.RegisterOutputType(IndexKeyValueJsonKeyArrayOutput{})
	pulumi.RegisterOutputType(IndexUserInnerKeyValueOutput{})
	pulumi.RegisterOutputType(IndexUserInnerKeyValueArrayOutput{})
	pulumi.RegisterOutputType(IndexUserInnerKeyValueJsonKeyOutput{})
	pulumi.RegisterOutputType(IndexUserInnerKeyValueJsonKeyArrayOutput{})
	pulumi.RegisterOutputType(IndexesTlsIndexOutput{})
	pulumi.RegisterOutputType(IndexesTlsIndexArrayOutput{})
	pulumi.RegisterOutputType(IndexesTlsIndexFullTextOutput{})
	pulumi.RegisterOutputType(IndexesTlsIndexKeyValueOutput{})
	pulumi.RegisterOutputType(IndexesTlsIndexKeyValueArrayOutput{})
	pulumi.RegisterOutputType(IndexesTlsIndexKeyValueJsonKeyOutput{})
	pulumi.RegisterOutputType(IndexesTlsIndexKeyValueJsonKeyArrayOutput{})
	pulumi.RegisterOutputType(IndexesTlsIndexUserInnerKeyValueOutput{})
	pulumi.RegisterOutputType(IndexesTlsIndexUserInnerKeyValueArrayOutput{})
	pulumi.RegisterOutputType(IndexesTlsIndexUserInnerKeyValueJsonKeyOutput{})
	pulumi.RegisterOutputType(IndexesTlsIndexUserInnerKeyValueJsonKeyArrayOutput{})
	pulumi.RegisterOutputType(KafkaConsumersDataOutput{})
	pulumi.RegisterOutputType(KafkaConsumersDataArrayOutput{})
	pulumi.RegisterOutputType(ProjectTagOutput{})
	pulumi.RegisterOutputType(ProjectTagArrayOutput{})
	pulumi.RegisterOutputType(ProjectsTagOutput{})
	pulumi.RegisterOutputType(ProjectsTagArrayOutput{})
	pulumi.RegisterOutputType(ProjectsTlsProjectOutput{})
	pulumi.RegisterOutputType(ProjectsTlsProjectArrayOutput{})
	pulumi.RegisterOutputType(ProjectsTlsProjectTagOutput{})
	pulumi.RegisterOutputType(ProjectsTlsProjectTagArrayOutput{})
	pulumi.RegisterOutputType(RuleAppliersRuleOutput{})
	pulumi.RegisterOutputType(RuleAppliersRuleArrayOutput{})
	pulumi.RegisterOutputType(RuleAppliersRuleContainerRuleOutput{})
	pulumi.RegisterOutputType(RuleAppliersRuleContainerRuleArrayOutput{})
	pulumi.RegisterOutputType(RuleAppliersRuleContainerRuleKubernetesRuleOutput{})
	pulumi.RegisterOutputType(RuleAppliersRuleContainerRuleKubernetesRuleArrayOutput{})
	pulumi.RegisterOutputType(RuleAppliersRuleExcludePathOutput{})
	pulumi.RegisterOutputType(RuleAppliersRuleExcludePathArrayOutput{})
	pulumi.RegisterOutputType(RuleAppliersRuleExtractRuleOutput{})
	pulumi.RegisterOutputType(RuleAppliersRuleExtractRuleArrayOutput{})
	pulumi.RegisterOutputType(RuleAppliersRuleExtractRuleFilterKeyRegexOutput{})
	pulumi.RegisterOutputType(RuleAppliersRuleExtractRuleFilterKeyRegexArrayOutput{})
	pulumi.RegisterOutputType(RuleAppliersRuleExtractRuleLogTemplateOutput{})
	pulumi.RegisterOutputType(RuleAppliersRuleExtractRuleLogTemplateArrayOutput{})
	pulumi.RegisterOutputType(RuleAppliersRuleUserDefineRuleOutput{})
	pulumi.RegisterOutputType(RuleAppliersRuleUserDefineRuleArrayOutput{})
	pulumi.RegisterOutputType(RuleAppliersRuleUserDefineRuleAdvancedOutput{})
	pulumi.RegisterOutputType(RuleAppliersRuleUserDefineRuleAdvancedArrayOutput{})
	pulumi.RegisterOutputType(RuleAppliersRuleUserDefineRuleParsePathRuleOutput{})
	pulumi.RegisterOutputType(RuleAppliersRuleUserDefineRuleParsePathRuleArrayOutput{})
	pulumi.RegisterOutputType(RuleAppliersRuleUserDefineRulePluginOutput{})
	pulumi.RegisterOutputType(RuleAppliersRuleUserDefineRulePluginArrayOutput{})
	pulumi.RegisterOutputType(RuleAppliersRuleUserDefineRuleShardHashKeyOutput{})
	pulumi.RegisterOutputType(RuleAppliersRuleUserDefineRuleShardHashKeyArrayOutput{})
	pulumi.RegisterOutputType(RuleContainerRuleOutput{})
	pulumi.RegisterOutputType(RuleContainerRulePtrOutput{})
	pulumi.RegisterOutputType(RuleContainerRuleKubernetesRuleOutput{})
	pulumi.RegisterOutputType(RuleContainerRuleKubernetesRulePtrOutput{})
	pulumi.RegisterOutputType(RuleExcludePathOutput{})
	pulumi.RegisterOutputType(RuleExcludePathArrayOutput{})
	pulumi.RegisterOutputType(RuleExtractRuleOutput{})
	pulumi.RegisterOutputType(RuleExtractRulePtrOutput{})
	pulumi.RegisterOutputType(RuleExtractRuleFilterKeyRegexOutput{})
	pulumi.RegisterOutputType(RuleExtractRuleFilterKeyRegexArrayOutput{})
	pulumi.RegisterOutputType(RuleExtractRuleLogTemplateOutput{})
	pulumi.RegisterOutputType(RuleExtractRuleLogTemplatePtrOutput{})
	pulumi.RegisterOutputType(RuleUserDefineRuleOutput{})
	pulumi.RegisterOutputType(RuleUserDefineRulePtrOutput{})
	pulumi.RegisterOutputType(RuleUserDefineRuleAdvancedOutput{})
	pulumi.RegisterOutputType(RuleUserDefineRuleAdvancedPtrOutput{})
	pulumi.RegisterOutputType(RuleUserDefineRuleParsePathRuleOutput{})
	pulumi.RegisterOutputType(RuleUserDefineRuleParsePathRulePtrOutput{})
	pulumi.RegisterOutputType(RuleUserDefineRulePluginOutput{})
	pulumi.RegisterOutputType(RuleUserDefineRulePluginPtrOutput{})
	pulumi.RegisterOutputType(RuleUserDefineRuleShardHashKeyOutput{})
	pulumi.RegisterOutputType(RuleUserDefineRuleShardHashKeyPtrOutput{})
	pulumi.RegisterOutputType(RulesRuleOutput{})
	pulumi.RegisterOutputType(RulesRuleArrayOutput{})
	pulumi.RegisterOutputType(RulesRuleContainerRuleOutput{})
	pulumi.RegisterOutputType(RulesRuleContainerRuleArrayOutput{})
	pulumi.RegisterOutputType(RulesRuleContainerRuleKubernetesRuleOutput{})
	pulumi.RegisterOutputType(RulesRuleContainerRuleKubernetesRuleArrayOutput{})
	pulumi.RegisterOutputType(RulesRuleExcludePathOutput{})
	pulumi.RegisterOutputType(RulesRuleExcludePathArrayOutput{})
	pulumi.RegisterOutputType(RulesRuleExtractRuleOutput{})
	pulumi.RegisterOutputType(RulesRuleExtractRuleArrayOutput{})
	pulumi.RegisterOutputType(RulesRuleExtractRuleFilterKeyRegexOutput{})
	pulumi.RegisterOutputType(RulesRuleExtractRuleFilterKeyRegexArrayOutput{})
	pulumi.RegisterOutputType(RulesRuleExtractRuleLogTemplateOutput{})
	pulumi.RegisterOutputType(RulesRuleExtractRuleLogTemplateArrayOutput{})
	pulumi.RegisterOutputType(RulesRuleUserDefineRuleOutput{})
	pulumi.RegisterOutputType(RulesRuleUserDefineRuleArrayOutput{})
	pulumi.RegisterOutputType(RulesRuleUserDefineRuleAdvancedOutput{})
	pulumi.RegisterOutputType(RulesRuleUserDefineRuleAdvancedArrayOutput{})
	pulumi.RegisterOutputType(RulesRuleUserDefineRuleParsePathRuleOutput{})
	pulumi.RegisterOutputType(RulesRuleUserDefineRuleParsePathRuleArrayOutput{})
	pulumi.RegisterOutputType(RulesRuleUserDefineRulePluginOutput{})
	pulumi.RegisterOutputType(RulesRuleUserDefineRulePluginArrayOutput{})
	pulumi.RegisterOutputType(RulesRuleUserDefineRuleShardHashKeyOutput{})
	pulumi.RegisterOutputType(RulesRuleUserDefineRuleShardHashKeyArrayOutput{})
	pulumi.RegisterOutputType(ShardsShardOutput{})
	pulumi.RegisterOutputType(ShardsShardArrayOutput{})
	pulumi.RegisterOutputType(TopicTagOutput{})
	pulumi.RegisterOutputType(TopicTagArrayOutput{})
	pulumi.RegisterOutputType(TopicsTagOutput{})
	pulumi.RegisterOutputType(TopicsTagArrayOutput{})
	pulumi.RegisterOutputType(TopicsTlsTopicOutput{})
	pulumi.RegisterOutputType(TopicsTlsTopicArrayOutput{})
	pulumi.RegisterOutputType(TopicsTlsTopicTagOutput{})
	pulumi.RegisterOutputType(TopicsTlsTopicTagArrayOutput{})
}
