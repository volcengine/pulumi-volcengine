// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package tls

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/volcengine/pulumi-volcengine/sdk/go/volcengine/internal"
)

// Provides a resource to manage tls schedule sql task
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/volcengine/pulumi-volcengine/sdk/go/volcengine/tls"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := tls.NewScheduleSqlTask(ctx, "foo", &tls.ScheduleSqlTaskArgs{
//				Description:       pulumi.String("tf-test"),
//				DestRegion:        pulumi.String("cn-beijing"),
//				DestTopicId:       pulumi.String("b966e41a-d6a6-4999-bd75-39962xxxxxx"),
//				ProcessEndTime:    pulumi.Int(1751295600),
//				ProcessSqlDelay:   pulumi.Int(60),
//				ProcessStartTime:  pulumi.Int(1751212980),
//				ProcessTimeWindow: pulumi.String("@m-15m,@m"),
//				Query:             pulumi.String("* | SELECT * limit 10000"),
//				RequestCycle: &tls.ScheduleSqlTaskRequestCycleArgs{
//					CronTab:      pulumi.String("0 10 * * *"),
//					CronTimeZone: pulumi.String("GMT+08:00"),
//					Time:         pulumi.Int(1),
//					Type:         pulumi.String("CronTab"),
//				},
//				Status:   pulumi.Int(1),
//				TaskName: pulumi.String("tf-test"),
//				TopicId:  pulumi.String("8ba48bd7-2493-4300-b1d0-cb760bxxxxxx"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// ScheduleSqlTask can be imported using the id, e.g.
//
// ```sh
// $ pulumi import volcengine:tls/scheduleSqlTask:ScheduleSqlTask default resource_id
// ```
type ScheduleSqlTask struct {
	pulumi.CustomResourceState

	// A simple description of the timed SQL analysis task.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// The region to which the target log topic belongs. The default is the current region.
	DestRegion pulumi.StringPtrOutput `pulumi:"destRegion"`
	// The target log topic ID used for storing the result data of timed SQL analysis.
	DestTopicId pulumi.StringOutput `pulumi:"destTopicId"`
	// Schedule the end time of the timed SQL analysis task in the format of a second-level timestamp.
	ProcessEndTime pulumi.IntPtrOutput `pulumi:"processEndTime"`
	// The delay time of each scheduling. The value range is from 0 to 120, and the unit is seconds.
	ProcessSqlDelay pulumi.IntOutput `pulumi:"processSqlDelay"`
	// The start time of the scheduled SQL analysis task, that is, the time when the first instance is created. The format is a timestamp at the second level.
	ProcessStartTime pulumi.IntOutput `pulumi:"processStartTime"`
	// SQL time window, which refers to the time range for log retrieval and analysis when a timed SQL analysis task is running, is in a left-closed and right-open format.
	ProcessTimeWindow pulumi.StringOutput `pulumi:"processTimeWindow"`
	// The retrieval and analysis statements for the regular execution of timed SQL analysis tasks should conform to the retrieval and analysis syntax of the log service.
	Query pulumi.StringOutput `pulumi:"query"`
	// The scheduling cycle of timed SQL analysis tasks.
	RequestCycle ScheduleSqlTaskRequestCycleOutput `pulumi:"requestCycle"`
	// Whether to start the scheduled SQL analysis task immediately after completing the task configuration.
	Status pulumi.IntOutput `pulumi:"status"`
	// The Name of timed SQL analysis task.
	TaskName pulumi.StringOutput `pulumi:"taskName"`
	// The log topic ID where the original log to be analyzed for scheduled SQL is located.
	TopicId pulumi.StringOutput `pulumi:"topicId"`
}

// NewScheduleSqlTask registers a new resource with the given unique name, arguments, and options.
func NewScheduleSqlTask(ctx *pulumi.Context,
	name string, args *ScheduleSqlTaskArgs, opts ...pulumi.ResourceOption) (*ScheduleSqlTask, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.DestTopicId == nil {
		return nil, errors.New("invalid value for required argument 'DestTopicId'")
	}
	if args.ProcessSqlDelay == nil {
		return nil, errors.New("invalid value for required argument 'ProcessSqlDelay'")
	}
	if args.ProcessStartTime == nil {
		return nil, errors.New("invalid value for required argument 'ProcessStartTime'")
	}
	if args.ProcessTimeWindow == nil {
		return nil, errors.New("invalid value for required argument 'ProcessTimeWindow'")
	}
	if args.Query == nil {
		return nil, errors.New("invalid value for required argument 'Query'")
	}
	if args.RequestCycle == nil {
		return nil, errors.New("invalid value for required argument 'RequestCycle'")
	}
	if args.Status == nil {
		return nil, errors.New("invalid value for required argument 'Status'")
	}
	if args.TaskName == nil {
		return nil, errors.New("invalid value for required argument 'TaskName'")
	}
	if args.TopicId == nil {
		return nil, errors.New("invalid value for required argument 'TopicId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ScheduleSqlTask
	err := ctx.RegisterResource("volcengine:tls/scheduleSqlTask:ScheduleSqlTask", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetScheduleSqlTask gets an existing ScheduleSqlTask resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetScheduleSqlTask(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ScheduleSqlTaskState, opts ...pulumi.ResourceOption) (*ScheduleSqlTask, error) {
	var resource ScheduleSqlTask
	err := ctx.ReadResource("volcengine:tls/scheduleSqlTask:ScheduleSqlTask", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ScheduleSqlTask resources.
type scheduleSqlTaskState struct {
	// A simple description of the timed SQL analysis task.
	Description *string `pulumi:"description"`
	// The region to which the target log topic belongs. The default is the current region.
	DestRegion *string `pulumi:"destRegion"`
	// The target log topic ID used for storing the result data of timed SQL analysis.
	DestTopicId *string `pulumi:"destTopicId"`
	// Schedule the end time of the timed SQL analysis task in the format of a second-level timestamp.
	ProcessEndTime *int `pulumi:"processEndTime"`
	// The delay time of each scheduling. The value range is from 0 to 120, and the unit is seconds.
	ProcessSqlDelay *int `pulumi:"processSqlDelay"`
	// The start time of the scheduled SQL analysis task, that is, the time when the first instance is created. The format is a timestamp at the second level.
	ProcessStartTime *int `pulumi:"processStartTime"`
	// SQL time window, which refers to the time range for log retrieval and analysis when a timed SQL analysis task is running, is in a left-closed and right-open format.
	ProcessTimeWindow *string `pulumi:"processTimeWindow"`
	// The retrieval and analysis statements for the regular execution of timed SQL analysis tasks should conform to the retrieval and analysis syntax of the log service.
	Query *string `pulumi:"query"`
	// The scheduling cycle of timed SQL analysis tasks.
	RequestCycle *ScheduleSqlTaskRequestCycle `pulumi:"requestCycle"`
	// Whether to start the scheduled SQL analysis task immediately after completing the task configuration.
	Status *int `pulumi:"status"`
	// The Name of timed SQL analysis task.
	TaskName *string `pulumi:"taskName"`
	// The log topic ID where the original log to be analyzed for scheduled SQL is located.
	TopicId *string `pulumi:"topicId"`
}

type ScheduleSqlTaskState struct {
	// A simple description of the timed SQL analysis task.
	Description pulumi.StringPtrInput
	// The region to which the target log topic belongs. The default is the current region.
	DestRegion pulumi.StringPtrInput
	// The target log topic ID used for storing the result data of timed SQL analysis.
	DestTopicId pulumi.StringPtrInput
	// Schedule the end time of the timed SQL analysis task in the format of a second-level timestamp.
	ProcessEndTime pulumi.IntPtrInput
	// The delay time of each scheduling. The value range is from 0 to 120, and the unit is seconds.
	ProcessSqlDelay pulumi.IntPtrInput
	// The start time of the scheduled SQL analysis task, that is, the time when the first instance is created. The format is a timestamp at the second level.
	ProcessStartTime pulumi.IntPtrInput
	// SQL time window, which refers to the time range for log retrieval and analysis when a timed SQL analysis task is running, is in a left-closed and right-open format.
	ProcessTimeWindow pulumi.StringPtrInput
	// The retrieval and analysis statements for the regular execution of timed SQL analysis tasks should conform to the retrieval and analysis syntax of the log service.
	Query pulumi.StringPtrInput
	// The scheduling cycle of timed SQL analysis tasks.
	RequestCycle ScheduleSqlTaskRequestCyclePtrInput
	// Whether to start the scheduled SQL analysis task immediately after completing the task configuration.
	Status pulumi.IntPtrInput
	// The Name of timed SQL analysis task.
	TaskName pulumi.StringPtrInput
	// The log topic ID where the original log to be analyzed for scheduled SQL is located.
	TopicId pulumi.StringPtrInput
}

func (ScheduleSqlTaskState) ElementType() reflect.Type {
	return reflect.TypeOf((*scheduleSqlTaskState)(nil)).Elem()
}

type scheduleSqlTaskArgs struct {
	// A simple description of the timed SQL analysis task.
	Description *string `pulumi:"description"`
	// The region to which the target log topic belongs. The default is the current region.
	DestRegion *string `pulumi:"destRegion"`
	// The target log topic ID used for storing the result data of timed SQL analysis.
	DestTopicId string `pulumi:"destTopicId"`
	// Schedule the end time of the timed SQL analysis task in the format of a second-level timestamp.
	ProcessEndTime *int `pulumi:"processEndTime"`
	// The delay time of each scheduling. The value range is from 0 to 120, and the unit is seconds.
	ProcessSqlDelay int `pulumi:"processSqlDelay"`
	// The start time of the scheduled SQL analysis task, that is, the time when the first instance is created. The format is a timestamp at the second level.
	ProcessStartTime int `pulumi:"processStartTime"`
	// SQL time window, which refers to the time range for log retrieval and analysis when a timed SQL analysis task is running, is in a left-closed and right-open format.
	ProcessTimeWindow string `pulumi:"processTimeWindow"`
	// The retrieval and analysis statements for the regular execution of timed SQL analysis tasks should conform to the retrieval and analysis syntax of the log service.
	Query string `pulumi:"query"`
	// The scheduling cycle of timed SQL analysis tasks.
	RequestCycle ScheduleSqlTaskRequestCycle `pulumi:"requestCycle"`
	// Whether to start the scheduled SQL analysis task immediately after completing the task configuration.
	Status int `pulumi:"status"`
	// The Name of timed SQL analysis task.
	TaskName string `pulumi:"taskName"`
	// The log topic ID where the original log to be analyzed for scheduled SQL is located.
	TopicId string `pulumi:"topicId"`
}

// The set of arguments for constructing a ScheduleSqlTask resource.
type ScheduleSqlTaskArgs struct {
	// A simple description of the timed SQL analysis task.
	Description pulumi.StringPtrInput
	// The region to which the target log topic belongs. The default is the current region.
	DestRegion pulumi.StringPtrInput
	// The target log topic ID used for storing the result data of timed SQL analysis.
	DestTopicId pulumi.StringInput
	// Schedule the end time of the timed SQL analysis task in the format of a second-level timestamp.
	ProcessEndTime pulumi.IntPtrInput
	// The delay time of each scheduling. The value range is from 0 to 120, and the unit is seconds.
	ProcessSqlDelay pulumi.IntInput
	// The start time of the scheduled SQL analysis task, that is, the time when the first instance is created. The format is a timestamp at the second level.
	ProcessStartTime pulumi.IntInput
	// SQL time window, which refers to the time range for log retrieval and analysis when a timed SQL analysis task is running, is in a left-closed and right-open format.
	ProcessTimeWindow pulumi.StringInput
	// The retrieval and analysis statements for the regular execution of timed SQL analysis tasks should conform to the retrieval and analysis syntax of the log service.
	Query pulumi.StringInput
	// The scheduling cycle of timed SQL analysis tasks.
	RequestCycle ScheduleSqlTaskRequestCycleInput
	// Whether to start the scheduled SQL analysis task immediately after completing the task configuration.
	Status pulumi.IntInput
	// The Name of timed SQL analysis task.
	TaskName pulumi.StringInput
	// The log topic ID where the original log to be analyzed for scheduled SQL is located.
	TopicId pulumi.StringInput
}

func (ScheduleSqlTaskArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*scheduleSqlTaskArgs)(nil)).Elem()
}

type ScheduleSqlTaskInput interface {
	pulumi.Input

	ToScheduleSqlTaskOutput() ScheduleSqlTaskOutput
	ToScheduleSqlTaskOutputWithContext(ctx context.Context) ScheduleSqlTaskOutput
}

func (*ScheduleSqlTask) ElementType() reflect.Type {
	return reflect.TypeOf((**ScheduleSqlTask)(nil)).Elem()
}

func (i *ScheduleSqlTask) ToScheduleSqlTaskOutput() ScheduleSqlTaskOutput {
	return i.ToScheduleSqlTaskOutputWithContext(context.Background())
}

func (i *ScheduleSqlTask) ToScheduleSqlTaskOutputWithContext(ctx context.Context) ScheduleSqlTaskOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScheduleSqlTaskOutput)
}

// ScheduleSqlTaskArrayInput is an input type that accepts ScheduleSqlTaskArray and ScheduleSqlTaskArrayOutput values.
// You can construct a concrete instance of `ScheduleSqlTaskArrayInput` via:
//
//	ScheduleSqlTaskArray{ ScheduleSqlTaskArgs{...} }
type ScheduleSqlTaskArrayInput interface {
	pulumi.Input

	ToScheduleSqlTaskArrayOutput() ScheduleSqlTaskArrayOutput
	ToScheduleSqlTaskArrayOutputWithContext(context.Context) ScheduleSqlTaskArrayOutput
}

type ScheduleSqlTaskArray []ScheduleSqlTaskInput

func (ScheduleSqlTaskArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ScheduleSqlTask)(nil)).Elem()
}

func (i ScheduleSqlTaskArray) ToScheduleSqlTaskArrayOutput() ScheduleSqlTaskArrayOutput {
	return i.ToScheduleSqlTaskArrayOutputWithContext(context.Background())
}

func (i ScheduleSqlTaskArray) ToScheduleSqlTaskArrayOutputWithContext(ctx context.Context) ScheduleSqlTaskArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScheduleSqlTaskArrayOutput)
}

// ScheduleSqlTaskMapInput is an input type that accepts ScheduleSqlTaskMap and ScheduleSqlTaskMapOutput values.
// You can construct a concrete instance of `ScheduleSqlTaskMapInput` via:
//
//	ScheduleSqlTaskMap{ "key": ScheduleSqlTaskArgs{...} }
type ScheduleSqlTaskMapInput interface {
	pulumi.Input

	ToScheduleSqlTaskMapOutput() ScheduleSqlTaskMapOutput
	ToScheduleSqlTaskMapOutputWithContext(context.Context) ScheduleSqlTaskMapOutput
}

type ScheduleSqlTaskMap map[string]ScheduleSqlTaskInput

func (ScheduleSqlTaskMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ScheduleSqlTask)(nil)).Elem()
}

func (i ScheduleSqlTaskMap) ToScheduleSqlTaskMapOutput() ScheduleSqlTaskMapOutput {
	return i.ToScheduleSqlTaskMapOutputWithContext(context.Background())
}

func (i ScheduleSqlTaskMap) ToScheduleSqlTaskMapOutputWithContext(ctx context.Context) ScheduleSqlTaskMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScheduleSqlTaskMapOutput)
}

type ScheduleSqlTaskOutput struct{ *pulumi.OutputState }

func (ScheduleSqlTaskOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ScheduleSqlTask)(nil)).Elem()
}

func (o ScheduleSqlTaskOutput) ToScheduleSqlTaskOutput() ScheduleSqlTaskOutput {
	return o
}

func (o ScheduleSqlTaskOutput) ToScheduleSqlTaskOutputWithContext(ctx context.Context) ScheduleSqlTaskOutput {
	return o
}

// A simple description of the timed SQL analysis task.
func (o ScheduleSqlTaskOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ScheduleSqlTask) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// The region to which the target log topic belongs. The default is the current region.
func (o ScheduleSqlTaskOutput) DestRegion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ScheduleSqlTask) pulumi.StringPtrOutput { return v.DestRegion }).(pulumi.StringPtrOutput)
}

// The target log topic ID used for storing the result data of timed SQL analysis.
func (o ScheduleSqlTaskOutput) DestTopicId() pulumi.StringOutput {
	return o.ApplyT(func(v *ScheduleSqlTask) pulumi.StringOutput { return v.DestTopicId }).(pulumi.StringOutput)
}

// Schedule the end time of the timed SQL analysis task in the format of a second-level timestamp.
func (o ScheduleSqlTaskOutput) ProcessEndTime() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ScheduleSqlTask) pulumi.IntPtrOutput { return v.ProcessEndTime }).(pulumi.IntPtrOutput)
}

// The delay time of each scheduling. The value range is from 0 to 120, and the unit is seconds.
func (o ScheduleSqlTaskOutput) ProcessSqlDelay() pulumi.IntOutput {
	return o.ApplyT(func(v *ScheduleSqlTask) pulumi.IntOutput { return v.ProcessSqlDelay }).(pulumi.IntOutput)
}

// The start time of the scheduled SQL analysis task, that is, the time when the first instance is created. The format is a timestamp at the second level.
func (o ScheduleSqlTaskOutput) ProcessStartTime() pulumi.IntOutput {
	return o.ApplyT(func(v *ScheduleSqlTask) pulumi.IntOutput { return v.ProcessStartTime }).(pulumi.IntOutput)
}

// SQL time window, which refers to the time range for log retrieval and analysis when a timed SQL analysis task is running, is in a left-closed and right-open format.
func (o ScheduleSqlTaskOutput) ProcessTimeWindow() pulumi.StringOutput {
	return o.ApplyT(func(v *ScheduleSqlTask) pulumi.StringOutput { return v.ProcessTimeWindow }).(pulumi.StringOutput)
}

// The retrieval and analysis statements for the regular execution of timed SQL analysis tasks should conform to the retrieval and analysis syntax of the log service.
func (o ScheduleSqlTaskOutput) Query() pulumi.StringOutput {
	return o.ApplyT(func(v *ScheduleSqlTask) pulumi.StringOutput { return v.Query }).(pulumi.StringOutput)
}

// The scheduling cycle of timed SQL analysis tasks.
func (o ScheduleSqlTaskOutput) RequestCycle() ScheduleSqlTaskRequestCycleOutput {
	return o.ApplyT(func(v *ScheduleSqlTask) ScheduleSqlTaskRequestCycleOutput { return v.RequestCycle }).(ScheduleSqlTaskRequestCycleOutput)
}

// Whether to start the scheduled SQL analysis task immediately after completing the task configuration.
func (o ScheduleSqlTaskOutput) Status() pulumi.IntOutput {
	return o.ApplyT(func(v *ScheduleSqlTask) pulumi.IntOutput { return v.Status }).(pulumi.IntOutput)
}

// The Name of timed SQL analysis task.
func (o ScheduleSqlTaskOutput) TaskName() pulumi.StringOutput {
	return o.ApplyT(func(v *ScheduleSqlTask) pulumi.StringOutput { return v.TaskName }).(pulumi.StringOutput)
}

// The log topic ID where the original log to be analyzed for scheduled SQL is located.
func (o ScheduleSqlTaskOutput) TopicId() pulumi.StringOutput {
	return o.ApplyT(func(v *ScheduleSqlTask) pulumi.StringOutput { return v.TopicId }).(pulumi.StringOutput)
}

type ScheduleSqlTaskArrayOutput struct{ *pulumi.OutputState }

func (ScheduleSqlTaskArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ScheduleSqlTask)(nil)).Elem()
}

func (o ScheduleSqlTaskArrayOutput) ToScheduleSqlTaskArrayOutput() ScheduleSqlTaskArrayOutput {
	return o
}

func (o ScheduleSqlTaskArrayOutput) ToScheduleSqlTaskArrayOutputWithContext(ctx context.Context) ScheduleSqlTaskArrayOutput {
	return o
}

func (o ScheduleSqlTaskArrayOutput) Index(i pulumi.IntInput) ScheduleSqlTaskOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ScheduleSqlTask {
		return vs[0].([]*ScheduleSqlTask)[vs[1].(int)]
	}).(ScheduleSqlTaskOutput)
}

type ScheduleSqlTaskMapOutput struct{ *pulumi.OutputState }

func (ScheduleSqlTaskMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ScheduleSqlTask)(nil)).Elem()
}

func (o ScheduleSqlTaskMapOutput) ToScheduleSqlTaskMapOutput() ScheduleSqlTaskMapOutput {
	return o
}

func (o ScheduleSqlTaskMapOutput) ToScheduleSqlTaskMapOutputWithContext(ctx context.Context) ScheduleSqlTaskMapOutput {
	return o
}

func (o ScheduleSqlTaskMapOutput) MapIndex(k pulumi.StringInput) ScheduleSqlTaskOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ScheduleSqlTask {
		return vs[0].(map[string]*ScheduleSqlTask)[vs[1].(string)]
	}).(ScheduleSqlTaskOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ScheduleSqlTaskInput)(nil)).Elem(), &ScheduleSqlTask{})
	pulumi.RegisterInputType(reflect.TypeOf((*ScheduleSqlTaskArrayInput)(nil)).Elem(), ScheduleSqlTaskArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ScheduleSqlTaskMapInput)(nil)).Elem(), ScheduleSqlTaskMap{})
	pulumi.RegisterOutputType(ScheduleSqlTaskOutput{})
	pulumi.RegisterOutputType(ScheduleSqlTaskArrayOutput{})
	pulumi.RegisterOutputType(ScheduleSqlTaskMapOutput{})
}
