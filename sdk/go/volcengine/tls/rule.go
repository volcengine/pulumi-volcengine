// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package tls

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a resource to manage tls rule
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"encoding/json"
//
//	"github.com/pulumi/pulumi-volcengine/sdk/go/volcengine/tls"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			tmpJSON0, err := json.Marshal(map[string]interface{}{
//				"json": map[string]interface{}{
//					"field": "__content__",
//					"trim_keys": map[string]interface{}{
//						"mode":  "all",
//						"chars": "#",
//					},
//					"trim_values": map[string]interface{}{
//						"mode":  "all",
//						"chars": "#t",
//					},
//					"allow_overwrite_keys": true,
//					"allow_empty_values":   true,
//				},
//			})
//			if err != nil {
//				return err
//			}
//			json0 := string(tmpJSON0)
//			tmpJSON1, err := json.Marshal(map[string]interface{}{
//				"json": map[string]interface{}{
//					"field": "__content__",
//					"trim_keys": map[string]interface{}{
//						"mode":  "all",
//						"chars": "#xx",
//					},
//					"trim_values": map[string]interface{}{
//						"mode":  "all",
//						"chars": "#txxxt",
//					},
//					"allow_overwrite_keys": true,
//					"allow_empty_values":   true,
//				},
//			})
//			if err != nil {
//				return err
//			}
//			json1 := string(tmpJSON1)
//			_, err := tls.NewRule(ctx, "foo", &tls.RuleArgs{
//				TopicId:   pulumi.String("7bfa2cdc-4f8b-4cf9-b4c9-0ed05c33349f"),
//				RuleName:  pulumi.String("test"),
//				LogType:   pulumi.String("minimalist_log"),
//				LogSample: pulumi.String("2018-05-22 15:35:53.850 INFO XXXX"),
//				InputType: pulumi.Int(1),
//				UserDefineRule: &tls.RuleUserDefineRuleArgs{
//					EnableRawLog: pulumi.Bool(false),
//					TailFiles:    pulumi.Bool(true),
//					ShardHashKey: &tls.RuleUserDefineRuleShardHashKeyArgs{
//						HashKey: pulumi.String("3C"),
//					},
//					Plugin: &tls.RuleUserDefineRulePluginArgs{
//						Processors: pulumi.StringArray{
//							pulumi.String(json0),
//							pulumi.String(json1),
//						},
//					},
//					Advanced: &tls.RuleUserDefineRuleAdvancedArgs{
//						CloseInactive: pulumi.Int(10),
//						CloseRemoved:  pulumi.Bool(false),
//						CloseRenamed:  pulumi.Bool(false),
//						CloseEof:      pulumi.Bool(false),
//						CloseTimeout:  pulumi.Int(1),
//					},
//				},
//				ContainerRule: &tls.RuleContainerRuleArgs{
//					Stream:             pulumi.String("all"),
//					ContainerNameRegex: pulumi.String(".*test.*"),
//					IncludeContainerLabelRegex: pulumi.StringMap{
//						"Key1": pulumi.String("Value12"),
//						"Key2": pulumi.String("Value23"),
//					},
//					ExcludeContainerLabelRegex: pulumi.StringMap{
//						"Key1": pulumi.String("Value12"),
//						"Key2": pulumi.String("Value22"),
//					},
//					IncludeContainerEnvRegex: pulumi.StringMap{
//						"Key1": pulumi.String("Value1"),
//						"Key2": pulumi.String("Value2"),
//					},
//					ExcludeContainerEnvRegex: pulumi.StringMap{
//						"Key1": pulumi.String("Value1"),
//						"Key2": pulumi.String("Value2"),
//					},
//					EnvTag: pulumi.StringMap{
//						"Key1": pulumi.String("Value1"),
//						"Key2": pulumi.String("Value2"),
//					},
//					KubernetesRule: &tls.RuleContainerRuleKubernetesRuleArgs{
//						NamespaceNameRegex: pulumi.String(".*test.*"),
//						WorkloadType:       pulumi.String("Deployment"),
//						WorkloadNameRegex:  pulumi.String(".*test.*"),
//						IncludePodLabelRegex: pulumi.StringMap{
//							"Key1": pulumi.String("Value1"),
//							"Key2": pulumi.String("Value2"),
//						},
//						ExcludePodLabelRegex: pulumi.StringMap{
//							"Key1": pulumi.String("Value1"),
//							"Key2": pulumi.String("Value2"),
//						},
//						PodNameRegex: pulumi.String(".*test.*"),
//						LabelTag: pulumi.StringMap{
//							"Key1": pulumi.String("Value1"),
//							"Key2": pulumi.String("Value2"),
//						},
//						AnnotationTag: pulumi.StringMap{
//							"Key1": pulumi.String("Value1"),
//							"Key2": pulumi.String("Value2"),
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// tls rule can be imported using the id, e.g.
//
// ```sh
//
//	$ pulumi import volcengine:tls/rule:Rule default fa************
//
// ```
type Rule struct {
	pulumi.CustomResourceState

	// Container collection rules.
	ContainerRule RuleContainerRulePtrOutput `pulumi:"containerRule"`
	// Collect the blacklist list.
	ExcludePaths RuleExcludePathArrayOutput `pulumi:"excludePaths"`
	// The extract rule.
	ExtractRule RuleExtractRuleOutput `pulumi:"extractRule"`
	// The type of the collection configuration. Validate value can be `0`(host log file), `1`(K8s container standard output) and `2`(Log files in the K8s container).
	InputType pulumi.IntPtrOutput `pulumi:"inputType"`
	// The sample of the log.
	LogSample pulumi.StringPtrOutput `pulumi:"logSample"`
	// The log type. The value can be one of the following: `minimalistLog`, `jsonLog`, `delimiterLog`, `multilineLog`, `fullregexLog`.
	LogType pulumi.StringPtrOutput `pulumi:"logType"`
	// Collection path list.
	Paths pulumi.StringArrayOutput `pulumi:"paths"`
	// The id of the rule.
	RuleId pulumi.StringOutput `pulumi:"ruleId"`
	// The name of the collection configuration.
	RuleName pulumi.StringOutput `pulumi:"ruleName"`
	// The ID of the log topic to which the collection configuration belongs.
	TopicId pulumi.StringOutput `pulumi:"topicId"`
	// User-defined collection rules.
	UserDefineRule RuleUserDefineRulePtrOutput `pulumi:"userDefineRule"`
}

// NewRule registers a new resource with the given unique name, arguments, and options.
func NewRule(ctx *pulumi.Context,
	name string, args *RuleArgs, opts ...pulumi.ResourceOption) (*Rule, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.RuleName == nil {
		return nil, errors.New("invalid value for required argument 'RuleName'")
	}
	if args.TopicId == nil {
		return nil, errors.New("invalid value for required argument 'TopicId'")
	}
	var resource Rule
	err := ctx.RegisterResource("volcengine:tls/rule:Rule", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetRule gets an existing Rule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetRule(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *RuleState, opts ...pulumi.ResourceOption) (*Rule, error) {
	var resource Rule
	err := ctx.ReadResource("volcengine:tls/rule:Rule", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Rule resources.
type ruleState struct {
	// Container collection rules.
	ContainerRule *RuleContainerRule `pulumi:"containerRule"`
	// Collect the blacklist list.
	ExcludePaths []RuleExcludePath `pulumi:"excludePaths"`
	// The extract rule.
	ExtractRule *RuleExtractRule `pulumi:"extractRule"`
	// The type of the collection configuration. Validate value can be `0`(host log file), `1`(K8s container standard output) and `2`(Log files in the K8s container).
	InputType *int `pulumi:"inputType"`
	// The sample of the log.
	LogSample *string `pulumi:"logSample"`
	// The log type. The value can be one of the following: `minimalistLog`, `jsonLog`, `delimiterLog`, `multilineLog`, `fullregexLog`.
	LogType *string `pulumi:"logType"`
	// Collection path list.
	Paths []string `pulumi:"paths"`
	// The id of the rule.
	RuleId *string `pulumi:"ruleId"`
	// The name of the collection configuration.
	RuleName *string `pulumi:"ruleName"`
	// The ID of the log topic to which the collection configuration belongs.
	TopicId *string `pulumi:"topicId"`
	// User-defined collection rules.
	UserDefineRule *RuleUserDefineRule `pulumi:"userDefineRule"`
}

type RuleState struct {
	// Container collection rules.
	ContainerRule RuleContainerRulePtrInput
	// Collect the blacklist list.
	ExcludePaths RuleExcludePathArrayInput
	// The extract rule.
	ExtractRule RuleExtractRulePtrInput
	// The type of the collection configuration. Validate value can be `0`(host log file), `1`(K8s container standard output) and `2`(Log files in the K8s container).
	InputType pulumi.IntPtrInput
	// The sample of the log.
	LogSample pulumi.StringPtrInput
	// The log type. The value can be one of the following: `minimalistLog`, `jsonLog`, `delimiterLog`, `multilineLog`, `fullregexLog`.
	LogType pulumi.StringPtrInput
	// Collection path list.
	Paths pulumi.StringArrayInput
	// The id of the rule.
	RuleId pulumi.StringPtrInput
	// The name of the collection configuration.
	RuleName pulumi.StringPtrInput
	// The ID of the log topic to which the collection configuration belongs.
	TopicId pulumi.StringPtrInput
	// User-defined collection rules.
	UserDefineRule RuleUserDefineRulePtrInput
}

func (RuleState) ElementType() reflect.Type {
	return reflect.TypeOf((*ruleState)(nil)).Elem()
}

type ruleArgs struct {
	// Container collection rules.
	ContainerRule *RuleContainerRule `pulumi:"containerRule"`
	// Collect the blacklist list.
	ExcludePaths []RuleExcludePath `pulumi:"excludePaths"`
	// The extract rule.
	ExtractRule *RuleExtractRule `pulumi:"extractRule"`
	// The type of the collection configuration. Validate value can be `0`(host log file), `1`(K8s container standard output) and `2`(Log files in the K8s container).
	InputType *int `pulumi:"inputType"`
	// The sample of the log.
	LogSample *string `pulumi:"logSample"`
	// The log type. The value can be one of the following: `minimalistLog`, `jsonLog`, `delimiterLog`, `multilineLog`, `fullregexLog`.
	LogType *string `pulumi:"logType"`
	// Collection path list.
	Paths []string `pulumi:"paths"`
	// The name of the collection configuration.
	RuleName string `pulumi:"ruleName"`
	// The ID of the log topic to which the collection configuration belongs.
	TopicId string `pulumi:"topicId"`
	// User-defined collection rules.
	UserDefineRule *RuleUserDefineRule `pulumi:"userDefineRule"`
}

// The set of arguments for constructing a Rule resource.
type RuleArgs struct {
	// Container collection rules.
	ContainerRule RuleContainerRulePtrInput
	// Collect the blacklist list.
	ExcludePaths RuleExcludePathArrayInput
	// The extract rule.
	ExtractRule RuleExtractRulePtrInput
	// The type of the collection configuration. Validate value can be `0`(host log file), `1`(K8s container standard output) and `2`(Log files in the K8s container).
	InputType pulumi.IntPtrInput
	// The sample of the log.
	LogSample pulumi.StringPtrInput
	// The log type. The value can be one of the following: `minimalistLog`, `jsonLog`, `delimiterLog`, `multilineLog`, `fullregexLog`.
	LogType pulumi.StringPtrInput
	// Collection path list.
	Paths pulumi.StringArrayInput
	// The name of the collection configuration.
	RuleName pulumi.StringInput
	// The ID of the log topic to which the collection configuration belongs.
	TopicId pulumi.StringInput
	// User-defined collection rules.
	UserDefineRule RuleUserDefineRulePtrInput
}

func (RuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ruleArgs)(nil)).Elem()
}

type RuleInput interface {
	pulumi.Input

	ToRuleOutput() RuleOutput
	ToRuleOutputWithContext(ctx context.Context) RuleOutput
}

func (*Rule) ElementType() reflect.Type {
	return reflect.TypeOf((**Rule)(nil)).Elem()
}

func (i *Rule) ToRuleOutput() RuleOutput {
	return i.ToRuleOutputWithContext(context.Background())
}

func (i *Rule) ToRuleOutputWithContext(ctx context.Context) RuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleOutput)
}

// RuleArrayInput is an input type that accepts RuleArray and RuleArrayOutput values.
// You can construct a concrete instance of `RuleArrayInput` via:
//
//	RuleArray{ RuleArgs{...} }
type RuleArrayInput interface {
	pulumi.Input

	ToRuleArrayOutput() RuleArrayOutput
	ToRuleArrayOutputWithContext(context.Context) RuleArrayOutput
}

type RuleArray []RuleInput

func (RuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Rule)(nil)).Elem()
}

func (i RuleArray) ToRuleArrayOutput() RuleArrayOutput {
	return i.ToRuleArrayOutputWithContext(context.Background())
}

func (i RuleArray) ToRuleArrayOutputWithContext(ctx context.Context) RuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleArrayOutput)
}

// RuleMapInput is an input type that accepts RuleMap and RuleMapOutput values.
// You can construct a concrete instance of `RuleMapInput` via:
//
//	RuleMap{ "key": RuleArgs{...} }
type RuleMapInput interface {
	pulumi.Input

	ToRuleMapOutput() RuleMapOutput
	ToRuleMapOutputWithContext(context.Context) RuleMapOutput
}

type RuleMap map[string]RuleInput

func (RuleMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Rule)(nil)).Elem()
}

func (i RuleMap) ToRuleMapOutput() RuleMapOutput {
	return i.ToRuleMapOutputWithContext(context.Background())
}

func (i RuleMap) ToRuleMapOutputWithContext(ctx context.Context) RuleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleMapOutput)
}

type RuleOutput struct{ *pulumi.OutputState }

func (RuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Rule)(nil)).Elem()
}

func (o RuleOutput) ToRuleOutput() RuleOutput {
	return o
}

func (o RuleOutput) ToRuleOutputWithContext(ctx context.Context) RuleOutput {
	return o
}

// Container collection rules.
func (o RuleOutput) ContainerRule() RuleContainerRulePtrOutput {
	return o.ApplyT(func(v *Rule) RuleContainerRulePtrOutput { return v.ContainerRule }).(RuleContainerRulePtrOutput)
}

// Collect the blacklist list.
func (o RuleOutput) ExcludePaths() RuleExcludePathArrayOutput {
	return o.ApplyT(func(v *Rule) RuleExcludePathArrayOutput { return v.ExcludePaths }).(RuleExcludePathArrayOutput)
}

// The extract rule.
func (o RuleOutput) ExtractRule() RuleExtractRuleOutput {
	return o.ApplyT(func(v *Rule) RuleExtractRuleOutput { return v.ExtractRule }).(RuleExtractRuleOutput)
}

// The type of the collection configuration. Validate value can be `0`(host log file), `1`(K8s container standard output) and `2`(Log files in the K8s container).
func (o RuleOutput) InputType() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Rule) pulumi.IntPtrOutput { return v.InputType }).(pulumi.IntPtrOutput)
}

// The sample of the log.
func (o RuleOutput) LogSample() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Rule) pulumi.StringPtrOutput { return v.LogSample }).(pulumi.StringPtrOutput)
}

// The log type. The value can be one of the following: `minimalistLog`, `jsonLog`, `delimiterLog`, `multilineLog`, `fullregexLog`.
func (o RuleOutput) LogType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Rule) pulumi.StringPtrOutput { return v.LogType }).(pulumi.StringPtrOutput)
}

// Collection path list.
func (o RuleOutput) Paths() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Rule) pulumi.StringArrayOutput { return v.Paths }).(pulumi.StringArrayOutput)
}

// The id of the rule.
func (o RuleOutput) RuleId() pulumi.StringOutput {
	return o.ApplyT(func(v *Rule) pulumi.StringOutput { return v.RuleId }).(pulumi.StringOutput)
}

// The name of the collection configuration.
func (o RuleOutput) RuleName() pulumi.StringOutput {
	return o.ApplyT(func(v *Rule) pulumi.StringOutput { return v.RuleName }).(pulumi.StringOutput)
}

// The ID of the log topic to which the collection configuration belongs.
func (o RuleOutput) TopicId() pulumi.StringOutput {
	return o.ApplyT(func(v *Rule) pulumi.StringOutput { return v.TopicId }).(pulumi.StringOutput)
}

// User-defined collection rules.
func (o RuleOutput) UserDefineRule() RuleUserDefineRulePtrOutput {
	return o.ApplyT(func(v *Rule) RuleUserDefineRulePtrOutput { return v.UserDefineRule }).(RuleUserDefineRulePtrOutput)
}

type RuleArrayOutput struct{ *pulumi.OutputState }

func (RuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Rule)(nil)).Elem()
}

func (o RuleArrayOutput) ToRuleArrayOutput() RuleArrayOutput {
	return o
}

func (o RuleArrayOutput) ToRuleArrayOutputWithContext(ctx context.Context) RuleArrayOutput {
	return o
}

func (o RuleArrayOutput) Index(i pulumi.IntInput) RuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Rule {
		return vs[0].([]*Rule)[vs[1].(int)]
	}).(RuleOutput)
}

type RuleMapOutput struct{ *pulumi.OutputState }

func (RuleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Rule)(nil)).Elem()
}

func (o RuleMapOutput) ToRuleMapOutput() RuleMapOutput {
	return o
}

func (o RuleMapOutput) ToRuleMapOutputWithContext(ctx context.Context) RuleMapOutput {
	return o
}

func (o RuleMapOutput) MapIndex(k pulumi.StringInput) RuleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Rule {
		return vs[0].(map[string]*Rule)[vs[1].(string)]
	}).(RuleOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*RuleInput)(nil)).Elem(), &Rule{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleArrayInput)(nil)).Elem(), RuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleMapInput)(nil)).Elem(), RuleMap{})
	pulumi.RegisterOutputType(RuleOutput{})
	pulumi.RegisterOutputType(RuleArrayOutput{})
	pulumi.RegisterOutputType(RuleMapOutput{})
}
