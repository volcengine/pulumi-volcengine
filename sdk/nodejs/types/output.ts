// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export namespace alb {
    export interface AclAclEntry {
        /**
         * The description of the AclEntry.
         */
        description?: string;
        /**
         * The content of the AclEntry.
         */
        entry: string;
    }

    export interface AclsAcl {
        /**
         * The entries info of acl.
         */
        aclEntries: outputs.alb.AclsAclAclEntry[];
        /**
         * The count of acl entry.
         */
        aclEntryCount: number;
        /**
         * The ID of Acl.
         */
        aclId: string;
        /**
         * The name of acl.
         */
        aclName: string;
        /**
         * Creation time of Acl.
         */
        createTime: string;
        /**
         * The description of Acl.
         */
        description: string;
        /**
         * The ID of Acl.
         */
        id: string;
        /**
         * The listeners of acl.
         */
        listeners: outputs.alb.AclsAclListener[];
        /**
         * The name of project.
         */
        projectName: string;
        /**
         * Update time of Acl.
         */
        updateTime: string;
    }

    export interface AclsAclAclEntry {
        /**
         * The description of Acl.
         */
        description: string;
        /**
         * The info of entry.
         */
        entry: string;
    }

    export interface AclsAclListener {
        /**
         * The type of acl.
         */
        aclType: string;
        /**
         * The ID of Listener.
         */
        listenerId: string;
        /**
         * The Name of Listener.
         */
        listenerName: string;
        /**
         * The port info of listener.
         */
        port: number;
        /**
         * The protocol info of listener.
         */
        protocol: string;
    }

    export interface AlbEipBillingConfig {
        /**
         * The peek bandwidth of the EIP which automatically assigned to the Alb. Unit: Mbps.
         */
        bandwidth: number;
        /**
         * The billing type of the EIP which automatically assigned to the Alb. Valid values: `PostPaidByBandwidth`, `PostPaidByTraffic`.
         */
        eipBillingType: string;
        /**
         * The ISP of the EIP which automatically associated to the Alb, the value can be `BGP`.
         */
        isp: string;
    }

    export interface AlbIpv6EipBillingConfig {
        /**
         * The peek bandwidth of the Ipv6 EIP which automatically assigned to the Alb. Unit: Mbps.
         */
        bandwidth: number;
        /**
         * The billing type of the Tpv6 EIP which automatically assigned to the Alb. Valid values: `PostPaidByBandwidth`, `PostPaidByTraffic`.
         */
        billingType: string;
        /**
         * The ISP of the Ipv6 EIP which automatically associated to the Alb, the value can be `BGP`.
         */
        isp: string;
    }

    export interface AlbTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface AlbZoneMapping {
        /**
         * The IP address information of the Alb in this availability zone.
         */
        loadBalancerAddresses: outputs.alb.AlbZoneMappingLoadBalancerAddress[];
        /**
         * The subnet id of the Alb in this availability zone.
         */
        subnetId: string;
        /**
         * The availability zone id of the Alb.
         */
        zoneId: string;
    }

    export interface AlbZoneMappingLoadBalancerAddress {
        /**
         * The Eip address of the Alb in this availability zone.
         */
        eipAddress: string;
        /**
         * The Eip id of alb instance in this availability zone.
         */
        eipId: string;
        /**
         * The Eni address of the Alb in this availability zone.
         */
        eniAddress: string;
        /**
         * The Eni id of the Alb in this availability zone.
         */
        eniId: string;
        /**
         * The Eni Ipv6 address of the Alb in this availability zone.
         */
        eniIpv6Address: string;
        /**
         * The Ipv6 Eip id of alb instance in this availability zone.
         */
        ipv6EipId: string;
    }

    export interface AlbsAlb {
        /**
         * The access log information of the Alb.
         */
        accessLogs: outputs.alb.AlbsAlbAccessLog[];
        /**
         * The address ip version of the Alb, valid value: `IPv4`, `DualStack`.
         */
        addressIpVersion: string;
        /**
         * The business status of the Alb, valid value:`Normal`, `FinancialLocked`.
         */
        businessStatus: string;
        /**
         * The create time of the Alb.
         */
        createTime: string;
        /**
         * The deletion protection function of the Alb instance is turned on or off.
         */
        deleteProtection: string;
        /**
         * The expected deleted time of the Alb. This parameter has a query value only when the status of the Alb instance is `FinancialLocked`.
         */
        deletedTime: string;
        /**
         * The description of the Alb.
         */
        description: string;
        /**
         * The DNS name.
         */
        dnsName: string;
        /**
         * The health log information of the Alb.
         */
        healthLogs: outputs.alb.AlbsAlbHealthLog[];
        /**
         * The ID of the Alb.
         */
        id: string;
        /**
         * The listener information of the Alb.
         */
        listeners: outputs.alb.AlbsAlbListener[];
        /**
         * The billing type of the Alb.
         */
        loadBalancerBillingType: number;
        /**
         * The ID of the Alb.
         */
        loadBalancerId: string;
        /**
         * The name of the Alb.
         */
        loadBalancerName: string;
        /**
         * The local addresses of the Alb.
         */
        localAddresses: string[];
        /**
         * The reason why Alb is locked. This parameter has a query value only when the status of the Alb instance is `FinancialLocked`.
         */
        lockReason: string;
        /**
         * The overdue time of the Alb. This parameter has a query value only when the status of the Alb instance is `FinancialLocked`.
         */
        overdueTime: string;
        /**
         * The project name of the Alb.
         */
        projectName: string;
        /**
         * The status of the Alb.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.alb.AlbsAlbTag[];
        /**
         * The tls access log information of the Alb.
         */
        tlsAccessLogs: outputs.alb.AlbsAlbTlsAccessLog[];
        /**
         * The type of the Alb, valid value: `public`, `private`.
         */
        type: string;
        /**
         * The update time of the Alb.
         */
        updateTime: string;
        /**
         * The vpc id which Alb belongs to.
         */
        vpcId: string;
        /**
         * Configuration information of the Alb instance in different Availability Zones.
         */
        zoneMappings: outputs.alb.AlbsAlbZoneMapping[];
    }

    export interface AlbsAlbAccessLog {
        /**
         * The bucket name where the logs are stored.
         */
        bucketName: string;
        /**
         * Whether the tls access log function is enabled.
         */
        enabled: boolean;
    }

    export interface AlbsAlbHealthLog {
        /**
         * Whether the tls access log function is enabled.
         */
        enabled: boolean;
        /**
         * The TLS project id bound to the access log.
         */
        projectId: string;
        /**
         * The TLS topic id bound to the access log.
         */
        topicId: string;
    }

    export interface AlbsAlbListener {
        /**
         * The listener id of the Alb.
         */
        listenerId: string;
        /**
         * The listener name of the Alb.
         */
        listenerName: string;
    }

    export interface AlbsAlbTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface AlbsAlbTlsAccessLog {
        /**
         * Whether the tls access log function is enabled.
         */
        enabled: boolean;
        /**
         * The TLS project id bound to the access log.
         */
        projectId: string;
        /**
         * The TLS topic id bound to the access log.
         */
        topicId: string;
    }

    export interface AlbsAlbZoneMapping {
        /**
         * The IP address information of the Alb in this availability zone.
         */
        loadBalancerAddresses: outputs.alb.AlbsAlbZoneMappingLoadBalancerAddress[];
        /**
         * The subnet id of the Alb in this availability zone.
         */
        subnetId: string;
        /**
         * The availability zone id of the Alb.
         */
        zoneId: string;
    }

    export interface AlbsAlbZoneMappingLoadBalancerAddress {
        /**
         * The Eip address of the Alb.
         */
        eipAddress: string;
        /**
         * The Eip id of alb instance in this availability zone.
         */
        eipId: string;
        /**
         * The Eip information of the Alb in this availability zone.
         */
        eips: outputs.alb.AlbsAlbZoneMappingLoadBalancerAddressEip[];
        /**
         * The private ip address of the Alb.
         */
        eniAddress: string;
        /**
         * The Eni id of the Alb in this availability zone.
         */
        eniId: string;
        /**
         * The Eni Ipv6 address of the Alb in this availability zone.
         */
        eniIpv6Address: string;
        /**
         * The Ipv6 Eip id of alb instance in this availability zone.
         */
        ipv6EipId: string;
        /**
         * The Ipv6 Eip information of the Alb in this availability zone.
         */
        ipv6Eips: outputs.alb.AlbsAlbZoneMappingLoadBalancerAddressIpv6Eip[];
    }

    export interface AlbsAlbZoneMappingLoadBalancerAddressEip {
        /**
         * The association mode of the Alb. This parameter has a query value only when the type of the Eip is `anycast`.
         */
        associationMode: string;
        /**
         * The peek bandwidth of the Ipv6 Eip assigned to Alb. Units: Mbps.
         */
        bandwidth: number;
        /**
         * The Eip address of the Alb.
         */
        eipAddress: string;
        /**
         * The billing type of the Eip assigned to Alb. And optional choice contains `PostPaidByBandwidth` or `PostPaidByTraffic`.
         */
        eipBillingType: string;
        /**
         * The Eip type of the Alb.
         */
        eipType: string;
        /**
         * The ISP of the Ipv6 Eip assigned to Alb, the value can be `BGP`.
         */
        isp: string;
        /**
         * The pop locations of the Alb. This parameter has a query value only when the type of the Eip is `anycast`.
         */
        popLocations: outputs.alb.AlbsAlbZoneMappingLoadBalancerAddressEipPopLocation[];
        /**
         * The security protection types of the Alb.
         */
        securityProtectionTypes: string[];
    }

    export interface AlbsAlbZoneMappingLoadBalancerAddressEipPopLocation {
        /**
         * The pop id of the Anycast Eip.
         */
        popId: string;
        /**
         * The pop name of the Anycast Eip.
         */
        popName: string;
    }

    export interface AlbsAlbZoneMappingLoadBalancerAddressIpv6Eip {
        /**
         * The peek bandwidth of the Ipv6 Eip assigned to Alb. Units: Mbps.
         */
        bandwidth: number;
        /**
         * The billing type of the Ipv6 Eip assigned to Alb. And optional choice contains `PostPaidByBandwidth` or `PostPaidByTraffic`.
         */
        billingType: string;
        /**
         * The ISP of the Ipv6 Eip assigned to Alb, the value can be `BGP`.
         */
        isp: string;
    }

    export interface AlbsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface CaCertificatesCertificate {
        /**
         * The ID of the CA certificate.
         */
        caCertificateId: string;
        /**
         * The name of the CA certificate.
         */
        caCertificateName: string;
        /**
         * The type of the CA certificate.
         */
        certificateType: string;
        /**
         * The create time of the CA Certificate.
         */
        createTime: string;
        /**
         * The description of the CA certificate.
         */
        description: string;
        /**
         * The domain name of the CA Certificate.
         */
        domainName: string;
        /**
         * The expire time of the CA Certificate.
         */
        expiredAt: string;
        /**
         * The ID list of the CA Listener.
         */
        listeners: string[];
        /**
         * The project name of the CA certificate.
         */
        projectName: string;
        /**
         * The status of the CA Certificate.
         */
        status: string;
    }

    export interface CertificatesCertificate {
        /**
         * The ID of the Certificate.
         */
        certificateId: string;
        /**
         * The Name of Certificate.
         */
        certificateName: string;
        /**
         * The type of the Certificate.
         */
        certificateType: string;
        /**
         * The create time of the Certificate.
         */
        createTime: string;
        /**
         * The description of the Certificate.
         */
        description: string;
        /**
         * The domain name of the Certificate.
         */
        domainName: string;
        /**
         * The expire time of the Certificate.
         */
        expiredAt: string;
        /**
         * The ID of the Certificate.
         */
        id: string;
        /**
         * The ID list of the Listener.
         */
        listeners: string[];
        /**
         * The ProjectName of the Certificate.
         */
        projectName: string;
        /**
         * The status of the Certificate.
         */
        status: string;
    }

    export interface CustomizedCfgsCfg {
        /**
         * The create time of CustomizedCfg.
         */
        createTime: string;
        /**
         * The content of CustomizedCfg.
         */
        customizedCfgContent: string;
        /**
         * The ID of CustomizedCfg.
         */
        customizedCfgId: string;
        /**
         * The name of the CustomizedCfg.
         */
        customizedCfgName: string;
        /**
         * The description of CustomizedCfg.
         */
        description: string;
        /**
         * The ID of CustomizedCfg.
         */
        id: string;
        /**
         * The listeners of CustomizedCfg.
         */
        listeners: outputs.alb.CustomizedCfgsCfgListener[];
        /**
         * The project name of the CustomizedCfg.
         */
        projectName: string;
        /**
         * The status of CustomizedCfg.
         */
        status: string;
        /**
         * The update time of CustomizedCfg.
         */
        updateTime: string;
    }

    export interface CustomizedCfgsCfgListener {
        /**
         * The id of the listener.
         */
        listenerId: string;
        /**
         * The Name of Listener.
         */
        listenerName: string;
        /**
         * The port info of listener.
         */
        port: number;
        /**
         * The protocol info of listener.
         */
        protocol: string;
    }

    export interface GetAclsAcl {
        /**
         * The entries info of acl.
         */
        aclEntries: outputs.alb.GetAclsAclAclEntry[];
        /**
         * The count of acl entry.
         */
        aclEntryCount: number;
        /**
         * The ID of Acl.
         */
        aclId: string;
        /**
         * The name of acl.
         */
        aclName: string;
        /**
         * Creation time of Acl.
         */
        createTime: string;
        /**
         * The description of Acl.
         */
        description: string;
        /**
         * The ID of Acl.
         */
        id: string;
        /**
         * The listeners of acl.
         */
        listeners: outputs.alb.GetAclsAclListener[];
        /**
         * The name of project.
         */
        projectName: string;
        /**
         * Update time of Acl.
         */
        updateTime: string;
    }

    export interface GetAclsAclAclEntry {
        /**
         * The description of Acl.
         */
        description: string;
        /**
         * The info of entry.
         */
        entry: string;
    }

    export interface GetAclsAclListener {
        /**
         * The type of acl.
         */
        aclType: string;
        /**
         * The ID of Listener.
         */
        listenerId: string;
        /**
         * The Name of Listener.
         */
        listenerName: string;
        /**
         * The port info of listener.
         */
        port: number;
        /**
         * The protocol info of listener.
         */
        protocol: string;
    }

    export interface GetAlbsAlb {
        /**
         * The access log information of the Alb.
         */
        accessLogs: outputs.alb.GetAlbsAlbAccessLog[];
        /**
         * The address ip version of the Alb, valid value: `IPv4`, `DualStack`.
         */
        addressIpVersion: string;
        /**
         * The business status of the Alb, valid value:`Normal`, `FinancialLocked`.
         */
        businessStatus: string;
        /**
         * The create time of the Alb.
         */
        createTime: string;
        /**
         * The deletion protection function of the Alb instance is turned on or off.
         */
        deleteProtection: string;
        /**
         * The expected deleted time of the Alb. This parameter has a query value only when the status of the Alb instance is `FinancialLocked`.
         */
        deletedTime: string;
        /**
         * The description of the Alb.
         */
        description: string;
        /**
         * The DNS name.
         */
        dnsName: string;
        /**
         * The health log information of the Alb.
         */
        healthLogs: outputs.alb.GetAlbsAlbHealthLog[];
        /**
         * The ID of the Alb.
         */
        id: string;
        /**
         * The listener information of the Alb.
         */
        listeners: outputs.alb.GetAlbsAlbListener[];
        /**
         * The billing type of the Alb.
         */
        loadBalancerBillingType: number;
        /**
         * The ID of the Alb.
         */
        loadBalancerId: string;
        /**
         * The name of the Alb.
         */
        loadBalancerName: string;
        /**
         * The local addresses of the Alb.
         */
        localAddresses: string[];
        /**
         * The reason why Alb is locked. This parameter has a query value only when the status of the Alb instance is `FinancialLocked`.
         */
        lockReason: string;
        /**
         * The overdue time of the Alb. This parameter has a query value only when the status of the Alb instance is `FinancialLocked`.
         */
        overdueTime: string;
        /**
         * The project name of the Alb.
         */
        projectName: string;
        /**
         * The status of the Alb.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.alb.GetAlbsAlbTag[];
        /**
         * The tls access log information of the Alb.
         */
        tlsAccessLogs: outputs.alb.GetAlbsAlbTlsAccessLog[];
        /**
         * The type of the Alb, valid value: `public`, `private`.
         */
        type: string;
        /**
         * The update time of the Alb.
         */
        updateTime: string;
        /**
         * The vpc id which Alb belongs to.
         */
        vpcId: string;
        /**
         * Configuration information of the Alb instance in different Availability Zones.
         */
        zoneMappings: outputs.alb.GetAlbsAlbZoneMapping[];
    }

    export interface GetAlbsAlbAccessLog {
        /**
         * The bucket name where the logs are stored.
         */
        bucketName: string;
        /**
         * Whether the tls access log function is enabled.
         */
        enabled: boolean;
    }

    export interface GetAlbsAlbHealthLog {
        /**
         * Whether the tls access log function is enabled.
         */
        enabled: boolean;
        /**
         * The TLS project id bound to the access log.
         */
        projectId: string;
        /**
         * The TLS topic id bound to the access log.
         */
        topicId: string;
    }

    export interface GetAlbsAlbListener {
        /**
         * The listener id of the Alb.
         */
        listenerId: string;
        /**
         * The listener name of the Alb.
         */
        listenerName: string;
    }

    export interface GetAlbsAlbTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetAlbsAlbTlsAccessLog {
        /**
         * Whether the tls access log function is enabled.
         */
        enabled: boolean;
        /**
         * The TLS project id bound to the access log.
         */
        projectId: string;
        /**
         * The TLS topic id bound to the access log.
         */
        topicId: string;
    }

    export interface GetAlbsAlbZoneMapping {
        /**
         * The IP address information of the Alb in this availability zone.
         */
        loadBalancerAddresses: outputs.alb.GetAlbsAlbZoneMappingLoadBalancerAddress[];
        /**
         * The subnet id of the Alb in this availability zone.
         */
        subnetId: string;
        /**
         * The availability zone id of the Alb.
         */
        zoneId: string;
    }

    export interface GetAlbsAlbZoneMappingLoadBalancerAddress {
        /**
         * The Eip address of the Alb.
         */
        eipAddress: string;
        /**
         * The Eip id of alb instance in this availability zone.
         */
        eipId: string;
        /**
         * The Eip information of the Alb in this availability zone.
         */
        eips: outputs.alb.GetAlbsAlbZoneMappingLoadBalancerAddressEip[];
        /**
         * The private ip address of the Alb.
         */
        eniAddress: string;
        /**
         * The Eni id of the Alb in this availability zone.
         */
        eniId: string;
        /**
         * The Eni Ipv6 address of the Alb in this availability zone.
         */
        eniIpv6Address: string;
        /**
         * The Ipv6 Eip id of alb instance in this availability zone.
         */
        ipv6EipId: string;
        /**
         * The Ipv6 Eip information of the Alb in this availability zone.
         */
        ipv6Eips: outputs.alb.GetAlbsAlbZoneMappingLoadBalancerAddressIpv6Eip[];
    }

    export interface GetAlbsAlbZoneMappingLoadBalancerAddressEip {
        /**
         * The association mode of the Alb. This parameter has a query value only when the type of the Eip is `anycast`.
         */
        associationMode: string;
        /**
         * The peek bandwidth of the Ipv6 Eip assigned to Alb. Units: Mbps.
         */
        bandwidth: number;
        /**
         * The Eip address of the Alb.
         */
        eipAddress: string;
        /**
         * The billing type of the Eip assigned to Alb. And optional choice contains `PostPaidByBandwidth` or `PostPaidByTraffic`.
         */
        eipBillingType: string;
        /**
         * The Eip type of the Alb.
         */
        eipType: string;
        /**
         * The ISP of the Ipv6 Eip assigned to Alb, the value can be `BGP`.
         */
        isp: string;
        /**
         * The pop locations of the Alb. This parameter has a query value only when the type of the Eip is `anycast`.
         */
        popLocations: outputs.alb.GetAlbsAlbZoneMappingLoadBalancerAddressEipPopLocation[];
        /**
         * The security protection types of the Alb.
         */
        securityProtectionTypes: string[];
    }

    export interface GetAlbsAlbZoneMappingLoadBalancerAddressEipPopLocation {
        /**
         * The pop id of the Anycast Eip.
         */
        popId: string;
        /**
         * The pop name of the Anycast Eip.
         */
        popName: string;
    }

    export interface GetAlbsAlbZoneMappingLoadBalancerAddressIpv6Eip {
        /**
         * The peek bandwidth of the Ipv6 Eip assigned to Alb. Units: Mbps.
         */
        bandwidth: number;
        /**
         * The billing type of the Ipv6 Eip assigned to Alb. And optional choice contains `PostPaidByBandwidth` or `PostPaidByTraffic`.
         */
        billingType: string;
        /**
         * The ISP of the Ipv6 Eip assigned to Alb, the value can be `BGP`.
         */
        isp: string;
    }

    export interface GetAlbsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetCaCertificatesCertificate {
        /**
         * The ID of the CA certificate.
         */
        caCertificateId: string;
        /**
         * The name of the CA certificate.
         */
        caCertificateName: string;
        /**
         * The type of the CA certificate.
         */
        certificateType: string;
        /**
         * The create time of the CA Certificate.
         */
        createTime: string;
        /**
         * The description of the CA certificate.
         */
        description: string;
        /**
         * The domain name of the CA Certificate.
         */
        domainName: string;
        /**
         * The expire time of the CA Certificate.
         */
        expiredAt: string;
        /**
         * The ID list of the CA Listener.
         */
        listeners: string[];
        /**
         * The project name of the CA certificate.
         */
        projectName: string;
        /**
         * The status of the CA Certificate.
         */
        status: string;
    }

    export interface GetCertificatesCertificate {
        /**
         * The ID of the Certificate.
         */
        certificateId: string;
        /**
         * The Name of Certificate.
         */
        certificateName: string;
        /**
         * The type of the Certificate.
         */
        certificateType: string;
        /**
         * The create time of the Certificate.
         */
        createTime: string;
        /**
         * The description of the Certificate.
         */
        description: string;
        /**
         * The domain name of the Certificate.
         */
        domainName: string;
        /**
         * The expire time of the Certificate.
         */
        expiredAt: string;
        /**
         * The ID of the Certificate.
         */
        id: string;
        /**
         * The ID list of the Listener.
         */
        listeners: string[];
        /**
         * The ProjectName of the Certificate.
         */
        projectName: string;
        /**
         * The status of the Certificate.
         */
        status: string;
    }

    export interface GetCustomizedCfgsCfg {
        /**
         * The create time of CustomizedCfg.
         */
        createTime: string;
        /**
         * The content of CustomizedCfg.
         */
        customizedCfgContent: string;
        /**
         * The ID of CustomizedCfg.
         */
        customizedCfgId: string;
        /**
         * The name of the CustomizedCfg.
         */
        customizedCfgName: string;
        /**
         * The description of CustomizedCfg.
         */
        description: string;
        /**
         * The ID of CustomizedCfg.
         */
        id: string;
        /**
         * The listeners of CustomizedCfg.
         */
        listeners: outputs.alb.GetCustomizedCfgsCfgListener[];
        /**
         * The project name of the CustomizedCfg.
         */
        projectName: string;
        /**
         * The status of CustomizedCfg.
         */
        status: string;
        /**
         * The update time of CustomizedCfg.
         */
        updateTime: string;
    }

    export interface GetCustomizedCfgsCfgListener {
        /**
         * The id of the listener.
         */
        listenerId: string;
        /**
         * The Name of Listener.
         */
        listenerName: string;
        /**
         * The port info of listener.
         */
        port: number;
        /**
         * The protocol info of listener.
         */
        protocol: string;
    }

    export interface GetHealthCheckTemplatesHealthCheckTemplate {
        /**
         * The description of health check template.
         */
        description: string;
        /**
         * The domain name to health check.
         */
        healthCheckDomain: string;
        /**
         * The normal HTTP status code for health check, the default is http_2xx, http_3xx, separated by commas.
         */
        healthCheckHttpCode: string;
        /**
         * The HTTP version of health check.
         */
        healthCheckHttpVersion: string;
        /**
         * The interval for performing health checks, the default value is 2, and the value is 1-300.
         */
        healthCheckInterval: number;
        /**
         * The health check method,default is `GET`,support `GET` and ``HEAD.
         */
        healthCheckMethod: string;
        /**
         * The protocol of health check,only support HTTP.
         */
        healthCheckProtocol: string;
        /**
         * The ID of health check template.
         */
        healthCheckTemplateId: string;
        /**
         * The name of health check template to query.
         */
        healthCheckTemplateName: string;
        /**
         * The timeout of health check response,the default value is 2, and the value is 1-60.
         */
        healthCheckTimeout: number;
        /**
         * The uri to health check,default is `/`.
         */
        healthCheckUri: string;
        /**
         * The healthy threshold of the health check, the default is 3, the value is 2-10.
         */
        healthyThreshold: number;
        /**
         * The id of the health check template.
         */
        id: string;
        /**
         * The unhealthy threshold of the health check, the default is 3, the value is 2-10.
         */
        unhealthyThreshold: number;
    }

    export interface GetListenerDomainExtensionsDomainExtension {
        /**
         * The server certificate ID that domain used.
         */
        certificateId: string;
        /**
         * The domain.
         */
        domain: string;
        /**
         * The extension domain ID.
         */
        domainExtensionId: string;
        /**
         * The ID of the Listener.
         */
        id: string;
        /**
         * A Listener ID.
         */
        listenerId: string;
    }

    export interface GetListenersListener {
        /**
         * The ID of the access control policy group bound to the listener, only returned when the AclStatus parameter is on.
         */
        aclIds: string[];
        /**
         * Whether to enable the access control function,valid value is on or off.
         */
        aclStatus: string;
        /**
         * The access control type.
         */
        aclType: string;
        /**
         * CA certificate ID associated with HTTPS listener.
         */
        caCertificateId: string;
        /**
         * The certificate id associated with the listener. Source is `certCenter`.
         */
        certCenterCertificateId: string;
        /**
         * The server certificate ID that domain used.
         */
        certificateId: string;
        /**
         * The source of the certificate.
         */
        certificateSource: string;
        /**
         * The create time of the Listener.
         */
        createTime: string;
        /**
         * The customized configuration ID, the value is empty string when not bound.
         */
        customizedCfgId: string;
        /**
         * The description of listener.
         */
        description: string;
        /**
         * The HTTPS listener association list of extension domains for.
         */
        domainExtensions: outputs.alb.GetListenersListenerDomainExtension[];
        /**
         * The HTTP2 feature switch,valid value is on or off.
         */
        enableHttp2: string;
        /**
         * The QUIC feature switch,valid value is on or off.
         */
        enableQuic: string;
        /**
         * The enable status of the Listener.
         */
        enabled: string;
        /**
         * The ID of the Listener.
         */
        id: string;
        /**
         * The ID of the Listener.
         */
        listenerId: string;
        /**
         * The name of the Listener.
         */
        listenerName: string;
        /**
         * The id of the Alb.
         */
        loadBalancerId: string;
        /**
         * The port receiving request of the Listener.
         */
        port: number;
        /**
         * The project name of the listener.
         */
        projectName: string;
        /**
         * The protocol of the Listener.
         */
        protocol: string;
        /**
         * The ID of server group.
         */
        serverGroupId: string;
        /**
         * The list of server groups with associated listeners.
         */
        serverGroups: outputs.alb.GetListenersListenerServerGroup[];
        /**
         * The status of the Listener.
         */
        status: string;
        /**
         * The update time of the Listener.
         */
        updateTime: string;
    }

    export interface GetListenersListenerDomainExtension {
        /**
         * The server certificate ID that domain used.
         */
        certificateId: string;
        /**
         * The domain.
         */
        domain: string;
        /**
         * The extension domain ID.
         */
        domainExtensionId: string;
        /**
         * The ID of the Listener.
         */
        listenerId: string;
    }

    export interface GetListenersListenerServerGroup {
        /**
         * The ID of server group.
         */
        serverGroupId: string;
        /**
         * The name of server group.
         */
        serverGroupName: string;
    }

    export interface GetRulesRule {
        /**
         * The Description of Rule.
         */
        description: string;
        /**
         * The Domain of Rule.
         */
        domain: string;
        /**
         * The Id of Rule.
         */
        id: string;
        /**
         * Redirect related configuration.
         */
        redirectConfigs: outputs.alb.GetRulesRuleRedirectConfig[];
        /**
         * The list of rewrite configurations.
         */
        rewriteConfigs: outputs.alb.GetRulesRuleRewriteConfig[];
        /**
         * Rewrite configuration switch for forwarding rules, only allows configuration and takes effect when RuleAction is empty (i.e., forwarding to server group). Only available for whitelist users, please submit an application to experience. Supported values are as follows:
         * on: enable.
         * off: disable.
         */
        rewriteEnabled: string;
        /**
         * The forwarding rule action, if this parameter is empty, forward to server group, if value is `Redirect`, will redirect.
         */
        ruleAction: string;
        /**
         * The Id of Rule.
         */
        ruleId: string;
        /**
         * The Id of Server Group.
         */
        serverGroupId: string;
        /**
         * Forwarding rule QPS rate limiting switch:
         * on: enable.
         * off: disable (default).
         */
        trafficLimitEnabled: string;
        /**
         * When Rules.N.TrafficLimitEnabled is turned on, this field is required. Requests per second. Valid values are between 100 and 100000.
         */
        trafficLimitQps: number;
        /**
         * The Url of Rule.
         */
        url: string;
    }

    export interface GetRulesRuleRedirectConfig {
        /**
         * The redirect domain.
         */
        redirectDomain: string;
        /**
         * The redirect HTTP code,support 301(default), 302, 307, 308.
         */
        redirectHttpCode: string;
        /**
         * The redirect port.
         */
        redirectPort: string;
        /**
         * The redirect protocol,support HTTP,HTTPS(default).
         */
        redirectProtocol: string;
        /**
         * The redirect URI.
         */
        redirectUri: string;
    }

    export interface GetRulesRuleRewriteConfig {
        /**
         * Rewrite path.
         */
        rewritePath: string;
    }

    export interface GetServerGroupServersServer {
        /**
         * The description of the instance.
         */
        description: string;
        /**
         * The server id of instance in ServerGroup.
         */
        id: string;
        /**
         * The ID of ecs instance or the network card bound to ecs instance.
         */
        instanceId: string;
        /**
         * The private ip of the instance.
         */
        ip: string;
        /**
         * The port receiving request.
         */
        port: number;
        /**
         * The server id of instance in ServerGroup.
         */
        serverId: string;
        /**
         * The type of instance. Optional choice contains `ecs`, `eni`.
         */
        type: string;
        /**
         * The weight of the instance.
         */
        weight: number;
    }

    export interface GetServerGroupsServerGroup {
        /**
         * The create time of the Alb server group.
         */
        createTime: string;
        /**
         * The description of the server group server.
         */
        description: string;
        /**
         * The health check config of the Alb server group.
         */
        healthChecks: outputs.alb.GetServerGroupsServerGroupHealthCheck[];
        /**
         * The ID of the Alb server group.
         */
        id: string;
        /**
         * The listener information of the Alb server group.
         */
        listeners: string[];
        /**
         * The project name of Alb server group.
         */
        projectName: string;
        /**
         * The scheduler algorithm of the Alb server group.
         */
        scheduler: string;
        /**
         * The server count of the Alb server group.
         */
        serverCount: number;
        /**
         * The ID of the Alb server group.
         */
        serverGroupId: string;
        /**
         * The name of the Alb server group.
         */
        serverGroupName: string;
        /**
         * The type of Alb server group. Valid values: `instance`, `ip`.
         */
        serverGroupType: string;
        /**
         * The server information of the Alb server group.
         */
        servers: outputs.alb.GetServerGroupsServerGroupServer[];
        /**
         * The status of the Alb server group.
         */
        status: string;
        /**
         * The sticky session config of the Alb server group.
         */
        stickySessionConfigs: outputs.alb.GetServerGroupsServerGroupStickySessionConfig[];
        /**
         * The update time of the Alb server group.
         */
        updateTime: string;
        /**
         * The vpc id of the Alb server group.
         */
        vpcId: string;
    }

    export interface GetServerGroupsServerGroupHealthCheck {
        /**
         * The domain of health check.
         */
        domain: string;
        /**
         * The enable status of health check function.
         */
        enabled: string;
        /**
         * The healthy threshold of health check.
         */
        healthyThreshold: number;
        /**
         * The normal http status code of health check.
         */
        httpCode?: string;
        /**
         * The http version of health check.
         */
        httpVersion?: string;
        /**
         * The interval executing health check.
         */
        interval: number;
        /**
         * The method of health check.
         */
        method: string;
        /**
         * The protocol of health check.
         */
        protocol?: string;
        /**
         * The response timeout of health check.
         */
        timeout?: number;
        /**
         * The unhealthy threshold of health check.
         */
        unhealthyThreshold: number;
        /**
         * The uri of health check.
         */
        uri: string;
    }

    export interface GetServerGroupsServerGroupServer {
        /**
         * The description of the server group server.
         */
        description: string;
        /**
         * The id of the ecs instance or the network interface.
         */
        instanceId: string;
        /**
         * The private ip of the server group server.
         */
        ip: string;
        /**
         * The port receiving request of the server group server.
         */
        port: number;
        /**
         * Whether to enable the remote IP function.
         */
        remoteEnabled: string;
        /**
         * The id of the server group server.
         */
        serverId: string;
        /**
         * The type of the server group server.
         */
        type: string;
        /**
         * The weight of the server group server.
         */
        weight: number;
    }

    export interface GetServerGroupsServerGroupStickySessionConfig {
        /**
         * The cookie name of the sticky session.
         */
        cookie: string;
        /**
         * The cookie timeout of the sticky session.
         */
        cookieTimeout: number;
        /**
         * The enable status of sticky session.
         */
        stickySessionEnabled: string;
        /**
         * The cookie handle type of the sticky session.
         */
        stickySessionType: string;
    }

    export interface GetZonesZone {
        /**
         * The id of the zone.
         */
        id: string;
        /**
         * The id of the zone.
         */
        zoneId: string;
    }

    export interface HealthCheckTemplatesHealthCheckTemplate {
        /**
         * The description of health check template.
         */
        description: string;
        /**
         * The domain name to health check.
         */
        healthCheckDomain: string;
        /**
         * The normal HTTP status code for health check, the default is http_2xx, http_3xx, separated by commas.
         */
        healthCheckHttpCode: string;
        /**
         * The HTTP version of health check.
         */
        healthCheckHttpVersion: string;
        /**
         * The interval for performing health checks, the default value is 2, and the value is 1-300.
         */
        healthCheckInterval: number;
        /**
         * The health check method,default is `GET`,support `GET` and ``HEAD.
         */
        healthCheckMethod: string;
        /**
         * The protocol of health check,only support HTTP.
         */
        healthCheckProtocol: string;
        /**
         * The ID of health check template.
         */
        healthCheckTemplateId: string;
        /**
         * The name of health check template to query.
         */
        healthCheckTemplateName: string;
        /**
         * The timeout of health check response,the default value is 2, and the value is 1-60.
         */
        healthCheckTimeout: number;
        /**
         * The uri to health check,default is `/`.
         */
        healthCheckUri: string;
        /**
         * The healthy threshold of the health check, the default is 3, the value is 2-10.
         */
        healthyThreshold: number;
        /**
         * The id of the health check template.
         */
        id: string;
        /**
         * The unhealthy threshold of the health check, the default is 3, the value is 2-10.
         */
        unhealthyThreshold: number;
    }

    export interface ListenerDomainExtensionsDomainExtension {
        /**
         * The server certificate ID that domain used.
         */
        certificateId: string;
        /**
         * The domain.
         */
        domain: string;
        /**
         * The extension domain ID.
         */
        domainExtensionId: string;
        /**
         * The ID of the Listener.
         */
        id: string;
        /**
         * A Listener ID.
         */
        listenerId: string;
    }

    export interface ListenersListener {
        /**
         * The ID of the access control policy group bound to the listener, only returned when the AclStatus parameter is on.
         */
        aclIds: string[];
        /**
         * Whether to enable the access control function,valid value is on or off.
         */
        aclStatus: string;
        /**
         * The access control type.
         */
        aclType: string;
        /**
         * CA certificate ID associated with HTTPS listener.
         */
        caCertificateId: string;
        /**
         * The certificate id associated with the listener. Source is `certCenter`.
         */
        certCenterCertificateId: string;
        /**
         * The server certificate ID that domain used.
         */
        certificateId: string;
        /**
         * The source of the certificate.
         */
        certificateSource: string;
        /**
         * The create time of the Listener.
         */
        createTime: string;
        /**
         * The customized configuration ID, the value is empty string when not bound.
         */
        customizedCfgId: string;
        /**
         * The description of listener.
         */
        description: string;
        /**
         * The HTTPS listener association list of extension domains for.
         */
        domainExtensions: outputs.alb.ListenersListenerDomainExtension[];
        /**
         * The HTTP2 feature switch,valid value is on or off.
         */
        enableHttp2: string;
        /**
         * The QUIC feature switch,valid value is on or off.
         */
        enableQuic: string;
        /**
         * The enable status of the Listener.
         */
        enabled: string;
        /**
         * The ID of the Listener.
         */
        id: string;
        /**
         * The ID of the Listener.
         */
        listenerId: string;
        /**
         * The name of the Listener.
         */
        listenerName: string;
        /**
         * The id of the Alb.
         */
        loadBalancerId: string;
        /**
         * The port receiving request of the Listener.
         */
        port: number;
        /**
         * The project name of the listener.
         */
        projectName: string;
        /**
         * The protocol of the Listener.
         */
        protocol: string;
        /**
         * The ID of server group.
         */
        serverGroupId: string;
        /**
         * The list of server groups with associated listeners.
         */
        serverGroups: outputs.alb.ListenersListenerServerGroup[];
        /**
         * The status of the Listener.
         */
        status: string;
        /**
         * The update time of the Listener.
         */
        updateTime: string;
    }

    export interface ListenersListenerDomainExtension {
        /**
         * The server certificate ID that domain used.
         */
        certificateId: string;
        /**
         * The domain.
         */
        domain: string;
        /**
         * The extension domain ID.
         */
        domainExtensionId: string;
        /**
         * The ID of the Listener.
         */
        listenerId: string;
    }

    export interface ListenersListenerServerGroup {
        /**
         * The ID of server group.
         */
        serverGroupId: string;
        /**
         * The name of server group.
         */
        serverGroupName: string;
    }

    export interface RuleRedirectConfig {
        /**
         * The redirect domain, only support exact domain name.
         */
        redirectDomain: string;
        /**
         * The redirect http code, support 301(default), 302, 307, 308.
         */
        redirectHttpCode?: string;
        /**
         * The redirect port.
         */
        redirectPort: string;
        /**
         * The redirect protocol, support HTTP, HTTPS(default).
         */
        redirectProtocol?: string;
        /**
         * The redirect URI.
         */
        redirectUri: string;
    }

    export interface RuleRewriteConfig {
        /**
         * Rewrite path.
         */
        rewritePath: string;
    }

    export interface RulesRule {
        /**
         * The Description of Rule.
         */
        description: string;
        /**
         * The Domain of Rule.
         */
        domain: string;
        /**
         * The Id of Rule.
         */
        id: string;
        /**
         * Redirect related configuration.
         */
        redirectConfigs: outputs.alb.RulesRuleRedirectConfig[];
        /**
         * The list of rewrite configurations.
         */
        rewriteConfigs: outputs.alb.RulesRuleRewriteConfig[];
        /**
         * Rewrite configuration switch for forwarding rules, only allows configuration and takes effect when RuleAction is empty (i.e., forwarding to server group). Only available for whitelist users, please submit an application to experience. Supported values are as follows:
         * on: enable.
         * off: disable.
         */
        rewriteEnabled: string;
        /**
         * The forwarding rule action, if this parameter is empty, forward to server group, if value is `Redirect`, will redirect.
         */
        ruleAction: string;
        /**
         * The Id of Rule.
         */
        ruleId: string;
        /**
         * The Id of Server Group.
         */
        serverGroupId: string;
        /**
         * Forwarding rule QPS rate limiting switch:
         * on: enable.
         * off: disable (default).
         */
        trafficLimitEnabled: string;
        /**
         * When Rules.N.TrafficLimitEnabled is turned on, this field is required. Requests per second. Valid values are between 100 and 100000.
         */
        trafficLimitQps: number;
        /**
         * The Url of Rule.
         */
        url: string;
    }

    export interface RulesRuleRedirectConfig {
        /**
         * The redirect domain.
         */
        redirectDomain: string;
        /**
         * The redirect HTTP code,support 301(default), 302, 307, 308.
         */
        redirectHttpCode: string;
        /**
         * The redirect port.
         */
        redirectPort: string;
        /**
         * The redirect protocol,support HTTP,HTTPS(default).
         */
        redirectProtocol: string;
        /**
         * The redirect URI.
         */
        redirectUri: string;
    }

    export interface RulesRuleRewriteConfig {
        /**
         * Rewrite path.
         */
        rewritePath: string;
    }

    export interface ServerGroupHealthCheck {
        /**
         * The domain of health check.
         */
        domain: string;
        /**
         * The enable status of health check function. Valid values: `on`, `off`. Default is `on`.
         */
        enabled?: string;
        /**
         * The healthy threshold of health check. Valid value range in 2~10. Default is 3.
         */
        healthyThreshold?: number;
        /**
         * The normal http status code of health check, the value can be `http2xx` or `http3xx` or `http4xx` or `http5xx`.
         */
        httpCode: string;
        /**
         * The http version of health check. Valid values: `HTTP1.0`, `HTTP1.1`. Default is `HTTP1.0`.
         */
        httpVersion?: string;
        /**
         * The interval executing health check. Unit: second. Valid value range in 1~300. Default is 2.
         */
        interval?: number;
        /**
         * The method of health check. Valid values: `GET` or `HEAD`. Default is `HEAD`.
         */
        method?: string;
        /**
         * The response timeout of health check. Unit: second. Valid value range in 1~60. Default is 2.
         */
        timeout?: number;
        /**
         * The unhealthy threshold of health check. Valid value range in 2~10. Default is 3.
         */
        unhealthyThreshold?: number;
        /**
         * The uri of health check.
         */
        uri: string;
    }

    export interface ServerGroupServersServer {
        /**
         * The description of the instance.
         */
        description: string;
        /**
         * The server id of instance in ServerGroup.
         */
        id: string;
        /**
         * The ID of ecs instance or the network card bound to ecs instance.
         */
        instanceId: string;
        /**
         * The private ip of the instance.
         */
        ip: string;
        /**
         * The port receiving request.
         */
        port: number;
        /**
         * The server id of instance in ServerGroup.
         */
        serverId: string;
        /**
         * The type of instance. Optional choice contains `ecs`, `eni`.
         */
        type: string;
        /**
         * The weight of the instance.
         */
        weight: number;
    }

    export interface ServerGroupStickySessionConfig {
        /**
         * The cookie name of the sticky session. This field is required when the value of the `stickySessionType` is `server`.
         */
        cookie: string;
        /**
         * The cookie timeout of the sticky session. Unit: second. Valid value range in 1~86400. Default is 1000. This field is required when the value of the `stickySessionType` is `insert`.
         */
        cookieTimeout?: number;
        /**
         * The enable status of sticky session. Valid values: `on`, `off`. Default is `off`.
         */
        stickySessionEnabled?: string;
        /**
         * The cookie handle type of the sticky session. Valid values: `insert`, `server`. Default is `insert`. This field is required when the value of the `stickySessionEnabled` is `on`.
         */
        stickySessionType?: string;
    }

    export interface ServerGroupsServerGroup {
        /**
         * The create time of the Alb server group.
         */
        createTime: string;
        /**
         * The description of the server group server.
         */
        description: string;
        /**
         * The health check config of the Alb server group.
         */
        healthChecks: outputs.alb.ServerGroupsServerGroupHealthCheck[];
        /**
         * The ID of the Alb server group.
         */
        id: string;
        /**
         * The listener information of the Alb server group.
         */
        listeners: string[];
        /**
         * The project name of Alb server group.
         */
        projectName: string;
        /**
         * The scheduler algorithm of the Alb server group.
         */
        scheduler: string;
        /**
         * The server count of the Alb server group.
         */
        serverCount: number;
        /**
         * The ID of the Alb server group.
         */
        serverGroupId: string;
        /**
         * The name of the Alb server group.
         */
        serverGroupName: string;
        /**
         * The type of Alb server group. Valid values: `instance`, `ip`.
         */
        serverGroupType: string;
        /**
         * The server information of the Alb server group.
         */
        servers: outputs.alb.ServerGroupsServerGroupServer[];
        /**
         * The status of the Alb server group.
         */
        status: string;
        /**
         * The sticky session config of the Alb server group.
         */
        stickySessionConfigs: outputs.alb.ServerGroupsServerGroupStickySessionConfig[];
        /**
         * The update time of the Alb server group.
         */
        updateTime: string;
        /**
         * The vpc id of the Alb server group.
         */
        vpcId: string;
    }

    export interface ServerGroupsServerGroupHealthCheck {
        /**
         * The domain of health check.
         */
        domain: string;
        /**
         * The enable status of health check function.
         */
        enabled: string;
        /**
         * The healthy threshold of health check.
         */
        healthyThreshold: number;
        /**
         * The normal http status code of health check.
         */
        httpCode?: string;
        /**
         * The http version of health check.
         */
        httpVersion?: string;
        /**
         * The interval executing health check.
         */
        interval: number;
        /**
         * The method of health check.
         */
        method: string;
        /**
         * The protocol of health check.
         */
        protocol?: string;
        /**
         * The response timeout of health check.
         */
        timeout?: number;
        /**
         * The unhealthy threshold of health check.
         */
        unhealthyThreshold: number;
        /**
         * The uri of health check.
         */
        uri: string;
    }

    export interface ServerGroupsServerGroupServer {
        /**
         * The description of the server group server.
         */
        description: string;
        /**
         * The id of the ecs instance or the network interface.
         */
        instanceId: string;
        /**
         * The private ip of the server group server.
         */
        ip: string;
        /**
         * The port receiving request of the server group server.
         */
        port: number;
        /**
         * Whether to enable the remote IP function.
         */
        remoteEnabled: string;
        /**
         * The id of the server group server.
         */
        serverId: string;
        /**
         * The type of the server group server.
         */
        type: string;
        /**
         * The weight of the server group server.
         */
        weight: number;
    }

    export interface ServerGroupsServerGroupStickySessionConfig {
        /**
         * The cookie name of the sticky session.
         */
        cookie: string;
        /**
         * The cookie timeout of the sticky session.
         */
        cookieTimeout: number;
        /**
         * The enable status of sticky session.
         */
        stickySessionEnabled: string;
        /**
         * The cookie handle type of the sticky session.
         */
        stickySessionType: string;
    }

    export interface ZonesZone {
        /**
         * The id of the zone.
         */
        id: string;
        /**
         * The id of the zone.
         */
        zoneId: string;
    }

}

export namespace apig {
    export interface ApigGatewayBackendSpec {
        /**
         * Whether the api gateway support vke flannel cni.
         */
        isVkeWithFlannelCniSupported: boolean;
        /**
         * The vke pod cidr of the api gateway.
         */
        vkePodCidr: string;
    }

    export interface ApigGatewayLogSpec {
        /**
         * Whether the api gateway enable tls log.
         */
        enable: boolean;
        /**
         * The project id of the tls. This field is required when `enable` is true.
         */
        projectId?: string;
        /**
         * The topic id of the tls.
         */
        topicId: string;
    }

    export interface ApigGatewayMonitorSpec {
        /**
         * Whether the api gateway enable monitor.
         */
        enable: boolean;
        /**
         * The workspace id of the monitor. This field is required when `enable` is true.
         */
        workspaceId?: string;
    }

    export interface ApigGatewayNetworkSpec {
        /**
         * The subnet ids of the network spec.
         */
        subnetIds: string[];
        /**
         * The vpc id of the network spec.
         */
        vpcId: string;
    }

    export interface ApigGatewayResourceSpec {
        /**
         * The clb spec code of the resource spec. Valid values: `small1`, `small2`, `medium1`, `medium2`, `large1`, `large2`.
         */
        clbSpecCode: string;
        /**
         * The instance spec code of the resource spec. Valid values: `1c2g`, `2c4g`, `4c8g`, `8c16g`.
         */
        instanceSpecCode: string;
        /**
         * The network type of the resource spec. The default values for both `enablePublicNetwork` and `enablePrivateNetwork` are true.
         */
        networkType: outputs.apig.ApigGatewayResourceSpecNetworkType;
        /**
         * The public network bandwidth of the resource spec.
         */
        publicNetworkBandwidth: number;
        /**
         * The public network billing type of the resource spec. Valid values: `traffic`, `bandwidth`.
         */
        publicNetworkBillingType: string;
        /**
         * The replicas of the resource spec.
         */
        replicas: number;
    }

    export interface ApigGatewayResourceSpecNetworkType {
        /**
         * Whether the api gateway enable private network.
         */
        enablePrivateNetwork: boolean;
        /**
         * Whether the api gateway enable public network.
         */
        enablePublicNetwork: boolean;
    }

    export interface ApigGatewayServiceAuthSpec {
        /**
         * Whether the api gateway service enable auth.
         */
        enable: boolean;
    }

    export interface ApigGatewayTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface ApigRouteAdvancedSetting {
        /**
         * The cors policy setting of the api gateway route.
         */
        corsPolicySetting?: outputs.apig.ApigRouteAdvancedSettingCorsPolicySetting;
        /**
         * The header operations of the api gateway route.
         */
        headerOperations?: outputs.apig.ApigRouteAdvancedSettingHeaderOperation[];
        /**
         * The mirror policies of the api gateway route.
         */
        mirrorPolicies?: outputs.apig.ApigRouteAdvancedSettingMirrorPolicy[];
        /**
         * The retry policy setting of the api gateway route.
         */
        retryPolicySetting?: outputs.apig.ApigRouteAdvancedSettingRetryPolicySetting;
        /**
         * The timeout setting of the api gateway route.
         */
        timeoutSetting?: outputs.apig.ApigRouteAdvancedSettingTimeoutSetting;
        /**
         * The url rewrite setting of the api gateway route.
         */
        urlRewriteSetting?: outputs.apig.ApigRouteAdvancedSettingUrlRewriteSetting;
    }

    export interface ApigRouteAdvancedSettingCorsPolicySetting {
        /**
         * Whether the cors policy setting is enabled.
         */
        enable?: boolean;
    }

    export interface ApigRouteAdvancedSettingHeaderOperation {
        /**
         * The direction type of the header. Valid values: `request`, `response`.
         */
        directionType?: string;
        /**
         * The key of the header.
         */
        key: string;
        /**
         * The operation of the header. Valid values: `set`, `add`, `remove`.
         */
        operation: string;
        /**
         * The value of the header.
         */
        value?: string;
    }

    export interface ApigRouteAdvancedSettingMirrorPolicy {
        /**
         * The percent of the mirror policy.
         */
        percent?: outputs.apig.ApigRouteAdvancedSettingMirrorPolicyPercent;
        /**
         * The upstream of the mirror policy.
         */
        upstream: outputs.apig.ApigRouteAdvancedSettingMirrorPolicyUpstream;
    }

    export interface ApigRouteAdvancedSettingMirrorPolicyPercent {
        /**
         * The percent value of the mirror policy.
         */
        value: number;
    }

    export interface ApigRouteAdvancedSettingMirrorPolicyUpstream {
        /**
         * The type of the api gateway upstream.
         */
        type: string;
        /**
         * The id of the api gateway upstream.
         */
        upstreamId: string;
        /**
         * The version of the api gateway upstream.
         */
        version?: string;
    }

    export interface ApigRouteAdvancedSettingRetryPolicySetting {
        /**
         * The attempts of the api gateway route.
         */
        attempts?: number;
        /**
         * Whether the retry policy setting is enabled.
         */
        enable?: boolean;
        /**
         * The http codes of the api gateway route.
         */
        httpCodes?: string[];
        /**
         * The per try timeout of the api gateway route.
         */
        perTryTimeout?: number;
        /**
         * The retry on of the api gateway route. Valid values: `5xx`, `reset`, `connect-failure`, `refused-stream`, `cancelled`, `deadline-exceeded`, `internal`, `resource-exhausted`, `unavailable`.
         */
        retryOns?: string[];
    }

    export interface ApigRouteAdvancedSettingTimeoutSetting {
        /**
         * Whether the timeout setting is enabled.
         */
        enable?: boolean;
        /**
         * The timeout of the api gateway route. Unit: s.
         */
        timeout?: number;
    }

    export interface ApigRouteAdvancedSettingUrlRewriteSetting {
        /**
         * Whether the url rewrite setting is enabled.
         */
        enable?: boolean;
        /**
         * The url rewrite path of the api gateway route.
         */
        urlRewrite?: string;
    }

    export interface ApigRouteCustomDomain {
        /**
         * The domain of the api gateway route.
         */
        domain: string;
        /**
         * The id of the custom domain.
         */
        id: string;
    }

    export interface ApigRouteDomain {
        /**
         * The domain of the api gateway route.
         */
        domain: string;
        /**
         * The type of the domain.
         */
        type: string;
    }

    export interface ApigRouteMatchRule {
        /**
         * The header of the api gateway route.
         */
        headers?: outputs.apig.ApigRouteMatchRuleHeader[];
        /**
         * The method of the api gateway route. Valid values: `GET`, `POST`, `PUT`, `DELETE`, `HEAD`, `OPTIONS`, `CONNECT`.
         */
        methods?: string[];
        /**
         * The path of the api gateway route.
         */
        path: outputs.apig.ApigRouteMatchRulePath;
        /**
         * The query string of the api gateway route.
         */
        queryStrings?: outputs.apig.ApigRouteMatchRuleQueryString[];
    }

    export interface ApigRouteMatchRuleHeader {
        /**
         * The key of the header.
         */
        key: string;
        /**
         * The path of the api gateway route.
         */
        value: outputs.apig.ApigRouteMatchRuleHeaderValue;
    }

    export interface ApigRouteMatchRuleHeaderValue {
        /**
         * The match content of the api gateway route.
         */
        matchContent: string;
        /**
         * The match type of the api gateway route. Valid values: `Prefix`, `Exact`, `Regex`.
         */
        matchType: string;
    }

    export interface ApigRouteMatchRulePath {
        /**
         * The match content of the api gateway route.
         */
        matchContent: string;
        /**
         * The match type of the api gateway route. Valid values: `Prefix`, `Exact`, `Regex`.
         */
        matchType: string;
    }

    export interface ApigRouteMatchRuleQueryString {
        /**
         * The key of the query string.
         */
        key: string;
        /**
         * The path of the api gateway route.
         */
        value: outputs.apig.ApigRouteMatchRuleQueryStringValue;
    }

    export interface ApigRouteMatchRuleQueryStringValue {
        /**
         * The match content of the api gateway route.
         */
        matchContent: string;
        /**
         * The match type of the api gateway route. Valid values: `Prefix`, `Exact`, `Regex`.
         */
        matchType: string;
    }

    export interface ApigRouteUpstreamList {
        /**
         * The ai provider settings of the api gateway route.
         */
        aiProviderSettings?: outputs.apig.ApigRouteUpstreamListAiProviderSettings;
        /**
         * The id of the api gateway upstream.
         */
        upstreamId: string;
        /**
         * The version of the api gateway upstream.
         */
        version?: string;
        /**
         * The weight of the api gateway upstream. Valid values: 0~10000.
         */
        weight: number;
    }

    export interface ApigRouteUpstreamListAiProviderSettings {
        /**
         * The model of the ai provider.
         */
        model: string;
        /**
         * The target path of the ai provider.
         */
        targetPath: string;
    }

    export interface ApigUpstreamCircuitBreakingSettings {
        /**
         * The base ejection time of circuit breaking. Unit: ms. Default is 10s.
         */
        baseEjectionTime: number;
        /**
         * The consecutive errors of circuit breaking. Default is 5.
         */
        consecutiveErrors: number;
        /**
         * Whether the circuit breaking is enabled.
         */
        enable: boolean;
        /**
         * The interval of circuit breaking. Unit: ms. Default is 10s.
         */
        interval: number;
        /**
         * The max ejection percent of circuit breaking. Default is 20%.
         */
        maxEjectionPercent: number;
        /**
         * The min health percent of circuit breaking. Default is 60%.
         */
        minHealthPercent: number;
    }

    export interface ApigUpstreamLoadBalancerSettings {
        /**
         * The consistent hash lb of apig upstream.
         */
        consistentHashLb?: outputs.apig.ApigUpstreamLoadBalancerSettingsConsistentHashLb;
        /**
         * The load balancer policy of apig upstream. Valid values: `SimpleLB`, `ConsistentHashLB`.
         */
        lbPolicy: string;
        /**
         * The simple load balancer of apig upstream. Valid values: `ROUND_ROBIN`, `LEAST_CONN`, `RANDOM`.
         */
        simpleLb?: string;
        /**
         * The warmup duration of apig upstream lb. This field is valid when the simpleLb is `ROUND_ROBIN` or `LEAST_CONN`.
         */
        warmupDuration?: number;
    }

    export interface ApigUpstreamLoadBalancerSettingsConsistentHashLb {
        /**
         * The hash key of apig upstream consistent hash lb. Valid values: `HTTPCookie`, `HttpHeaderName`, `HttpQueryParameterName`, `UseSourceIp`.
         */
        hashKey: string;
        /**
         * The http cookie of apig upstream consistent hash lb.
         */
        httpCookie?: outputs.apig.ApigUpstreamLoadBalancerSettingsConsistentHashLbHttpCookie;
        /**
         * The http header name of apig upstream consistent hash lb.
         */
        httpHeaderName?: string;
        /**
         * The http query parameter name of apig upstream consistent hash lb.
         */
        httpQueryParameterName?: string;
        /**
         * The use source ip of apig upstream consistent hash lb.
         */
        useSourceIp?: boolean;
    }

    export interface ApigUpstreamLoadBalancerSettingsConsistentHashLbHttpCookie {
        /**
         * The name of apig upstream consistent hash lb http cookie.
         */
        name: string;
        /**
         * The path of apig upstream consistent hash lb http cookie.
         */
        path: string;
        /**
         * The ttl of apig upstream consistent hash lb http cookie.
         */
        ttl: number;
    }

    export interface ApigUpstreamSourceIngressSetting {
        /**
         * Whether to enable all ingress classes.
         */
        enableAllIngressClasses: boolean;
        /**
         * Whether to enable all namespaces.
         */
        enableAllNamespaces: boolean;
        /**
         * Whether to enable ingress.
         */
        enableIngress: boolean;
        /**
         * Whether to enable ingress without ingress class.
         */
        enableIngressWithoutIngressClass: boolean;
        /**
         * The ingress classes of ingress settings.
         */
        ingressClasses: string[];
        /**
         * The update status of ingress settings.
         */
        updateStatus: boolean;
        /**
         * The watch namespaces of ingress settings.
         */
        watchNamespaces: string[];
    }

    export interface ApigUpstreamSourceSourceSpec {
        /**
         * The k8s source of apig upstream source.
         */
        k8sSource?: outputs.apig.ApigUpstreamSourceSourceSpecK8sSource;
        /**
         * The nacos source of apig upstream source.
         */
        nacosSource?: outputs.apig.ApigUpstreamSourceSourceSpecNacosSource;
    }

    export interface ApigUpstreamSourceSourceSpecK8sSource {
        /**
         * The cluster id of k8s source.
         */
        clusterId: string;
        /**
         * The cluster type of k8s source.
         */
        clusterType: string;
    }

    export interface ApigUpstreamSourceSourceSpecNacosSource {
        /**
         * The address of nacos source.
         */
        address: string;
        /**
         * The auth config of nacos source.
         */
        authConfig?: outputs.apig.ApigUpstreamSourceSourceSpecNacosSourceAuthConfig;
        /**
         * The context path of nacos source.
         */
        contextPath: string;
        /**
         * The grpc port of nacos source.
         */
        grpcPort: number;
        /**
         * The http port of nacos source.
         */
        httpPort: number;
        /**
         * The nacos id of nacos source.
         */
        nacosId: string;
        /**
         * The nacos name of nacos source.
         */
        nacosName: string;
    }

    export interface ApigUpstreamSourceSourceSpecNacosSourceAuthConfig {
        /**
         * The basic auth config of nacos source.
         */
        basic?: outputs.apig.ApigUpstreamSourceSourceSpecNacosSourceAuthConfigBasic;
    }

    export interface ApigUpstreamSourceSourceSpecNacosSourceAuthConfigBasic {
        /**
         * The password of basic auth config of nacos source.
         */
        password: string;
        /**
         * The username of basic auth config of nacos source.
         */
        username: string;
    }

    export interface ApigUpstreamTlsSettings {
        /**
         * The sni of apig upstream tls setting.
         */
        sni: string;
        /**
         * The tls mode of apig upstream tls setting. Valid values: `DISABLE`, `SIMPLE`.
         */
        tlsMode: string;
    }

    export interface ApigUpstreamUpstreamSpec {
        /**
         * The ai provider of apig upstream.
         */
        aiProvider?: outputs.apig.ApigUpstreamUpstreamSpecAiProvider;
        /**
         * The domain of apig upstream.
         */
        domain?: outputs.apig.ApigUpstreamUpstreamSpecDomain;
        /**
         * The ecs list of apig upstream.
         */
        ecsLists?: outputs.apig.ApigUpstreamUpstreamSpecEcsList[];
        /**
         * The fixed ip list of apig upstream.
         */
        fixedIpLists?: outputs.apig.ApigUpstreamUpstreamSpecFixedIpList[];
        /**
         * The k8s service of apig upstream.
         */
        k8sService?: outputs.apig.ApigUpstreamUpstreamSpecK8sService;
        /**
         * The nacos service of apig upstream.
         */
        nacosService?: outputs.apig.ApigUpstreamUpstreamSpecNacosService;
        /**
         * The vefaas of apig upstream.
         */
        veFaas?: outputs.apig.ApigUpstreamUpstreamSpecVeFaas;
        /**
         * The mlp of apig upstream.
         */
        veMlp?: outputs.apig.ApigUpstreamUpstreamSpecVeMlp;
    }

    export interface ApigUpstreamUpstreamSpecAiProvider {
        /**
         * The base url of ai provider.
         */
        baseUrl: string;
        /**
         * The custom body params of ai provider.
         */
        customBodyParams?: {[key: string]: string};
        /**
         * The custom header params of ai provider.
         */
        customHeaderParams?: {[key: string]: string};
        /**
         * The custom model service of ai provider.
         */
        customModelService?: outputs.apig.ApigUpstreamUpstreamSpecAiProviderCustomModelService;
        /**
         * The name of ai provider.
         */
        name: string;
        /**
         * The token of ai provider.
         */
        token: string;
    }

    export interface ApigUpstreamUpstreamSpecAiProviderCustomModelService {
        /**
         * The name of custom model service.
         */
        name: string;
        /**
         * The namespace of custom model service.
         */
        namespace: string;
        /**
         * The port of custom model service.
         */
        port: number;
    }

    export interface ApigUpstreamUpstreamSpecDomain {
        /**
         * The domain list of apig upstream.
         */
        domainList: outputs.apig.ApigUpstreamUpstreamSpecDomainDomainList;
        /**
         * The protocol of apig upstream. Valid values: `HTTP`, `HTTPS`.
         */
        protocol: string;
    }

    export interface ApigUpstreamUpstreamSpecDomainDomainList {
        /**
         * The domain of apig upstream.
         */
        domain: string;
        /**
         * The port of domain. Default is 80 for HTTP, 443 for HTTPS.
         */
        port: number;
    }

    export interface ApigUpstreamUpstreamSpecEcsList {
        /**
         * The instance id of ecs.
         */
        ecsId: string;
        /**
         * The ip of ecs.
         */
        ip: string;
        /**
         * The port of ecs.
         */
        port: number;
    }

    export interface ApigUpstreamUpstreamSpecFixedIpList {
        /**
         * The ip of apig upstream.
         */
        ip: string;
        /**
         * The port of apig upstream.
         */
        port: number;
    }

    export interface ApigUpstreamUpstreamSpecK8sService {
        /**
         * The name of k8s service.
         */
        name: string;
        /**
         * The namespace of k8s service.
         */
        namespace: string;
        /**
         * The port of k8s service.
         */
        port: number;
    }

    export interface ApigUpstreamUpstreamSpecNacosService {
        /**
         * The group of nacos service.
         */
        group: string;
        /**
         * The namespace of nacos service.
         */
        namespace: string;
        /**
         * The namespace id of nacos service.
         */
        namespaceId: string;
        /**
         * The service of nacos service.
         */
        service: string;
        /**
         * The upstream source id.
         */
        upstreamSourceId: string;
    }

    export interface ApigUpstreamUpstreamSpecVeFaas {
        /**
         * The function id of vefaas.
         */
        functionId: string;
    }

    export interface ApigUpstreamUpstreamSpecVeMlp {
        /**
         * The k8s service of mlp.
         */
        k8sService: outputs.apig.ApigUpstreamUpstreamSpecVeMlpK8sService;
        /**
         * The service discover type of mlp.
         */
        serviceDiscoverType: string;
        /**
         * The service id of mlp.
         */
        serviceId: string;
        /**
         * The service name of mlp.
         */
        serviceName: string;
        /**
         * The service url of mlp.
         */
        serviceUrl: string;
        /**
         * The upstream source id.
         */
        upstreamSourceId: string;
    }

    export interface ApigUpstreamUpstreamSpecVeMlpK8sService {
        /**
         * The cluster info of k8s service.
         */
        clusterInfo: outputs.apig.ApigUpstreamUpstreamSpecVeMlpK8sServiceClusterInfo;
        /**
         * The name of k8s service.
         */
        name: string;
        /**
         * The namespace of k8s service.
         */
        namespace: string;
        /**
         * The port of k8s service.
         */
        port: number;
    }

    export interface ApigUpstreamUpstreamSpecVeMlpK8sServiceClusterInfo {
        /**
         * The account id of k8s service.
         */
        accountId: number;
        /**
         * The cluster name of k8s service.
         */
        clusterName: string;
    }

    export interface ApigUpstreamVersionDetail {
        /**
         * The labels of apig upstream version.
         */
        labels: outputs.apig.ApigUpstreamVersionDetailLabel[];
        /**
         * The name of the apig upstream.
         */
        name: string;
        /**
         * The update time of apig upstream version.
         */
        updateTime: string;
    }

    export interface ApigUpstreamVersionDetailLabel {
        /**
         * The key of apig upstream version label.
         */
        key: string;
        /**
         * The value of apig upstream version label.
         */
        value: string;
    }

    export interface ApigUpstreamVersionUpstreamVersion {
        /**
         * The labels of apig upstream version.
         */
        labels?: outputs.apig.ApigUpstreamVersionUpstreamVersionLabel[];
        /**
         * The name of apig upstream version.
         */
        name: string;
        /**
         * The update time of apig upstream version.
         */
        updateTime: string;
    }

    export interface ApigUpstreamVersionUpstreamVersionLabel {
        /**
         * The key of apig upstream version label.
         */
        key: string;
        /**
         * The value of apig upstream version label.
         */
        value: string;
    }

    export interface CustomDomainsCustomDomain {
        /**
         * The id of the certificate.
         */
        certificateId: string;
        /**
         * The comments of the custom domain.
         */
        comments: string;
        /**
         * The create time of the custom domain.
         */
        createTime: string;
        /**
         * The custom domain of the api gateway service.
         */
        domain: string;
        /**
         * The id of the custom domain.
         */
        id: string;
        /**
         * The protocol of the custom domain.
         */
        protocols: string[];
        /**
         * The resource type of domain. Valid values: `Console`, `Ingress`.
         */
        resourceType: string;
        /**
         * The id of api gateway service.
         */
        serviceId: string;
        /**
         * Whether to redirect https.
         */
        sslRedirect: boolean;
        /**
         * The status of the custom domain.
         */
        status: string;
        /**
         * The type of the domain.
         */
        type: string;
        /**
         * The update time of the custom domain.
         */
        updateTime: string;
    }

    export interface GatewayServicesGatewayService {
        /**
         * The auth spec of the api gateway service.
         */
        authSpecs: outputs.apig.GatewayServicesGatewayServiceAuthSpec[];
        /**
         * The comments of the api gateway service.
         */
        comments: string;
        /**
         * The create time of the api gateway service.
         */
        createTime: string;
        /**
         * The custom domains of the api gateway service.
         */
        customDomains: outputs.apig.GatewayServicesGatewayServiceCustomDomain[];
        /**
         * The domains of the api gateway service.
         */
        domains: outputs.apig.GatewayServicesGatewayServiceDomain[];
        /**
         * The gateway id of api gateway service.
         */
        gatewayId: string;
        /**
         * The gateway name of the api gateway service.
         */
        gatewayName: string;
        /**
         * The Id of the api gateway service.
         */
        id: string;
        /**
         * The error message of the api gateway service.
         */
        message: string;
        /**
         * The name of api gateway service. This field support fuzzy query.
         */
        name: string;
        /**
         * The protocol of the api gateway service.
         */
        protocols: string[];
        /**
         * The status of api gateway service.
         */
        status: string;
    }

    export interface GatewayServicesGatewayServiceAuthSpec {
        /**
         * Whether the api gateway service enable auth.
         */
        enable: boolean;
    }

    export interface GatewayServicesGatewayServiceCustomDomain {
        /**
         * The domain of the api gateway service.
         */
        domain: string;
        /**
         * The Id of the api gateway service.
         */
        id: string;
    }

    export interface GatewayServicesGatewayServiceDomain {
        /**
         * The domain of the api gateway service.
         */
        domain: string;
        /**
         * The type of the domain.
         */
        type: string;
    }

    export interface GatewaysGateway {
        /**
         * The backend spec of the api gateway.
         */
        backendSpecs: outputs.apig.GatewaysGatewayBackendSpec[];
        /**
         * The comments of the api gateway.
         */
        comments: string;
        /**
         * The create time of the api gateway.
         */
        createTime: string;
        /**
         * The Id of the api gateway.
         */
        id: string;
        /**
         * The log spec of the api gateway.
         */
        logSpecs: outputs.apig.GatewaysGatewayLogSpec[];
        /**
         * The error message of the api gateway.
         */
        message: string;
        /**
         * The monitor spec of the api gateway.
         */
        monitorSpecs: outputs.apig.GatewaysGatewayMonitorSpec[];
        /**
         * The name of api gateway. This field support fuzzy query.
         */
        name: string;
        /**
         * The network spec of the api gateway.
         */
        networkSpecs: outputs.apig.GatewaysGatewayNetworkSpec[];
        /**
         * The project name of api gateway.
         */
        projectName: string;
        /**
         * The region of the api gateway.
         */
        region: string;
        /**
         * The resource spec of the api gateway.
         */
        resourceSpecs: outputs.apig.GatewaysGatewayResourceSpec[];
        /**
         * The status of api gateway.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.apig.GatewaysGatewayTag[];
        /**
         * The type of api gateway.
         */
        type: string;
        /**
         * The version of the api gateway.
         */
        version: string;
    }

    export interface GatewaysGatewayBackendSpec {
        /**
         * Whether the api gateway support vke flannel cni.
         */
        isVkeWithFlannelCniSupported: boolean;
        /**
         * The vke pod cidr of the api gateway.
         */
        vkePodCidr: string;
    }

    export interface GatewaysGatewayLogSpec {
        /**
         * Whether the api gateway enable monitor.
         */
        enable: boolean;
        /**
         * The project id of the tls.
         */
        projectId: string;
        /**
         * The topic id of the tls.
         */
        topicId: string;
    }

    export interface GatewaysGatewayMonitorSpec {
        /**
         * Whether the api gateway enable monitor.
         */
        enable: boolean;
        /**
         * The workspace id of the monitor.
         */
        workspaceId: string;
    }

    export interface GatewaysGatewayNetworkSpec {
        /**
         * The subnet ids of the api gateway.
         */
        subnetIds: string[];
        /**
         * The vpc id of the api gateway.
         */
        vpcId: string;
    }

    export interface GatewaysGatewayResourceSpec {
        /**
         * The clb spec code of the resource spec.
         */
        clbSpecCode: string;
        /**
         * The instance spec code of the resource spec.
         */
        instanceSpecCode: string;
        /**
         * The network type of the api gateway.
         */
        networkTypes: outputs.apig.GatewaysGatewayResourceSpecNetworkType[];
        /**
         * The public network bandwidth of the resource spec.
         */
        publicNetworkBandwidth: number;
        /**
         * The public network billing type of the resource spec.
         */
        publicNetworkBillingType: string;
        /**
         * The replicas of the resource spec.
         */
        replicas: number;
    }

    export interface GatewaysGatewayResourceSpecNetworkType {
        /**
         * Whether the api gateway enable private network.
         */
        enablePrivateNetwork: boolean;
        /**
         * Whether the api gateway enable public network.
         */
        enablePublicNetwork: boolean;
    }

    export interface GatewaysGatewayTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GatewaysTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetCustomDomainsCustomDomain {
        /**
         * The id of the certificate.
         */
        certificateId: string;
        /**
         * The comments of the custom domain.
         */
        comments: string;
        /**
         * The create time of the custom domain.
         */
        createTime: string;
        /**
         * The custom domain of the api gateway service.
         */
        domain: string;
        /**
         * The id of the custom domain.
         */
        id: string;
        /**
         * The protocol of the custom domain.
         */
        protocols: string[];
        /**
         * The resource type of domain. Valid values: `Console`, `Ingress`.
         */
        resourceType: string;
        /**
         * The id of api gateway service.
         */
        serviceId: string;
        /**
         * Whether to redirect https.
         */
        sslRedirect: boolean;
        /**
         * The status of the custom domain.
         */
        status: string;
        /**
         * The type of the domain.
         */
        type: string;
        /**
         * The update time of the custom domain.
         */
        updateTime: string;
    }

    export interface GetGatewayServicesGatewayService {
        /**
         * The auth spec of the api gateway service.
         */
        authSpecs: outputs.apig.GetGatewayServicesGatewayServiceAuthSpec[];
        /**
         * The comments of the api gateway service.
         */
        comments: string;
        /**
         * The create time of the api gateway service.
         */
        createTime: string;
        /**
         * The custom domains of the api gateway service.
         */
        customDomains: outputs.apig.GetGatewayServicesGatewayServiceCustomDomain[];
        /**
         * The domains of the api gateway service.
         */
        domains: outputs.apig.GetGatewayServicesGatewayServiceDomain[];
        /**
         * The gateway id of api gateway service.
         */
        gatewayId: string;
        /**
         * The gateway name of the api gateway service.
         */
        gatewayName: string;
        /**
         * The Id of the api gateway service.
         */
        id: string;
        /**
         * The error message of the api gateway service.
         */
        message: string;
        /**
         * The name of api gateway service. This field support fuzzy query.
         */
        name: string;
        /**
         * The protocol of the api gateway service.
         */
        protocols: string[];
        /**
         * The status of api gateway service.
         */
        status: string;
    }

    export interface GetGatewayServicesGatewayServiceAuthSpec {
        /**
         * Whether the api gateway service enable auth.
         */
        enable: boolean;
    }

    export interface GetGatewayServicesGatewayServiceCustomDomain {
        /**
         * The domain of the api gateway service.
         */
        domain: string;
        /**
         * The Id of the api gateway service.
         */
        id: string;
    }

    export interface GetGatewayServicesGatewayServiceDomain {
        /**
         * The domain of the api gateway service.
         */
        domain: string;
        /**
         * The type of the domain.
         */
        type: string;
    }

    export interface GetGatewaysGateway {
        /**
         * The backend spec of the api gateway.
         */
        backendSpecs: outputs.apig.GetGatewaysGatewayBackendSpec[];
        /**
         * The comments of the api gateway.
         */
        comments: string;
        /**
         * The create time of the api gateway.
         */
        createTime: string;
        /**
         * The Id of the api gateway.
         */
        id: string;
        /**
         * The log spec of the api gateway.
         */
        logSpecs: outputs.apig.GetGatewaysGatewayLogSpec[];
        /**
         * The error message of the api gateway.
         */
        message: string;
        /**
         * The monitor spec of the api gateway.
         */
        monitorSpecs: outputs.apig.GetGatewaysGatewayMonitorSpec[];
        /**
         * The name of api gateway. This field support fuzzy query.
         */
        name: string;
        /**
         * The network spec of the api gateway.
         */
        networkSpecs: outputs.apig.GetGatewaysGatewayNetworkSpec[];
        /**
         * The project name of api gateway.
         */
        projectName: string;
        /**
         * The region of the api gateway.
         */
        region: string;
        /**
         * The resource spec of the api gateway.
         */
        resourceSpecs: outputs.apig.GetGatewaysGatewayResourceSpec[];
        /**
         * The status of api gateway.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.apig.GetGatewaysGatewayTag[];
        /**
         * The type of api gateway.
         */
        type: string;
        /**
         * The version of the api gateway.
         */
        version: string;
    }

    export interface GetGatewaysGatewayBackendSpec {
        /**
         * Whether the api gateway support vke flannel cni.
         */
        isVkeWithFlannelCniSupported: boolean;
        /**
         * The vke pod cidr of the api gateway.
         */
        vkePodCidr: string;
    }

    export interface GetGatewaysGatewayLogSpec {
        /**
         * Whether the api gateway enable monitor.
         */
        enable: boolean;
        /**
         * The project id of the tls.
         */
        projectId: string;
        /**
         * The topic id of the tls.
         */
        topicId: string;
    }

    export interface GetGatewaysGatewayMonitorSpec {
        /**
         * Whether the api gateway enable monitor.
         */
        enable: boolean;
        /**
         * The workspace id of the monitor.
         */
        workspaceId: string;
    }

    export interface GetGatewaysGatewayNetworkSpec {
        /**
         * The subnet ids of the api gateway.
         */
        subnetIds: string[];
        /**
         * The vpc id of the api gateway.
         */
        vpcId: string;
    }

    export interface GetGatewaysGatewayResourceSpec {
        /**
         * The clb spec code of the resource spec.
         */
        clbSpecCode: string;
        /**
         * The instance spec code of the resource spec.
         */
        instanceSpecCode: string;
        /**
         * The network type of the api gateway.
         */
        networkTypes: outputs.apig.GetGatewaysGatewayResourceSpecNetworkType[];
        /**
         * The public network bandwidth of the resource spec.
         */
        publicNetworkBandwidth: number;
        /**
         * The public network billing type of the resource spec.
         */
        publicNetworkBillingType: string;
        /**
         * The replicas of the resource spec.
         */
        replicas: number;
    }

    export interface GetGatewaysGatewayResourceSpecNetworkType {
        /**
         * Whether the api gateway enable private network.
         */
        enablePrivateNetwork: boolean;
        /**
         * Whether the api gateway enable public network.
         */
        enablePublicNetwork: boolean;
    }

    export interface GetGatewaysGatewayTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetGatewaysTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetRoutesRoute {
        /**
         * The advanced setting of the api gateway route.
         */
        advancedSettings: outputs.apig.GetRoutesRouteAdvancedSetting[];
        /**
         * The create time of the api gateway route.
         */
        createTime: string;
        /**
         * The custom domains of the api gateway route.
         */
        customDomains: outputs.apig.GetRoutesRouteCustomDomain[];
        /**
         * The domains of the api gateway route.
         */
        domains: outputs.apig.GetRoutesRouteDomain[];
        /**
         * Whether the api gateway route is enabled.
         */
        enable: boolean;
        /**
         * The id of the api gateway route.
         */
        id: string;
        /**
         * The match rule of the api gateway route.
         */
        matchRules: outputs.apig.GetRoutesRouteMatchRule[];
        /**
         * The name of api gateway route. This field support fuzzy query.
         */
        name: string;
        /**
         * The priority of the api gateway route.
         */
        priority: number;
        /**
         * The reason of the api gateway route.
         */
        reason: string;
        /**
         * The resource type of route. Valid values: `Console`, `Ingress`.
         */
        resourceType: string;
        /**
         * The id of api gateway service.
         */
        serviceId: string;
        /**
         * The name of the api gateway service.
         */
        serviceName: string;
        /**
         * The status of the api gateway route.
         */
        status: string;
        /**
         * The update time of the api gateway route.
         */
        updateTime: string;
        /**
         * The upstream list of the api gateway route.
         */
        upstreamLists: outputs.apig.GetRoutesRouteUpstreamList[];
    }

    export interface GetRoutesRouteAdvancedSetting {
        /**
         * The cors policy setting of the api gateway route.
         */
        corsPolicySettings: outputs.apig.GetRoutesRouteAdvancedSettingCorsPolicySetting[];
        /**
         * The header operations of the api gateway route.
         */
        headerOperations: outputs.apig.GetRoutesRouteAdvancedSettingHeaderOperation[];
        /**
         * The mirror policies of the api gateway route.
         */
        mirrorPolicies: outputs.apig.GetRoutesRouteAdvancedSettingMirrorPolicy[];
        /**
         * The retry policy setting of the api gateway route.
         */
        retryPolicySettings: outputs.apig.GetRoutesRouteAdvancedSettingRetryPolicySetting[];
        /**
         * The timeout setting of the api gateway route.
         */
        timeoutSettings: outputs.apig.GetRoutesRouteAdvancedSettingTimeoutSetting[];
        /**
         * The url rewrite setting of the api gateway route.
         */
        urlRewriteSettings: outputs.apig.GetRoutesRouteAdvancedSettingUrlRewriteSetting[];
    }

    export interface GetRoutesRouteAdvancedSettingCorsPolicySetting {
        /**
         * Whether the api gateway route is enabled.
         */
        enable: boolean;
    }

    export interface GetRoutesRouteAdvancedSettingHeaderOperation {
        /**
         * The direction type of the header.
         */
        directionType: string;
        /**
         * The key of the query string.
         */
        key: string;
        /**
         * The operation of the header.
         */
        operation: string;
        /**
         * The path of the api gateway route.
         */
        value: string;
    }

    export interface GetRoutesRouteAdvancedSettingMirrorPolicy {
        /**
         * The percent of the mirror policy.
         */
        percents: outputs.apig.GetRoutesRouteAdvancedSettingMirrorPolicyPercent[];
        /**
         * The upstream of the mirror policy.
         */
        upstreams: outputs.apig.GetRoutesRouteAdvancedSettingMirrorPolicyUpstream[];
    }

    export interface GetRoutesRouteAdvancedSettingMirrorPolicyPercent {
        /**
         * The path of the api gateway route.
         */
        value: number;
    }

    export interface GetRoutesRouteAdvancedSettingMirrorPolicyUpstream {
        /**
         * The type of the domain.
         */
        type: string;
        /**
         * The id of api gateway upstream.
         */
        upstreamId: string;
        /**
         * The version of the api gateway upstream.
         */
        version: string;
    }

    export interface GetRoutesRouteAdvancedSettingRetryPolicySetting {
        /**
         * The attempts of the api gateway route.
         */
        attempts: number;
        /**
         * Whether the api gateway route is enabled.
         */
        enable: boolean;
        /**
         * The http codes of the api gateway route.
         */
        httpCodes: string[];
        /**
         * The per try timeout of the api gateway route.
         */
        perTryTimeout: number;
        /**
         * The retry on of the api gateway route.
         */
        retryOns: string[];
    }

    export interface GetRoutesRouteAdvancedSettingTimeoutSetting {
        /**
         * Whether the api gateway route is enabled.
         */
        enable: boolean;
        /**
         * The timeout of the api gateway route.
         */
        timeout: number;
    }

    export interface GetRoutesRouteAdvancedSettingUrlRewriteSetting {
        /**
         * Whether the api gateway route is enabled.
         */
        enable: boolean;
        /**
         * The url rewrite path of the api gateway route.
         */
        urlRewrite: string;
    }

    export interface GetRoutesRouteCustomDomain {
        /**
         * The domain of the api gateway route.
         */
        domain: string;
        /**
         * The id of the api gateway route.
         */
        id: string;
    }

    export interface GetRoutesRouteDomain {
        /**
         * The domain of the api gateway route.
         */
        domain: string;
        /**
         * The type of the domain.
         */
        type: string;
    }

    export interface GetRoutesRouteMatchRule {
        /**
         * The header of the api gateway route.
         */
        headers: outputs.apig.GetRoutesRouteMatchRuleHeader[];
        /**
         * The method of the api gateway route.
         */
        methods: string[];
        /**
         * The path of api gateway route.
         */
        paths: outputs.apig.GetRoutesRouteMatchRulePath[];
        /**
         * The query string of the api gateway route.
         */
        queryStrings: outputs.apig.GetRoutesRouteMatchRuleQueryString[];
    }

    export interface GetRoutesRouteMatchRuleHeader {
        /**
         * The key of the query string.
         */
        key: string;
        /**
         * The path of the api gateway route.
         */
        values: outputs.apig.GetRoutesRouteMatchRuleHeaderValue[];
    }

    export interface GetRoutesRouteMatchRuleHeaderValue {
        /**
         * The match content of the api gateway route.
         */
        matchContent: string;
        /**
         * The match type of the api gateway route.
         */
        matchType: string;
    }

    export interface GetRoutesRouteMatchRulePath {
        /**
         * The match content of the api gateway route.
         */
        matchContent: string;
        /**
         * The match type of the api gateway route.
         */
        matchType: string;
    }

    export interface GetRoutesRouteMatchRuleQueryString {
        /**
         * The key of the query string.
         */
        key: string;
        /**
         * The path of the api gateway route.
         */
        values: outputs.apig.GetRoutesRouteMatchRuleQueryStringValue[];
    }

    export interface GetRoutesRouteMatchRuleQueryStringValue {
        /**
         * The match content of the api gateway route.
         */
        matchContent: string;
        /**
         * The match type of the api gateway route.
         */
        matchType: string;
    }

    export interface GetRoutesRouteUpstreamList {
        /**
         * The ai provider settings of the api gateway route.
         */
        aiProviderSettings: outputs.apig.GetRoutesRouteUpstreamListAiProviderSetting[];
        /**
         * The id of api gateway upstream.
         */
        upstreamId: string;
        /**
         * The version of the api gateway upstream.
         */
        version: string;
        /**
         * The weight of the api gateway upstream.
         */
        weight: number;
    }

    export interface GetRoutesRouteUpstreamListAiProviderSetting {
        /**
         * The model of the ai provider.
         */
        model: string;
        /**
         * The target path of the ai provider.
         */
        targetPath: string;
    }

    export interface GetUpstreamSourcesUpstreamSource {
        /**
         * The comments of apig upstream source.
         */
        comments: string;
        /**
         * The create time of apig upstream source.
         */
        createTime: string;
        /**
         * The id of api gateway.
         */
        gatewayId: string;
        /**
         * The id of apig upstream source.
         */
        id: string;
        /**
         * The ingress settings of apig upstream source.
         */
        ingressSettings: outputs.apig.GetUpstreamSourcesUpstreamSourceIngressSetting[];
        /**
         * The source spec of apig upstream source.
         */
        sourceSpecs: outputs.apig.GetUpstreamSourcesUpstreamSourceSourceSpec[];
        /**
         * The source type of apig upstream source. Valid values: `K8S`, `Nacos`.
         */
        sourceType: string;
        /**
         * The status of apig upstream source. Valid values: `Syncing`, `SyncedSucceed`, `SyncedFailed`.
         */
        status: string;
        /**
         * The status message of apig upstream source.
         */
        statusMessage: string;
        /**
         * The update time of apig upstream source.
         */
        updateTime: string;
    }

    export interface GetUpstreamSourcesUpstreamSourceIngressSetting {
        /**
         * Whether to enable all ingress classes.
         */
        enableAllIngressClasses: boolean;
        /**
         * Whether to enable all namespaces.
         */
        enableAllNamespaces: boolean;
        /**
         * The enable ingress of apig upstream source.
         */
        enableIngress: boolean;
        /**
         * Whether to enable ingress without ingress class.
         */
        enableIngressWithoutIngressClass: boolean;
        /**
         * The ingress classes of ingress settings.
         */
        ingressClasses: string[];
        /**
         * The update status of ingress settings.
         */
        updateStatus: boolean;
        /**
         * The watch namespaces of ingress settings.
         */
        watchNamespaces: string[];
    }

    export interface GetUpstreamSourcesUpstreamSourceSourceSpec {
        /**
         * The k8s source of apig upstream source.
         */
        k8sSources: outputs.apig.GetUpstreamSourcesUpstreamSourceSourceSpecK8sSource[];
        /**
         * The nacos source of apig upstream source.
         */
        nacosSources: outputs.apig.GetUpstreamSourcesUpstreamSourceSourceSpecNacosSource[];
    }

    export interface GetUpstreamSourcesUpstreamSourceSourceSpecK8sSource {
        /**
         * The cluster id of k8s source.
         */
        clusterId: string;
        /**
         * The cluster type of k8s source.
         */
        clusterType: string;
    }

    export interface GetUpstreamSourcesUpstreamSourceSourceSpecNacosSource {
        /**
         * The address of nacos source.
         */
        address: string;
        /**
         * The auth config of nacos source.
         */
        authConfigs: outputs.apig.GetUpstreamSourcesUpstreamSourceSourceSpecNacosSourceAuthConfig[];
        /**
         * The context path of nacos source.
         */
        contextPath: string;
        /**
         * The grpc port of nacos source.
         */
        grpcPort: number;
        /**
         * The http port of nacos source.
         */
        httpPort: number;
        /**
         * The nacos id of nacos source.
         */
        nacosId: string;
        /**
         * The nacos name of nacos source.
         */
        nacosName: string;
    }

    export interface GetUpstreamSourcesUpstreamSourceSourceSpecNacosSourceAuthConfig {
        /**
         * The basic auth config of nacos source.
         */
        basics: outputs.apig.GetUpstreamSourcesUpstreamSourceSourceSpecNacosSourceAuthConfigBasic[];
    }

    export interface GetUpstreamSourcesUpstreamSourceSourceSpecNacosSourceAuthConfigBasic {
        /**
         * The password of basic auth config.
         */
        password: string;
        /**
         * The username of basic auth config.
         */
        username: string;
    }

    export interface GetUpstreamVersionsVersion {
        /**
         * The labels of apig upstream version.
         */
        labels: outputs.apig.GetUpstreamVersionsVersionLabel[];
        /**
         * The name of apig upstream version.
         */
        name: string;
        /**
         * The update time of apig upstream version.
         */
        updateTime: string;
    }

    export interface GetUpstreamVersionsVersionLabel {
        /**
         * The key of apig upstream version label.
         */
        key: string;
        /**
         * The value of apig upstream version label.
         */
        value: string;
    }

    export interface GetUpstreamsUpstream {
        /**
         * The backend target list of apig upstream.
         */
        backendTargetLists: outputs.apig.GetUpstreamsUpstreamBackendTargetList[];
        /**
         * The circuit breaking settings of apig upstream.
         */
        circuitBreakingSettings: outputs.apig.GetUpstreamsUpstreamCircuitBreakingSetting[];
        /**
         * The comments of apig upstream.
         */
        comments: string;
        /**
         * The create time of apig upstream.
         */
        createTime: string;
        /**
         * The id of api gateway.
         */
        gatewayId: string;
        /**
         * The id of apig upstream.
         */
        id: string;
        /**
         * The load balancer settings of apig upstream.
         */
        loadBalancerSettings: outputs.apig.GetUpstreamsUpstreamLoadBalancerSetting[];
        /**
         * The name of apig upstream. This field support fuzzy query.
         */
        name: string;
        /**
         * The protocol of apig upstream.
         */
        protocol: string;
        /**
         * The resource type of apig upstream. Valid values: `Console`, `Ingress`.
         */
        resourceType: string;
        /**
         * The source type of apig upstream. Valid values: `VeFaas`, `ECS`, `FixedIP`, `K8S`, `Nacos`, `Domain`, `AIProvider`, `VeMLP`.
         */
        sourceType: string;
        /**
         * The tls settings of apig upstream.
         */
        tlsSettings: outputs.apig.GetUpstreamsUpstreamTlsSetting[];
        /**
         * The update time of apig upstream version.
         */
        updateTime: string;
        /**
         * The upstream spec of apig upstream.
         */
        upstreamSpecs: outputs.apig.GetUpstreamsUpstreamUpstreamSpec[];
        /**
         * The version details of apig upstream.
         */
        versionDetails: outputs.apig.GetUpstreamsUpstreamVersionDetail[];
    }

    export interface GetUpstreamsUpstreamBackendTargetList {
        /**
         * The health status of apig upstream backend.
         */
        healthStatus: string;
        /**
         * The ip of apig upstream.
         */
        ip: string;
        /**
         * The port of k8s service.
         */
        port: number;
    }

    export interface GetUpstreamsUpstreamCircuitBreakingSetting {
        /**
         * The base ejection time of circuit breaking. Unit: ms.
         */
        baseEjectionTime: number;
        /**
         * The consecutive errors of circuit breaking.
         */
        consecutiveErrors: number;
        /**
         * Whether the circuit breaking is enabled.
         */
        enable: boolean;
        /**
         * The interval of circuit breaking. Unit: ms.
         */
        interval: number;
        /**
         * The max ejection percent of circuit breaking.
         */
        maxEjectionPercent: number;
        /**
         * The min health percent of circuit breaking.
         */
        minHealthPercent: number;
    }

    export interface GetUpstreamsUpstreamLoadBalancerSetting {
        /**
         * The consistent hash lb of apig upstream.
         */
        consistentHashLbs: outputs.apig.GetUpstreamsUpstreamLoadBalancerSettingConsistentHashLb[];
        /**
         * The load balancer policy of apig upstream.
         */
        lbPolicy: string;
        /**
         * The simple load balancer of apig upstream.
         */
        simpleLb: string;
        /**
         * The warmup duration of apig upstream lb.
         */
        warmupDuration: number;
    }

    export interface GetUpstreamsUpstreamLoadBalancerSettingConsistentHashLb {
        /**
         * The hash key of apig upstream consistent hash lb.
         */
        hashKey: string;
        /**
         * The http cookie of apig upstream consistent hash lb.
         */
        httpCookies: outputs.apig.GetUpstreamsUpstreamLoadBalancerSettingConsistentHashLbHttpCooky[];
        /**
         * The http header name of apig upstream consistent hash lb.
         */
        httpHeaderName: string;
        /**
         * The http query parameter name of apig upstream consistent hash lb.
         */
        httpQueryParameterName: string;
        /**
         * The use source ip of apig upstream consistent hash lb.
         */
        useSourceIp: boolean;
    }

    export interface GetUpstreamsUpstreamLoadBalancerSettingConsistentHashLbHttpCooky {
        /**
         * The name of apig upstream. This field support fuzzy query.
         */
        name: string;
        /**
         * The path of apig upstream consistent hash lb http cookie.
         */
        path: string;
        /**
         * The ttl of apig upstream consistent hash lb http cookie.
         */
        ttl: number;
    }

    export interface GetUpstreamsUpstreamTlsSetting {
        /**
         * The sni of apig upstream tls setting.
         */
        sni: string;
        /**
         * The tls mode of apig upstream tls setting.
         */
        tlsMode: string;
    }

    export interface GetUpstreamsUpstreamUpstreamSpec {
        /**
         * The ai provider of apig upstream.
         */
        aiProviders: outputs.apig.GetUpstreamsUpstreamUpstreamSpecAiProvider[];
        /**
         * The domain of apig upstream.
         */
        domains: outputs.apig.GetUpstreamsUpstreamUpstreamSpecDomain[];
        /**
         * The ecs list of apig upstream.
         */
        ecsLists: outputs.apig.GetUpstreamsUpstreamUpstreamSpecEcsList[];
        /**
         * The fixed ip list of apig upstream.
         */
        fixedIpLists: outputs.apig.GetUpstreamsUpstreamUpstreamSpecFixedIpList[];
        /**
         * The k8s service of mlp.
         */
        k8sServices: outputs.apig.GetUpstreamsUpstreamUpstreamSpecK8sService[];
        /**
         * The nacos service of apig upstream.
         */
        nacosServices: outputs.apig.GetUpstreamsUpstreamUpstreamSpecNacosService[];
        /**
         * The vefaas of apig upstream.
         */
        veFaas: outputs.apig.GetUpstreamsUpstreamUpstreamSpecVeFaa[];
        /**
         * The mlp of apig upstream.
         */
        veMlps: outputs.apig.GetUpstreamsUpstreamUpstreamSpecVeMlp[];
    }

    export interface GetUpstreamsUpstreamUpstreamSpecAiProvider {
        /**
         * The base url of ai provider.
         */
        baseUrl: string;
        /**
         * The custom body params of ai provider.
         */
        customBodyParams: {[key: string]: any};
        /**
         * The custom header params of ai provider.
         */
        customHeaderParams: {[key: string]: any};
        /**
         * The custom model service of ai provider.
         */
        customModelServices: outputs.apig.GetUpstreamsUpstreamUpstreamSpecAiProviderCustomModelService[];
        /**
         * The name of apig upstream. This field support fuzzy query.
         */
        name: string;
        /**
         * The token of ai provider.
         */
        token: string;
    }

    export interface GetUpstreamsUpstreamUpstreamSpecAiProviderCustomModelService {
        /**
         * The name of apig upstream. This field support fuzzy query.
         */
        name: string;
        /**
         * The namespace of k8s service.
         */
        namespace: string;
        /**
         * The port of k8s service.
         */
        port: number;
    }

    export interface GetUpstreamsUpstreamUpstreamSpecDomain {
        /**
         * The domain list of apig upstream.
         */
        domainLists: outputs.apig.GetUpstreamsUpstreamUpstreamSpecDomainDomainList[];
        /**
         * The protocol of apig upstream.
         */
        protocol: string;
    }

    export interface GetUpstreamsUpstreamUpstreamSpecDomainDomainList {
        /**
         * The domain of apig upstream.
         */
        domain: string;
        /**
         * The port of k8s service.
         */
        port: number;
    }

    export interface GetUpstreamsUpstreamUpstreamSpecEcsList {
        /**
         * The instance id of ecs.
         */
        ecsId: string;
        /**
         * The ip of apig upstream.
         */
        ip: string;
        /**
         * The port of k8s service.
         */
        port: number;
    }

    export interface GetUpstreamsUpstreamUpstreamSpecFixedIpList {
        /**
         * The ip of apig upstream.
         */
        ip: string;
        /**
         * The port of k8s service.
         */
        port: number;
    }

    export interface GetUpstreamsUpstreamUpstreamSpecK8sService {
        /**
         * The name of apig upstream. This field support fuzzy query.
         */
        name: string;
        /**
         * The namespace of k8s service.
         */
        namespace: string;
        /**
         * The port of k8s service.
         */
        port: number;
    }

    export interface GetUpstreamsUpstreamUpstreamSpecNacosService {
        /**
         * The group of nacos service.
         */
        group: string;
        /**
         * The namespace of k8s service.
         */
        namespace: string;
        /**
         * The namespace id of nacos service.
         */
        namespaceId: string;
        /**
         * The service of nacos service.
         */
        service: string;
        /**
         * The upstream source id.
         */
        upstreamSourceId: string;
    }

    export interface GetUpstreamsUpstreamUpstreamSpecVeFaa {
        /**
         * The function id of vefaas.
         */
        functionId: string;
    }

    export interface GetUpstreamsUpstreamUpstreamSpecVeMlp {
        /**
         * The k8s service of mlp.
         */
        k8sServices: outputs.apig.GetUpstreamsUpstreamUpstreamSpecVeMlpK8sService[];
        /**
         * The service discover type of mlp.
         */
        serviceDiscoverType: string;
        /**
         * The service id of mlp.
         */
        serviceId: string;
        /**
         * The service name of mlp.
         */
        serviceName: string;
        /**
         * The service url of mlp.
         */
        serviceUrl: string;
        /**
         * The upstream source id.
         */
        upstreamSourceId: string;
    }

    export interface GetUpstreamsUpstreamUpstreamSpecVeMlpK8sService {
        /**
         * The cluster info of k8s service.
         */
        clusterInfos: outputs.apig.GetUpstreamsUpstreamUpstreamSpecVeMlpK8sServiceClusterInfo[];
        /**
         * The name of apig upstream. This field support fuzzy query.
         */
        name: string;
        /**
         * The namespace of k8s service.
         */
        namespace: string;
        /**
         * The port of k8s service.
         */
        port: number;
    }

    export interface GetUpstreamsUpstreamUpstreamSpecVeMlpK8sServiceClusterInfo {
        /**
         * The account id of k8s service.
         */
        accountId: number;
        /**
         * The cluster name of k8s service.
         */
        clusterName: string;
    }

    export interface GetUpstreamsUpstreamVersionDetail {
        /**
         * The labels of apig upstream version.
         */
        labels: outputs.apig.GetUpstreamsUpstreamVersionDetailLabel[];
        /**
         * The name of apig upstream. This field support fuzzy query.
         */
        name: string;
        /**
         * The update time of apig upstream version.
         */
        updateTime: string;
    }

    export interface GetUpstreamsUpstreamVersionDetailLabel {
        /**
         * The key of apig upstream version label.
         */
        key: string;
        /**
         * The value of apig upstream version label.
         */
        value: string;
    }

    export interface RoutesRoute {
        /**
         * The advanced setting of the api gateway route.
         */
        advancedSettings: outputs.apig.RoutesRouteAdvancedSetting[];
        /**
         * The create time of the api gateway route.
         */
        createTime: string;
        /**
         * The custom domains of the api gateway route.
         */
        customDomains: outputs.apig.RoutesRouteCustomDomain[];
        /**
         * The domains of the api gateway route.
         */
        domains: outputs.apig.RoutesRouteDomain[];
        /**
         * Whether the api gateway route is enabled.
         */
        enable: boolean;
        /**
         * The id of the api gateway route.
         */
        id: string;
        /**
         * The match rule of the api gateway route.
         */
        matchRules: outputs.apig.RoutesRouteMatchRule[];
        /**
         * The name of api gateway route. This field support fuzzy query.
         */
        name: string;
        /**
         * The priority of the api gateway route.
         */
        priority: number;
        /**
         * The reason of the api gateway route.
         */
        reason: string;
        /**
         * The resource type of route. Valid values: `Console`, `Ingress`.
         */
        resourceType: string;
        /**
         * The id of api gateway service.
         */
        serviceId: string;
        /**
         * The name of the api gateway service.
         */
        serviceName: string;
        /**
         * The status of the api gateway route.
         */
        status: string;
        /**
         * The update time of the api gateway route.
         */
        updateTime: string;
        /**
         * The upstream list of the api gateway route.
         */
        upstreamLists: outputs.apig.RoutesRouteUpstreamList[];
    }

    export interface RoutesRouteAdvancedSetting {
        /**
         * The cors policy setting of the api gateway route.
         */
        corsPolicySettings: outputs.apig.RoutesRouteAdvancedSettingCorsPolicySetting[];
        /**
         * The header operations of the api gateway route.
         */
        headerOperations: outputs.apig.RoutesRouteAdvancedSettingHeaderOperation[];
        /**
         * The mirror policies of the api gateway route.
         */
        mirrorPolicies: outputs.apig.RoutesRouteAdvancedSettingMirrorPolicy[];
        /**
         * The retry policy setting of the api gateway route.
         */
        retryPolicySettings: outputs.apig.RoutesRouteAdvancedSettingRetryPolicySetting[];
        /**
         * The timeout setting of the api gateway route.
         */
        timeoutSettings: outputs.apig.RoutesRouteAdvancedSettingTimeoutSetting[];
        /**
         * The url rewrite setting of the api gateway route.
         */
        urlRewriteSettings: outputs.apig.RoutesRouteAdvancedSettingUrlRewriteSetting[];
    }

    export interface RoutesRouteAdvancedSettingCorsPolicySetting {
        /**
         * Whether the api gateway route is enabled.
         */
        enable: boolean;
    }

    export interface RoutesRouteAdvancedSettingHeaderOperation {
        /**
         * The direction type of the header.
         */
        directionType: string;
        /**
         * The key of the query string.
         */
        key: string;
        /**
         * The operation of the header.
         */
        operation: string;
        /**
         * The path of the api gateway route.
         */
        value: string;
    }

    export interface RoutesRouteAdvancedSettingMirrorPolicy {
        /**
         * The percent of the mirror policy.
         */
        percents: outputs.apig.RoutesRouteAdvancedSettingMirrorPolicyPercent[];
        /**
         * The upstream of the mirror policy.
         */
        upstreams: outputs.apig.RoutesRouteAdvancedSettingMirrorPolicyUpstream[];
    }

    export interface RoutesRouteAdvancedSettingMirrorPolicyPercent {
        /**
         * The path of the api gateway route.
         */
        value: number;
    }

    export interface RoutesRouteAdvancedSettingMirrorPolicyUpstream {
        /**
         * The type of the domain.
         */
        type: string;
        /**
         * The id of api gateway upstream.
         */
        upstreamId: string;
        /**
         * The version of the api gateway upstream.
         */
        version: string;
    }

    export interface RoutesRouteAdvancedSettingRetryPolicySetting {
        /**
         * The attempts of the api gateway route.
         */
        attempts: number;
        /**
         * Whether the api gateway route is enabled.
         */
        enable: boolean;
        /**
         * The http codes of the api gateway route.
         */
        httpCodes: string[];
        /**
         * The per try timeout of the api gateway route.
         */
        perTryTimeout: number;
        /**
         * The retry on of the api gateway route.
         */
        retryOns: string[];
    }

    export interface RoutesRouteAdvancedSettingTimeoutSetting {
        /**
         * Whether the api gateway route is enabled.
         */
        enable: boolean;
        /**
         * The timeout of the api gateway route.
         */
        timeout: number;
    }

    export interface RoutesRouteAdvancedSettingUrlRewriteSetting {
        /**
         * Whether the api gateway route is enabled.
         */
        enable: boolean;
        /**
         * The url rewrite path of the api gateway route.
         */
        urlRewrite: string;
    }

    export interface RoutesRouteCustomDomain {
        /**
         * The domain of the api gateway route.
         */
        domain: string;
        /**
         * The id of the api gateway route.
         */
        id: string;
    }

    export interface RoutesRouteDomain {
        /**
         * The domain of the api gateway route.
         */
        domain: string;
        /**
         * The type of the domain.
         */
        type: string;
    }

    export interface RoutesRouteMatchRule {
        /**
         * The header of the api gateway route.
         */
        headers: outputs.apig.RoutesRouteMatchRuleHeader[];
        /**
         * The method of the api gateway route.
         */
        methods: string[];
        /**
         * The path of api gateway route.
         */
        paths: outputs.apig.RoutesRouteMatchRulePath[];
        /**
         * The query string of the api gateway route.
         */
        queryStrings: outputs.apig.RoutesRouteMatchRuleQueryString[];
    }

    export interface RoutesRouteMatchRuleHeader {
        /**
         * The key of the query string.
         */
        key: string;
        /**
         * The path of the api gateway route.
         */
        values: outputs.apig.RoutesRouteMatchRuleHeaderValue[];
    }

    export interface RoutesRouteMatchRuleHeaderValue {
        /**
         * The match content of the api gateway route.
         */
        matchContent: string;
        /**
         * The match type of the api gateway route.
         */
        matchType: string;
    }

    export interface RoutesRouteMatchRulePath {
        /**
         * The match content of the api gateway route.
         */
        matchContent: string;
        /**
         * The match type of the api gateway route.
         */
        matchType: string;
    }

    export interface RoutesRouteMatchRuleQueryString {
        /**
         * The key of the query string.
         */
        key: string;
        /**
         * The path of the api gateway route.
         */
        values: outputs.apig.RoutesRouteMatchRuleQueryStringValue[];
    }

    export interface RoutesRouteMatchRuleQueryStringValue {
        /**
         * The match content of the api gateway route.
         */
        matchContent: string;
        /**
         * The match type of the api gateway route.
         */
        matchType: string;
    }

    export interface RoutesRouteUpstreamList {
        /**
         * The ai provider settings of the api gateway route.
         */
        aiProviderSettings: outputs.apig.RoutesRouteUpstreamListAiProviderSetting[];
        /**
         * The id of api gateway upstream.
         */
        upstreamId: string;
        /**
         * The version of the api gateway upstream.
         */
        version: string;
        /**
         * The weight of the api gateway upstream.
         */
        weight: number;
    }

    export interface RoutesRouteUpstreamListAiProviderSetting {
        /**
         * The model of the ai provider.
         */
        model: string;
        /**
         * The target path of the ai provider.
         */
        targetPath: string;
    }

    export interface UpstreamSourcesUpstreamSource {
        /**
         * The comments of apig upstream source.
         */
        comments: string;
        /**
         * The create time of apig upstream source.
         */
        createTime: string;
        /**
         * The id of api gateway.
         */
        gatewayId: string;
        /**
         * The id of apig upstream source.
         */
        id: string;
        /**
         * The ingress settings of apig upstream source.
         */
        ingressSettings: outputs.apig.UpstreamSourcesUpstreamSourceIngressSetting[];
        /**
         * The source spec of apig upstream source.
         */
        sourceSpecs: outputs.apig.UpstreamSourcesUpstreamSourceSourceSpec[];
        /**
         * The source type of apig upstream source. Valid values: `K8S`, `Nacos`.
         */
        sourceType: string;
        /**
         * The status of apig upstream source. Valid values: `Syncing`, `SyncedSucceed`, `SyncedFailed`.
         */
        status: string;
        /**
         * The status message of apig upstream source.
         */
        statusMessage: string;
        /**
         * The update time of apig upstream source.
         */
        updateTime: string;
    }

    export interface UpstreamSourcesUpstreamSourceIngressSetting {
        /**
         * Whether to enable all ingress classes.
         */
        enableAllIngressClasses: boolean;
        /**
         * Whether to enable all namespaces.
         */
        enableAllNamespaces: boolean;
        /**
         * The enable ingress of apig upstream source.
         */
        enableIngress: boolean;
        /**
         * Whether to enable ingress without ingress class.
         */
        enableIngressWithoutIngressClass: boolean;
        /**
         * The ingress classes of ingress settings.
         */
        ingressClasses: string[];
        /**
         * The update status of ingress settings.
         */
        updateStatus: boolean;
        /**
         * The watch namespaces of ingress settings.
         */
        watchNamespaces: string[];
    }

    export interface UpstreamSourcesUpstreamSourceSourceSpec {
        /**
         * The k8s source of apig upstream source.
         */
        k8sSources: outputs.apig.UpstreamSourcesUpstreamSourceSourceSpecK8sSource[];
        /**
         * The nacos source of apig upstream source.
         */
        nacosSources: outputs.apig.UpstreamSourcesUpstreamSourceSourceSpecNacosSource[];
    }

    export interface UpstreamSourcesUpstreamSourceSourceSpecK8sSource {
        /**
         * The cluster id of k8s source.
         */
        clusterId: string;
        /**
         * The cluster type of k8s source.
         */
        clusterType: string;
    }

    export interface UpstreamSourcesUpstreamSourceSourceSpecNacosSource {
        /**
         * The address of nacos source.
         */
        address: string;
        /**
         * The auth config of nacos source.
         */
        authConfigs: outputs.apig.UpstreamSourcesUpstreamSourceSourceSpecNacosSourceAuthConfig[];
        /**
         * The context path of nacos source.
         */
        contextPath: string;
        /**
         * The grpc port of nacos source.
         */
        grpcPort: number;
        /**
         * The http port of nacos source.
         */
        httpPort: number;
        /**
         * The nacos id of nacos source.
         */
        nacosId: string;
        /**
         * The nacos name of nacos source.
         */
        nacosName: string;
    }

    export interface UpstreamSourcesUpstreamSourceSourceSpecNacosSourceAuthConfig {
        /**
         * The basic auth config of nacos source.
         */
        basics: outputs.apig.UpstreamSourcesUpstreamSourceSourceSpecNacosSourceAuthConfigBasic[];
    }

    export interface UpstreamSourcesUpstreamSourceSourceSpecNacosSourceAuthConfigBasic {
        /**
         * The password of basic auth config.
         */
        password: string;
        /**
         * The username of basic auth config.
         */
        username: string;
    }

    export interface UpstreamVersionsVersion {
        /**
         * The labels of apig upstream version.
         */
        labels: outputs.apig.UpstreamVersionsVersionLabel[];
        /**
         * The name of apig upstream version.
         */
        name: string;
        /**
         * The update time of apig upstream version.
         */
        updateTime: string;
    }

    export interface UpstreamVersionsVersionLabel {
        /**
         * The key of apig upstream version label.
         */
        key: string;
        /**
         * The value of apig upstream version label.
         */
        value: string;
    }

    export interface UpstreamsUpstream {
        /**
         * The backend target list of apig upstream.
         */
        backendTargetLists: outputs.apig.UpstreamsUpstreamBackendTargetList[];
        /**
         * The circuit breaking settings of apig upstream.
         */
        circuitBreakingSettings: outputs.apig.UpstreamsUpstreamCircuitBreakingSetting[];
        /**
         * The comments of apig upstream.
         */
        comments: string;
        /**
         * The create time of apig upstream.
         */
        createTime: string;
        /**
         * The id of api gateway.
         */
        gatewayId: string;
        /**
         * The id of apig upstream.
         */
        id: string;
        /**
         * The load balancer settings of apig upstream.
         */
        loadBalancerSettings: outputs.apig.UpstreamsUpstreamLoadBalancerSetting[];
        /**
         * The name of apig upstream. This field support fuzzy query.
         */
        name: string;
        /**
         * The protocol of apig upstream.
         */
        protocol: string;
        /**
         * The resource type of apig upstream. Valid values: `Console`, `Ingress`.
         */
        resourceType: string;
        /**
         * The source type of apig upstream. Valid values: `VeFaas`, `ECS`, `FixedIP`, `K8S`, `Nacos`, `Domain`, `AIProvider`, `VeMLP`.
         */
        sourceType: string;
        /**
         * The tls settings of apig upstream.
         */
        tlsSettings: outputs.apig.UpstreamsUpstreamTlsSetting[];
        /**
         * The update time of apig upstream version.
         */
        updateTime: string;
        /**
         * The upstream spec of apig upstream.
         */
        upstreamSpecs: outputs.apig.UpstreamsUpstreamUpstreamSpec[];
        /**
         * The version details of apig upstream.
         */
        versionDetails: outputs.apig.UpstreamsUpstreamVersionDetail[];
    }

    export interface UpstreamsUpstreamBackendTargetList {
        /**
         * The health status of apig upstream backend.
         */
        healthStatus: string;
        /**
         * The ip of apig upstream.
         */
        ip: string;
        /**
         * The port of k8s service.
         */
        port: number;
    }

    export interface UpstreamsUpstreamCircuitBreakingSetting {
        /**
         * The base ejection time of circuit breaking. Unit: ms.
         */
        baseEjectionTime: number;
        /**
         * The consecutive errors of circuit breaking.
         */
        consecutiveErrors: number;
        /**
         * Whether the circuit breaking is enabled.
         */
        enable: boolean;
        /**
         * The interval of circuit breaking. Unit: ms.
         */
        interval: number;
        /**
         * The max ejection percent of circuit breaking.
         */
        maxEjectionPercent: number;
        /**
         * The min health percent of circuit breaking.
         */
        minHealthPercent: number;
    }

    export interface UpstreamsUpstreamLoadBalancerSetting {
        /**
         * The consistent hash lb of apig upstream.
         */
        consistentHashLbs: outputs.apig.UpstreamsUpstreamLoadBalancerSettingConsistentHashLb[];
        /**
         * The load balancer policy of apig upstream.
         */
        lbPolicy: string;
        /**
         * The simple load balancer of apig upstream.
         */
        simpleLb: string;
        /**
         * The warmup duration of apig upstream lb.
         */
        warmupDuration: number;
    }

    export interface UpstreamsUpstreamLoadBalancerSettingConsistentHashLb {
        /**
         * The hash key of apig upstream consistent hash lb.
         */
        hashKey: string;
        /**
         * The http cookie of apig upstream consistent hash lb.
         */
        httpCookies: outputs.apig.UpstreamsUpstreamLoadBalancerSettingConsistentHashLbHttpCooky[];
        /**
         * The http header name of apig upstream consistent hash lb.
         */
        httpHeaderName: string;
        /**
         * The http query parameter name of apig upstream consistent hash lb.
         */
        httpQueryParameterName: string;
        /**
         * The use source ip of apig upstream consistent hash lb.
         */
        useSourceIp: boolean;
    }

    export interface UpstreamsUpstreamLoadBalancerSettingConsistentHashLbHttpCooky {
        /**
         * The name of apig upstream. This field support fuzzy query.
         */
        name: string;
        /**
         * The path of apig upstream consistent hash lb http cookie.
         */
        path: string;
        /**
         * The ttl of apig upstream consistent hash lb http cookie.
         */
        ttl: number;
    }

    export interface UpstreamsUpstreamTlsSetting {
        /**
         * The sni of apig upstream tls setting.
         */
        sni: string;
        /**
         * The tls mode of apig upstream tls setting.
         */
        tlsMode: string;
    }

    export interface UpstreamsUpstreamUpstreamSpec {
        /**
         * The ai provider of apig upstream.
         */
        aiProviders: outputs.apig.UpstreamsUpstreamUpstreamSpecAiProvider[];
        /**
         * The domain of apig upstream.
         */
        domains: outputs.apig.UpstreamsUpstreamUpstreamSpecDomain[];
        /**
         * The ecs list of apig upstream.
         */
        ecsLists: outputs.apig.UpstreamsUpstreamUpstreamSpecEcsList[];
        /**
         * The fixed ip list of apig upstream.
         */
        fixedIpLists: outputs.apig.UpstreamsUpstreamUpstreamSpecFixedIpList[];
        /**
         * The k8s service of mlp.
         */
        k8sServices: outputs.apig.UpstreamsUpstreamUpstreamSpecK8sService[];
        /**
         * The nacos service of apig upstream.
         */
        nacosServices: outputs.apig.UpstreamsUpstreamUpstreamSpecNacosService[];
        /**
         * The vefaas of apig upstream.
         */
        veFaas: outputs.apig.UpstreamsUpstreamUpstreamSpecVeFaa[];
        /**
         * The mlp of apig upstream.
         */
        veMlps: outputs.apig.UpstreamsUpstreamUpstreamSpecVeMlp[];
    }

    export interface UpstreamsUpstreamUpstreamSpecAiProvider {
        /**
         * The base url of ai provider.
         */
        baseUrl: string;
        /**
         * The custom body params of ai provider.
         */
        customBodyParams: {[key: string]: any};
        /**
         * The custom header params of ai provider.
         */
        customHeaderParams: {[key: string]: any};
        /**
         * The custom model service of ai provider.
         */
        customModelServices: outputs.apig.UpstreamsUpstreamUpstreamSpecAiProviderCustomModelService[];
        /**
         * The name of apig upstream. This field support fuzzy query.
         */
        name: string;
        /**
         * The token of ai provider.
         */
        token: string;
    }

    export interface UpstreamsUpstreamUpstreamSpecAiProviderCustomModelService {
        /**
         * The name of apig upstream. This field support fuzzy query.
         */
        name: string;
        /**
         * The namespace of k8s service.
         */
        namespace: string;
        /**
         * The port of k8s service.
         */
        port: number;
    }

    export interface UpstreamsUpstreamUpstreamSpecDomain {
        /**
         * The domain list of apig upstream.
         */
        domainLists: outputs.apig.UpstreamsUpstreamUpstreamSpecDomainDomainList[];
        /**
         * The protocol of apig upstream.
         */
        protocol: string;
    }

    export interface UpstreamsUpstreamUpstreamSpecDomainDomainList {
        /**
         * The domain of apig upstream.
         */
        domain: string;
        /**
         * The port of k8s service.
         */
        port: number;
    }

    export interface UpstreamsUpstreamUpstreamSpecEcsList {
        /**
         * The instance id of ecs.
         */
        ecsId: string;
        /**
         * The ip of apig upstream.
         */
        ip: string;
        /**
         * The port of k8s service.
         */
        port: number;
    }

    export interface UpstreamsUpstreamUpstreamSpecFixedIpList {
        /**
         * The ip of apig upstream.
         */
        ip: string;
        /**
         * The port of k8s service.
         */
        port: number;
    }

    export interface UpstreamsUpstreamUpstreamSpecK8sService {
        /**
         * The name of apig upstream. This field support fuzzy query.
         */
        name: string;
        /**
         * The namespace of k8s service.
         */
        namespace: string;
        /**
         * The port of k8s service.
         */
        port: number;
    }

    export interface UpstreamsUpstreamUpstreamSpecNacosService {
        /**
         * The group of nacos service.
         */
        group: string;
        /**
         * The namespace of k8s service.
         */
        namespace: string;
        /**
         * The namespace id of nacos service.
         */
        namespaceId: string;
        /**
         * The service of nacos service.
         */
        service: string;
        /**
         * The upstream source id.
         */
        upstreamSourceId: string;
    }

    export interface UpstreamsUpstreamUpstreamSpecVeFaa {
        /**
         * The function id of vefaas.
         */
        functionId: string;
    }

    export interface UpstreamsUpstreamUpstreamSpecVeMlp {
        /**
         * The k8s service of mlp.
         */
        k8sServices: outputs.apig.UpstreamsUpstreamUpstreamSpecVeMlpK8sService[];
        /**
         * The service discover type of mlp.
         */
        serviceDiscoverType: string;
        /**
         * The service id of mlp.
         */
        serviceId: string;
        /**
         * The service name of mlp.
         */
        serviceName: string;
        /**
         * The service url of mlp.
         */
        serviceUrl: string;
        /**
         * The upstream source id.
         */
        upstreamSourceId: string;
    }

    export interface UpstreamsUpstreamUpstreamSpecVeMlpK8sService {
        /**
         * The cluster info of k8s service.
         */
        clusterInfos: outputs.apig.UpstreamsUpstreamUpstreamSpecVeMlpK8sServiceClusterInfo[];
        /**
         * The name of apig upstream. This field support fuzzy query.
         */
        name: string;
        /**
         * The namespace of k8s service.
         */
        namespace: string;
        /**
         * The port of k8s service.
         */
        port: number;
    }

    export interface UpstreamsUpstreamUpstreamSpecVeMlpK8sServiceClusterInfo {
        /**
         * The account id of k8s service.
         */
        accountId: number;
        /**
         * The cluster name of k8s service.
         */
        clusterName: string;
    }

    export interface UpstreamsUpstreamVersionDetail {
        /**
         * The labels of apig upstream version.
         */
        labels: outputs.apig.UpstreamsUpstreamVersionDetailLabel[];
        /**
         * The name of apig upstream. This field support fuzzy query.
         */
        name: string;
        /**
         * The update time of apig upstream version.
         */
        updateTime: string;
    }

    export interface UpstreamsUpstreamVersionDetailLabel {
        /**
         * The key of apig upstream version label.
         */
        key: string;
        /**
         * The value of apig upstream version label.
         */
        value: string;
    }

}

export namespace autoscaling {
    export interface GetScalingActivitiesActivity {
        /**
         * The Actual Type.
         */
        activityType: string;
        /**
         * The Actual Adjustment Instance Number.
         */
        actualAdjustInstanceNumber: number;
        /**
         * The Cooldown time.
         */
        cooldown: number;
        /**
         * The create time of Scaling Activity.
         */
        createdAt: string;
        /**
         * The Current Instance Number.
         */
        currentInstanceNumber: number;
        /**
         * The expected run time of Scaling Activity.
         */
        expectedRunTime: string;
        /**
         * The ID of Scaling Activity.
         */
        id: string;
        /**
         * The Max Instance Number.
         */
        maxInstanceNumber: number;
        /**
         * The Min Instance Number.
         */
        minInstanceNumber: number;
        /**
         * The related instances.
         */
        relatedInstances: outputs.autoscaling.GetScalingActivitiesActivityRelatedInstance[];
        /**
         * The Result of Scaling Activity.
         */
        resultMsg: string;
        /**
         * The ID of Scaling Activity.
         */
        scalingActivityId: string;
        /**
         * A Id of Scaling Group.
         */
        scalingGroupId: string;
        /**
         * A status code of Scaling Activity. Valid values: Init, Running, Success, PartialSuccess, Error, Rejected, Exception.
         */
        statusCode: string;
        /**
         * The stopped time of Scaling Activity.
         */
        stoppedAt: string;
        /**
         * The task category of Scaling Activity.
         */
        taskCategory: string;
    }

    export interface GetScalingActivitiesActivityRelatedInstance {
        /**
         * The Instance ID.
         */
        instanceId: string;
        /**
         * The message of Instance.
         */
        message: string;
        /**
         * The Operation Type.
         */
        operateType: string;
        /**
         * The Status.
         */
        status: string;
    }

    export interface GetScalingConfigurationsScalingConfiguration {
        /**
         * The create time of the scaling configuration.
         */
        createdAt: string;
        /**
         * The EIP bandwidth which the scaling configuration set.
         */
        eipBandwidth: number;
        /**
         * The EIP ISP which the scaling configuration set.
         */
        eipBillingType: string;
        /**
         * The EIP ISP which the scaling configuration set.
         */
        eipIsp: string;
        /**
         * The ECS hostname which the scaling configuration set.
         */
        hostName: string;
        /**
         * The ID of the HPC cluster to which the instance belongs. Valid only when InstanceTypes.N specifies High Performance Computing GPU Type.
         */
        hpcClusterId: string;
        /**
         * The id of the scaling configuration.
         */
        id: string;
        /**
         * The ECS image id which the scaling configuration set.
         */
        imageId: string;
        /**
         * The ECS instance description which the scaling configuration set.
         */
        instanceDescription: string;
        /**
         * The ECS instance name which the scaling configuration set.
         */
        instanceName: string;
        /**
         * The list of the ECS instance type which the scaling configuration set.
         */
        instanceTypes: string[];
        /**
         * Assign IPv6 address to instance network card. Possible values:
         * 0: Do not assign IPv6 address.
         * 1: Assign IPv6 address and the system will automatically assign an IPv6 subnet for you.
         */
        ipv6AddressCount: number;
        /**
         * The ECS key pair name which the scaling configuration set.
         */
        keyPairName: string;
        /**
         * The lifecycle state of the scaling configuration.
         */
        lifecycleState: string;
        /**
         * The project to which the instance created by the scaling configuration belongs.
         */
        projectName: string;
        /**
         * The id of the scaling configuration.
         */
        scalingConfigurationId: string;
        /**
         * The name of the scaling configuration.
         */
        scalingConfigurationName: string;
        /**
         * An id of scaling group.
         */
        scalingGroupId: string;
        /**
         * The Ecs security enhancement strategy which the scaling configuration set.
         */
        securityEnhancementStrategy: string;
        /**
         * The list of the security group id of the networkInterface which the scaling configuration set.
         */
        securityGroupIds: string[];
        /**
         * The preemption policy of the instance. Valid Value: NoSpot (default), SpotAsPriceGo.
         */
        spotStrategy: string;
        /**
         * The label of the instance created by the scaling configuration.
         */
        tags: outputs.autoscaling.GetScalingConfigurationsScalingConfigurationTag[];
        /**
         * The create time of the scaling configuration.
         */
        updatedAt: string;
        /**
         * The ECS user data which the scaling configuration set.
         */
        userData: string;
        /**
         * The list of volume of the scaling configuration.
         */
        volumes: outputs.autoscaling.GetScalingConfigurationsScalingConfigurationVolume[];
    }

    export interface GetScalingConfigurationsScalingConfigurationTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetScalingConfigurationsScalingConfigurationVolume {
        /**
         * The delete with instance flag of volume.
         */
        deleteWithInstance: boolean;
        /**
         * The size of volume.
         */
        size: number;
        /**
         * The type of volume.
         */
        volumeType: string;
    }

    export interface GetScalingGroupsScalingGroup {
        /**
         * The scaling configuration id which used by the scaling group.
         */
        activeScalingConfigurationId: string;
        /**
         * The create time of the scaling group.
         */
        createdAt: string;
        /**
         * The list of db instance ids.
         */
        dbInstanceIds: string[];
        /**
         * The default cooldown interval of the scaling group.
         */
        defaultCooldown: number;
        /**
         * The desire instance number of the scaling group.
         */
        desireInstanceNumber: number;
        /**
         * The health check type of the scaling group.
         */
        healthCheckType: string;
        /**
         * The id of the scaling group.
         */
        id: string;
        /**
         * The instance terminate policy of the scaling group.
         */
        instanceTerminatePolicy: string;
        /**
         * The ID of the launch template bound to the scaling group.
         */
        launchTemplateId: string;
        /**
         * Instance start template information.
         */
        launchTemplateOverrides: outputs.autoscaling.GetScalingGroupsScalingGroupLaunchTemplateOverride[];
        /**
         * The version of the launch template bound to the scaling group.
         */
        launchTemplateVersion: string;
        /**
         * The lifecycle state of the scaling group.
         */
        lifecycleState: string;
        /**
         * Grace period for health check of CLB instance in elastic group.
         */
        loadBalancerHealthCheckGracePeriod: number;
        /**
         * The max instance number of the scaling group.
         */
        maxInstanceNumber: number;
        /**
         * The min instance number of the scaling group.
         */
        minInstanceNumber: number;
        /**
         * The multi az policy of the scaling group. Valid values: PRIORITY, BALANCE.
         */
        multiAzPolicy: string;
        /**
         * The project name of the scaling group.
         */
        projectName: string;
        /**
         * The id of the scaling group.
         */
        scalingGroupId: string;
        /**
         * The name of the scaling group.
         */
        scalingGroupName: string;
        /**
         * The scaling mode of the scaling group.
         */
        scalingMode: string;
        /**
         * The list of server group attributes.
         */
        serverGroupAttributes: outputs.autoscaling.GetScalingGroupsScalingGroupServerGroupAttribute[];
        /**
         * The number of stopped instances.
         */
        stoppedInstanceCount: number;
        /**
         * The list of the subnet id to which the ENI is connected.
         */
        subnetIds: string[];
        /**
         * Tags.
         */
        tags: outputs.autoscaling.GetScalingGroupsScalingGroupTag[];
        /**
         * The total instance count of the scaling group.
         */
        totalInstanceCount: number;
        /**
         * The create time of the scaling group.
         */
        updatedAt: string;
        /**
         * The VPC id of the scaling group.
         */
        vpcId: string;
    }

    export interface GetScalingGroupsScalingGroupLaunchTemplateOverride {
        /**
         * The instance type.
         */
        instanceType: string;
        /**
         * Weight of instance specifications.
         */
        weightedCapacity: number;
    }

    export interface GetScalingGroupsScalingGroupServerGroupAttribute {
        /**
         * The load balancer id.
         */
        loadBalancerId: string;
        /**
         * The port receiving request of the server group.
         */
        port: number;
        /**
         * The server group id.
         */
        serverGroupId: string;
        /**
         * The weight of the instance.
         */
        weight: number;
    }

    export interface GetScalingGroupsScalingGroupTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetScalingInstancesScalingInstance {
        /**
         * The time when the instance was added to the scaling group.
         */
        createdTime: string;
        /**
         * The creation type of the instances. Valid values: AutoCreated, Attached.
         */
        creationType: string;
        /**
         * Whether to host the instance to a scaling group.
         */
        entrusted: boolean;
        /**
         * The id of the scaling instance.
         */
        id: string;
        /**
         * The id of the scaling instance.
         */
        instanceId: string;
        /**
         * The id of the scaling configuration id.
         */
        scalingConfigurationId: string;
        /**
         * The id of the scaling group.
         */
        scalingGroupId: string;
        /**
         * The id of the scaling policy.
         */
        scalingPolicyId: string;
        /**
         * The status of instances. Valid values: Init, Pending, Pending:Wait, InService, Error, Removing, Removing:Wait, Stopped, Protected.
         */
        status: string;
    }

    export interface GetScalingLifecycleHooksLifecycleHook {
        /**
         * The id of the lifecycle hook.
         */
        id: string;
        /**
         * Batch job command.
         */
        lifecycleCommands: outputs.autoscaling.GetScalingLifecycleHooksLifecycleHookLifecycleCommand[];
        /**
         * The id of the lifecycle hook.
         */
        lifecycleHookId: string;
        /**
         * The name of the lifecycle hook.
         */
        lifecycleHookName: string;
        /**
         * The policy of the lifecycle hook.
         */
        lifecycleHookPolicy: string;
        /**
         * The timeout of the lifecycle hook.
         */
        lifecycleHookTimeout: number;
        /**
         * The type of the lifecycle hook.
         */
        lifecycleHookType: string;
        /**
         * An id of scaling group id.
         */
        scalingGroupId: string;
    }

    export interface GetScalingLifecycleHooksLifecycleHookLifecycleCommand {
        /**
         * Batch job command ID, which indicates the batch job command to be executed after triggering the lifecycle hook and installed in the instance.
         */
        commandId: string;
        /**
         * Parameters and parameter values in batch job commands.
         * The number of parameters ranges from 0 to 60.
         */
        parameters: string;
    }

    export interface GetScalingPoliciesScalingPolicy {
        /**
         * The adjustment type of the scaling policy.
         */
        adjustmentType: string;
        /**
         * The adjustment value of the scaling policy.
         */
        adjustmentValue: number;
        /**
         * The comparison operator of the alarm policy condition of the scaling policy.
         */
        alarmPolicyConditionComparisonOperator: string;
        /**
         * The metric name of the alarm policy condition of the scaling policy.
         */
        alarmPolicyConditionMetricName: string;
        /**
         * The comparison operator of the alarm policy condition of the scaling policy.
         */
        alarmPolicyConditionMetricUnit: string;
        /**
         * The threshold of the alarm policy condition of the scaling policy.
         */
        alarmPolicyConditionThreshold: string;
        /**
         * The evaluation count of the alarm policy of the scaling policy.
         */
        alarmPolicyEvaluationCount: number;
        /**
         * The rule type of the alarm policy of the scaling policy.
         */
        alarmPolicyRuleType: string;
        /**
         * The cooldown of the scaling policy.
         */
        cooldown: number;
        /**
         * The id of the scaling policy.
         */
        id: string;
        /**
         * An id of the scaling group to which the scaling policy belongs.
         */
        scalingGroupId: string;
        /**
         * The id of the scaling policy.
         */
        scalingPolicyId: string;
        /**
         * The name of the scaling policy.
         */
        scalingPolicyName: string;
        /**
         * A type of scaling policy. Valid values: Scheduled, Recurrence, Manual, Alarm.
         */
        scalingPolicyType: string;
        /**
         * The launch time of the scheduled policy of the scaling policy.
         */
        scheduledPolicyLaunchTime: string;
        /**
         * The recurrence end time of the scheduled policy of the scaling policy.
         */
        scheduledPolicyRecurrenceEndTime: string;
        /**
         * The recurrence start time of the scheduled policy of the scaling policy.
         */
        scheduledPolicyRecurrenceStartTime: string;
        /**
         * The recurrence type of the scheduled policy of the scaling policy.
         */
        scheduledPolicyRecurrenceType: string;
        /**
         * The recurrence value of the scheduled policy of the scaling policy.
         */
        scheduledPolicyRecurrenceValue: string;
        /**
         * The status of the scaling policy.
         */
        status: string;
    }

    export interface ScalingActivitiesActivity {
        /**
         * The Actual Type.
         */
        activityType: string;
        /**
         * The Actual Adjustment Instance Number.
         */
        actualAdjustInstanceNumber: number;
        /**
         * The Cooldown time.
         */
        cooldown: number;
        /**
         * The create time of Scaling Activity.
         */
        createdAt: string;
        /**
         * The Current Instance Number.
         */
        currentInstanceNumber: number;
        /**
         * The expected run time of Scaling Activity.
         */
        expectedRunTime: string;
        /**
         * The ID of Scaling Activity.
         */
        id: string;
        /**
         * The Max Instance Number.
         */
        maxInstanceNumber: number;
        /**
         * The Min Instance Number.
         */
        minInstanceNumber: number;
        /**
         * The related instances.
         */
        relatedInstances: outputs.autoscaling.ScalingActivitiesActivityRelatedInstance[];
        /**
         * The Result of Scaling Activity.
         */
        resultMsg: string;
        /**
         * The ID of Scaling Activity.
         */
        scalingActivityId: string;
        /**
         * A Id of Scaling Group.
         */
        scalingGroupId: string;
        /**
         * A status code of Scaling Activity. Valid values: Init, Running, Success, PartialSuccess, Error, Rejected, Exception.
         */
        statusCode: string;
        /**
         * The stopped time of Scaling Activity.
         */
        stoppedAt: string;
        /**
         * The task category of Scaling Activity.
         */
        taskCategory: string;
    }

    export interface ScalingActivitiesActivityRelatedInstance {
        /**
         * The Instance ID.
         */
        instanceId: string;
        /**
         * The message of Instance.
         */
        message: string;
        /**
         * The Operation Type.
         */
        operateType: string;
        /**
         * The Status.
         */
        status: string;
    }

    export interface ScalingConfigurationTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface ScalingConfigurationVolume {
        /**
         * The delete with instance flag of volume. Valid values: true, false. Default value: true.
         */
        deleteWithInstance?: boolean;
        /**
         * The size of volume. System disk value range: 10 - 500. The value range of the data disk: 10 - 8192.
         */
        size: number;
        /**
         * The type of volume.
         */
        volumeType: string;
    }

    export interface ScalingConfigurationsScalingConfiguration {
        /**
         * The create time of the scaling configuration.
         */
        createdAt: string;
        /**
         * The EIP bandwidth which the scaling configuration set.
         */
        eipBandwidth: number;
        /**
         * The EIP ISP which the scaling configuration set.
         */
        eipBillingType: string;
        /**
         * The EIP ISP which the scaling configuration set.
         */
        eipIsp: string;
        /**
         * The ECS hostname which the scaling configuration set.
         */
        hostName: string;
        /**
         * The ID of the HPC cluster to which the instance belongs. Valid only when InstanceTypes.N specifies High Performance Computing GPU Type.
         */
        hpcClusterId: string;
        /**
         * The id of the scaling configuration.
         */
        id: string;
        /**
         * The ECS image id which the scaling configuration set.
         */
        imageId: string;
        /**
         * The ECS instance description which the scaling configuration set.
         */
        instanceDescription: string;
        /**
         * The ECS instance name which the scaling configuration set.
         */
        instanceName: string;
        /**
         * The list of the ECS instance type which the scaling configuration set.
         */
        instanceTypes: string[];
        /**
         * Assign IPv6 address to instance network card. Possible values:
         * 0: Do not assign IPv6 address.
         * 1: Assign IPv6 address and the system will automatically assign an IPv6 subnet for you.
         */
        ipv6AddressCount: number;
        /**
         * The ECS key pair name which the scaling configuration set.
         */
        keyPairName: string;
        /**
         * The lifecycle state of the scaling configuration.
         */
        lifecycleState: string;
        /**
         * The project to which the instance created by the scaling configuration belongs.
         */
        projectName: string;
        /**
         * The id of the scaling configuration.
         */
        scalingConfigurationId: string;
        /**
         * The name of the scaling configuration.
         */
        scalingConfigurationName: string;
        /**
         * An id of scaling group.
         */
        scalingGroupId: string;
        /**
         * The Ecs security enhancement strategy which the scaling configuration set.
         */
        securityEnhancementStrategy: string;
        /**
         * The list of the security group id of the networkInterface which the scaling configuration set.
         */
        securityGroupIds: string[];
        /**
         * The preemption policy of the instance. Valid Value: NoSpot (default), SpotAsPriceGo.
         */
        spotStrategy: string;
        /**
         * The label of the instance created by the scaling configuration.
         */
        tags: outputs.autoscaling.ScalingConfigurationsScalingConfigurationTag[];
        /**
         * The create time of the scaling configuration.
         */
        updatedAt: string;
        /**
         * The ECS user data which the scaling configuration set.
         */
        userData: string;
        /**
         * The list of volume of the scaling configuration.
         */
        volumes: outputs.autoscaling.ScalingConfigurationsScalingConfigurationVolume[];
    }

    export interface ScalingConfigurationsScalingConfigurationTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface ScalingConfigurationsScalingConfigurationVolume {
        /**
         * The delete with instance flag of volume.
         */
        deleteWithInstance: boolean;
        /**
         * The size of volume.
         */
        size: number;
        /**
         * The type of volume.
         */
        volumeType: string;
    }

    export interface ScalingGroupLaunchTemplateOverride {
        /**
         * The instance type.
         */
        instanceType: string;
    }

    export interface ScalingGroupServerGroupAttribute {
        /**
         * The load balancer id.
         */
        loadBalancerId: string;
        /**
         * The port receiving request of the server group. Value range: 1 ~ 65535.
         */
        port: number;
        /**
         * The id of the server group.
         */
        serverGroupId: string;
        /**
         * The weight of the instance. Value range: 0 ~ 100.
         */
        weight: number;
    }

    export interface ScalingGroupTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface ScalingGroupsScalingGroup {
        /**
         * The scaling configuration id which used by the scaling group.
         */
        activeScalingConfigurationId: string;
        /**
         * The create time of the scaling group.
         */
        createdAt: string;
        /**
         * The list of db instance ids.
         */
        dbInstanceIds: string[];
        /**
         * The default cooldown interval of the scaling group.
         */
        defaultCooldown: number;
        /**
         * The desire instance number of the scaling group.
         */
        desireInstanceNumber: number;
        /**
         * The health check type of the scaling group.
         */
        healthCheckType: string;
        /**
         * The id of the scaling group.
         */
        id: string;
        /**
         * The instance terminate policy of the scaling group.
         */
        instanceTerminatePolicy: string;
        /**
         * The ID of the launch template bound to the scaling group.
         */
        launchTemplateId: string;
        /**
         * Instance start template information.
         */
        launchTemplateOverrides: outputs.autoscaling.ScalingGroupsScalingGroupLaunchTemplateOverride[];
        /**
         * The version of the launch template bound to the scaling group.
         */
        launchTemplateVersion: string;
        /**
         * The lifecycle state of the scaling group.
         */
        lifecycleState: string;
        /**
         * Grace period for health check of CLB instance in elastic group.
         */
        loadBalancerHealthCheckGracePeriod: number;
        /**
         * The max instance number of the scaling group.
         */
        maxInstanceNumber: number;
        /**
         * The min instance number of the scaling group.
         */
        minInstanceNumber: number;
        /**
         * The multi az policy of the scaling group. Valid values: PRIORITY, BALANCE.
         */
        multiAzPolicy: string;
        /**
         * The project name of the scaling group.
         */
        projectName: string;
        /**
         * The id of the scaling group.
         */
        scalingGroupId: string;
        /**
         * The name of the scaling group.
         */
        scalingGroupName: string;
        /**
         * The scaling mode of the scaling group.
         */
        scalingMode: string;
        /**
         * The list of server group attributes.
         */
        serverGroupAttributes: outputs.autoscaling.ScalingGroupsScalingGroupServerGroupAttribute[];
        /**
         * The number of stopped instances.
         */
        stoppedInstanceCount: number;
        /**
         * The list of the subnet id to which the ENI is connected.
         */
        subnetIds: string[];
        /**
         * Tags.
         */
        tags: outputs.autoscaling.ScalingGroupsScalingGroupTag[];
        /**
         * The total instance count of the scaling group.
         */
        totalInstanceCount: number;
        /**
         * The create time of the scaling group.
         */
        updatedAt: string;
        /**
         * The VPC id of the scaling group.
         */
        vpcId: string;
    }

    export interface ScalingGroupsScalingGroupLaunchTemplateOverride {
        /**
         * The instance type.
         */
        instanceType: string;
        /**
         * Weight of instance specifications.
         */
        weightedCapacity: number;
    }

    export interface ScalingGroupsScalingGroupServerGroupAttribute {
        /**
         * The load balancer id.
         */
        loadBalancerId: string;
        /**
         * The port receiving request of the server group.
         */
        port: number;
        /**
         * The server group id.
         */
        serverGroupId: string;
        /**
         * The weight of the instance.
         */
        weight: number;
    }

    export interface ScalingGroupsScalingGroupTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface ScalingInstancesScalingInstance {
        /**
         * The time when the instance was added to the scaling group.
         */
        createdTime: string;
        /**
         * The creation type of the instances. Valid values: AutoCreated, Attached.
         */
        creationType: string;
        /**
         * Whether to host the instance to a scaling group.
         */
        entrusted: boolean;
        /**
         * The id of the scaling instance.
         */
        id: string;
        /**
         * The id of the scaling instance.
         */
        instanceId: string;
        /**
         * The id of the scaling configuration id.
         */
        scalingConfigurationId: string;
        /**
         * The id of the scaling group.
         */
        scalingGroupId: string;
        /**
         * The id of the scaling policy.
         */
        scalingPolicyId: string;
        /**
         * The status of instances. Valid values: Init, Pending, Pending:Wait, InService, Error, Removing, Removing:Wait, Stopped, Protected.
         */
        status: string;
    }

    export interface ScalingLifecycleHookLifecycleCommand {
        /**
         * Batch job command ID, which indicates the batch job command to be executed after triggering the lifecycle hook and installed in the instance.
         */
        commandId: string;
        /**
         * Parameters and parameter values in batch job commands.
         * The number of parameters ranges from 0 to 60.
         */
        parameters?: string;
    }

    export interface ScalingLifecycleHooksLifecycleHook {
        /**
         * The id of the lifecycle hook.
         */
        id: string;
        /**
         * Batch job command.
         */
        lifecycleCommands: outputs.autoscaling.ScalingLifecycleHooksLifecycleHookLifecycleCommand[];
        /**
         * The id of the lifecycle hook.
         */
        lifecycleHookId: string;
        /**
         * The name of the lifecycle hook.
         */
        lifecycleHookName: string;
        /**
         * The policy of the lifecycle hook.
         */
        lifecycleHookPolicy: string;
        /**
         * The timeout of the lifecycle hook.
         */
        lifecycleHookTimeout: number;
        /**
         * The type of the lifecycle hook.
         */
        lifecycleHookType: string;
        /**
         * An id of scaling group id.
         */
        scalingGroupId: string;
    }

    export interface ScalingLifecycleHooksLifecycleHookLifecycleCommand {
        /**
         * Batch job command ID, which indicates the batch job command to be executed after triggering the lifecycle hook and installed in the instance.
         */
        commandId: string;
        /**
         * Parameters and parameter values in batch job commands.
         * The number of parameters ranges from 0 to 60.
         */
        parameters: string;
    }

    export interface ScalingPoliciesScalingPolicy {
        /**
         * The adjustment type of the scaling policy.
         */
        adjustmentType: string;
        /**
         * The adjustment value of the scaling policy.
         */
        adjustmentValue: number;
        /**
         * The comparison operator of the alarm policy condition of the scaling policy.
         */
        alarmPolicyConditionComparisonOperator: string;
        /**
         * The metric name of the alarm policy condition of the scaling policy.
         */
        alarmPolicyConditionMetricName: string;
        /**
         * The comparison operator of the alarm policy condition of the scaling policy.
         */
        alarmPolicyConditionMetricUnit: string;
        /**
         * The threshold of the alarm policy condition of the scaling policy.
         */
        alarmPolicyConditionThreshold: string;
        /**
         * The evaluation count of the alarm policy of the scaling policy.
         */
        alarmPolicyEvaluationCount: number;
        /**
         * The rule type of the alarm policy of the scaling policy.
         */
        alarmPolicyRuleType: string;
        /**
         * The cooldown of the scaling policy.
         */
        cooldown: number;
        /**
         * The id of the scaling policy.
         */
        id: string;
        /**
         * An id of the scaling group to which the scaling policy belongs.
         */
        scalingGroupId: string;
        /**
         * The id of the scaling policy.
         */
        scalingPolicyId: string;
        /**
         * The name of the scaling policy.
         */
        scalingPolicyName: string;
        /**
         * A type of scaling policy. Valid values: Scheduled, Recurrence, Manual, Alarm.
         */
        scalingPolicyType: string;
        /**
         * The launch time of the scheduled policy of the scaling policy.
         */
        scheduledPolicyLaunchTime: string;
        /**
         * The recurrence end time of the scheduled policy of the scaling policy.
         */
        scheduledPolicyRecurrenceEndTime: string;
        /**
         * The recurrence start time of the scheduled policy of the scaling policy.
         */
        scheduledPolicyRecurrenceStartTime: string;
        /**
         * The recurrence type of the scheduled policy of the scaling policy.
         */
        scheduledPolicyRecurrenceType: string;
        /**
         * The recurrence value of the scheduled policy of the scaling policy.
         */
        scheduledPolicyRecurrenceValue: string;
        /**
         * The status of the scaling policy.
         */
        status: string;
    }

}

export namespace bandwidth_package {
    export interface BandwidthPackageTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface BandwidthPackagesPackage {
        /**
         * The bandwidth of the bandwidth package.
         */
        bandwidth: number;
        /**
         * The id of the bandwidth package.
         */
        bandwidthPackageId: string;
        /**
         * Shared bandwidth package name to be queried.
         */
        bandwidthPackageName: string;
        /**
         * The billing type of the bandwidth package.
         */
        billingType: string;
        /**
         * The business status of the bandwidth package.
         */
        businessStatus: string;
        /**
         * The creation time of the bandwidth package.
         */
        creationTime: string;
        /**
         * The deleted time of the bandwidth package.
         */
        deletedTime: string;
        /**
         * List of public IP information included in the shared bandwidth package.
         */
        eipAddresses: outputs.bandwidth_package.BandwidthPackagesPackageEipAddress[];
        /**
         * The expiration time of the bandwidth package.
         */
        expiredTime: string;
        /**
         * The id of the bandwidth package.
         */
        id: string;
        /**
         * Line types for shared bandwidth packages.
         */
        isp: string;
        /**
         * The overdue time of the bandwidth package.
         */
        overdueTime: string;
        /**
         * The project name of the bandwidth package to be queried.
         */
        projectName: string;
        /**
         * The IP protocol values for shared bandwidth packages are as follows: `IPv4`: IPv4 protocol. `IPv6`: IPv6 protocol.
         */
        protocol: string;
        /**
         * Security protection types for shared bandwidth packages. Parameter - N: Indicates the number of security protection types, currently only supports taking 1. Value: `AntiDDoS_Enhanced`.
         */
        securityProtectionTypes: string[];
        /**
         * The status of the bandwidth package.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.bandwidth_package.BandwidthPackagesPackageTag[];
        /**
         * The update time of the bandwidth package.
         */
        updateTime: string;
    }

    export interface BandwidthPackagesPackageEipAddress {
        /**
         * The id of the eip.
         */
        allocationId: string;
        /**
         * The eip address.
         */
        eipAddress: string;
    }

    export interface BandwidthPackagesPackageTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface BandwidthPackagesTagFilter {
        /**
         * The key of the tag.
         */
        key: string;
        /**
         * The values of the tag.
         */
        values: string[];
    }

    export interface GetBandwidthPackagesPackage {
        /**
         * The bandwidth of the bandwidth package.
         */
        bandwidth: number;
        /**
         * The id of the bandwidth package.
         */
        bandwidthPackageId: string;
        /**
         * Shared bandwidth package name to be queried.
         */
        bandwidthPackageName: string;
        /**
         * The billing type of the bandwidth package.
         */
        billingType: string;
        /**
         * The business status of the bandwidth package.
         */
        businessStatus: string;
        /**
         * The creation time of the bandwidth package.
         */
        creationTime: string;
        /**
         * The deleted time of the bandwidth package.
         */
        deletedTime: string;
        /**
         * List of public IP information included in the shared bandwidth package.
         */
        eipAddresses: outputs.bandwidth_package.GetBandwidthPackagesPackageEipAddress[];
        /**
         * The expiration time of the bandwidth package.
         */
        expiredTime: string;
        /**
         * The id of the bandwidth package.
         */
        id: string;
        /**
         * Line types for shared bandwidth packages.
         */
        isp: string;
        /**
         * The overdue time of the bandwidth package.
         */
        overdueTime: string;
        /**
         * The project name of the bandwidth package to be queried.
         */
        projectName: string;
        /**
         * The IP protocol values for shared bandwidth packages are as follows: `IPv4`: IPv4 protocol. `IPv6`: IPv6 protocol.
         */
        protocol: string;
        /**
         * Security protection types for shared bandwidth packages. Parameter - N: Indicates the number of security protection types, currently only supports taking 1. Value: `AntiDDoS_Enhanced`.
         */
        securityProtectionTypes: string[];
        /**
         * The status of the bandwidth package.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.bandwidth_package.GetBandwidthPackagesPackageTag[];
        /**
         * The update time of the bandwidth package.
         */
        updateTime: string;
    }

    export interface GetBandwidthPackagesPackageEipAddress {
        /**
         * The id of the eip.
         */
        allocationId: string;
        /**
         * The eip address.
         */
        eipAddress: string;
    }

    export interface GetBandwidthPackagesPackageTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetBandwidthPackagesTagFilter {
        /**
         * The key of the tag.
         */
        key: string;
        /**
         * The values of the tag.
         */
        values: string[];
    }

}

export namespace bioos {
    export interface ClusterSharedConfig {
        /**
         * Whether to enable a shared cluster. This value must be `true`.
         */
        enable: boolean;
    }

    export interface ClusterVkeConfig {
        /**
         * The id of the vke cluster.
         */
        clusterId: string;
        /**
         * The name of the StorageClass that the vke cluster has installed.
         */
        storageClass: string;
    }

    export interface ClustersItem {
        /**
         * Whether there is a bound workspace.
         */
        bound: boolean;
        /**
         * The description of the cluster.
         */
        description: string;
        /**
         * The id of the bioos cluster.
         */
        id: string;
        /**
         * The name of the cluster.
         */
        name: string;
        /**
         * whether it is a public cluster.
         */
        public: boolean;
        /**
         * The configuration of the shared cluster.
         */
        sharedConfigs: outputs.bioos.ClustersItemSharedConfig[];
        /**
         * The start time of the cluster.
         */
        startTime: number;
        /**
         * The status of the clusters.
         */
        status: string;
        /**
         * The end time of the cluster.
         */
        stoppedTime: number;
        /**
         * The id of the vke cluster.
         */
        vkeConfigId: string;
        /**
         * The name of the StorageClass that the vke cluster has installed.
         */
        vkeConfigStorageClass: string;
    }

    export interface ClustersItemSharedConfig {
        /**
         * Whether to enable a shared cluster. This value must be `true`.
         */
        enable: boolean;
    }

    export interface GetClustersItem {
        /**
         * Whether there is a bound workspace.
         */
        bound: boolean;
        /**
         * The description of the cluster.
         */
        description: string;
        /**
         * The id of the bioos cluster.
         */
        id: string;
        /**
         * The name of the cluster.
         */
        name: string;
        /**
         * whether it is a public cluster.
         */
        public: boolean;
        /**
         * The configuration of the shared cluster.
         */
        sharedConfigs: outputs.bioos.GetClustersItemSharedConfig[];
        /**
         * The start time of the cluster.
         */
        startTime: number;
        /**
         * The status of the clusters.
         */
        status: string;
        /**
         * The end time of the cluster.
         */
        stoppedTime: number;
        /**
         * The id of the vke cluster.
         */
        vkeConfigId: string;
        /**
         * The name of the StorageClass that the vke cluster has installed.
         */
        vkeConfigStorageClass: string;
    }

    export interface GetClustersItemSharedConfig {
        /**
         * Whether to enable a shared cluster. This value must be `true`.
         */
        enable: boolean;
    }

    export interface GetWorkspacesItem {
        /**
         * The URL of the cover.
         */
        coverDownloadUrl: string;
        /**
         * The creation time of the workspace.
         */
        createTime: number;
        /**
         * The description of the workspace.
         */
        description: string;
        /**
         * The id of the workspace.
         */
        id: string;
        /**
         * The name of the workspace.
         */
        name: string;
        /**
         * The name of the owner of the workspace.
         */
        ownerName: string;
        /**
         * The role of the user.
         */
        role: string;
        /**
         * S3 bucket address.
         */
        s3Bucket: string;
        /**
         * The update time of the workspace.
         */
        updateTime: number;
    }

    export interface WorkspacesItem {
        /**
         * The URL of the cover.
         */
        coverDownloadUrl: string;
        /**
         * The creation time of the workspace.
         */
        createTime: number;
        /**
         * The description of the workspace.
         */
        description: string;
        /**
         * The id of the workspace.
         */
        id: string;
        /**
         * The name of the workspace.
         */
        name: string;
        /**
         * The name of the owner of the workspace.
         */
        ownerName: string;
        /**
         * The role of the user.
         */
        role: string;
        /**
         * S3 bucket address.
         */
        s3Bucket: string;
        /**
         * The update time of the workspace.
         */
        updateTime: number;
    }

}

export namespace cdn {
    export interface CdnDomainSharedCname {
        /**
         * Assign a CNAME to the accelerated domain.
         */
        cname: string;
        /**
         * Specify whether to enable shared CNAME.
         */
        switch: boolean;
    }

    export interface CdnDomainTag {
        /**
         * The key of the tag.
         */
        key: string;
        /**
         * The value of the tag.
         */
        value: string;
    }

    export interface CertificatesCertInfo {
        /**
         * ID indicating the certificate.
         */
        certId: string;
        /**
         * The domain name to which the certificate is issued.
         */
        certName: string;
        /**
         * The domain name associated with the certificate. If the certificate is not yet associated with any domain name, the parameter value is null.
         */
        configuredDomain: string;
        /**
         * The remark of the cert.
         */
        desc: string;
        /**
         * The domain names included in the SAN field of the certificate.
         */
        dnsName: string;
        /**
         * The issuance time of the certificate is indicated. The unit is Unix timestamp.
         */
        effectiveTime: number;
        /**
         * The expiration time of the certificate is indicated. The unit is Unix timestamp.
         */
        expireTime: number;
        /**
         * Specify the location for storing the certificate. The parameter can take the following values: `volcCertCenter`: indicates that the certificate will be stored in the certificate center.`cdnCertHosting`: indicates that the certificate will be hosted on the content delivery network.
         */
        source: string;
        /**
         * Specify one or more states to retrieve certificates in those states. By default, all certificates in all states are returned. You can specify the following states. Multiple states are separated by commas. running: Retrieves certificates with a validity period greater than 30 days. expired: Retrieves certificates that have already expired. expiring_soon: Retrieves certificates with a validity period less than or equal to 30 days but have not yet expired.
         */
        status: string;
    }

    export interface ConfigsDomainConfig {
        /**
         * The cname of the domain.
         */
        cname: string;
        /**
         * The create time of the domain.
         */
        createTime: number;
        /**
         * The domain name.
         */
        domain: string;
        /**
         * Indicates whether the configuration of this domain name is allowed to be changed.
         */
        lockStatus: string;
        /**
         * The project name.
         */
        project: string;
        /**
         * The service region of the domain.
         */
        serviceRegion: string;
        /**
         * The service type of the domain.
         */
        serviceType: string;
        /**
         * The status of the domain.
         */
        status: string;
        /**
         * The update time of the domain.
         */
        updateTime: number;
    }

    export interface DomainsDomain {
        /**
         * The list of backup origin servers for accelerating this domain name. If no backup origin server is configured for this acceleration domain name, the parameter value is null.
         */
        backupOrigins: string[];
        /**
         * Indicates the role of the accelerated domain in the shared cache configuration. This parameter can take the following values: `targetHost`: Indicates that there is a shared cache configuration where the role of the accelerated domain is the target domain.`cacheSharedOn`: Indicates that there is a shared cache configuration where the role of the accelerated domain is the configured domain.`""`: This parameter value is empty, indicating that the accelerated domain does not exist in any shared cache configuration.
         */
        cacheShared: string;
        /**
         * If CacheShared is cache_shared_on, it means the target domain name that shares cache with the accelerated domain name. If CacheShared is targetHost or an empty value, the parameter value is empty.
         */
        cacheSharedTargetHost: string;
        /**
         * The CNAME address of the domain is automatically assigned when adding the domain.
         */
        cname: string;
        /**
         * The creation time of the domain.
         */
        createTime: number;
        /**
         * Search by specifying domain name keywords, with fuzzy matching.
         */
        domain: string;
        /**
         * Indicates the locked status of the accelerated domain.
         */
        domainLocks: outputs.cdn.DomainsDomainDomainLock[];
        /**
         * Specify HTTPS configuration to filter accelerated domains. The optional values for this parameter are as follows: `true`: Indicates that the accelerated domain has enabled HTTPS function.`false`: Indicates that the accelerated domain has not enabled HTTPS function.
         */
        https: boolean;
        /**
         * Specify IPv6 configuration to filter accelerated domain names. The optional values for this parameter are as follows: `true`: Indicates that the accelerated domain name supports requests using IPv6 addresses.`false`: Indicates that the accelerated domain name does not support requests using IPv6 addresses.
         */
        ipv6: boolean;
        /**
         * Indicates whether the accelerated domain name is a conflicting domain name. By default, each accelerated domain name is unique in the content delivery network. If you need to add an accelerated domain name that already exists in the content delivery network, you need to submit a ticket. If the domain name is added successfully, it becomes a conflicting domain name.
         */
        isConflictDomain: boolean;
        /**
         * Configure the origin protocol for the accelerated domain.
         */
        originProtocol: string;
        /**
         * Specify a primary origin server for filtering accelerated domains.
         */
        primaryOrigins: string[];
        /**
         * The project name of the domain.
         */
        project: string;
        /**
         * Indicates the acceleration area. The parameter can take the following values: `chineseMainland`: Indicates mainland China. `global`: Indicates global. `outsideChineseMainland`: Indicates global (excluding mainland China).
         */
        serviceRegion: string;
        /**
         * The business type of the domain name is indicated by this parameter. The possible values are: `download`: for file downloads. `web`: for web pages. `video`: for audio and video on demand.
         */
        serviceType: string;
        /**
         * The status of the domain.
         */
        status: string;
        /**
         * Filter by specified domain name tags, up to 10 tags can be specified. Each tag is entered as a string in the format of key:value.
         */
        tags: outputs.cdn.DomainsDomainTag[];
        /**
         * The update time of the domain.
         */
        updateTime: number;
    }

    export interface DomainsDomainDomainLock {
        /**
         * If the Status is on, this parameter value records the reason for the lock.
         */
        remark: string;
        /**
         * The status of the domain.
         */
        status: string;
    }

    export interface DomainsDomainTag {
        /**
         * The key of the tag.
         */
        key: string;
        /**
         * The value of the tag.
         */
        value: string;
    }

    export interface GetCertificatesCertInfo {
        /**
         * ID indicating the certificate.
         */
        certId: string;
        /**
         * The domain name to which the certificate is issued.
         */
        certName: string;
        /**
         * The domain name associated with the certificate. If the certificate is not yet associated with any domain name, the parameter value is null.
         */
        configuredDomain: string;
        /**
         * The remark of the cert.
         */
        desc: string;
        /**
         * The domain names included in the SAN field of the certificate.
         */
        dnsName: string;
        /**
         * The issuance time of the certificate is indicated. The unit is Unix timestamp.
         */
        effectiveTime: number;
        /**
         * The expiration time of the certificate is indicated. The unit is Unix timestamp.
         */
        expireTime: number;
        /**
         * Specify the location for storing the certificate. The parameter can take the following values: `volcCertCenter`: indicates that the certificate will be stored in the certificate center.`cdnCertHosting`: indicates that the certificate will be hosted on the content delivery network.
         */
        source: string;
        /**
         * Specify one or more states to retrieve certificates in those states. By default, all certificates in all states are returned. You can specify the following states. Multiple states are separated by commas. running: Retrieves certificates with a validity period greater than 30 days. expired: Retrieves certificates that have already expired. expiring_soon: Retrieves certificates with a validity period less than or equal to 30 days but have not yet expired.
         */
        status: string;
    }

    export interface GetConfigsDomainConfig {
        /**
         * The cname of the domain.
         */
        cname: string;
        /**
         * The create time of the domain.
         */
        createTime: number;
        /**
         * The domain name.
         */
        domain: string;
        /**
         * Indicates whether the configuration of this domain name is allowed to be changed.
         */
        lockStatus: string;
        /**
         * The project name.
         */
        project: string;
        /**
         * The service region of the domain.
         */
        serviceRegion: string;
        /**
         * The service type of the domain.
         */
        serviceType: string;
        /**
         * The status of the domain.
         */
        status: string;
        /**
         * The update time of the domain.
         */
        updateTime: number;
    }

    export interface GetDomainsDomain {
        /**
         * The list of backup origin servers for accelerating this domain name. If no backup origin server is configured for this acceleration domain name, the parameter value is null.
         */
        backupOrigins: string[];
        /**
         * Indicates the role of the accelerated domain in the shared cache configuration. This parameter can take the following values: `targetHost`: Indicates that there is a shared cache configuration where the role of the accelerated domain is the target domain.`cacheSharedOn`: Indicates that there is a shared cache configuration where the role of the accelerated domain is the configured domain.`""`: This parameter value is empty, indicating that the accelerated domain does not exist in any shared cache configuration.
         */
        cacheShared: string;
        /**
         * If CacheShared is cache_shared_on, it means the target domain name that shares cache with the accelerated domain name. If CacheShared is targetHost or an empty value, the parameter value is empty.
         */
        cacheSharedTargetHost: string;
        /**
         * The CNAME address of the domain is automatically assigned when adding the domain.
         */
        cname: string;
        /**
         * The creation time of the domain.
         */
        createTime: number;
        /**
         * Search by specifying domain name keywords, with fuzzy matching.
         */
        domain: string;
        /**
         * Indicates the locked status of the accelerated domain.
         */
        domainLocks: outputs.cdn.GetDomainsDomainDomainLock[];
        /**
         * Specify HTTPS configuration to filter accelerated domains. The optional values for this parameter are as follows: `true`: Indicates that the accelerated domain has enabled HTTPS function.`false`: Indicates that the accelerated domain has not enabled HTTPS function.
         */
        https: boolean;
        /**
         * Specify IPv6 configuration to filter accelerated domain names. The optional values for this parameter are as follows: `true`: Indicates that the accelerated domain name supports requests using IPv6 addresses.`false`: Indicates that the accelerated domain name does not support requests using IPv6 addresses.
         */
        ipv6: boolean;
        /**
         * Indicates whether the accelerated domain name is a conflicting domain name. By default, each accelerated domain name is unique in the content delivery network. If you need to add an accelerated domain name that already exists in the content delivery network, you need to submit a ticket. If the domain name is added successfully, it becomes a conflicting domain name.
         */
        isConflictDomain: boolean;
        /**
         * Configure the origin protocol for the accelerated domain.
         */
        originProtocol: string;
        /**
         * Specify a primary origin server for filtering accelerated domains.
         */
        primaryOrigins: string[];
        /**
         * The project name of the domain.
         */
        project: string;
        /**
         * Indicates the acceleration area. The parameter can take the following values: `chineseMainland`: Indicates mainland China. `global`: Indicates global. `outsideChineseMainland`: Indicates global (excluding mainland China).
         */
        serviceRegion: string;
        /**
         * The business type of the domain name is indicated by this parameter. The possible values are: `download`: for file downloads. `web`: for web pages. `video`: for audio and video on demand.
         */
        serviceType: string;
        /**
         * The status of the domain.
         */
        status: string;
        /**
         * Filter by specified domain name tags, up to 10 tags can be specified. Each tag is entered as a string in the format of key:value.
         */
        tags: outputs.cdn.GetDomainsDomainTag[];
        /**
         * The update time of the domain.
         */
        updateTime: number;
    }

    export interface GetDomainsDomainDomainLock {
        /**
         * If the Status is on, this parameter value records the reason for the lock.
         */
        remark: string;
        /**
         * The status of the domain.
         */
        status: string;
    }

    export interface GetDomainsDomainTag {
        /**
         * The key of the tag.
         */
        key: string;
        /**
         * The value of the tag.
         */
        value: string;
    }

    export interface GetSharedConfigsConfigData {
        /**
         * The configuration for IP whitelist corresponds to ConfigType allow_ip_access_rule.
         */
        allowIpAccessRules: outputs.cdn.GetSharedConfigsConfigDataAllowIpAccessRule[];
        /**
         * The configuration for the Referer whitelist corresponds to ConfigType allow_referer_access_rule.
         */
        allowRefererAccessRules: outputs.cdn.GetSharedConfigsConfigDataAllowRefererAccessRule[];
        /**
         * The configuration for a common list is represented by ConfigType common_match_list.
         */
        commonMatchLists: outputs.cdn.GetSharedConfigsConfigDataCommonMatchList[];
        /**
         * The name of the shared config.
         */
        configName: string;
        /**
         * The type of the shared config.
         */
        configType: string;
        /**
         * The configuration for IP blacklist is denoted by ConfigType deny_ip_access_rule.
         */
        denyIpAccessRules: outputs.cdn.GetSharedConfigsConfigDataDenyIpAccessRule[];
        /**
         * The configuration for the Referer blacklist corresponds to ConfigType deny_referer_access_rule.
         */
        denyRefererAccessRules: outputs.cdn.GetSharedConfigsConfigDataDenyRefererAccessRule[];
        /**
         * The number of domains.
         */
        domainCount: number;
        /**
         * The name of the project.
         */
        projectName: string;
        /**
         * The update time of the shared config.
         */
        updateTime: number;
    }

    export interface GetSharedConfigsConfigDataAllowIpAccessRule {
        /**
         * The entries in this list are an array of IP addresses and CIDR network segments. The total number of entries cannot exceed 3,000. The IP addresses and segments can be in IPv4 and IPv6 format. Duplicate entries in the list will be removed and will not count towards the limit.
         */
        rules: string[];
    }

    export interface GetSharedConfigsConfigDataAllowRefererAccessRule {
        /**
         * Indicates whether an empty Referer header, or a request without a Referer header, is not allowed. Default is false.
         */
        allowEmpty: boolean;
        /**
         * The content indicating the Referer blacklist.
         */
        commonTypes: outputs.cdn.GetSharedConfigsConfigDataAllowRefererAccessRuleCommonType[];
    }

    export interface GetSharedConfigsConfigDataAllowRefererAccessRuleCommonType {
        /**
         * This list is case-sensitive when matching requests. Default is true.
         */
        ignoreCase: boolean;
        /**
         * The entries in this list are an array of IP addresses and CIDR network segments. The total number of entries cannot exceed 3,000. The IP addresses and segments can be in IPv4 and IPv6 format. Duplicate entries in the list will be removed and will not count towards the limit.
         */
        rules: string[];
    }

    export interface GetSharedConfigsConfigDataCommonMatchList {
        /**
         * The content indicating the Referer blacklist.
         */
        commonTypes: outputs.cdn.GetSharedConfigsConfigDataCommonMatchListCommonType[];
    }

    export interface GetSharedConfigsConfigDataCommonMatchListCommonType {
        /**
         * This list is case-sensitive when matching requests. Default is true.
         */
        ignoreCase: boolean;
        /**
         * The entries in this list are an array of IP addresses and CIDR network segments. The total number of entries cannot exceed 3,000. The IP addresses and segments can be in IPv4 and IPv6 format. Duplicate entries in the list will be removed and will not count towards the limit.
         */
        rules: string[];
    }

    export interface GetSharedConfigsConfigDataDenyIpAccessRule {
        /**
         * The entries in this list are an array of IP addresses and CIDR network segments. The total number of entries cannot exceed 3,000. The IP addresses and segments can be in IPv4 and IPv6 format. Duplicate entries in the list will be removed and will not count towards the limit.
         */
        rules: string[];
    }

    export interface GetSharedConfigsConfigDataDenyRefererAccessRule {
        /**
         * Indicates whether an empty Referer header, or a request without a Referer header, is not allowed. Default is false.
         */
        allowEmpty: boolean;
        /**
         * The content indicating the Referer blacklist.
         */
        commonTypes: outputs.cdn.GetSharedConfigsConfigDataDenyRefererAccessRuleCommonType[];
    }

    export interface GetSharedConfigsConfigDataDenyRefererAccessRuleCommonType {
        /**
         * This list is case-sensitive when matching requests. Default is true.
         */
        ignoreCase: boolean;
        /**
         * The entries in this list are an array of IP addresses and CIDR network segments. The total number of entries cannot exceed 3,000. The IP addresses and segments can be in IPv4 and IPv6 format. Duplicate entries in the list will be removed and will not count towards the limit.
         */
        rules: string[];
    }

    export interface SharedConfigAllowIpAccessRule {
        /**
         * The entries in this list are an array of IP addresses and CIDR network segments. The total number of entries cannot exceed 3,000. The IP addresses and segments can be in IPv4 and IPv6 format. Duplicate entries in the list will be removed and will not count towards the limit.
         */
        rules: string[];
    }

    export interface SharedConfigAllowRefererAccessRule {
        /**
         * Indicates whether an empty Referer header, or a request without a Referer header, is not allowed. Default is false.
         */
        allowEmpty?: boolean;
        /**
         * The content indicating the Referer whitelist.
         */
        commonType: outputs.cdn.SharedConfigAllowRefererAccessRuleCommonType;
    }

    export interface SharedConfigAllowRefererAccessRuleCommonType {
        /**
         * This list is case-sensitive when matching requests. Default is true.
         */
        ignoreCase?: boolean;
        /**
         * The entries in this list are an array of IP addresses and CIDR network segments. The total number of entries cannot exceed 3,000. The IP addresses and segments can be in IPv4 and IPv6 format. Duplicate entries in the list will be removed and will not count towards the limit.
         */
        rules: string[];
    }

    export interface SharedConfigCommonMatchList {
        /**
         * The content indicating the Referer blacklist.
         */
        commonType: outputs.cdn.SharedConfigCommonMatchListCommonType;
    }

    export interface SharedConfigCommonMatchListCommonType {
        /**
         * This list is case-sensitive when matching requests. Default is true.
         */
        ignoreCase?: boolean;
        /**
         * The entries in this list are an array of IP addresses and CIDR network segments. The total number of entries cannot exceed 3,000. The IP addresses and segments can be in IPv4 and IPv6 format. Duplicate entries in the list will be removed and will not count towards the limit.
         */
        rules: string[];
    }

    export interface SharedConfigDenyIpAccessRule {
        /**
         * The entries in this list are an array of IP addresses and CIDR network segments. The total number of entries cannot exceed 3,000. The IP addresses and segments can be in IPv4 and IPv6 format. Duplicate entries in the list will be removed and will not count towards the limit.
         */
        rules: string[];
    }

    export interface SharedConfigDenyRefererAccessRule {
        /**
         * Indicates whether an empty Referer header, or a request without a Referer header, is not allowed. Default is false.
         */
        allowEmpty?: boolean;
        /**
         * The content indicating the Referer blacklist.
         */
        commonType: outputs.cdn.SharedConfigDenyRefererAccessRuleCommonType;
    }

    export interface SharedConfigDenyRefererAccessRuleCommonType {
        /**
         * This list is case-sensitive when matching requests. Default is true.
         */
        ignoreCase?: boolean;
        /**
         * The entries in this list are an array of IP addresses and CIDR network segments. The total number of entries cannot exceed 3,000. The IP addresses and segments can be in IPv4 and IPv6 format. Duplicate entries in the list will be removed and will not count towards the limit.
         */
        rules: string[];
    }

    export interface SharedConfigsConfigData {
        /**
         * The configuration for IP whitelist corresponds to ConfigType allow_ip_access_rule.
         */
        allowIpAccessRules: outputs.cdn.SharedConfigsConfigDataAllowIpAccessRule[];
        /**
         * The configuration for the Referer whitelist corresponds to ConfigType allow_referer_access_rule.
         */
        allowRefererAccessRules: outputs.cdn.SharedConfigsConfigDataAllowRefererAccessRule[];
        /**
         * The configuration for a common list is represented by ConfigType common_match_list.
         */
        commonMatchLists: outputs.cdn.SharedConfigsConfigDataCommonMatchList[];
        /**
         * The name of the shared config.
         */
        configName: string;
        /**
         * The type of the shared config.
         */
        configType: string;
        /**
         * The configuration for IP blacklist is denoted by ConfigType deny_ip_access_rule.
         */
        denyIpAccessRules: outputs.cdn.SharedConfigsConfigDataDenyIpAccessRule[];
        /**
         * The configuration for the Referer blacklist corresponds to ConfigType deny_referer_access_rule.
         */
        denyRefererAccessRules: outputs.cdn.SharedConfigsConfigDataDenyRefererAccessRule[];
        /**
         * The number of domains.
         */
        domainCount: number;
        /**
         * The name of the project.
         */
        projectName: string;
        /**
         * The update time of the shared config.
         */
        updateTime: number;
    }

    export interface SharedConfigsConfigDataAllowIpAccessRule {
        /**
         * The entries in this list are an array of IP addresses and CIDR network segments. The total number of entries cannot exceed 3,000. The IP addresses and segments can be in IPv4 and IPv6 format. Duplicate entries in the list will be removed and will not count towards the limit.
         */
        rules: string[];
    }

    export interface SharedConfigsConfigDataAllowRefererAccessRule {
        /**
         * Indicates whether an empty Referer header, or a request without a Referer header, is not allowed. Default is false.
         */
        allowEmpty: boolean;
        /**
         * The content indicating the Referer blacklist.
         */
        commonTypes: outputs.cdn.SharedConfigsConfigDataAllowRefererAccessRuleCommonType[];
    }

    export interface SharedConfigsConfigDataAllowRefererAccessRuleCommonType {
        /**
         * This list is case-sensitive when matching requests. Default is true.
         */
        ignoreCase: boolean;
        /**
         * The entries in this list are an array of IP addresses and CIDR network segments. The total number of entries cannot exceed 3,000. The IP addresses and segments can be in IPv4 and IPv6 format. Duplicate entries in the list will be removed and will not count towards the limit.
         */
        rules: string[];
    }

    export interface SharedConfigsConfigDataCommonMatchList {
        /**
         * The content indicating the Referer blacklist.
         */
        commonTypes: outputs.cdn.SharedConfigsConfigDataCommonMatchListCommonType[];
    }

    export interface SharedConfigsConfigDataCommonMatchListCommonType {
        /**
         * This list is case-sensitive when matching requests. Default is true.
         */
        ignoreCase: boolean;
        /**
         * The entries in this list are an array of IP addresses and CIDR network segments. The total number of entries cannot exceed 3,000. The IP addresses and segments can be in IPv4 and IPv6 format. Duplicate entries in the list will be removed and will not count towards the limit.
         */
        rules: string[];
    }

    export interface SharedConfigsConfigDataDenyIpAccessRule {
        /**
         * The entries in this list are an array of IP addresses and CIDR network segments. The total number of entries cannot exceed 3,000. The IP addresses and segments can be in IPv4 and IPv6 format. Duplicate entries in the list will be removed and will not count towards the limit.
         */
        rules: string[];
    }

    export interface SharedConfigsConfigDataDenyRefererAccessRule {
        /**
         * Indicates whether an empty Referer header, or a request without a Referer header, is not allowed. Default is false.
         */
        allowEmpty: boolean;
        /**
         * The content indicating the Referer blacklist.
         */
        commonTypes: outputs.cdn.SharedConfigsConfigDataDenyRefererAccessRuleCommonType[];
    }

    export interface SharedConfigsConfigDataDenyRefererAccessRuleCommonType {
        /**
         * This list is case-sensitive when matching requests. Default is true.
         */
        ignoreCase: boolean;
        /**
         * The entries in this list are an array of IP addresses and CIDR network segments. The total number of entries cannot exceed 3,000. The IP addresses and segments can be in IPv4 and IPv6 format. Duplicate entries in the list will be removed and will not count towards the limit.
         */
        rules: string[];
    }

}

export namespace cen {
    export interface AttachInstancesAttachInstance {
        /**
         * A cen ID.
         */
        cenId: string;
        /**
         * The create time of the cen attaching instance.
         */
        creationTime: string;
        /**
         * An instance ID.
         */
        instanceId: string;
        /**
         * The owner ID of the instance.
         */
        instanceOwnerId: string;
        /**
         * A region id of instance.
         */
        instanceRegionId: string;
        /**
         * An instance type.
         */
        instanceType: string;
        /**
         * The status of the cen attaching instance.
         */
        status: string;
    }

    export interface BandwidthPackageTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface BandwidthPackagesBandwidthPackage {
        /**
         * The account ID of the cen bandwidth package.
         */
        accountId: string;
        /**
         * The bandwidth of the cen bandwidth package.
         */
        bandwidth: number;
        /**
         * The billing type of the cen bandwidth package.
         */
        billingType: string;
        /**
         * The business status of the cen bandwidth package.
         */
        businessStatus: string;
        /**
         * The ID of the cen bandwidth package.
         */
        cenBandwidthPackageId: string;
        /**
         * The name of the cen bandwidth package.
         */
        cenBandwidthPackageName: string;
        /**
         * The cen IDs of the bandwidth package.
         */
        cenIds: string[];
        /**
         * The create time of the cen bandwidth package.
         */
        creationTime: string;
        /**
         * The deleted time of the cen bandwidth package.
         */
        deletedTime: string;
        /**
         * The description of the cen bandwidth package.
         */
        description: string;
        /**
         * The expired time of the cen bandwidth package.
         */
        expiredTime: string;
        /**
         * The ID of the cen bandwidth package.
         */
        id: string;
        /**
         * The line operator of the cen bandwidth package.
         */
        lineOperator: string;
        /**
         * A local geographic region set id.
         */
        localGeographicRegionSetId: string;
        /**
         * A peer geographic region set id.
         */
        peerGeographicRegionSetId: string;
        /**
         * The ProjectName of the cen bandwidth package.
         */
        projectName: string;
        /**
         * The remain bandwidth of the cen bandwidth package.
         */
        remainingBandwidth: number;
        /**
         * The status of the cen bandwidth package.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.cen.BandwidthPackagesBandwidthPackageTag[];
        /**
         * The update time of the cen bandwidth package.
         */
        updateTime: string;
    }

    export interface BandwidthPackagesBandwidthPackageTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface BandwidthPackagesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface CenTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface CensCen {
        /**
         * The account ID of the cen.
         */
        accountId: string;
        /**
         * A list of bandwidth package IDs of the cen.
         */
        cenBandwidthPackageIds: string[];
        /**
         * The ID of the cen.
         */
        cenId: string;
        /**
         * The name of the cen.
         */
        cenName: string;
        /**
         * The create time of the cen.
         */
        creationTime: string;
        /**
         * The description of the cen.
         */
        description: string;
        /**
         * The ID of the cen.
         */
        id: string;
        /**
         * The ProjectName of the cen instance.
         */
        projectName: string;
        /**
         * The status of the cen.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.cen.CensCenTag[];
        /**
         * The update time of the cen.
         */
        updateTime: string;
    }

    export interface CensCenTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface CensTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetAttachInstancesAttachInstance {
        /**
         * A cen ID.
         */
        cenId: string;
        /**
         * The create time of the cen attaching instance.
         */
        creationTime: string;
        /**
         * An instance ID.
         */
        instanceId: string;
        /**
         * The owner ID of the instance.
         */
        instanceOwnerId: string;
        /**
         * A region id of instance.
         */
        instanceRegionId: string;
        /**
         * An instance type.
         */
        instanceType: string;
        /**
         * The status of the cen attaching instance.
         */
        status: string;
    }

    export interface GetBandwidthPackagesBandwidthPackage {
        /**
         * The account ID of the cen bandwidth package.
         */
        accountId: string;
        /**
         * The bandwidth of the cen bandwidth package.
         */
        bandwidth: number;
        /**
         * The billing type of the cen bandwidth package.
         */
        billingType: string;
        /**
         * The business status of the cen bandwidth package.
         */
        businessStatus: string;
        /**
         * The ID of the cen bandwidth package.
         */
        cenBandwidthPackageId: string;
        /**
         * The name of the cen bandwidth package.
         */
        cenBandwidthPackageName: string;
        /**
         * The cen IDs of the bandwidth package.
         */
        cenIds: string[];
        /**
         * The create time of the cen bandwidth package.
         */
        creationTime: string;
        /**
         * The deleted time of the cen bandwidth package.
         */
        deletedTime: string;
        /**
         * The description of the cen bandwidth package.
         */
        description: string;
        /**
         * The expired time of the cen bandwidth package.
         */
        expiredTime: string;
        /**
         * The ID of the cen bandwidth package.
         */
        id: string;
        /**
         * The line operator of the cen bandwidth package.
         */
        lineOperator: string;
        /**
         * A local geographic region set id.
         */
        localGeographicRegionSetId: string;
        /**
         * A peer geographic region set id.
         */
        peerGeographicRegionSetId: string;
        /**
         * The ProjectName of the cen bandwidth package.
         */
        projectName: string;
        /**
         * The remain bandwidth of the cen bandwidth package.
         */
        remainingBandwidth: number;
        /**
         * The status of the cen bandwidth package.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.cen.GetBandwidthPackagesBandwidthPackageTag[];
        /**
         * The update time of the cen bandwidth package.
         */
        updateTime: string;
    }

    export interface GetBandwidthPackagesBandwidthPackageTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetBandwidthPackagesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetCensCen {
        /**
         * The account ID of the cen.
         */
        accountId: string;
        /**
         * A list of bandwidth package IDs of the cen.
         */
        cenBandwidthPackageIds: string[];
        /**
         * The ID of the cen.
         */
        cenId: string;
        /**
         * The name of the cen.
         */
        cenName: string;
        /**
         * The create time of the cen.
         */
        creationTime: string;
        /**
         * The description of the cen.
         */
        description: string;
        /**
         * The ID of the cen.
         */
        id: string;
        /**
         * The ProjectName of the cen instance.
         */
        projectName: string;
        /**
         * The status of the cen.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.cen.GetCensCenTag[];
        /**
         * The update time of the cen.
         */
        updateTime: string;
    }

    export interface GetCensCenTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetCensTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetGrantInstancesGrantRule {
        /**
         * The ID of the cen.
         */
        cenId: string;
        /**
         * The owner ID of the cen.
         */
        cenOwnerId: string;
        /**
         * The creation time of the grant rule.
         */
        creationTime: string;
        /**
         * The ID of the instance.
         */
        instanceId: string;
        /**
         * The region ID of the instance.
         */
        instanceRegionId: string;
        /**
         * The type of the instance. Valid values: `VPC`, `DCGW`.
         */
        instanceType: string;
    }

    export interface GetInterRegionBandwidthsInterRegionBandwidth {
        /**
         * The bandwidth of the cen inter region bandwidth.
         */
        bandwidth: number;
        /**
         * The ID of the cen bandwidth package.
         */
        cenBandwidthPackageId: string;
        /**
         * The ID of the cen.
         */
        cenId: string;
        /**
         * The create time of the cen inter region bandwidth.
         */
        creationTime: string;
        /**
         * The ID of the cen inter region bandwidth.
         */
        id: string;
        /**
         * The ID of the cen inter region bandwidth.
         */
        interRegionBandwidthId: string;
        /**
         * The local region id of the cen inter region bandwidth.
         */
        localRegionId: string;
        /**
         * The peer region id of the cen inter region bandwidth.
         */
        peerRegionId: string;
        /**
         * The status of the cen inter region bandwidth.
         */
        status: string;
        /**
         * The update time of the cen inter region bandwidth.
         */
        updateTime: string;
    }

    export interface GetRouteEntriesCenRouteEntry {
        /**
         * The AS path of the cen route entry.
         */
        asPaths: string[];
        /**
         * A cen ID.
         */
        cenId: string;
        /**
         * A destination cidr block.
         */
        destinationCidrBlock: string;
        /**
         * An instance ID.
         */
        instanceId: string;
        /**
         * An instance region ID.
         */
        instanceRegionId: string;
        /**
         * An instance type.
         */
        instanceType: string;
        /**
         * The publish status of the cen route entry.
         */
        publishStatus: string;
        /**
         * The status of the cen route entry.
         */
        status: string;
    }

    export interface GetServiceRouteEntriesServiceRouteEntry {
        /**
         * A cen ID.
         */
        cenId: string;
        /**
         * The create time of the cen service route entry.
         */
        creationTime: string;
        /**
         * The description of the cen service route entry.
         */
        description: string;
        /**
         * A destination cidr block.
         */
        destinationCidrBlock: string;
        /**
         * Publishing scope of cloud service access routes. Valid values are `LocalDCGW`(default), `Custom`.
         */
        publishMode: string;
        /**
         * The publish instances. A maximum of 100 can be uploaded in one request.
         */
        publishToInstances: outputs.cen.GetServiceRouteEntriesServiceRouteEntryPublishToInstance[];
        /**
         * A service region id.
         */
        serviceRegionId: string;
        /**
         * A service VPC id.
         */
        serviceVpcId: string;
        /**
         * The status of the cen service route entry.
         */
        status: string;
    }

    export interface GetServiceRouteEntriesServiceRouteEntryPublishToInstance {
        /**
         * Cloud service access routes need to publish the network instance ID.
         */
        instanceId: string;
        /**
         * The region where the cloud service access route needs to be published.
         */
        instanceRegionId: string;
        /**
         * The network instance type that needs to be published for cloud service access routes. The values are as follows: `VPC`, `DCGW`.
         */
        instanceType: string;
    }

    export interface GrantInstancesGrantRule {
        /**
         * The ID of the cen.
         */
        cenId: string;
        /**
         * The owner ID of the cen.
         */
        cenOwnerId: string;
        /**
         * The creation time of the grant rule.
         */
        creationTime: string;
        /**
         * The ID of the instance.
         */
        instanceId: string;
        /**
         * The region ID of the instance.
         */
        instanceRegionId: string;
        /**
         * The type of the instance. Valid values: `VPC`, `DCGW`.
         */
        instanceType: string;
    }

    export interface InterRegionBandwidthsInterRegionBandwidth {
        /**
         * The bandwidth of the cen inter region bandwidth.
         */
        bandwidth: number;
        /**
         * The ID of the cen bandwidth package.
         */
        cenBandwidthPackageId: string;
        /**
         * The ID of the cen.
         */
        cenId: string;
        /**
         * The create time of the cen inter region bandwidth.
         */
        creationTime: string;
        /**
         * The ID of the cen inter region bandwidth.
         */
        id: string;
        /**
         * The ID of the cen inter region bandwidth.
         */
        interRegionBandwidthId: string;
        /**
         * The local region id of the cen inter region bandwidth.
         */
        localRegionId: string;
        /**
         * The peer region id of the cen inter region bandwidth.
         */
        peerRegionId: string;
        /**
         * The status of the cen inter region bandwidth.
         */
        status: string;
        /**
         * The update time of the cen inter region bandwidth.
         */
        updateTime: string;
    }

    export interface RouteEntriesCenRouteEntry {
        /**
         * The AS path of the cen route entry.
         */
        asPaths: string[];
        /**
         * A cen ID.
         */
        cenId: string;
        /**
         * A destination cidr block.
         */
        destinationCidrBlock: string;
        /**
         * An instance ID.
         */
        instanceId: string;
        /**
         * An instance region ID.
         */
        instanceRegionId: string;
        /**
         * An instance type.
         */
        instanceType: string;
        /**
         * The publish status of the cen route entry.
         */
        publishStatus: string;
        /**
         * The status of the cen route entry.
         */
        status: string;
    }

    export interface ServiceRouteEntriesServiceRouteEntry {
        /**
         * A cen ID.
         */
        cenId: string;
        /**
         * The create time of the cen service route entry.
         */
        creationTime: string;
        /**
         * The description of the cen service route entry.
         */
        description: string;
        /**
         * A destination cidr block.
         */
        destinationCidrBlock: string;
        /**
         * Publishing scope of cloud service access routes. Valid values are `LocalDCGW`(default), `Custom`.
         */
        publishMode: string;
        /**
         * The publish instances. A maximum of 100 can be uploaded in one request.
         */
        publishToInstances: outputs.cen.ServiceRouteEntriesServiceRouteEntryPublishToInstance[];
        /**
         * A service region id.
         */
        serviceRegionId: string;
        /**
         * A service VPC id.
         */
        serviceVpcId: string;
        /**
         * The status of the cen service route entry.
         */
        status: string;
    }

    export interface ServiceRouteEntriesServiceRouteEntryPublishToInstance {
        /**
         * Cloud service access routes need to publish the network instance ID.
         */
        instanceId: string;
        /**
         * The region where the cloud service access route needs to be published.
         */
        instanceRegionId: string;
        /**
         * The network instance type that needs to be published for cloud service access routes. The values are as follows: `VPC`, `DCGW`.
         */
        instanceType: string;
    }

    export interface ServiceRouteEntryPublishToInstance {
        /**
         * Cloud service access routes need to publish the network instance ID.
         */
        instanceId?: string;
        /**
         * The region where the cloud service access route needs to be published.
         */
        instanceRegionId?: string;
        /**
         * The network instance type that needs to be published for cloud service access routes. The values are as follows: `VPC`, `DCGW`.
         */
        instanceType?: string;
    }

}

export namespace clb {
    export interface AclAclEntry {
        /**
         * The description of the AclEntry.
         */
        description?: string;
        /**
         * The content of the AclEntry.
         */
        entry: string;
    }

    export interface AclsAcl {
        /**
         * The count of acl entry.
         */
        aclEntryCount: number;
        /**
         * The ID of Acl.
         */
        aclId: string;
        /**
         * The name of acl.
         */
        aclName: string;
        /**
         * Creation time of Acl.
         */
        createTime: string;
        /**
         * The description of Acl.
         */
        description: string;
        /**
         * The ID of Acl.
         */
        id: string;
        /**
         * The listeners of Acl.
         */
        listeners: string[];
        /**
         * The ProjectName of Acl.
         */
        projectName: string;
        /**
         * Update time of Acl.
         */
        updateTime: string;
    }

    export interface CertificateTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface CertificatesCertificate {
        /**
         * The ID of the Certificate.
         */
        certificateId: string;
        /**
         * The name of the Certificate.
         */
        certificateName: string;
        /**
         * The create time of the Certificate.
         */
        createTime: string;
        /**
         * The description of the Certificate.
         */
        description: string;
        /**
         * The domain name of the Certificate.
         */
        domainName: string;
        /**
         * The expire time of the Certificate.
         */
        expiredAt: string;
        /**
         * The ID of the Certificate.
         */
        id: string;
        /**
         * The ID list of the Listener.
         */
        listeners: string[];
        /**
         * The ProjectName of Certificate.
         */
        projectName: string;
        /**
         * Tags.
         */
        tags: outputs.clb.CertificatesCertificateTag[];
    }

    export interface CertificatesCertificateTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface CertificatesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface ClbEipBillingConfig {
        /**
         * The peek bandwidth of the EIP which automatically assigned to CLB.
         */
        bandwidth: number;
        /**
         * The billing type of the EIP which automatically assigned to CLB. And optional choice contains `PostPaidByBandwidth` or `PostPaidByTraffic` or `PrePaid`.When creating a `PrePaid` public CLB, this field must be specified as `PrePaid` simultaneously.When the LoadBalancerBillingType changes from `PostPaid` to `PrePaid`, please manually modify the value of this field to `PrePaid` simultaneously.
         */
        eipBillingType: string;
        /**
         * The ISP of the EIP which automatically associated to CLB, the value can be `BGP` or `ChinaMobile` or `ChinaUnicom` or `ChinaTelecom` or `SingleLine_BGP` or `Static_BGP` or `Fusion_BGP`.
         */
        isp: string;
    }

    export interface ClbTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface ClbsClb {
        /**
         * The address ip version of the Clb.
         */
        addressIpVersion: string;
        /**
         * The business status of the Clb.
         */
        businessStatus: string;
        /**
         * The create time of the Clb.
         */
        createTime: string;
        /**
         * The expected recycle time of the Clb.
         */
        deletedTime: string;
        /**
         * The description of the Clb.
         */
        description: string;
        /**
         * The Eip address of the Clb.
         */
        eipAddress: string;
        /**
         * The eip billing config of the Clb.
         */
        eipBillingConfigs: outputs.clb.ClbsClbEipBillingConfig[];
        /**
         * The Eip ID of the Clb.
         */
        eipId: string;
        /**
         * The private ip address of the Clb.
         */
        eniAddress: string;
        /**
         * The Eni ID of the Clb.
         */
        eniId: string;
        /**
         * The eni ipv6 address of the Clb.
         */
        eniIpv6Address: string;
        /**
         * The expired time of the CLB.
         */
        expiredTime: string;
        /**
         * The ID of the Clb.
         */
        id: string;
        /**
         * The billing status of the CLB.
         */
        instanceStatus: number;
        /**
         * The ipv6 address bandwidth information of the Clb.
         */
        ipv6AddressBandwidths: outputs.clb.ClbsClbIpv6AddressBandwidth[];
        /**
         * The Ipv6 Eip ID of the Clb.
         */
        ipv6EipId: string;
        /**
         * The billing type of the Clb.
         */
        loadBalancerBillingType: string;
        /**
         * The ID of the Clb.
         */
        loadBalancerId: string;
        /**
         * The name of the Clb.
         */
        loadBalancerName: string;
        /**
         * The specifications of the Clb.
         */
        loadBalancerSpec: string;
        /**
         * The reason why Clb is locked.
         */
        lockReason: string;
        /**
         * The master zone ID of the CLB.
         */
        masterZoneId: string;
        /**
         * The modification protection reason of the Clb.
         */
        modificationProtectionReason: string;
        /**
         * The modification protection status of the Clb.
         */
        modificationProtectionStatus: string;
        /**
         * The over reclaim time of the CLB.
         */
        overdueReclaimTime: string;
        /**
         * The overdue time of the Clb.
         */
        overdueTime: string;
        /**
         * The ProjectName of Clb.
         */
        projectName: string;
        /**
         * The reclaim time of the CLB.
         */
        reclaimTime: string;
        /**
         * The remain renew times of the CLB. When the value of the renewType is `AutoRenew`, the query returns this field.
         */
        remainRenewTimes: number;
        /**
         * The renew period times of the CLB. When the value of the renewType is `AutoRenew`, the query returns this field.
         */
        renewPeriodTimes: number;
        /**
         * The renew type of the CLB. When the value of the loadBalancerBillingType is `PrePaid`, the query returns this field.
         */
        renewType: string;
        /**
         * The slave zone ID of the CLB.
         */
        slaveZoneId: string;
        /**
         * The status of the Clb.
         */
        status: string;
        /**
         * The subnet ID of the Clb.
         */
        subnetId: string;
        /**
         * Tags.
         */
        tags: outputs.clb.ClbsClbTag[];
        /**
         * The type of the Clb.
         */
        type: string;
        /**
         * The update time of the Clb.
         */
        updateTime: string;
        /**
         * The id of the VPC.
         */
        vpcId: string;
    }

    export interface ClbsClbEipBillingConfig {
        /**
         * The peek bandwidth of the Ipv6 EIP assigned to CLB. Units: Mbps.
         */
        bandwidth: number;
        /**
         * The billing type of the EIP assigned to CLB. And optional choice contains `PostPaidByBandwidth` or `PostPaidByTraffic` or `PrePaid`.
         */
        eipBillingType: string;
        /**
         * The ISP of the Ipv6 EIP assigned to CLB, the value can be `BGP`.
         */
        isp: string;
    }

    export interface ClbsClbIpv6AddressBandwidth {
        /**
         * The peek bandwidth of the Ipv6 EIP assigned to CLB. Units: Mbps.
         */
        bandwidth: number;
        /**
         * The bandwidth package id of the Ipv6 EIP assigned to CLB.
         */
        bandwidthPackageId: string;
        /**
         * The billing type of the Ipv6 EIP assigned to CLB. And optional choice contains `PostPaidByBandwidth` or `PostPaidByTraffic`.
         */
        billingType: string;
        /**
         * The ISP of the Ipv6 EIP assigned to CLB, the value can be `BGP`.
         */
        isp: string;
        /**
         * The network type of the CLB Ipv6 address.
         */
        networkType: string;
    }

    export interface ClbsClbTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface ClbsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetAclsAcl {
        /**
         * The count of acl entry.
         */
        aclEntryCount: number;
        /**
         * The ID of Acl.
         */
        aclId: string;
        /**
         * The name of acl.
         */
        aclName: string;
        /**
         * Creation time of Acl.
         */
        createTime: string;
        /**
         * The description of Acl.
         */
        description: string;
        /**
         * The ID of Acl.
         */
        id: string;
        /**
         * The listeners of Acl.
         */
        listeners: string[];
        /**
         * The ProjectName of Acl.
         */
        projectName: string;
        /**
         * Update time of Acl.
         */
        updateTime: string;
    }

    export interface GetCertificatesCertificate {
        /**
         * The ID of the Certificate.
         */
        certificateId: string;
        /**
         * The name of the Certificate.
         */
        certificateName: string;
        /**
         * The create time of the Certificate.
         */
        createTime: string;
        /**
         * The description of the Certificate.
         */
        description: string;
        /**
         * The domain name of the Certificate.
         */
        domainName: string;
        /**
         * The expire time of the Certificate.
         */
        expiredAt: string;
        /**
         * The ID of the Certificate.
         */
        id: string;
        /**
         * The ID list of the Listener.
         */
        listeners: string[];
        /**
         * The ProjectName of Certificate.
         */
        projectName: string;
        /**
         * Tags.
         */
        tags: outputs.clb.GetCertificatesCertificateTag[];
    }

    export interface GetCertificatesCertificateTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetCertificatesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetClbsClb {
        /**
         * The address ip version of the Clb.
         */
        addressIpVersion: string;
        /**
         * The business status of the Clb.
         */
        businessStatus: string;
        /**
         * The create time of the Clb.
         */
        createTime: string;
        /**
         * The expected recycle time of the Clb.
         */
        deletedTime: string;
        /**
         * The description of the Clb.
         */
        description: string;
        /**
         * The Eip address of the Clb.
         */
        eipAddress: string;
        /**
         * The eip billing config of the Clb.
         */
        eipBillingConfigs: outputs.clb.GetClbsClbEipBillingConfig[];
        /**
         * The Eip ID of the Clb.
         */
        eipId: string;
        /**
         * The private ip address of the Clb.
         */
        eniAddress: string;
        /**
         * The Eni ID of the Clb.
         */
        eniId: string;
        /**
         * The eni ipv6 address of the Clb.
         */
        eniIpv6Address: string;
        /**
         * The expired time of the CLB.
         */
        expiredTime: string;
        /**
         * The ID of the Clb.
         */
        id: string;
        /**
         * The billing status of the CLB.
         */
        instanceStatus: number;
        /**
         * The ipv6 address bandwidth information of the Clb.
         */
        ipv6AddressBandwidths: outputs.clb.GetClbsClbIpv6AddressBandwidth[];
        /**
         * The Ipv6 Eip ID of the Clb.
         */
        ipv6EipId: string;
        /**
         * The billing type of the Clb.
         */
        loadBalancerBillingType: string;
        /**
         * The ID of the Clb.
         */
        loadBalancerId: string;
        /**
         * The name of the Clb.
         */
        loadBalancerName: string;
        /**
         * The specifications of the Clb.
         */
        loadBalancerSpec: string;
        /**
         * The reason why Clb is locked.
         */
        lockReason: string;
        /**
         * The master zone ID of the CLB.
         */
        masterZoneId: string;
        /**
         * The modification protection reason of the Clb.
         */
        modificationProtectionReason: string;
        /**
         * The modification protection status of the Clb.
         */
        modificationProtectionStatus: string;
        /**
         * The over reclaim time of the CLB.
         */
        overdueReclaimTime: string;
        /**
         * The overdue time of the Clb.
         */
        overdueTime: string;
        /**
         * The ProjectName of Clb.
         */
        projectName: string;
        /**
         * The reclaim time of the CLB.
         */
        reclaimTime: string;
        /**
         * The remain renew times of the CLB. When the value of the renewType is `AutoRenew`, the query returns this field.
         */
        remainRenewTimes: number;
        /**
         * The renew period times of the CLB. When the value of the renewType is `AutoRenew`, the query returns this field.
         */
        renewPeriodTimes: number;
        /**
         * The renew type of the CLB. When the value of the loadBalancerBillingType is `PrePaid`, the query returns this field.
         */
        renewType: string;
        /**
         * The slave zone ID of the CLB.
         */
        slaveZoneId: string;
        /**
         * The status of the Clb.
         */
        status: string;
        /**
         * The subnet ID of the Clb.
         */
        subnetId: string;
        /**
         * Tags.
         */
        tags: outputs.clb.GetClbsClbTag[];
        /**
         * The type of the Clb.
         */
        type: string;
        /**
         * The update time of the Clb.
         */
        updateTime: string;
        /**
         * The id of the VPC.
         */
        vpcId: string;
    }

    export interface GetClbsClbEipBillingConfig {
        /**
         * The peek bandwidth of the Ipv6 EIP assigned to CLB. Units: Mbps.
         */
        bandwidth: number;
        /**
         * The billing type of the EIP assigned to CLB. And optional choice contains `PostPaidByBandwidth` or `PostPaidByTraffic` or `PrePaid`.
         */
        eipBillingType: string;
        /**
         * The ISP of the Ipv6 EIP assigned to CLB, the value can be `BGP`.
         */
        isp: string;
    }

    export interface GetClbsClbIpv6AddressBandwidth {
        /**
         * The peek bandwidth of the Ipv6 EIP assigned to CLB. Units: Mbps.
         */
        bandwidth: number;
        /**
         * The bandwidth package id of the Ipv6 EIP assigned to CLB.
         */
        bandwidthPackageId: string;
        /**
         * The billing type of the Ipv6 EIP assigned to CLB. And optional choice contains `PostPaidByBandwidth` or `PostPaidByTraffic`.
         */
        billingType: string;
        /**
         * The ISP of the Ipv6 EIP assigned to CLB, the value can be `BGP`.
         */
        isp: string;
        /**
         * The network type of the CLB Ipv6 address.
         */
        networkType: string;
    }

    export interface GetClbsClbTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetClbsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetListenersListener {
        /**
         * The acl ID list to which the Listener is bound.
         */
        aclIds: string[];
        /**
         * The acl status of the Listener.
         */
        aclStatus: string;
        /**
         * The acl type of the Listener.
         */
        aclType: string;
        /**
         * The bandwidth of the Listener. Unit: Mbps.
         */
        bandwidth: number;
        /**
         * The ID of the certificate which is associated with the Listener.
         */
        certificateId: string;
        /**
         * Whether to enable connection drain of the Listener.
         */
        connectionDrainEnabled: string;
        /**
         * The connection drain timeout of the Listener.
         */
        connectionDrainTimeout: number;
        /**
         * The name of the cookie for session persistence configured on the backend server.
         */
        cookie: string;
        /**
         * The create time of the Listener.
         */
        createTime: string;
        /**
         * The enable status of the Listener.
         */
        enabled: string;
        /**
         * The domain of health check.
         */
        healthCheckDomain: string;
        /**
         * The enable status of health check function.
         */
        healthCheckEnabled: string;
        /**
         * The healthy threshold of health check.
         */
        healthCheckHealthyThreshold: number;
        /**
         * The normal http status code of health check.
         */
        healthCheckHttpCode: string;
        /**
         * The interval executing health check.
         */
        healthCheckInterval: number;
        /**
         * The method of health check.
         */
        healthCheckMethod: string;
        /**
         * The response timeout of health check.
         */
        healthCheckTimeout: number;
        /**
         * The expected response string for the health check.
         */
        healthCheckUdpExpect: string;
        /**
         * A request string to perform a health check.
         */
        healthCheckUdpRequest: string;
        /**
         * The unhealthy threshold of health check.
         */
        healthCheckUnHealthyThreshold: number;
        /**
         * The uri of health check.
         */
        healthCheckUri: string;
        /**
         * The ID of the Listener.
         */
        id: string;
        /**
         * The ID of the Listener.
         */
        listenerId: string;
        /**
         * The name of the Listener.
         */
        listenerName: string;
        /**
         * The persistence timeout of the Listener.
         */
        persistenceTimeout: number;
        /**
         * The persistence type of the Listener.
         */
        persistenceType: string;
        /**
         * The port receiving request of the Listener.
         */
        port: number;
        /**
         * The protocol of the Listener.
         */
        protocol: string;
        /**
         * Whether to enable proxy protocol.
         */
        proxyProtocolType: string;
        /**
         * The ID of the backend server group which is associated with the Listener.
         */
        serverGroupId: string;
        /**
         * The status of the Listener.
         */
        status: string;
        /**
         * The update time of the Listener.
         */
        updateTime: string;
    }

    export interface GetRulesRule {
        /**
         * The Description of Rule.
         */
        description: string;
        /**
         * The Domain of Rule.
         */
        domain: string;
        /**
         * The Id of Rule.
         */
        id: string;
        /**
         * The Id of Rule.
         */
        ruleId: string;
        /**
         * The Id of Server Group.
         */
        serverGroupId: string;
        /**
         * The Url of Rule.
         */
        url: string;
    }

    export interface GetServerGroupServersServer {
        /**
         * The description of the instance.
         */
        description: string;
        /**
         * The server id of instance in ServerGroup.
         */
        id: string;
        /**
         * The ID of ecs instance or the network card bound to ecs instance.
         */
        instanceId: string;
        /**
         * The private ip of the instance.
         */
        ip: string;
        /**
         * The port receiving request.
         */
        port: number;
        /**
         * The server id of instance in ServerGroup.
         */
        serverId: string;
        /**
         * The type of instance. Optional choice contains `ecs`, `eni`.
         */
        type: string;
        /**
         * The weight of the instance.
         */
        weight: number;
    }

    export interface GetServerGroupsGroup {
        /**
         * The address ip version of the ServerGroup.
         */
        addressIpVersion: string;
        /**
         * The create time of the ServerGroup.
         */
        createTime: string;
        /**
         * The description of the ServerGroup.
         */
        description: string;
        /**
         * The ID of the ServerGroup.
         */
        id: string;
        /**
         * The ID of the ServerGroup.
         */
        serverGroupId: string;
        /**
         * The name of the ServerGroup.
         */
        serverGroupName: string;
        /**
         * The update time of the ServerGroup.
         */
        updateTime: string;
    }

    export interface GetZonesMasterZone {
        /**
         * The slave zones list.
         */
        slaveZones: outputs.clb.GetZonesMasterZoneSlaveZone[];
        /**
         * The master zone id.
         */
        zoneId: string;
    }

    export interface GetZonesMasterZoneSlaveZone {
        /**
         * The master zone id.
         */
        zoneId: string;
    }

    export interface ListenerHealthCheck {
        /**
         * The domain of health check.
         */
        domain?: string;
        /**
         * The enable status of health check function. Optional choice contains `on`, `off`.
         */
        enabled?: string;
        /**
         * The healthy threshold of health check, default 3, range in 2~10.
         */
        healthyThreshold?: number;
        /**
         * The normal http status code of health check, the value can be `http2xx` or `http3xx` or `http4xx` or `http5xx`.
         */
        httpCode?: string;
        /**
         * The interval executing health check, default 2, range in 1~300.
         */
        interval?: number;
        /**
         * The method of health check, the value can be `GET` or `HEAD`.
         */
        method?: string;
        /**
         * The response timeout of health check, default 2, range in 1~60..
         */
        timeout?: number;
        /**
         * The UDP expect of health check. This field must be specified simultaneously with field `udpRequest`.
         */
        udpExpect?: string;
        /**
         * The UDP request of health check. This field must be specified simultaneously with field `udpExpect`.
         */
        udpRequest?: string;
        /**
         * The unhealthy threshold of health check, default 3, range in 2~10.
         */
        unHealthyThreshold?: number;
        /**
         * The uri of health check.
         */
        uri?: string;
    }

    export interface ListenersListener {
        /**
         * The acl ID list to which the Listener is bound.
         */
        aclIds: string[];
        /**
         * The acl status of the Listener.
         */
        aclStatus: string;
        /**
         * The acl type of the Listener.
         */
        aclType: string;
        /**
         * The bandwidth of the Listener. Unit: Mbps.
         */
        bandwidth: number;
        /**
         * The ID of the certificate which is associated with the Listener.
         */
        certificateId: string;
        /**
         * Whether to enable connection drain of the Listener.
         */
        connectionDrainEnabled: string;
        /**
         * The connection drain timeout of the Listener.
         */
        connectionDrainTimeout: number;
        /**
         * The name of the cookie for session persistence configured on the backend server.
         */
        cookie: string;
        /**
         * The create time of the Listener.
         */
        createTime: string;
        /**
         * The enable status of the Listener.
         */
        enabled: string;
        /**
         * The domain of health check.
         */
        healthCheckDomain: string;
        /**
         * The enable status of health check function.
         */
        healthCheckEnabled: string;
        /**
         * The healthy threshold of health check.
         */
        healthCheckHealthyThreshold: number;
        /**
         * The normal http status code of health check.
         */
        healthCheckHttpCode: string;
        /**
         * The interval executing health check.
         */
        healthCheckInterval: number;
        /**
         * The method of health check.
         */
        healthCheckMethod: string;
        /**
         * The response timeout of health check.
         */
        healthCheckTimeout: number;
        /**
         * The expected response string for the health check.
         */
        healthCheckUdpExpect: string;
        /**
         * A request string to perform a health check.
         */
        healthCheckUdpRequest: string;
        /**
         * The unhealthy threshold of health check.
         */
        healthCheckUnHealthyThreshold: number;
        /**
         * The uri of health check.
         */
        healthCheckUri: string;
        /**
         * The ID of the Listener.
         */
        id: string;
        /**
         * The ID of the Listener.
         */
        listenerId: string;
        /**
         * The name of the Listener.
         */
        listenerName: string;
        /**
         * The persistence timeout of the Listener.
         */
        persistenceTimeout: number;
        /**
         * The persistence type of the Listener.
         */
        persistenceType: string;
        /**
         * The port receiving request of the Listener.
         */
        port: number;
        /**
         * The protocol of the Listener.
         */
        protocol: string;
        /**
         * Whether to enable proxy protocol.
         */
        proxyProtocolType: string;
        /**
         * The ID of the backend server group which is associated with the Listener.
         */
        serverGroupId: string;
        /**
         * The status of the Listener.
         */
        status: string;
        /**
         * The update time of the Listener.
         */
        updateTime: string;
    }

    export interface RulesRule {
        /**
         * The Description of Rule.
         */
        description: string;
        /**
         * The Domain of Rule.
         */
        domain: string;
        /**
         * The Id of Rule.
         */
        id: string;
        /**
         * The Id of Rule.
         */
        ruleId: string;
        /**
         * The Id of Server Group.
         */
        serverGroupId: string;
        /**
         * The Url of Rule.
         */
        url: string;
    }

    export interface ServerGroupServersServer {
        /**
         * The description of the instance.
         */
        description: string;
        /**
         * The server id of instance in ServerGroup.
         */
        id: string;
        /**
         * The ID of ecs instance or the network card bound to ecs instance.
         */
        instanceId: string;
        /**
         * The private ip of the instance.
         */
        ip: string;
        /**
         * The port receiving request.
         */
        port: number;
        /**
         * The server id of instance in ServerGroup.
         */
        serverId: string;
        /**
         * The type of instance. Optional choice contains `ecs`, `eni`.
         */
        type: string;
        /**
         * The weight of the instance.
         */
        weight: number;
    }

    export interface ServerGroupsGroup {
        /**
         * The address ip version of the ServerGroup.
         */
        addressIpVersion: string;
        /**
         * The create time of the ServerGroup.
         */
        createTime: string;
        /**
         * The description of the ServerGroup.
         */
        description: string;
        /**
         * The ID of the ServerGroup.
         */
        id: string;
        /**
         * The ID of the ServerGroup.
         */
        serverGroupId: string;
        /**
         * The name of the ServerGroup.
         */
        serverGroupName: string;
        /**
         * The update time of the ServerGroup.
         */
        updateTime: string;
    }

    export interface ZonesMasterZone {
        /**
         * The slave zones list.
         */
        slaveZones: outputs.clb.ZonesMasterZoneSlaveZone[];
        /**
         * The master zone id.
         */
        zoneId: string;
    }

    export interface ZonesMasterZoneSlaveZone {
        /**
         * The master zone id.
         */
        zoneId: string;
    }

}

export namespace cloud_firewall {
    export interface CfwAddressBooksAddressBook {
        /**
         * The address list of the address book.
         */
        addressLists: string[];
        /**
         * The group type of address book. This field support fuzzy query.
         */
        description: string;
        /**
         * The group name of address book. This field support fuzzy query.
         */
        groupName: string;
        /**
         * The group type of address book. Valid values: `ip`, `port`, `domain`.
         */
        groupType: string;
        /**
         * The uuid of the address book.
         */
        groupUuid: string;
        /**
         * The uuid of the address book.
         */
        id: string;
        /**
         * The reference count of the address book.
         */
        refCnt: number;
    }

    export interface CfwControlPoliciesControlPolicy {
        /**
         * The account id of the control policy.
         */
        accountId: string;
        /**
         * The action list of the control policy. Valid values: `accept`, `deny`, `monitor`.
         */
        action: string;
        /**
         * The description of the control policy. This field support fuzzy query.
         */
        description: string;
        /**
         * The dest port of the control policy.
         */
        destPort: string;
        /**
         * The dest port group type of the control policy.
         */
        destPortGroupType: string;
        /**
         * The dest port list of the control policy.
         */
        destPortLists: string[];
        /**
         * The dest port type of the control policy.
         */
        destPortType: string;
        /**
         * The destination of the control policy. This field support fuzzy query.
         */
        destination: string;
        /**
         * The destination cidr list of the control policy.
         */
        destinationCidrLists: string[];
        /**
         * The destination group type of the control policy.
         */
        destinationGroupType: string;
        /**
         * The destination type of the control policy.
         */
        destinationType: string;
        /**
         * The direction of control policy. Valid values: `in`, `out`.
         */
        direction: string;
        /**
         * The effect status of the control policy. 1: Not yet effective, 2: Issued in progress, 3: Effective.
         */
        effectStatus: number;
        /**
         * The end time of the control policy. Unix timestamp.
         */
        endTime: number;
        /**
         * The hit count of the control policy.
         */
        hitCnt: number;
        /**
         * The id of the control policy.
         */
        id: string;
        /**
         * Whether the control policy is effected.
         */
        isEffected: boolean;
        /**
         * The priority of the control policy.
         */
        prio: number;
        /**
         * The proto list of the control policy. Valid values: `TCP`, `ICMP`, `UDP`, `ANY`. When the destinationType is `domain`, The proto must be `TCP`.
         */
        proto: string;
        /**
         * The repeat days of the control policy.
         */
        repeatDays: number[];
        /**
         * The repeat end time of the control policy.
         */
        repeatEndTime: string;
        /**
         * The repeat start time of the control policy.
         */
        repeatStartTime: string;
        /**
         * The repeat type of the control policy. Valid values: `Permanent`, `Once`, `Daily`, `Weekly`, `Monthly`.
         */
        repeatType: string;
        /**
         * The rule id of the control policy. This field support fuzzy query.
         */
        ruleId: string;
        /**
         * The source of the control policy. This field support fuzzy query.
         */
        source: string;
        /**
         * The source cidr list of the control policy.
         */
        sourceCidrLists: string[];
        /**
         * The source group type of the control policy.
         */
        sourceGroupType: string;
        /**
         * The source type of the control policy.
         */
        sourceType: string;
        /**
         * The start time of the control policy. Unix timestamp.
         */
        startTime: number;
        /**
         * The enable status list of the control policy.
         */
        status: boolean;
        /**
         * The update time of the control policy.
         */
        updateTime: number;
        /**
         * The use count of the control policy.
         */
        useCount: number;
    }

    export interface CfwDnsControlPoliciesDnsControlPolicy {
        /**
         * The account id of the dns control policy.
         */
        accountId: string;
        /**
         * The description of the dns control policy. This field support fuzzy query.
         */
        description: string;
        /**
         * The destination list of the dns control policy. This field support fuzzy query.
         */
        destination: string;
        /**
         * The destination group list of the dns control policy.
         */
        destinationGroupLists: string[];
        /**
         * The destination type of the dns control policy.
         */
        destinationType: string;
        /**
         * The destination domain list of the dns control policy.
         */
        domainLists: string[];
        /**
         * The hit count of the dns control policy.
         */
        hitCnt: number;
        /**
         * The id of the dns control policy.
         */
        id: string;
        /**
         * The last hit time of the dns control policy. Unix timestamp.
         */
        lastHitTime: number;
        /**
         * The id of the dns control policy.
         */
        ruleId: string;
        /**
         * The source list of the dns control policy. This field support fuzzy query.
         */
        sources: outputs.cloud_firewall.CfwDnsControlPoliciesDnsControlPolicySource[];
        /**
         * The enable status list of the dns control policy. This field support fuzzy query.
         */
        status: boolean;
        /**
         * The use count of the dns control policy.
         */
        useCount: number;
    }

    export interface CfwDnsControlPoliciesDnsControlPolicySource {
        /**
         * The region of the source vpc.
         */
        region: string;
        /**
         * The id of the source vpc.
         */
        vpcId: string;
    }

    export interface CfwDnsControlPolicySource {
        /**
         * The region of the source vpc.
         */
        region: string;
        /**
         * The id of the source vpc.
         */
        vpcId: string;
    }

    export interface CfwNatFirewallControlPoliciesNatFirewallControlPolicy {
        /**
         * The account id of the nat firewall control policy.
         */
        accountId: string;
        /**
         * The action list of the nat firewall control policy. Valid values: `accept`, `deny`, `monitor`.
         */
        action: string;
        /**
         * The description of the nat firewall control policy. This field support fuzzy query.
         */
        description: string;
        /**
         * The dest port of the nat firewall control policy.
         */
        destPort: string;
        /**
         * The dest port group list of the nat firewall control policy.
         */
        destPortGroupLists: string[];
        /**
         * The dest port group type of the nat firewall control policy.
         */
        destPortGroupType: string;
        /**
         * The dest port list of the nat firewall control policy.
         */
        destPortLists: string[];
        /**
         * The dest port type of the nat firewall control policy.
         */
        destPortType: string;
        /**
         * The destination of the nat firewall control policy. This field support fuzzy query.
         */
        destination: string;
        /**
         * The destination cidr list of the nat firewall control policy.
         */
        destinationCidrLists: string[];
        /**
         * The destination group list of the nat firewall control policy.
         */
        destinationGroupLists: string[];
        /**
         * The destination group type of the nat firewall control policy.
         */
        destinationGroupType: string;
        /**
         * The destination type of the nat firewall control policy.
         */
        destinationType: string;
        /**
         * The direction of nat firewall control policy. Valid values: `in`, `out`.
         */
        direction: string;
        /**
         * The effect status of the nat firewall control policy. 1: Not yet effective, 2: Issued in progress, 3: Effective.
         */
        effectStatus: number;
        /**
         * The end time of the nat firewall control policy. Unix timestamp.
         */
        endTime: number;
        /**
         * The hit count of the nat firewall control policy.
         */
        hitCnt: number;
        /**
         * The id of the nat firewall control policy.
         */
        id: string;
        /**
         * Whether the nat firewall control policy is effected.
         */
        isEffected: boolean;
        /**
         * The nat firewall id of the nat firewall control policy.
         */
        natFirewallId: string;
        /**
         * The name of the nat firewall.
         */
        natFirewallName: string;
        /**
         * The priority of the nat firewall control policy.
         */
        prio: number;
        /**
         * The proto list of the nat firewall control policy. Valid values: `TCP`, `ICMP`, `UDP`, `ANY`. When the destinationType is `domain`, The proto must be `TCP`.
         */
        proto: string;
        /**
         * The repeat days of the nat firewall control policy.
         */
        repeatDays: number[];
        /**
         * The repeat end time of the nat firewall control policy.
         */
        repeatEndTime: string;
        /**
         * The repeat start time of the nat firewall control policy.
         */
        repeatStartTime: string;
        /**
         * The repeat type of the nat firewall control policy. Valid values: `Permanent`, `Once`, `Daily`, `Weekly`, `Monthly`.
         */
        repeatType: string;
        /**
         * The rule id of the nat firewall control policy. This field support fuzzy query.
         */
        ruleId: string;
        /**
         * The source of the nat firewall control policy. This field support fuzzy query.
         */
        source: string;
        /**
         * The source cidr list of the nat firewall control policy.
         */
        sourceCidrLists: string[];
        /**
         * The source group list of the nat firewall control policy.
         */
        sourceGroupLists: string[];
        /**
         * The source group type of the nat firewall control policy.
         */
        sourceGroupType: string;
        /**
         * The source type of the nat firewall control policy.
         */
        sourceType: string;
        /**
         * The start time of the nat firewall control policy. Unix timestamp.
         */
        startTime: number;
        /**
         * The enable status list of the nat firewall control policy.
         */
        status: boolean;
        /**
         * The update time of the nat firewall control policy.
         */
        updateTime: number;
        /**
         * The use count of the nat firewall control policy.
         */
        useCount: number;
    }

    export interface CfwVpcFirewallAclRulesVpcFirewallAclRule {
        /**
         * The account id of the vpc firewall acl rule.
         */
        accountId: string;
        /**
         * The action list of the vpc firewall acl rule. Valid values: `accept`, `deny`, `monitor`.
         */
        action: string;
        /**
         * The description of the vpc firewall acl rule. This field support fuzzy query.
         */
        description: string;
        /**
         * The dest port of the vpc firewall acl rule.
         */
        destPort: string;
        /**
         * The dest port group type of the vpc firewall acl rule.
         */
        destPortGroupType: string;
        /**
         * The dest port list of the vpc firewall acl rule.
         */
        destPortLists: string[];
        /**
         * The dest port type of the vpc firewall acl rule.
         */
        destPortType: string;
        /**
         * The destination of the vpc firewall acl rule. This field support fuzzy query.
         */
        destination: string;
        /**
         * The destination cidr list of the vpc firewall acl rule.
         */
        destinationCidrLists: string[];
        /**
         * The destination group type of the vpc firewall acl rule.
         */
        destinationGroupType: string;
        /**
         * The destination type of the vpc firewall acl rule.
         */
        destinationType: string;
        /**
         * The effect status of the vpc firewall acl rule. 1: Not yet effective, 2: Issued in progress, 3: Effective.
         */
        effectStatus: number;
        /**
         * The end time of the vpc firewall acl rule. Unix timestamp.
         */
        endTime: number;
        /**
         * The hit count of the vpc firewall acl rule.
         */
        hitCnt: number;
        /**
         * The id of the vpc firewall acl rule.
         */
        id: string;
        /**
         * Whether the vpc firewall acl rule is effected.
         */
        isEffected: boolean;
        /**
         * The priority of the vpc firewall acl rule.
         */
        prio: number;
        /**
         * The proto list of the vpc firewall acl rule. Valid values: `TCP`, `ICMP`, `UDP`, `ANY`. When the destinationType is `domain`, The proto must be `TCP`.
         */
        proto: string;
        /**
         * The repeat days of the vpc firewall acl rule.
         */
        repeatDays: number[];
        /**
         * The repeat end time of the vpc firewall acl rule.
         */
        repeatEndTime: string;
        /**
         * The repeat start time of the vpc firewall acl rule.
         */
        repeatStartTime: string;
        /**
         * The repeat type of the vpc firewall acl rule. Valid values: `Permanent`, `Once`, `Daily`, `Weekly`, `Monthly`.
         */
        repeatType: string;
        /**
         * The rule id of the vpc firewall acl rule. This field support fuzzy query.
         */
        ruleId: string;
        /**
         * The source of the vpc firewall acl rule. This field support fuzzy query.
         */
        source: string;
        /**
         * The source cidr list of the vpc firewall acl rule.
         */
        sourceCidrLists: string[];
        /**
         * The source group type of the vpc firewall acl rule.
         */
        sourceGroupType: string;
        /**
         * The source type of the vpc firewall acl rule.
         */
        sourceType: string;
        /**
         * The start time of the vpc firewall acl rule. Unix timestamp.
         */
        startTime: number;
        /**
         * The enable status list of the vpc firewall acl rule.
         */
        status: boolean;
        /**
         * The update time of the vpc firewall acl rule.
         */
        updateTime: number;
        /**
         * The use count of the vpc firewall acl rule.
         */
        useCount: number;
        /**
         * The vpc firewall id of the vpc firewall acl rule.
         */
        vpcFirewallId: string;
        /**
         * The name of the vpc firewall.
         */
        vpcFirewallName: string;
    }

    export interface GetCfwAddressBooksAddressBook {
        /**
         * The address list of the address book.
         */
        addressLists: string[];
        /**
         * The group type of address book. This field support fuzzy query.
         */
        description: string;
        /**
         * The group name of address book. This field support fuzzy query.
         */
        groupName: string;
        /**
         * The group type of address book. Valid values: `ip`, `port`, `domain`.
         */
        groupType: string;
        /**
         * The uuid of the address book.
         */
        groupUuid: string;
        /**
         * The uuid of the address book.
         */
        id: string;
        /**
         * The reference count of the address book.
         */
        refCnt: number;
    }

    export interface GetCfwControlPoliciesControlPolicy {
        /**
         * The account id of the control policy.
         */
        accountId: string;
        /**
         * The action list of the control policy. Valid values: `accept`, `deny`, `monitor`.
         */
        action: string;
        /**
         * The description of the control policy. This field support fuzzy query.
         */
        description: string;
        /**
         * The dest port of the control policy.
         */
        destPort: string;
        /**
         * The dest port group type of the control policy.
         */
        destPortGroupType: string;
        /**
         * The dest port list of the control policy.
         */
        destPortLists: string[];
        /**
         * The dest port type of the control policy.
         */
        destPortType: string;
        /**
         * The destination of the control policy. This field support fuzzy query.
         */
        destination: string;
        /**
         * The destination cidr list of the control policy.
         */
        destinationCidrLists: string[];
        /**
         * The destination group type of the control policy.
         */
        destinationGroupType: string;
        /**
         * The destination type of the control policy.
         */
        destinationType: string;
        /**
         * The direction of control policy. Valid values: `in`, `out`.
         */
        direction: string;
        /**
         * The effect status of the control policy. 1: Not yet effective, 2: Issued in progress, 3: Effective.
         */
        effectStatus: number;
        /**
         * The end time of the control policy. Unix timestamp.
         */
        endTime: number;
        /**
         * The hit count of the control policy.
         */
        hitCnt: number;
        /**
         * The id of the control policy.
         */
        id: string;
        /**
         * Whether the control policy is effected.
         */
        isEffected: boolean;
        /**
         * The priority of the control policy.
         */
        prio: number;
        /**
         * The proto list of the control policy. Valid values: `TCP`, `ICMP`, `UDP`, `ANY`. When the destinationType is `domain`, The proto must be `TCP`.
         */
        proto: string;
        /**
         * The repeat days of the control policy.
         */
        repeatDays: number[];
        /**
         * The repeat end time of the control policy.
         */
        repeatEndTime: string;
        /**
         * The repeat start time of the control policy.
         */
        repeatStartTime: string;
        /**
         * The repeat type of the control policy. Valid values: `Permanent`, `Once`, `Daily`, `Weekly`, `Monthly`.
         */
        repeatType: string;
        /**
         * The rule id of the control policy. This field support fuzzy query.
         */
        ruleId: string;
        /**
         * The source of the control policy. This field support fuzzy query.
         */
        source: string;
        /**
         * The source cidr list of the control policy.
         */
        sourceCidrLists: string[];
        /**
         * The source group type of the control policy.
         */
        sourceGroupType: string;
        /**
         * The source type of the control policy.
         */
        sourceType: string;
        /**
         * The start time of the control policy. Unix timestamp.
         */
        startTime: number;
        /**
         * The enable status list of the control policy.
         */
        status: boolean;
        /**
         * The update time of the control policy.
         */
        updateTime: number;
        /**
         * The use count of the control policy.
         */
        useCount: number;
    }

    export interface GetCfwDnsControlPoliciesDnsControlPolicy {
        /**
         * The account id of the dns control policy.
         */
        accountId: string;
        /**
         * The description of the dns control policy. This field support fuzzy query.
         */
        description: string;
        /**
         * The destination list of the dns control policy. This field support fuzzy query.
         */
        destination: string;
        /**
         * The destination group list of the dns control policy.
         */
        destinationGroupLists: string[];
        /**
         * The destination type of the dns control policy.
         */
        destinationType: string;
        /**
         * The destination domain list of the dns control policy.
         */
        domainLists: string[];
        /**
         * The hit count of the dns control policy.
         */
        hitCnt: number;
        /**
         * The id of the dns control policy.
         */
        id: string;
        /**
         * The last hit time of the dns control policy. Unix timestamp.
         */
        lastHitTime: number;
        /**
         * The id of the dns control policy.
         */
        ruleId: string;
        /**
         * The source list of the dns control policy. This field support fuzzy query.
         */
        sources: outputs.cloud_firewall.GetCfwDnsControlPoliciesDnsControlPolicySource[];
        /**
         * The enable status list of the dns control policy. This field support fuzzy query.
         */
        status: boolean;
        /**
         * The use count of the dns control policy.
         */
        useCount: number;
    }

    export interface GetCfwDnsControlPoliciesDnsControlPolicySource {
        /**
         * The region of the source vpc.
         */
        region: string;
        /**
         * The id of the source vpc.
         */
        vpcId: string;
    }

    export interface GetCfwNatFirewallControlPoliciesNatFirewallControlPolicy {
        /**
         * The account id of the nat firewall control policy.
         */
        accountId: string;
        /**
         * The action list of the nat firewall control policy. Valid values: `accept`, `deny`, `monitor`.
         */
        action: string;
        /**
         * The description of the nat firewall control policy. This field support fuzzy query.
         */
        description: string;
        /**
         * The dest port of the nat firewall control policy.
         */
        destPort: string;
        /**
         * The dest port group list of the nat firewall control policy.
         */
        destPortGroupLists: string[];
        /**
         * The dest port group type of the nat firewall control policy.
         */
        destPortGroupType: string;
        /**
         * The dest port list of the nat firewall control policy.
         */
        destPortLists: string[];
        /**
         * The dest port type of the nat firewall control policy.
         */
        destPortType: string;
        /**
         * The destination of the nat firewall control policy. This field support fuzzy query.
         */
        destination: string;
        /**
         * The destination cidr list of the nat firewall control policy.
         */
        destinationCidrLists: string[];
        /**
         * The destination group list of the nat firewall control policy.
         */
        destinationGroupLists: string[];
        /**
         * The destination group type of the nat firewall control policy.
         */
        destinationGroupType: string;
        /**
         * The destination type of the nat firewall control policy.
         */
        destinationType: string;
        /**
         * The direction of nat firewall control policy. Valid values: `in`, `out`.
         */
        direction: string;
        /**
         * The effect status of the nat firewall control policy. 1: Not yet effective, 2: Issued in progress, 3: Effective.
         */
        effectStatus: number;
        /**
         * The end time of the nat firewall control policy. Unix timestamp.
         */
        endTime: number;
        /**
         * The hit count of the nat firewall control policy.
         */
        hitCnt: number;
        /**
         * The id of the nat firewall control policy.
         */
        id: string;
        /**
         * Whether the nat firewall control policy is effected.
         */
        isEffected: boolean;
        /**
         * The nat firewall id of the nat firewall control policy.
         */
        natFirewallId: string;
        /**
         * The name of the nat firewall.
         */
        natFirewallName: string;
        /**
         * The priority of the nat firewall control policy.
         */
        prio: number;
        /**
         * The proto list of the nat firewall control policy. Valid values: `TCP`, `ICMP`, `UDP`, `ANY`. When the destinationType is `domain`, The proto must be `TCP`.
         */
        proto: string;
        /**
         * The repeat days of the nat firewall control policy.
         */
        repeatDays: number[];
        /**
         * The repeat end time of the nat firewall control policy.
         */
        repeatEndTime: string;
        /**
         * The repeat start time of the nat firewall control policy.
         */
        repeatStartTime: string;
        /**
         * The repeat type of the nat firewall control policy. Valid values: `Permanent`, `Once`, `Daily`, `Weekly`, `Monthly`.
         */
        repeatType: string;
        /**
         * The rule id of the nat firewall control policy. This field support fuzzy query.
         */
        ruleId: string;
        /**
         * The source of the nat firewall control policy. This field support fuzzy query.
         */
        source: string;
        /**
         * The source cidr list of the nat firewall control policy.
         */
        sourceCidrLists: string[];
        /**
         * The source group list of the nat firewall control policy.
         */
        sourceGroupLists: string[];
        /**
         * The source group type of the nat firewall control policy.
         */
        sourceGroupType: string;
        /**
         * The source type of the nat firewall control policy.
         */
        sourceType: string;
        /**
         * The start time of the nat firewall control policy. Unix timestamp.
         */
        startTime: number;
        /**
         * The enable status list of the nat firewall control policy.
         */
        status: boolean;
        /**
         * The update time of the nat firewall control policy.
         */
        updateTime: number;
        /**
         * The use count of the nat firewall control policy.
         */
        useCount: number;
    }

    export interface GetCfwVpcFirewallAclRulesVpcFirewallAclRule {
        /**
         * The account id of the vpc firewall acl rule.
         */
        accountId: string;
        /**
         * The action list of the vpc firewall acl rule. Valid values: `accept`, `deny`, `monitor`.
         */
        action: string;
        /**
         * The description of the vpc firewall acl rule. This field support fuzzy query.
         */
        description: string;
        /**
         * The dest port of the vpc firewall acl rule.
         */
        destPort: string;
        /**
         * The dest port group type of the vpc firewall acl rule.
         */
        destPortGroupType: string;
        /**
         * The dest port list of the vpc firewall acl rule.
         */
        destPortLists: string[];
        /**
         * The dest port type of the vpc firewall acl rule.
         */
        destPortType: string;
        /**
         * The destination of the vpc firewall acl rule. This field support fuzzy query.
         */
        destination: string;
        /**
         * The destination cidr list of the vpc firewall acl rule.
         */
        destinationCidrLists: string[];
        /**
         * The destination group type of the vpc firewall acl rule.
         */
        destinationGroupType: string;
        /**
         * The destination type of the vpc firewall acl rule.
         */
        destinationType: string;
        /**
         * The effect status of the vpc firewall acl rule. 1: Not yet effective, 2: Issued in progress, 3: Effective.
         */
        effectStatus: number;
        /**
         * The end time of the vpc firewall acl rule. Unix timestamp.
         */
        endTime: number;
        /**
         * The hit count of the vpc firewall acl rule.
         */
        hitCnt: number;
        /**
         * The id of the vpc firewall acl rule.
         */
        id: string;
        /**
         * Whether the vpc firewall acl rule is effected.
         */
        isEffected: boolean;
        /**
         * The priority of the vpc firewall acl rule.
         */
        prio: number;
        /**
         * The proto list of the vpc firewall acl rule. Valid values: `TCP`, `ICMP`, `UDP`, `ANY`. When the destinationType is `domain`, The proto must be `TCP`.
         */
        proto: string;
        /**
         * The repeat days of the vpc firewall acl rule.
         */
        repeatDays: number[];
        /**
         * The repeat end time of the vpc firewall acl rule.
         */
        repeatEndTime: string;
        /**
         * The repeat start time of the vpc firewall acl rule.
         */
        repeatStartTime: string;
        /**
         * The repeat type of the vpc firewall acl rule. Valid values: `Permanent`, `Once`, `Daily`, `Weekly`, `Monthly`.
         */
        repeatType: string;
        /**
         * The rule id of the vpc firewall acl rule. This field support fuzzy query.
         */
        ruleId: string;
        /**
         * The source of the vpc firewall acl rule. This field support fuzzy query.
         */
        source: string;
        /**
         * The source cidr list of the vpc firewall acl rule.
         */
        sourceCidrLists: string[];
        /**
         * The source group type of the vpc firewall acl rule.
         */
        sourceGroupType: string;
        /**
         * The source type of the vpc firewall acl rule.
         */
        sourceType: string;
        /**
         * The start time of the vpc firewall acl rule. Unix timestamp.
         */
        startTime: number;
        /**
         * The enable status list of the vpc firewall acl rule.
         */
        status: boolean;
        /**
         * The update time of the vpc firewall acl rule.
         */
        updateTime: number;
        /**
         * The use count of the vpc firewall acl rule.
         */
        useCount: number;
        /**
         * The vpc firewall id of the vpc firewall acl rule.
         */
        vpcFirewallId: string;
        /**
         * The name of the vpc firewall.
         */
        vpcFirewallName: string;
    }

}

export namespace cloud_identity {
    export interface GetGroupsGroup {
        /**
         * The created time of the cloud identity group.
         */
        createdTime: string;
        /**
         * The description of the cloud identity group.
         */
        description: string;
        /**
         * The display name of cloud identity group.
         */
        displayName: string;
        /**
         * The id of the cloud identity group.
         */
        groupId: string;
        /**
         * The name of cloud identity group.
         */
        groupName: string;
        /**
         * The id of the cloud identity group.
         */
        id: string;
        /**
         * The join type of cloud identity group. Valid values: `Auto`, `Manual`.
         */
        joinType: string;
        /**
         * The source of the cloud identity group.
         */
        source: string;
        /**
         * The updated time of the cloud identity group.
         */
        updatedTime: string;
    }

    export interface GetPermissionSetAssignmentsAssignment {
        /**
         * The create time of the cloud identity permission set assignment.
         */
        createTime: string;
        /**
         * The id of the cloud identity permission set.
         */
        id: string;
        /**
         * The id of cloud identity permission set.
         */
        permissionSetId: string;
        /**
         * The name of the cloud identity permission set.
         */
        permissionSetName: string;
        /**
         * The principal id of cloud identity permission set. When the `principalType` is `User`, this field is specified to `UserId`. When the `principalType` is `Group`, this field is specified to `GroupId`.
         */
        principalId: string;
        /**
         * The principal type of cloud identity permission set. Valid values: `User`, `Group`.
         */
        principalType: string;
        /**
         * The target account id of cloud identity permission set assignment.
         */
        targetId: string;
    }

    export interface GetPermissionSetProvisioningsPermissionProvisioning {
        /**
         * The create time of the cloud identity permission set provisioning.
         */
        createTime: string;
        /**
         * The id of the cloud identity permission set.
         */
        id: string;
        /**
         * The id of cloud identity permission set.
         */
        permissionSetId: string;
        /**
         * The name of the cloud identity permission set.
         */
        permissionSetName: string;
        /**
         * The target account id of cloud identity permission set.
         */
        targetId: string;
        /**
         * The update time of the cloud identity permission set provisioning.
         */
        updateTime: string;
    }

    export interface GetPermissionSetsPermissionSet {
        /**
         * The create time of the cloud identity permission set.
         */
        createdTime: string;
        /**
         * The description of the cloud identity permission set.
         */
        description: string;
        /**
         * The id of the cloud identity permission set.
         */
        id: string;
        /**
         * The name of the cloud identity permission set.
         */
        name: string;
        /**
         * The policies of the cloud identity permission set.
         */
        permissionPolicies: outputs.cloud_identity.GetPermissionSetsPermissionSetPermissionPolicy[];
        /**
         * The id of the cloud identity permission set.
         */
        permissionSetId: string;
        /**
         * The relay state of the cloud identity permission set.
         */
        relayState: string;
        /**
         * The session duration of the cloud identity permission set.
         */
        sessionDuration: number;
        /**
         * The updated time of the cloud identity permission set.
         */
        updatedTime: string;
    }

    export interface GetPermissionSetsPermissionSetPermissionPolicy {
        /**
         * The create time of the cloud identity permission set policy.
         */
        createTime: string;
        /**
         * The document of the cloud identity permission set policy.
         */
        permissionPolicyDocument: string;
        /**
         * The name of the cloud identity permission set policy.
         */
        permissionPolicyName: string;
        /**
         * The type of the cloud identity permission set policy.
         */
        permissionPolicyType: string;
    }

    export interface GetUserProvisioningsUserProvisioning {
        /**
         * The created time of the cloud identity user provisioning.
         */
        createdTime: string;
        /**
         * The deletion strategy of the cloud identity user provisioning.
         */
        deletionStrategy: string;
        /**
         * The department names of the cloud identity user provisioning.
         */
        departmentNames: string[];
        /**
         * The description of the cloud identity user provisioning.
         */
        description: string;
        /**
         * The duplication strategy of the cloud identity user provisioning.
         */
        duplicationStrategy: string;
        /**
         * The duplication suffix of the cloud identity user provisioning.
         */
        duplicationSuffix: string;
        /**
         * The id of the cloud identity user provisioning.
         */
        id: string;
        /**
         * The identity source strategy of the cloud identity user provisioning.
         */
        identitySourceStrategy: string;
        /**
         * The principal id of the cloud identity user provisioning.
         */
        principalId: string;
        /**
         * The principal name of the cloud identity user provisioning.
         */
        principalName: string;
        /**
         * The principal type of the cloud identity user provisioning.
         */
        principalType: string;
        /**
         * The status of the cloud identity user provisioning.
         */
        provisionStatus: string;
        /**
         * The target account id of the cloud identity user provisioning.
         */
        targetId: string;
        /**
         * The updated time of the cloud identity user provisioning.
         */
        updatedTime: string;
        /**
         * The id of the cloud identity user provisioning.
         */
        userProvisioningId: string;
    }

    export interface GetUsersUser {
        /**
         * The created time of the cloud identity user.
         */
        createdTime: string;
        /**
         * The description of the cloud identity user.
         */
        description: string;
        /**
         * The display name of cloud identity user.
         */
        displayName: string;
        /**
         * The email of the cloud identity user.
         */
        email: string;
        /**
         * The id of the cloud identity user.
         */
        id: string;
        /**
         * The identity type of the cloud identity user.
         */
        identityType: string;
        /**
         * The phone of the cloud identity user.
         */
        phone: string;
        /**
         * The source of cloud identity user. Valid values: `Sync`, `Manual`.
         */
        source: string;
        /**
         * The updated time of the cloud identity user.
         */
        updatedTime: string;
        /**
         * The id of the cloud identity user.
         */
        userId: string;
        /**
         * The name of cloud identity user.
         */
        userName: string;
    }

    export interface GroupMember {
        /**
         * The description of the cloud identity group.
         */
        description: string;
        /**
         * The display name of the cloud identity group.
         */
        displayName: string;
        /**
         * The email of the cloud identity user.
         */
        email: string;
        /**
         * The identity type of the cloud identity user.
         */
        identityType: string;
        /**
         * The join time of the cloud identity user.
         */
        joinTime: string;
        /**
         * The phone of the cloud identity user.
         */
        phone: string;
        /**
         * The source of the cloud identity group.
         */
        source: string;
        /**
         * The id of the cloud identity user.
         */
        userId: string;
        /**
         * The name of the cloud identity user.
         */
        userName: string;
    }

    export interface GroupsGroup {
        /**
         * The created time of the cloud identity group.
         */
        createdTime: string;
        /**
         * The description of the cloud identity group.
         */
        description: string;
        /**
         * The display name of cloud identity group.
         */
        displayName: string;
        /**
         * The id of the cloud identity group.
         */
        groupId: string;
        /**
         * The name of cloud identity group.
         */
        groupName: string;
        /**
         * The id of the cloud identity group.
         */
        id: string;
        /**
         * The join type of cloud identity group. Valid values: `Auto`, `Manual`.
         */
        joinType: string;
        /**
         * The source of the cloud identity group.
         */
        source: string;
        /**
         * The updated time of the cloud identity group.
         */
        updatedTime: string;
    }

    export interface PermissionSetAssignmentsAssignment {
        /**
         * The create time of the cloud identity permission set assignment.
         */
        createTime: string;
        /**
         * The id of the cloud identity permission set.
         */
        id: string;
        /**
         * The id of cloud identity permission set.
         */
        permissionSetId: string;
        /**
         * The name of the cloud identity permission set.
         */
        permissionSetName: string;
        /**
         * The principal id of cloud identity permission set. When the `principalType` is `User`, this field is specified to `UserId`. When the `principalType` is `Group`, this field is specified to `GroupId`.
         */
        principalId: string;
        /**
         * The principal type of cloud identity permission set. Valid values: `User`, `Group`.
         */
        principalType: string;
        /**
         * The target account id of cloud identity permission set assignment.
         */
        targetId: string;
    }

    export interface PermissionSetPermissionPolicy {
        /**
         * The document of the cloud identity permission set inline policy. When the `permissionPolicyType` is `Inline`, this field must be specified.
         */
        inlinePolicyDocument?: string;
        /**
         * The name of the cloud identity permission set system policy. When the `permissionPolicyType` is `System`, this field must be specified.
         */
        permissionPolicyName: string;
        /**
         * The type of the cloud identity permission set policy. Valid values: `System`, `Inline`.
         */
        permissionPolicyType: string;
    }

    export interface PermissionSetProvisioningsPermissionProvisioning {
        /**
         * The create time of the cloud identity permission set provisioning.
         */
        createTime: string;
        /**
         * The id of the cloud identity permission set.
         */
        id: string;
        /**
         * The id of cloud identity permission set.
         */
        permissionSetId: string;
        /**
         * The name of the cloud identity permission set.
         */
        permissionSetName: string;
        /**
         * The target account id of cloud identity permission set.
         */
        targetId: string;
        /**
         * The update time of the cloud identity permission set provisioning.
         */
        updateTime: string;
    }

    export interface PermissionSetsPermissionSet {
        /**
         * The create time of the cloud identity permission set.
         */
        createdTime: string;
        /**
         * The description of the cloud identity permission set.
         */
        description: string;
        /**
         * The id of the cloud identity permission set.
         */
        id: string;
        /**
         * The name of the cloud identity permission set.
         */
        name: string;
        /**
         * The policies of the cloud identity permission set.
         */
        permissionPolicies: outputs.cloud_identity.PermissionSetsPermissionSetPermissionPolicy[];
        /**
         * The id of the cloud identity permission set.
         */
        permissionSetId: string;
        /**
         * The relay state of the cloud identity permission set.
         */
        relayState: string;
        /**
         * The session duration of the cloud identity permission set.
         */
        sessionDuration: number;
        /**
         * The updated time of the cloud identity permission set.
         */
        updatedTime: string;
    }

    export interface PermissionSetsPermissionSetPermissionPolicy {
        /**
         * The create time of the cloud identity permission set policy.
         */
        createTime: string;
        /**
         * The document of the cloud identity permission set policy.
         */
        permissionPolicyDocument: string;
        /**
         * The name of the cloud identity permission set policy.
         */
        permissionPolicyName: string;
        /**
         * The type of the cloud identity permission set policy.
         */
        permissionPolicyType: string;
    }

    export interface UserProvisioningsUserProvisioning {
        /**
         * The created time of the cloud identity user provisioning.
         */
        createdTime: string;
        /**
         * The deletion strategy of the cloud identity user provisioning.
         */
        deletionStrategy: string;
        /**
         * The department names of the cloud identity user provisioning.
         */
        departmentNames: string[];
        /**
         * The description of the cloud identity user provisioning.
         */
        description: string;
        /**
         * The duplication strategy of the cloud identity user provisioning.
         */
        duplicationStrategy: string;
        /**
         * The duplication suffix of the cloud identity user provisioning.
         */
        duplicationSuffix: string;
        /**
         * The id of the cloud identity user provisioning.
         */
        id: string;
        /**
         * The identity source strategy of the cloud identity user provisioning.
         */
        identitySourceStrategy: string;
        /**
         * The principal id of the cloud identity user provisioning.
         */
        principalId: string;
        /**
         * The principal name of the cloud identity user provisioning.
         */
        principalName: string;
        /**
         * The principal type of the cloud identity user provisioning.
         */
        principalType: string;
        /**
         * The status of the cloud identity user provisioning.
         */
        provisionStatus: string;
        /**
         * The target account id of the cloud identity user provisioning.
         */
        targetId: string;
        /**
         * The updated time of the cloud identity user provisioning.
         */
        updatedTime: string;
        /**
         * The id of the cloud identity user provisioning.
         */
        userProvisioningId: string;
    }

    export interface UsersUser {
        /**
         * The created time of the cloud identity user.
         */
        createdTime: string;
        /**
         * The description of the cloud identity user.
         */
        description: string;
        /**
         * The display name of cloud identity user.
         */
        displayName: string;
        /**
         * The email of the cloud identity user.
         */
        email: string;
        /**
         * The id of the cloud identity user.
         */
        id: string;
        /**
         * The identity type of the cloud identity user.
         */
        identityType: string;
        /**
         * The phone of the cloud identity user.
         */
        phone: string;
        /**
         * The source of cloud identity user. Valid values: `Sync`, `Manual`.
         */
        source: string;
        /**
         * The updated time of the cloud identity user.
         */
        updatedTime: string;
        /**
         * The id of the cloud identity user.
         */
        userId: string;
        /**
         * The name of cloud identity user.
         */
        userName: string;
    }

}

export namespace cloud_monitor {
    export interface ContactGroupsGroup {
        /**
         * The id of the account.
         */
        accountId: string;
        /**
         * Contact information in the contact group.
         */
        contacts: outputs.cloud_monitor.ContactGroupsGroupContact[];
        /**
         * The create time.
         */
        createdAt: string;
        /**
         * The description of the contact group.
         */
        description: string;
        /**
         * The id of the contact group.
         */
        id: string;
        /**
         * Search for keywords in contact group names, supports fuzzy search.
         */
        name: string;
        /**
         * The update time.
         */
        updatedAt: string;
    }

    export interface ContactGroupsGroupContact {
        /**
         * The email of contact.
         */
        email: string;
        /**
         * The id of the contact group.
         */
        id: string;
        /**
         * Search for keywords in contact group names, supports fuzzy search.
         */
        name: string;
        /**
         * The phone of contact.
         */
        phone: string;
    }

    export interface ContactsContact {
        /**
         * The email of contact.
         */
        email: string;
        /**
         * The ID of contact.
         */
        id: string;
        /**
         * The name of contact.
         */
        name: string;
        /**
         * The phone of contact.
         */
        phone: string;
    }

    export interface EventRuleEffectiveTime {
        /**
         * End time for rule activation.
         */
        endTime: string;
        /**
         * Start time for rule activation.
         */
        startTime: string;
    }

    export interface EventRuleFilterPattern {
        /**
         * Event source corresponding to pattern matching.
         */
        source: string;
        /**
         * The list of corresponding event types in pattern matching, currently set to match any.
         */
        types: string[];
    }

    export interface EventRuleMessageQueue {
        /**
         * The kafka instance id.
         */
        instanceId: string;
        /**
         * The region.
         */
        region: string;
        /**
         * The topic name.
         */
        topic: string;
        /**
         * The message queue type, only support kafka now.
         */
        type: string;
        /**
         * The vpc id.
         */
        vpcId: string;
    }

    export interface EventRuleTlsTarget {
        /**
         * The project id.
         */
        projectId: string;
        /**
         * The project name.
         */
        projectName: string;
        /**
         * The Chinese region name.
         */
        regionNameCn: string;
        /**
         * The English region name.
         */
        regionNameEn: string;
        /**
         * The topic id.
         */
        topicId: string;
    }

    export interface EventRulesRule {
        /**
         * The id of the account.
         */
        accountId: string;
        /**
         * When the alarm notification method is phone, SMS, or email, the triggered alarm contact group ID.
         */
        contactGroupIds: string[];
        /**
         * List of contact methods.
         */
        contactMethods: string[];
        /**
         * The create time.
         */
        createdAt: number;
        /**
         * The description of the rule.
         */
        description: string;
        /**
         * The end time of the rule.
         */
        effectEndAt: string;
        /**
         * The start time of the rule.
         */
        effectStartAt: string;
        /**
         * When the alarm notification method is alarm callback, it triggers the callback address.
         */
        endpoint: string;
        /**
         * The name of the event bus.
         */
        eventBusName: string;
        /**
         * The source of the event.
         */
        eventSource: string;
        /**
         * The event type.
         */
        eventTypes: string[];
        /**
         * Filter mode, also known as event matching rules. Custom matching rules are not currently supported.
         */
        filterPatterns: outputs.cloud_monitor.EventRulesRuleFilterPattern[];
        /**
         * The id of the rule.
         */
        id: string;
        /**
         * The level of the rule.
         */
        level: string;
        /**
         * The triggered message queue when the alarm notification method is Kafka message queue.
         */
        messageQueues: outputs.cloud_monitor.EventRulesRuleMessageQueue[];
        /**
         * The name of the region.
         */
        region: string;
        /**
         * The id of the rule.
         */
        ruleId: string;
        /**
         * Rule name, search rules by name using fuzzy search.
         */
        ruleName: string;
        /**
         * Enable the state of the rule.
         */
        status: string;
        /**
         * The alarm method for log service triggers the configuration of the log service.
         */
        tlsTargets: outputs.cloud_monitor.EventRulesRuleTlsTarget[];
        /**
         * The updated time.
         */
        updatedAt: number;
    }

    export interface EventRulesRuleFilterPattern {
        /**
         * Event source.
         */
        source: string;
        /**
         * The message queue type, only support kafka now.
         */
        types: string[];
    }

    export interface EventRulesRuleMessageQueue {
        /**
         * The kafka instance id.
         */
        instanceId: string;
        /**
         * The name of the region.
         */
        region: string;
        /**
         * The topic name.
         */
        topic: string;
        /**
         * The message queue type, only support kafka now.
         */
        type: string;
        /**
         * The vpc id.
         */
        vpcId: string;
    }

    export interface EventRulesRuleTlsTarget {
        /**
         * The project id.
         */
        projectId: string;
        /**
         * The project name.
         */
        projectName: string;
        /**
         * The Chinese region name.
         */
        regionNameCn: string;
        /**
         * The English region name.
         */
        regionNameEn: string;
        /**
         * The topic id.
         */
        topicId: string;
        /**
         * The topic name.
         */
        topicName: string;
    }

    export interface GetContactGroupsGroup {
        /**
         * The id of the account.
         */
        accountId: string;
        /**
         * Contact information in the contact group.
         */
        contacts: outputs.cloud_monitor.GetContactGroupsGroupContact[];
        /**
         * The create time.
         */
        createdAt: string;
        /**
         * The description of the contact group.
         */
        description: string;
        /**
         * The id of the contact group.
         */
        id: string;
        /**
         * Search for keywords in contact group names, supports fuzzy search.
         */
        name: string;
        /**
         * The update time.
         */
        updatedAt: string;
    }

    export interface GetContactGroupsGroupContact {
        /**
         * The email of contact.
         */
        email: string;
        /**
         * The id of the contact group.
         */
        id: string;
        /**
         * Search for keywords in contact group names, supports fuzzy search.
         */
        name: string;
        /**
         * The phone of contact.
         */
        phone: string;
    }

    export interface GetContactsContact {
        /**
         * The email of contact.
         */
        email: string;
        /**
         * The ID of contact.
         */
        id: string;
        /**
         * The name of contact.
         */
        name: string;
        /**
         * The phone of contact.
         */
        phone: string;
    }

    export interface GetEventRulesRule {
        /**
         * The id of the account.
         */
        accountId: string;
        /**
         * When the alarm notification method is phone, SMS, or email, the triggered alarm contact group ID.
         */
        contactGroupIds: string[];
        /**
         * List of contact methods.
         */
        contactMethods: string[];
        /**
         * The create time.
         */
        createdAt: number;
        /**
         * The description of the rule.
         */
        description: string;
        /**
         * The end time of the rule.
         */
        effectEndAt: string;
        /**
         * The start time of the rule.
         */
        effectStartAt: string;
        /**
         * When the alarm notification method is alarm callback, it triggers the callback address.
         */
        endpoint: string;
        /**
         * The name of the event bus.
         */
        eventBusName: string;
        /**
         * The source of the event.
         */
        eventSource: string;
        /**
         * The event type.
         */
        eventTypes: string[];
        /**
         * Filter mode, also known as event matching rules. Custom matching rules are not currently supported.
         */
        filterPatterns: outputs.cloud_monitor.GetEventRulesRuleFilterPattern[];
        /**
         * The id of the rule.
         */
        id: string;
        /**
         * The level of the rule.
         */
        level: string;
        /**
         * The triggered message queue when the alarm notification method is Kafka message queue.
         */
        messageQueues: outputs.cloud_monitor.GetEventRulesRuleMessageQueue[];
        /**
         * The name of the region.
         */
        region: string;
        /**
         * The id of the rule.
         */
        ruleId: string;
        /**
         * Rule name, search rules by name using fuzzy search.
         */
        ruleName: string;
        /**
         * Enable the state of the rule.
         */
        status: string;
        /**
         * The alarm method for log service triggers the configuration of the log service.
         */
        tlsTargets: outputs.cloud_monitor.GetEventRulesRuleTlsTarget[];
        /**
         * The updated time.
         */
        updatedAt: number;
    }

    export interface GetEventRulesRuleFilterPattern {
        /**
         * Event source.
         */
        source: string;
        /**
         * The message queue type, only support kafka now.
         */
        types: string[];
    }

    export interface GetEventRulesRuleMessageQueue {
        /**
         * The kafka instance id.
         */
        instanceId: string;
        /**
         * The name of the region.
         */
        region: string;
        /**
         * The topic name.
         */
        topic: string;
        /**
         * The message queue type, only support kafka now.
         */
        type: string;
        /**
         * The vpc id.
         */
        vpcId: string;
    }

    export interface GetEventRulesRuleTlsTarget {
        /**
         * The project id.
         */
        projectId: string;
        /**
         * The project name.
         */
        projectName: string;
        /**
         * The Chinese region name.
         */
        regionNameCn: string;
        /**
         * The English region name.
         */
        regionNameEn: string;
        /**
         * The topic id.
         */
        topicId: string;
        /**
         * The topic name.
         */
        topicName: string;
    }

    export interface GetRulesRule {
        /**
         * The alert methods of the cloud monitor rule.
         */
        alertMethods: string[];
        /**
         * The alert state of the cloud monitor rule. Valid values: `altering`, `normal`.
         */
        alertState: string;
        /**
         * The condition operator of the cloud monitor rule. Valid values: `&&`, `||`.
         */
        conditionOperator: string;
        /**
         * The conditions of the cloud monitor rule.
         */
        conditions: outputs.cloud_monitor.GetRulesRuleCondition[];
        /**
         * The contact group ids of the cloud monitor rule.
         */
        contactGroupIds: string[];
        /**
         * The created time of the cloud monitor rule.
         */
        createdAt: string;
        /**
         * The description of the cloud monitor rule.
         */
        description: string;
        /**
         * The effect end time of the cloud monitor rule.
         */
        effectEndAt: string;
        /**
         * The effect start time of the cloud monitor rule.
         */
        effectStartAt: string;
        /**
         * The enable state of the cloud monitor rule. Valid values: `enable`, `disable`.
         */
        enableState: string;
        /**
         * The evaluation count of the cloud monitor rule.
         */
        evaluationCount: number;
        /**
         * The id of the cloud monitor rule.
         */
        id: string;
        /**
         * The level of the cloud monitor rule. Valid values: `critical`, `warning`, `notice`.
         */
        level: string;
        /**
         * Whether to enable the multiple conditions function of the cloud monitor rule.
         */
        multipleConditions: boolean;
        /**
         * The namespace of the cloud monitor rule.
         */
        namespace: string;
        /**
         * The original dimensions of the cloud monitor rule.
         */
        originalDimensions: outputs.cloud_monitor.GetRulesRuleOriginalDimension[];
        /**
         * The region id of the cloud monitor rule.
         */
        regions: string[];
        /**
         * The name of the cloud monitor rule. This field support fuzzy query.
         */
        ruleName: string;
        /**
         * The silence time of the cloud monitor rule. Unit in minutes.
         */
        silenceTime: number;
        /**
         * The sub namespace of the cloud monitor rule.
         */
        subNamespace: string;
        /**
         * The updated time of the cloud monitor rule.
         */
        updatedAt: string;
        /**
         * The web hook of the cloud monitor rule.
         */
        webHook: string;
        /**
         * The webhook id list of the cloud monitor rule.
         */
        webhookIds: string[];
    }

    export interface GetRulesRuleCondition {
        /**
         * The comparison operation of the cloud monitor rule.
         */
        comparisonOperator: string;
        /**
         * The metric name of the cloud monitor rule.
         */
        metricName: string;
        /**
         * The metric unit of the cloud monitor rule.
         */
        metricUnit: string;
        /**
         * The period of the cloud monitor rule.
         */
        period: string;
        /**
         * The statistics of the cloud monitor rule.
         */
        statistics: string;
        /**
         * The threshold of the cloud monitor rule.
         */
        threshold: string;
    }

    export interface GetRulesRuleOriginalDimension {
        /**
         * The key of the dimension.
         */
        key: string;
        /**
         * The value of the dimension.
         */
        values: string[];
    }

    export interface RuleCondition {
        /**
         * The comparison operation of the cloud monitor rule. Valid values: `>`, `>=`, `<`, `<=`, `!=`, `=`.
         */
        comparisonOperator: string;
        /**
         * The metric name of the cloud monitor rule.
         */
        metricName: string;
        /**
         * The metric unit of the cloud monitor rule.
         */
        metricUnit: string;
        /**
         * The period of the cloud monitor rule.
         */
        period: string;
        /**
         * The statistics of the cloud monitor rule. Valid values: `avg`, `max`, `min`.
         */
        statistics: string;
        /**
         * The threshold of the cloud monitor rule.
         */
        threshold: string;
    }

    export interface RuleOriginalDimension {
        /**
         * The key of the dimension.
         */
        key: string;
        /**
         * The value of the dimension.
         */
        values: string[];
    }

    export interface RuleRecoveryNotify {
        /**
         * Whether to enable the recovery notify function.
         */
        enable?: boolean;
    }

    export interface RulesRule {
        /**
         * The alert methods of the cloud monitor rule.
         */
        alertMethods: string[];
        /**
         * The alert state of the cloud monitor rule. Valid values: `altering`, `normal`.
         */
        alertState: string;
        /**
         * The condition operator of the cloud monitor rule. Valid values: `&&`, `||`.
         */
        conditionOperator: string;
        /**
         * The conditions of the cloud monitor rule.
         */
        conditions: outputs.cloud_monitor.RulesRuleCondition[];
        /**
         * The contact group ids of the cloud monitor rule.
         */
        contactGroupIds: string[];
        /**
         * The created time of the cloud monitor rule.
         */
        createdAt: string;
        /**
         * The description of the cloud monitor rule.
         */
        description: string;
        /**
         * The effect end time of the cloud monitor rule.
         */
        effectEndAt: string;
        /**
         * The effect start time of the cloud monitor rule.
         */
        effectStartAt: string;
        /**
         * The enable state of the cloud monitor rule. Valid values: `enable`, `disable`.
         */
        enableState: string;
        /**
         * The evaluation count of the cloud monitor rule.
         */
        evaluationCount: number;
        /**
         * The id of the cloud monitor rule.
         */
        id: string;
        /**
         * The level of the cloud monitor rule. Valid values: `critical`, `warning`, `notice`.
         */
        level: string;
        /**
         * Whether to enable the multiple conditions function of the cloud monitor rule.
         */
        multipleConditions: boolean;
        /**
         * The namespace of the cloud monitor rule.
         */
        namespace: string;
        /**
         * The original dimensions of the cloud monitor rule.
         */
        originalDimensions: outputs.cloud_monitor.RulesRuleOriginalDimension[];
        /**
         * The region id of the cloud monitor rule.
         */
        regions: string[];
        /**
         * The name of the cloud monitor rule. This field support fuzzy query.
         */
        ruleName: string;
        /**
         * The silence time of the cloud monitor rule. Unit in minutes.
         */
        silenceTime: number;
        /**
         * The sub namespace of the cloud monitor rule.
         */
        subNamespace: string;
        /**
         * The updated time of the cloud monitor rule.
         */
        updatedAt: string;
        /**
         * The web hook of the cloud monitor rule.
         */
        webHook: string;
        /**
         * The webhook id list of the cloud monitor rule.
         */
        webhookIds: string[];
    }

    export interface RulesRuleCondition {
        /**
         * The comparison operation of the cloud monitor rule.
         */
        comparisonOperator: string;
        /**
         * The metric name of the cloud monitor rule.
         */
        metricName: string;
        /**
         * The metric unit of the cloud monitor rule.
         */
        metricUnit: string;
        /**
         * The period of the cloud monitor rule.
         */
        period: string;
        /**
         * The statistics of the cloud monitor rule.
         */
        statistics: string;
        /**
         * The threshold of the cloud monitor rule.
         */
        threshold: string;
    }

    export interface RulesRuleOriginalDimension {
        /**
         * The key of the dimension.
         */
        key: string;
        /**
         * The value of the dimension.
         */
        values: string[];
    }

}

export namespace cloudfs {
    export interface AccessesAccess {
        /**
         * The account id of access.
         */
        accessAccountId: number;
        /**
         * The id of access.
         */
        accessId: string;
        /**
         * The service name of access.
         */
        accessServiceName: string;
        /**
         * The creation time.
         */
        createdTime: string;
        /**
         * The name of file system.
         */
        fsName: string;
        /**
         * Whether is default access.
         */
        isDefault: boolean;
        /**
         * The id of security group.
         */
        securityGroupId: string;
        /**
         * The status of access.
         */
        status: string;
        /**
         * The id of subnet.
         */
        subnetId: string;
        /**
         * The id of vpc.
         */
        vpcId: string;
        /**
         * Whether to enable all vpc route.
         */
        vpcRouteEnabled: boolean;
    }

    export interface FileSystemsFileSystem {
        /**
         * The capacity of cache.
         */
        cacheCapacityTib: number;
        /**
         * The plan of cache.
         */
        cachePlan: string;
        /**
         * The creation time.
         */
        createdTime: string;
        /**
         * The ID of file system.
         */
        id: string;
        /**
         * The mode of file system.
         */
        mode: string;
        /**
         * The point mount.
         */
        mountPoint: string;
        /**
         * The name of file system.
         */
        name: string;
        /**
         * The id of region.
         */
        regionId: string;
        /**
         * The id of security group.
         */
        securityGroupId: string;
        /**
         * The status of file system.
         */
        status: string;
        /**
         * The id of subnet.
         */
        subnetId: string;
        /**
         * The tos bucket.
         */
        tosBucket: string;
        /**
         * The tos prefix.
         */
        tosPrefix: string;
        /**
         * The id of vpc.
         */
        vpcId: string;
        /**
         * The id of zone.
         */
        zoneId: string;
    }

    export interface GetAccessesAccess {
        /**
         * The account id of access.
         */
        accessAccountId: number;
        /**
         * The id of access.
         */
        accessId: string;
        /**
         * The service name of access.
         */
        accessServiceName: string;
        /**
         * The creation time.
         */
        createdTime: string;
        /**
         * The name of file system.
         */
        fsName: string;
        /**
         * Whether is default access.
         */
        isDefault: boolean;
        /**
         * The id of security group.
         */
        securityGroupId: string;
        /**
         * The status of access.
         */
        status: string;
        /**
         * The id of subnet.
         */
        subnetId: string;
        /**
         * The id of vpc.
         */
        vpcId: string;
        /**
         * Whether to enable all vpc route.
         */
        vpcRouteEnabled: boolean;
    }

    export interface GetFileSystemsFileSystem {
        /**
         * The capacity of cache.
         */
        cacheCapacityTib: number;
        /**
         * The plan of cache.
         */
        cachePlan: string;
        /**
         * The creation time.
         */
        createdTime: string;
        /**
         * The ID of file system.
         */
        id: string;
        /**
         * The mode of file system.
         */
        mode: string;
        /**
         * The point mount.
         */
        mountPoint: string;
        /**
         * The name of file system.
         */
        name: string;
        /**
         * The id of region.
         */
        regionId: string;
        /**
         * The id of security group.
         */
        securityGroupId: string;
        /**
         * The status of file system.
         */
        status: string;
        /**
         * The id of subnet.
         */
        subnetId: string;
        /**
         * The tos bucket.
         */
        tosBucket: string;
        /**
         * The tos prefix.
         */
        tosPrefix: string;
        /**
         * The id of vpc.
         */
        vpcId: string;
        /**
         * The id of zone.
         */
        zoneId: string;
    }

    export interface GetNamespacesNamespace {
        /**
         * The creation time of the namespace.
         */
        createdTime: string;
        /**
         * The ID of the namespace.
         */
        id: string;
        /**
         * Whether the tos bucket is your own bucket.
         */
        isMyBucket: boolean;
        /**
         * Whether the namespace is read-only.
         */
        readOnly: boolean;
        /**
         * Whether the namespace is the official service for volcengine.
         */
        serviceManaged: boolean;
        /**
         * The status of the namespace.
         */
        status: string;
        /**
         * The name of tos bucket.
         */
        tosBucket: string;
        /**
         * The tos prefix.
         */
        tosPrefix: string;
    }

    export interface GetNsQuotasQuota {
        /**
         * The ID of account.
         */
        accountId: number;
        /**
         * The name of fs.
         */
        fsName: string;
        /**
         * The count of cloud fs namespace.
         */
        nsCount: number;
        /**
         * This file stores the number of namespaces under the instance.
         */
        nsCountPerFs: number;
        /**
         * The quota of cloud fs namespace.
         */
        nsQuota: number;
        /**
         * This file stores the total namespace quota under the instance.
         */
        nsQuotaPerFs: number;
        /**
         * Whether is enough of cloud fs namespace.
         */
        quotaEnough: boolean;
    }

    export interface GetQuotasQuota {
        /**
         * The ID of account.
         */
        accountId: number;
        /**
         * The count of cloud fs.
         */
        fsCount: number;
        /**
         * The quota of cloud fs.
         */
        fsQuota: number;
        /**
         * Whether is enough of cloud fs.
         */
        quotaEnough: boolean;
    }

    export interface NamespacesNamespace {
        /**
         * The creation time of the namespace.
         */
        createdTime: string;
        /**
         * The ID of the namespace.
         */
        id: string;
        /**
         * Whether the tos bucket is your own bucket.
         */
        isMyBucket: boolean;
        /**
         * Whether the namespace is read-only.
         */
        readOnly: boolean;
        /**
         * Whether the namespace is the official service for volcengine.
         */
        serviceManaged: boolean;
        /**
         * The status of the namespace.
         */
        status: string;
        /**
         * The name of tos bucket.
         */
        tosBucket: string;
        /**
         * The tos prefix.
         */
        tosPrefix: string;
    }

    export interface NsQuotasQuota {
        /**
         * The ID of account.
         */
        accountId: number;
        /**
         * The name of fs.
         */
        fsName: string;
        /**
         * The count of cloud fs namespace.
         */
        nsCount: number;
        /**
         * This file stores the number of namespaces under the instance.
         */
        nsCountPerFs: number;
        /**
         * The quota of cloud fs namespace.
         */
        nsQuota: number;
        /**
         * This file stores the total namespace quota under the instance.
         */
        nsQuotaPerFs: number;
        /**
         * Whether is enough of cloud fs namespace.
         */
        quotaEnough: boolean;
    }

    export interface QuotasQuota {
        /**
         * The ID of account.
         */
        accountId: number;
        /**
         * The count of cloud fs.
         */
        fsCount: number;
        /**
         * The quota of cloud fs.
         */
        fsQuota: number;
        /**
         * Whether is enough of cloud fs.
         */
        quotaEnough: boolean;
    }

}

export namespace config {
    export interface AssumeRole {
        /**
         * The session name to use when making the AssumeRole call.
         */
        assumeRoleSessionName: string;
        /**
         * The TRN of the role to assume.
         */
        assumeRoleTrn: string;
        /**
         * The duration of the session when making the AssumeRole call. Its value ranges from 900 to 43200(seconds), and default is 3600 seconds.
         */
        durationSeconds: number;
        /**
         * A more restrictive policy when making the AssumeRole call.
         */
        policy?: string;
    }

    export interface AssumeRoleWithOidc {
        /**
         * The duration of the session when making the AssumeRole call. Its value ranges from 900 to 43200(seconds), and default is 3600 seconds.
         */
        durationSeconds: number;
        /**
         * The OIDC token to use when making the AssumeRole call.
         */
        oidcToken: string;
        /**
         * A more restrictive policy when making the AssumeRole call.
         */
        policy?: string;
        /**
         * The session name to use when making the AssumeRole call.
         */
        roleSessionName: string;
        /**
         * The TRN of the role to assume, in the format `trn:iam:${AccountId}:role/${RoleName}`.
         */
        roleTrn: string;
    }

}

export namespace cr {
    export interface AuthorizationTokensToken {
        /**
         * The expiration time of the temporary access token.
         */
        expireTime: string;
        /**
         * The Temporary access token.
         */
        token: string;
        /**
         * The username for login repository instance.
         */
        username: string;
    }

    export interface EndpointAclPolicy {
        /**
         * The description of the acl policy.
         */
        description: string;
        /**
         * The ip of the acl policy.
         */
        entry: string;
    }

    export interface EndpointsEndpoint {
        /**
         * The list of acl policies.
         */
        aclPolicies: outputs.cr.EndpointsEndpointAclPolicy[];
        /**
         * Whether public endpoint is enabled.
         */
        enabled: boolean;
        /**
         * The CR instance name.
         */
        registry: string;
        /**
         * The status of public endpoint.
         */
        status: string;
    }

    export interface EndpointsEndpointAclPolicy {
        /**
         * The description of the acl policy.
         */
        description: string;
        /**
         * The ip of the acl policy.
         */
        entry: string;
    }

    export interface GetAuthorizationTokensToken {
        /**
         * The expiration time of the temporary access token.
         */
        expireTime: string;
        /**
         * The Temporary access token.
         */
        token: string;
        /**
         * The username for login repository instance.
         */
        username: string;
    }

    export interface GetEndpointsEndpoint {
        /**
         * The list of acl policies.
         */
        aclPolicies: outputs.cr.GetEndpointsEndpointAclPolicy[];
        /**
         * Whether public endpoint is enabled.
         */
        enabled: boolean;
        /**
         * The CR instance name.
         */
        registry: string;
        /**
         * The status of public endpoint.
         */
        status: string;
    }

    export interface GetEndpointsEndpointAclPolicy {
        /**
         * The description of the acl policy.
         */
        description: string;
        /**
         * The ip of the acl policy.
         */
        entry: string;
    }

    export interface GetNamespacesNamespace {
        /**
         * The time when namespace created.
         */
        createTime: string;
        /**
         * The name of OCI repository.
         */
        name: string;
        /**
         * The ProjectName of the CrNamespace.
         */
        project: string;
        /**
         * The default access level of repository. Valid values: `Private`, `Public`.
         */
        repositoryDefaultAccessLevel: string;
    }

    export interface GetRegistriesRegistry {
        /**
         * The charge type of registry.
         */
        chargeType: string;
        /**
         * The creation time of registry.
         */
        createTime: string;
        /**
         * The domain of registry.
         */
        domains: outputs.cr.GetRegistriesRegistryDomain[];
        /**
         * The name of registry.
         */
        name: string;
        /**
         * The ProjectName of the cr registry.
         */
        project: string;
        /**
         * Whether to enable proxy cache.
         */
        proxyCacheEnabled: boolean;
        /**
         * The proxy cache of registry. This field is valid when proxyCacheEnabled is true.
         */
        proxyCaches: outputs.cr.GetRegistriesRegistryProxyCach[];
        /**
         * The tags of cr registry.
         */
        resourceTags: outputs.cr.GetRegistriesRegistryResourceTag[];
        /**
         * The status of registry.
         */
        status: outputs.cr.GetRegistriesRegistryStatus;
        /**
         * The type of registry.
         */
        type: string;
        /**
         * The status of user.
         */
        userStatus: string;
        /**
         * The username of cr instance.
         */
        username: string;
    }

    export interface GetRegistriesRegistryDomain {
        /**
         * The domain of registry.
         */
        domain: string;
        /**
         * The type of registry.
         */
        type: string;
    }

    export interface GetRegistriesRegistryProxyCach {
        /**
         * The endpoint of proxy cache.
         */
        endpoint: string;
        /**
         * Whether to skip ssl verify.
         */
        skipSslVerify: boolean;
        /**
         * The type of registry.
         */
        type: string;
        /**
         * The username of cr instance.
         */
        username: string;
    }

    export interface GetRegistriesRegistryResourceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetRegistriesRegistryStatus {
        /**
         * The condition of registry.
         */
        conditions: string[];
        /**
         * The phase status of registry.
         */
        phase: string;
    }

    export interface GetRegistriesResourceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        values: string[];
    }

    export interface GetRegistriesStatus {
        /**
         * The condition of registry.
         */
        condition?: string;
        /**
         * The phase of status.
         */
        phase?: string;
    }

    export interface GetRepositoriesRepository {
        /**
         * The access level of repository.
         */
        accessLevel: string;
        /**
         * The creation time of repository.
         */
        createTime: string;
        /**
         * The description of repository.
         */
        description: string;
        /**
         * The name of repository.
         */
        name: string;
        /**
         * The namespace of repository.
         */
        namespace: string;
        /**
         * The last update time of repository.
         */
        updateTime: string;
    }

    export interface GetTagsTag {
        /**
         * The chart attribute,valid when tag type is Chart.
         */
        chartAttribute: outputs.cr.GetTagsTagChartAttribute;
        /**
         * The digest of image.
         */
        digest: string;
        /**
         * The list of image attributes,valid when tag type is Image.
         */
        imageAttributes: outputs.cr.GetTagsTagImageAttribute[];
        /**
         * The name of OCI product tag.
         */
        name: string;
        /**
         * The last push time of OCI product.
         */
        pushTime: string;
        /**
         * The size of OCI product.
         */
        size: number;
        /**
         * The type of OCI product tag.
         */
        type: string;
    }

    export interface GetTagsTagChartAttribute {
        /**
         * The Helm version.
         */
        apiVersion: string;
        /**
         * The name of OCI product tag.
         */
        name: string;
        /**
         * The Helm Chart version.
         */
        version: string;
    }

    export interface GetTagsTagImageAttribute {
        /**
         * The image architecture.
         */
        architecture: string;
        /**
         * The image author.
         */
        author: string;
        /**
         * The digest of image.
         */
        digest: string;
        /**
         * The iamge os.
         */
        os: string;
    }

    export interface GetVpcEndpointsEndpoint {
        /**
         * The CR registry name.
         */
        registry: string;
        /**
         * List of vpc information.
         */
        vpcs: outputs.cr.GetVpcEndpointsEndpointVpc[];
    }

    export interface GetVpcEndpointsEndpointVpc {
        /**
         * The id of the account.
         */
        accountId: number;
        /**
         * The creation time.
         */
        createTime: string;
        /**
         * The IP address of the mirror repository in the VPC.
         */
        ip: string;
        /**
         * The region id.
         */
        region: string;
        /**
         * The status of the vpc endpoint.
         */
        status: string;
        /**
         * The ID of the subnet.
         */
        subnetId: string;
        /**
         * The ID of the vpc.
         */
        vpcId: string;
    }

    export interface NamespacesNamespace {
        /**
         * The time when namespace created.
         */
        createTime: string;
        /**
         * The name of OCI repository.
         */
        name: string;
        /**
         * The ProjectName of the CrNamespace.
         */
        project: string;
        /**
         * The default access level of repository. Valid values: `Private`, `Public`.
         */
        repositoryDefaultAccessLevel: string;
    }

    export interface RegistriesRegistry {
        /**
         * The charge type of registry.
         */
        chargeType: string;
        /**
         * The creation time of registry.
         */
        createTime: string;
        /**
         * The domain of registry.
         */
        domains: outputs.cr.RegistriesRegistryDomain[];
        /**
         * The name of registry.
         */
        name: string;
        /**
         * The ProjectName of the cr registry.
         */
        project: string;
        /**
         * Whether to enable proxy cache.
         */
        proxyCacheEnabled: boolean;
        /**
         * The proxy cache of registry. This field is valid when proxyCacheEnabled is true.
         */
        proxyCaches: outputs.cr.RegistriesRegistryProxyCach[];
        /**
         * The tags of cr registry.
         */
        resourceTags: outputs.cr.RegistriesRegistryResourceTag[];
        /**
         * The status of registry.
         */
        status: outputs.cr.RegistriesRegistryStatus;
        /**
         * The type of registry.
         */
        type: string;
        /**
         * The status of user.
         */
        userStatus: string;
        /**
         * The username of cr instance.
         */
        username: string;
    }

    export interface RegistriesRegistryDomain {
        /**
         * The domain of registry.
         */
        domain: string;
        /**
         * The type of registry.
         */
        type: string;
    }

    export interface RegistriesRegistryProxyCach {
        /**
         * The endpoint of proxy cache.
         */
        endpoint: string;
        /**
         * Whether to skip ssl verify.
         */
        skipSslVerify: boolean;
        /**
         * The type of registry.
         */
        type: string;
        /**
         * The username of cr instance.
         */
        username: string;
    }

    export interface RegistriesRegistryResourceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface RegistriesRegistryStatus {
        /**
         * The condition of registry.
         */
        conditions: string[];
        /**
         * The phase status of registry.
         */
        phase: string;
    }

    export interface RegistriesResourceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        values: string[];
    }

    export interface RegistriesStatus {
        /**
         * The condition of registry.
         */
        condition?: string;
        /**
         * The phase of status.
         */
        phase?: string;
    }

    export interface RegistryDomain {
        /**
         * The domain of registry.
         */
        domain: string;
        /**
         * The type of registry. Valid values: `Enterprise`, `Micro`. Default is `Enterprise`.
         */
        type: string;
    }

    export interface RegistryProxyCache {
        /**
         * The endpoint of proxy cache.
         */
        endpoint: string;
        /**
         * The password of proxy cache.
         */
        password?: string;
        /**
         * Whether to skip ssl verify.
         */
        skipSslVerify: boolean;
        /**
         * The type of proxy cache. Valid values: `DockerHub`, `DockerRegistry`.
         */
        type: string;
        /**
         * The username of proxy cache.
         */
        username: string;
    }

    export interface RegistryResourceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface RegistryStatus {
        /**
         * The condition of registry.
         */
        conditions: string[];
        /**
         * The phase status of registry.
         */
        phase: string;
    }

    export interface RepositoriesRepository {
        /**
         * The access level of repository.
         */
        accessLevel: string;
        /**
         * The creation time of repository.
         */
        createTime: string;
        /**
         * The description of repository.
         */
        description: string;
        /**
         * The name of repository.
         */
        name: string;
        /**
         * The namespace of repository.
         */
        namespace: string;
        /**
         * The last update time of repository.
         */
        updateTime: string;
    }

    export interface StateStatus {
        /**
         * The condition of instance.
         */
        conditions: string[];
        /**
         * The phase status of instance.
         */
        phase: string;
    }

    export interface TagChartAttribute {
        /**
         * The Helm version.
         */
        apiVersion: string;
        /**
         * The name of OCI product.
         */
        name: string;
        /**
         * The Helm Chart version.
         */
        version: string;
    }

    export interface TagImageAttribute {
        /**
         * The image architecture.
         */
        architecture: string;
        /**
         * The image author.
         */
        author: string;
        /**
         * The digest of image.
         */
        digest: string;
        /**
         * The iamge os.
         */
        os: string;
    }

    export interface TagsTag {
        /**
         * The chart attribute,valid when tag type is Chart.
         */
        chartAttribute: outputs.cr.TagsTagChartAttribute;
        /**
         * The digest of image.
         */
        digest: string;
        /**
         * The list of image attributes,valid when tag type is Image.
         */
        imageAttributes: outputs.cr.TagsTagImageAttribute[];
        /**
         * The name of OCI product tag.
         */
        name: string;
        /**
         * The last push time of OCI product.
         */
        pushTime: string;
        /**
         * The size of OCI product.
         */
        size: number;
        /**
         * The type of OCI product tag.
         */
        type: string;
    }

    export interface TagsTagChartAttribute {
        /**
         * The Helm version.
         */
        apiVersion: string;
        /**
         * The name of OCI product tag.
         */
        name: string;
        /**
         * The Helm Chart version.
         */
        version: string;
    }

    export interface TagsTagImageAttribute {
        /**
         * The image architecture.
         */
        architecture: string;
        /**
         * The image author.
         */
        author: string;
        /**
         * The digest of image.
         */
        digest: string;
        /**
         * The iamge os.
         */
        os: string;
    }

    export interface VpcEndpointVpc {
        /**
         * The id of the account. When you need to expose the Enterprise Edition instance to a VPC under another primary account, you need to specify the ID of the primary account to which the VPC belongs.
         */
        accountId: number;
        /**
         * The id of the subnet. If not specified, the subnet with the most remaining IPs under the VPC will be automatically selected.
         */
        subnetId: string;
        /**
         * The id of the vpc.
         */
        vpcId?: string;
    }

    export interface VpcEndpointsEndpoint {
        /**
         * The CR registry name.
         */
        registry: string;
        /**
         * List of vpc information.
         */
        vpcs: outputs.cr.VpcEndpointsEndpointVpc[];
    }

    export interface VpcEndpointsEndpointVpc {
        /**
         * The id of the account.
         */
        accountId: number;
        /**
         * The creation time.
         */
        createTime: string;
        /**
         * The IP address of the mirror repository in the VPC.
         */
        ip: string;
        /**
         * The region id.
         */
        region: string;
        /**
         * The status of the vpc endpoint.
         */
        status: string;
        /**
         * The ID of the subnet.
         */
        subnetId: string;
        /**
         * The ID of the vpc.
         */
        vpcId: string;
    }

}

export namespace direct_connect {
    export interface BgpPeersBgpPeer {
        /**
         * The id of account.
         */
        accountId: string;
        /**
         * The key of auth.
         */
        authKey: string;
        /**
         * The id of bgp peer.
         */
        bgpPeerId: string;
        /**
         * The name of bgp peer.
         */
        bgpPeerName: string;
        /**
         * The create time of bgp peer.
         */
        creationTime: string;
        /**
         * The Description of bgp peer.
         */
        description: string;
        /**
         * The local asn of bgp peer.
         */
        localAsn: number;
        /**
         * The remote asn of bgp peer.
         */
        remoteAsn: number;
        /**
         * The session status of bgp peer.
         */
        sessionStatus: string;
        /**
         * The status of bgp peer.
         */
        status: string;
        /**
         * The update time of bgp peer.
         */
        updateTime: string;
        /**
         * The id of virtual interface.
         */
        virtualInterfaceId: string;
    }

    export interface ConnectionTag {
        /**
         * The tag key.
         */
        key?: string;
        /**
         * The tag value.
         */
        value?: string;
    }

    export interface ConnectionsDirectConnectConnection {
        /**
         * The account ID which the physical leased line belongs.
         */
        accountId: string;
        /**
         * The bandwidth of direct connect.
         */
        bandwidth: number;
        /**
         * The dedicated line billing type,only support `1` for yearly and monthly billing currently.
         */
        billingType: number;
        /**
         * The dedicated line billing status.
         */
        businessStatus: string;
        /**
         * The connection type of physical leased line,valid value contains `SharedConnection`,`DedicatedConnection`.
         */
        connectionType: string;
        /**
         * The creation time of direct connect.
         */
        creationTime: string;
        /**
         * The dedicated line contact email.
         */
        customerContactEmail: string;
        /**
         * The dedicated line contact phone.
         */
        customerContactPhone: string;
        /**
         * The dedicated line contact name.
         */
        customerName: string;
        /**
         * The expected resource force collection time.
         */
        deletedTime: string;
        /**
         * The description of direct connect connection.
         */
        description: string;
        /**
         * The ID of the physical leased line access point.
         */
        directConnectAccessPointId: string;
        /**
         * The ID of direct connect connection.
         */
        directConnectConnectionId: string;
        /**
         * The name of directi connect connection.
         */
        directConnectConnectionName: string;
        /**
         * The expect bandwidth of direct connect.
         */
        expectBandwidth: number;
        /**
         * The expired time.
         */
        expiredTime: string;
        /**
         * The operator of the physical leased line,valid value contains `ChinaTelecom`,`ChinaMobile`,`ChinaUnicom`,`ChinaOther`.
         */
        lineOperator: string;
        /**
         * The account ID of physical leased line to which the shared leased line belongs.If the physical leased line type is an exclusive leased line,this parameter returns empty.
         */
        parentConnectionAccountId: string;
        /**
         * The ID of the physical leased line to which the shared leased line belongs. If the physical leased line type is an exclusive leased line, this parameter returns empty.
         */
        parentConnectionId: string;
        /**
         * The peer access point of the physical leased line.
         */
        peerLocation: string;
        /**
         * The dedicated line port spec.
         */
        portSpec: string;
        /**
         * The port type of direct connect.
         */
        portType: string;
        /**
         * The status of physical leased line.
         */
        status: string;
        /**
         * All tags that physical leased line added.
         */
        tags: outputs.direct_connect.ConnectionsDirectConnectConnectionTag[];
        /**
         * The update time of direct connect.
         */
        updateTime: string;
        /**
         * The vlan ID of shared connection,if `connectionType` is `DedicatedConnection`,this parameter returns 0.
         */
        vlanId: number;
    }

    export interface ConnectionsDirectConnectConnectionTag {
        /**
         * The tag key.
         */
        key: string;
        /**
         * The tag value.
         */
        value: string;
    }

    export interface ConnectionsTagFilter {
        /**
         * The tag key of cloud resource instance.
         */
        key?: string;
        /**
         * The tag value of cloud resource instance.
         */
        value?: string;
    }

    export interface GatewayRoutesDirectConnectGatewayRoute {
        /**
         * The id of account.
         */
        accountId: string;
        /**
         * The create time.
         */
        creationTime: string;
        /**
         * The cidr block.
         */
        destinationCidrBlock: string;
        /**
         * The id of direct connect gateway.
         */
        directConnectGatewayId: string;
        /**
         * The id of direct connect gateway route.
         */
        directConnectGatewayRouteId: string;
        /**
         * The id of next hop.
         */
        nextHopId: string;
        /**
         * The type of next hop.
         */
        nextHopType: string;
        /**
         * The type of route. The value can be BGP or CEN or Static.
         */
        routeType: string;
        /**
         * The status info.
         */
        status: string;
    }

    export interface GatewayTag {
        /**
         * The tag key.
         */
        key?: string;
        /**
         * The tag value.
         */
        value?: string;
    }

    export interface GatewaysDirectConnectGateway {
        /**
         * The account ID that direct connect gateway belongs.
         */
        accountId: string;
        /**
         * The CEN information associated with the direct connect gateway.
         */
        associateCens: outputs.direct_connect.GatewaysDirectConnectGatewayAssociateCen[];
        /**
         * The business status of direct connect gateway.
         */
        businessStatus: string;
        /**
         * The creation time of direct connect gateway.
         */
        creationTime: string;
        /**
         * The expected resource force collection time. Only when the resource is frozen due to arrears, this parameter will have a return value, otherwise it will return a null value.
         */
        deletedTime: string;
        /**
         * The description of direct connect gateway.
         */
        description: string;
        /**
         * The direct connect gateway ID.
         */
        directConnectGatewayId: string;
        /**
         * The direst connect gateway name.
         */
        directConnectGatewayName: string;
        /**
         * The reason of the direct connect gateway locked.
         */
        lockReason: string;
        /**
         * The resource freeze time. Only when the resource is frozen due to arrears, this parameter will have a return value, otherwise it will return a null value.
         */
        overdueTime: string;
        /**
         * The status of direct connect gateway.
         */
        status: string;
        /**
         * The tags that direct connect gateway added.
         */
        tags: outputs.direct_connect.GatewaysDirectConnectGatewayTag[];
        /**
         * The update time of direct connect gateway.
         */
        updateTime: string;
    }

    export interface GatewaysDirectConnectGatewayAssociateCen {
        /**
         * The CEN ID which direct connect gateway belongs.
         */
        cenId: string;
        /**
         * The CEN owner's ID.
         */
        cenOwnerId: string;
        /**
         * The CEN status.
         */
        cenStatus: string;
    }

    export interface GatewaysDirectConnectGatewayTag {
        /**
         * The tag key.
         */
        key: string;
        /**
         * The tag value.
         */
        value: string;
    }

    export interface GatewaysTagFilter {
        /**
         * The tag key of cloud resource instance.
         */
        key?: string;
        /**
         * The tag value of cloud resource instance.
         */
        value?: string;
    }

    export interface GetBgpPeersBgpPeer {
        /**
         * The id of account.
         */
        accountId: string;
        /**
         * The key of auth.
         */
        authKey: string;
        /**
         * The id of bgp peer.
         */
        bgpPeerId: string;
        /**
         * The name of bgp peer.
         */
        bgpPeerName: string;
        /**
         * The create time of bgp peer.
         */
        creationTime: string;
        /**
         * The Description of bgp peer.
         */
        description: string;
        /**
         * The local asn of bgp peer.
         */
        localAsn: number;
        /**
         * The remote asn of bgp peer.
         */
        remoteAsn: number;
        /**
         * The session status of bgp peer.
         */
        sessionStatus: string;
        /**
         * The status of bgp peer.
         */
        status: string;
        /**
         * The update time of bgp peer.
         */
        updateTime: string;
        /**
         * The id of virtual interface.
         */
        virtualInterfaceId: string;
    }

    export interface GetConnectionsDirectConnectConnection {
        /**
         * The account ID which the physical leased line belongs.
         */
        accountId: string;
        /**
         * The bandwidth of direct connect.
         */
        bandwidth: number;
        /**
         * The dedicated line billing type,only support `1` for yearly and monthly billing currently.
         */
        billingType: number;
        /**
         * The dedicated line billing status.
         */
        businessStatus: string;
        /**
         * The connection type of physical leased line,valid value contains `SharedConnection`,`DedicatedConnection`.
         */
        connectionType: string;
        /**
         * The creation time of direct connect.
         */
        creationTime: string;
        /**
         * The dedicated line contact email.
         */
        customerContactEmail: string;
        /**
         * The dedicated line contact phone.
         */
        customerContactPhone: string;
        /**
         * The dedicated line contact name.
         */
        customerName: string;
        /**
         * The expected resource force collection time.
         */
        deletedTime: string;
        /**
         * The description of direct connect connection.
         */
        description: string;
        /**
         * The ID of the physical leased line access point.
         */
        directConnectAccessPointId: string;
        /**
         * The ID of direct connect connection.
         */
        directConnectConnectionId: string;
        /**
         * The name of directi connect connection.
         */
        directConnectConnectionName: string;
        /**
         * The expect bandwidth of direct connect.
         */
        expectBandwidth: number;
        /**
         * The expired time.
         */
        expiredTime: string;
        /**
         * The operator of the physical leased line,valid value contains `ChinaTelecom`,`ChinaMobile`,`ChinaUnicom`,`ChinaOther`.
         */
        lineOperator: string;
        /**
         * The account ID of physical leased line to which the shared leased line belongs.If the physical leased line type is an exclusive leased line,this parameter returns empty.
         */
        parentConnectionAccountId: string;
        /**
         * The ID of the physical leased line to which the shared leased line belongs. If the physical leased line type is an exclusive leased line, this parameter returns empty.
         */
        parentConnectionId: string;
        /**
         * The peer access point of the physical leased line.
         */
        peerLocation: string;
        /**
         * The dedicated line port spec.
         */
        portSpec: string;
        /**
         * The port type of direct connect.
         */
        portType: string;
        /**
         * The status of physical leased line.
         */
        status: string;
        /**
         * All tags that physical leased line added.
         */
        tags: outputs.direct_connect.GetConnectionsDirectConnectConnectionTag[];
        /**
         * The update time of direct connect.
         */
        updateTime: string;
        /**
         * The vlan ID of shared connection,if `connectionType` is `DedicatedConnection`,this parameter returns 0.
         */
        vlanId: number;
    }

    export interface GetConnectionsDirectConnectConnectionTag {
        /**
         * The tag key.
         */
        key: string;
        /**
         * The tag value.
         */
        value: string;
    }

    export interface GetConnectionsTagFilter {
        /**
         * The tag key of cloud resource instance.
         */
        key?: string;
        /**
         * The tag value of cloud resource instance.
         */
        value?: string;
    }

    export interface GetGatewayRoutesDirectConnectGatewayRoute {
        /**
         * The id of account.
         */
        accountId: string;
        /**
         * The create time.
         */
        creationTime: string;
        /**
         * The cidr block.
         */
        destinationCidrBlock: string;
        /**
         * The id of direct connect gateway.
         */
        directConnectGatewayId: string;
        /**
         * The id of direct connect gateway route.
         */
        directConnectGatewayRouteId: string;
        /**
         * The id of next hop.
         */
        nextHopId: string;
        /**
         * The type of next hop.
         */
        nextHopType: string;
        /**
         * The type of route. The value can be BGP or CEN or Static.
         */
        routeType: string;
        /**
         * The status info.
         */
        status: string;
    }

    export interface GetGatewaysDirectConnectGateway {
        /**
         * The account ID that direct connect gateway belongs.
         */
        accountId: string;
        /**
         * The CEN information associated with the direct connect gateway.
         */
        associateCens: outputs.direct_connect.GetGatewaysDirectConnectGatewayAssociateCen[];
        /**
         * The business status of direct connect gateway.
         */
        businessStatus: string;
        /**
         * The creation time of direct connect gateway.
         */
        creationTime: string;
        /**
         * The expected resource force collection time. Only when the resource is frozen due to arrears, this parameter will have a return value, otherwise it will return a null value.
         */
        deletedTime: string;
        /**
         * The description of direct connect gateway.
         */
        description: string;
        /**
         * The direct connect gateway ID.
         */
        directConnectGatewayId: string;
        /**
         * The direst connect gateway name.
         */
        directConnectGatewayName: string;
        /**
         * The reason of the direct connect gateway locked.
         */
        lockReason: string;
        /**
         * The resource freeze time. Only when the resource is frozen due to arrears, this parameter will have a return value, otherwise it will return a null value.
         */
        overdueTime: string;
        /**
         * The status of direct connect gateway.
         */
        status: string;
        /**
         * The tags that direct connect gateway added.
         */
        tags: outputs.direct_connect.GetGatewaysDirectConnectGatewayTag[];
        /**
         * The update time of direct connect gateway.
         */
        updateTime: string;
    }

    export interface GetGatewaysDirectConnectGatewayAssociateCen {
        /**
         * The CEN ID which direct connect gateway belongs.
         */
        cenId: string;
        /**
         * The CEN owner's ID.
         */
        cenOwnerId: string;
        /**
         * The CEN status.
         */
        cenStatus: string;
    }

    export interface GetGatewaysDirectConnectGatewayTag {
        /**
         * The tag key.
         */
        key: string;
        /**
         * The tag value.
         */
        value: string;
    }

    export interface GetGatewaysTagFilter {
        /**
         * The tag key of cloud resource instance.
         */
        key?: string;
        /**
         * The tag value of cloud resource instance.
         */
        value?: string;
    }

    export interface GetVirtualInterfacesTagFilter {
        /**
         * The tag key of cloud resource instance.
         */
        key?: string;
        /**
         * The tag value of cloud resource instance.
         */
        value?: string;
    }

    export interface GetVirtualInterfacesVirtualInterface {
        /**
         * The account ID which this virtual interface belongs.
         */
        accountId: string;
        /**
         * The band width limit of virtual interface,in Mbps.
         */
        bandwidth: number;
        /**
         * The BFD detect interval.
         */
        bfdDetectInterval: number;
        /**
         * The BFD detect times.
         */
        bfdDetectMultiplier: number;
        /**
         * The creation time of virtual interface.
         */
        creationTime: string;
        /**
         * The description of the virtual interface.
         */
        description: string;
        /**
         * The direct connect connection ID that associated with this virtual interface.
         */
        directConnectConnectionId: string;
        /**
         * The direct connect gateway ID that associated with this virtual interface.
         */
        directConnectGatewayId: string;
        /**
         * Whether enable BFD detect.
         */
        enableBfd: boolean;
        /**
         * Whether enable NQA detect.
         */
        enableNqa: boolean;
        /**
         * The local IP that associated with this virtual interface.
         */
        localIp: string;
        /**
         * The NQA detect interval.
         */
        nqaDetectInterval: number;
        /**
         * The NAQ detect times.
         */
        nqaDetectMultiplier: number;
        /**
         * The peer IP that associated with this virtual interface.
         */
        peerIp: string;
        /**
         * The route type of virtual interface.
         */
        routeType: string;
        /**
         * The status of virtaul interface.
         */
        status: string;
        /**
         * The tags that direct connect gateway added.
         */
        tags: outputs.direct_connect.GetVirtualInterfacesVirtualInterfaceTag[];
        /**
         * The update time of virtual interface.
         */
        updateTime: string;
        /**
         * The virtual interface ID.
         */
        virtualInterfaceId: string;
        /**
         * The name of virtual interface.
         */
        virtualInterfaceName: string;
        /**
         * The VLAN ID of virtual interface.
         */
        vlanId: number;
    }

    export interface GetVirtualInterfacesVirtualInterfaceTag {
        /**
         * The tag key.
         */
        key: string;
        /**
         * The tag value.
         */
        value: string;
    }

    export interface VirtualInterfaceTag {
        /**
         * The tag key.
         */
        key?: string;
        /**
         * The tag value.
         */
        value?: string;
    }

    export interface VirtualInterfacesTagFilter {
        /**
         * The tag key of cloud resource instance.
         */
        key?: string;
        /**
         * The tag value of cloud resource instance.
         */
        value?: string;
    }

    export interface VirtualInterfacesVirtualInterface {
        /**
         * The account ID which this virtual interface belongs.
         */
        accountId: string;
        /**
         * The band width limit of virtual interface,in Mbps.
         */
        bandwidth: number;
        /**
         * The BFD detect interval.
         */
        bfdDetectInterval: number;
        /**
         * The BFD detect times.
         */
        bfdDetectMultiplier: number;
        /**
         * The creation time of virtual interface.
         */
        creationTime: string;
        /**
         * The description of the virtual interface.
         */
        description: string;
        /**
         * The direct connect connection ID that associated with this virtual interface.
         */
        directConnectConnectionId: string;
        /**
         * The direct connect gateway ID that associated with this virtual interface.
         */
        directConnectGatewayId: string;
        /**
         * Whether enable BFD detect.
         */
        enableBfd: boolean;
        /**
         * Whether enable NQA detect.
         */
        enableNqa: boolean;
        /**
         * The local IP that associated with this virtual interface.
         */
        localIp: string;
        /**
         * The NQA detect interval.
         */
        nqaDetectInterval: number;
        /**
         * The NAQ detect times.
         */
        nqaDetectMultiplier: number;
        /**
         * The peer IP that associated with this virtual interface.
         */
        peerIp: string;
        /**
         * The route type of virtual interface.
         */
        routeType: string;
        /**
         * The status of virtaul interface.
         */
        status: string;
        /**
         * The tags that direct connect gateway added.
         */
        tags: outputs.direct_connect.VirtualInterfacesVirtualInterfaceTag[];
        /**
         * The update time of virtual interface.
         */
        updateTime: string;
        /**
         * The virtual interface ID.
         */
        virtualInterfaceId: string;
        /**
         * The name of virtual interface.
         */
        virtualInterfaceName: string;
        /**
         * The VLAN ID of virtual interface.
         */
        vlanId: number;
    }

    export interface VirtualInterfacesVirtualInterfaceTag {
        /**
         * The tag key.
         */
        key: string;
        /**
         * The tag value.
         */
        value: string;
    }

}

export namespace dns {
    export interface BackupsBackupInfo {
        /**
         * The ID of the backup.
         */
        backupId: string;
        /**
         * The time when the backup was created. The time zone is UTC + 8.
         */
        backupTime: string;
        /**
         * The number of DNS records in the backup.
         */
        recordCount: number;
    }

    export interface GetBackupsBackupInfo {
        /**
         * The ID of the backup.
         */
        backupId: string;
        /**
         * The time when the backup was created. The time zone is UTC + 8.
         */
        backupTime: string;
        /**
         * The number of DNS records in the backup.
         */
        recordCount: number;
    }

    export interface GetRecordSetsRecordSet {
        /**
         * The domain prefix of the record set.
         */
        host: string;
        /**
         * The ID of the DNS record set.
         */
        id: string;
        /**
         * The line code corresponding to the DNS record set.
         */
        line: string;
        /**
         * The domain prefix contained in the DNS record set, in PQDN (Partially Qualified Domain Name) format.
         */
        pqdn: string;
        /**
         * The type of DNS records in the DNS record set.
         */
        type: string;
        /**
         * Indicates whether load balancing is enabled for the DNS record set.
         */
        weightEnabled: boolean;
    }

    export interface GetRecordsRecord {
        /**
         * The creation time of the domain.
         */
        createdAt: string;
        /**
         * Indicates whether the DNS record is enabled.
         */
        enable: boolean;
        /**
         * Domain prefix of the DNS record.
         */
        host: string;
        /**
         * Line of the DNS record.
         */
        line: string;
        /**
         * The account ID that called this API.
         */
        operators: string[];
        /**
         * The hostname included in the DNS record, in PQDN (Partially Qualified Domain Name) format.
         */
        pqdn: string;
        /**
         * The ID of the DNS record.
         */
        recordId: string;
        /**
         * The ID of the record set to which the DNS record belongs.
         */
        recordSetId: string;
        /**
         * The remark of the DNS record.
         */
        remark: string;
        /**
         * The tag information of the DNS record.
         */
        tags: string[];
        /**
         * The Time to Live (TTL) of the DNS record. The unit is seconds.
         */
        ttl: number;
        /**
         * Type of the DNS record.
         */
        type: string;
        /**
         * The most recent update time of the domain.
         */
        updatedAt: string;
        /**
         * Value of the DNS record.
         */
        value: string;
        /**
         * The weight of the DNS record.
         */
        weight: number;
    }

    export interface GetZonesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        values: string[];
    }

    export interface GetZonesZone {
        /**
         * The list of DNS servers allocated to the domain by BytePlus DNS.
         */
        allocateDnsServerLists: string[];
        /**
         * Whether automatic domain renewal is enabled.
         */
        autoRenew: boolean;
        /**
         * The most recent update time of the domain.
         */
        cacheStage: number;
        /**
         * The creation time of the domain.
         */
        createdAt: string;
        /**
         * The version of DNS DDoS protection service.
         */
        dnsSecurity: string;
        /**
         * The expiration time of the domain.
         */
        expiredTime: number;
        /**
         * The id of the zone.
         */
        id: string;
        /**
         * The ID of the instance.
         */
        instanceId: string;
        /**
         * The ID of the instance. For free edition, the value of this field is null.
         */
        instanceNo: string;
        /**
         * Indicates whether the configuration of NS servers is correct. If the configuration is correct, the status of the domain in BytePlus DNS is Active.
         */
        isNsCorrect: boolean;
        /**
         * Whether the domain is a subdomain.
         */
        isSubDomain: boolean;
        /**
         * The ID of the account that last updated this domain.
         */
        lastOperator: string;
        /**
         * The ProjectName of the domain.
         */
        projectName: string;
        /**
         * The list of DNS servers actually used by the domain.
         */
        realDnsServerLists: string[];
        /**
         * The total number of DNS records contained in the domain.
         */
        recordCount: number;
        /**
         * The remarks for the domain.
         */
        remark: string;
        /**
         * The status of the domain.
         */
        stage: number;
        /**
         * The domain prefix of the subdomain. If the domain is not a subdomain, this parameter is null.
         */
        subDomainHost: string;
        /**
         * Tags.
         */
        tags: outputs.dns.GetZonesZoneTag[];
        /**
         * The edition of the domain.
         */
        tradeCode: string;
        /**
         * The most recent update time of the domain.
         */
        updatedAt: string;
        /**
         * The ID of the domain.
         */
        zid: number;
        /**
         * The domain name.
         */
        zoneName: string;
    }

    export interface GetZonesZoneTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface RecordSetsRecordSet {
        /**
         * The domain prefix of the record set.
         */
        host: string;
        /**
         * The ID of the DNS record set.
         */
        id: string;
        /**
         * The line code corresponding to the DNS record set.
         */
        line: string;
        /**
         * The domain prefix contained in the DNS record set, in PQDN (Partially Qualified Domain Name) format.
         */
        pqdn: string;
        /**
         * The type of DNS records in the DNS record set.
         */
        type: string;
        /**
         * Indicates whether load balancing is enabled for the DNS record set.
         */
        weightEnabled: boolean;
    }

    export interface RecordsRecord {
        /**
         * The creation time of the domain.
         */
        createdAt: string;
        /**
         * Indicates whether the DNS record is enabled.
         */
        enable: boolean;
        /**
         * Domain prefix of the DNS record.
         */
        host: string;
        /**
         * Line of the DNS record.
         */
        line: string;
        /**
         * The account ID that called this API.
         */
        operators: string[];
        /**
         * The hostname included in the DNS record, in PQDN (Partially Qualified Domain Name) format.
         */
        pqdn: string;
        /**
         * The ID of the DNS record.
         */
        recordId: string;
        /**
         * The ID of the record set to which the DNS record belongs.
         */
        recordSetId: string;
        /**
         * The remark of the DNS record.
         */
        remark: string;
        /**
         * The tag information of the DNS record.
         */
        tags: string[];
        /**
         * The Time to Live (TTL) of the DNS record. The unit is seconds.
         */
        ttl: number;
        /**
         * Type of the DNS record.
         */
        type: string;
        /**
         * The most recent update time of the domain.
         */
        updatedAt: string;
        /**
         * Value of the DNS record.
         */
        value: string;
        /**
         * The weight of the DNS record.
         */
        weight: number;
    }

    export interface ZoneTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface ZonesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        values: string[];
    }

    export interface ZonesZone {
        /**
         * The list of DNS servers allocated to the domain by BytePlus DNS.
         */
        allocateDnsServerLists: string[];
        /**
         * Whether automatic domain renewal is enabled.
         */
        autoRenew: boolean;
        /**
         * The most recent update time of the domain.
         */
        cacheStage: number;
        /**
         * The creation time of the domain.
         */
        createdAt: string;
        /**
         * The version of DNS DDoS protection service.
         */
        dnsSecurity: string;
        /**
         * The expiration time of the domain.
         */
        expiredTime: number;
        /**
         * The id of the zone.
         */
        id: string;
        /**
         * The ID of the instance.
         */
        instanceId: string;
        /**
         * The ID of the instance. For free edition, the value of this field is null.
         */
        instanceNo: string;
        /**
         * Indicates whether the configuration of NS servers is correct. If the configuration is correct, the status of the domain in BytePlus DNS is Active.
         */
        isNsCorrect: boolean;
        /**
         * Whether the domain is a subdomain.
         */
        isSubDomain: boolean;
        /**
         * The ID of the account that last updated this domain.
         */
        lastOperator: string;
        /**
         * The ProjectName of the domain.
         */
        projectName: string;
        /**
         * The list of DNS servers actually used by the domain.
         */
        realDnsServerLists: string[];
        /**
         * The total number of DNS records contained in the domain.
         */
        recordCount: number;
        /**
         * The remarks for the domain.
         */
        remark: string;
        /**
         * The status of the domain.
         */
        stage: number;
        /**
         * The domain prefix of the subdomain. If the domain is not a subdomain, this parameter is null.
         */
        subDomainHost: string;
        /**
         * Tags.
         */
        tags: outputs.dns.ZonesZoneTag[];
        /**
         * The edition of the domain.
         */
        tradeCode: string;
        /**
         * The most recent update time of the domain.
         */
        updatedAt: string;
        /**
         * The ID of the domain.
         */
        zid: number;
        /**
         * The domain name.
         */
        zoneName: string;
    }

    export interface ZonesZoneTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

}

export namespace ebs {
    export interface AutoSnapshotPoliciesAutoSnapshotPolicy {
        /**
         * The id of the auto snapshot policy.
         */
        autoSnapshotPolicyId: string;
        /**
         * The name of the auto snapshot policy.
         */
        autoSnapshotPolicyName: string;
        /**
         * The creation time of the auto snapshot policy.
         */
        createdAt: string;
        /**
         * The id of the auto snapshot policy.
         */
        id: string;
        /**
         * The project name of auto snapshot policy.
         */
        projectName: string;
        /**
         * Create snapshots repeatedly on a daily basis, with intervals of a certain number of days between each snapshot.
         */
        repeatDays: number;
        /**
         * The date of creating snapshot repeatedly by week. The value range is `1-7`, for example, 1 represents Monday.
         */
        repeatWeekdays: string[];
        /**
         * The retention days of the auto snapshot. `-1` means permanently preserving the snapshot.
         */
        retentionDays: number;
        /**
         * The status of the auto snapshot policy.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.ebs.AutoSnapshotPoliciesAutoSnapshotPolicyTag[];
        /**
         * The creation time points of the auto snapshot policy. The value range is `0~23`, representing a total of 24 time points from 00:00 to 23:00, for example, 1 represents 01:00.
         */
        timePoints: string[];
        /**
         * The updated time of the auto snapshot policy.
         */
        updatedAt: string;
        /**
         * The number of volumes associated with the auto snapshot policy.
         */
        volumeNums: number;
    }

    export interface AutoSnapshotPoliciesAutoSnapshotPolicyTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface AutoSnapshotPoliciesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface AutoSnapshotPolicyTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetAutoSnapshotPoliciesAutoSnapshotPolicy {
        /**
         * The id of the auto snapshot policy.
         */
        autoSnapshotPolicyId: string;
        /**
         * The name of the auto snapshot policy.
         */
        autoSnapshotPolicyName: string;
        /**
         * The creation time of the auto snapshot policy.
         */
        createdAt: string;
        /**
         * The id of the auto snapshot policy.
         */
        id: string;
        /**
         * The project name of auto snapshot policy.
         */
        projectName: string;
        /**
         * Create snapshots repeatedly on a daily basis, with intervals of a certain number of days between each snapshot.
         */
        repeatDays: number;
        /**
         * The date of creating snapshot repeatedly by week. The value range is `1-7`, for example, 1 represents Monday.
         */
        repeatWeekdays: string[];
        /**
         * The retention days of the auto snapshot. `-1` means permanently preserving the snapshot.
         */
        retentionDays: number;
        /**
         * The status of the auto snapshot policy.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.ebs.GetAutoSnapshotPoliciesAutoSnapshotPolicyTag[];
        /**
         * The creation time points of the auto snapshot policy. The value range is `0~23`, representing a total of 24 time points from 00:00 to 23:00, for example, 1 represents 01:00.
         */
        timePoints: string[];
        /**
         * The updated time of the auto snapshot policy.
         */
        updatedAt: string;
        /**
         * The number of volumes associated with the auto snapshot policy.
         */
        volumeNums: number;
    }

    export interface GetAutoSnapshotPoliciesAutoSnapshotPolicyTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetAutoSnapshotPoliciesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetMaxExtraPerformancesPerformance {
        /**
         * The baseline of the performance.
         */
        baselines: outputs.ebs.GetMaxExtraPerformancesPerformanceBaseline[];
        /**
         * The limit of the extra performance.
         */
        limits: outputs.ebs.GetMaxExtraPerformancesPerformanceLimit[];
        /**
         * The max extra performance can purchase.
         */
        maxExtraPerformanceCanPurchases: outputs.ebs.GetMaxExtraPerformancesPerformanceMaxExtraPerformanceCanPurchase[];
    }

    export interface GetMaxExtraPerformancesPerformanceBaseline {
        /**
         * The limit of the iops.
         */
        iops: number;
        /**
         * The limit of the throughput.
         */
        throughput: number;
    }

    export interface GetMaxExtraPerformancesPerformanceLimit {
        /**
         * The limit of the iops.
         */
        iops: number;
        /**
         * The limit of the throughput.
         */
        throughput: number;
    }

    export interface GetMaxExtraPerformancesPerformanceMaxExtraPerformanceCanPurchase {
        /**
         * The type of the extra performance.
         */
        extraPerformanceTypeId: string;
        /**
         * The limit of the extra performance.
         */
        limit: number;
    }

    export interface GetSnapshotGroupsSnapshotGroup {
        /**
         * The creation time of the snapshot.
         */
        creationTime: string;
        /**
         * The description of the snapshot.
         */
        description: string;
        /**
         * The id of the snapshot group.
         */
        id: string;
        /**
         * The image id of the snapshot.
         */
        imageId: string;
        /**
         * The instance id of snapshot group.
         */
        instanceId: string;
        /**
         * The name of snapshot group.
         */
        name: string;
        /**
         * The project name of snapshot group.
         */
        projectName: string;
        /**
         * The id of the snapshot group.
         */
        snapshotGroupId: string;
        /**
         * The snapshots of the snapshot group.
         */
        snapshots: outputs.ebs.GetSnapshotGroupsSnapshotGroupSnapshot[];
        /**
         * A list of snapshot group status. Valid values: `creating`, `available`, `failed`.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.ebs.GetSnapshotGroupsSnapshotGroupTag[];
    }

    export interface GetSnapshotGroupsSnapshotGroupSnapshot {
        /**
         * The creation time of the snapshot.
         */
        creationTime: string;
        /**
         * The description of the snapshot.
         */
        description: string;
        /**
         * The image id of the snapshot.
         */
        imageId: string;
        /**
         * The progress of the snapshot.
         */
        progress: number;
        /**
         * The project name of snapshot group.
         */
        projectName: string;
        /**
         * The id of the snapshot.
         */
        retentionDays: number;
        /**
         * The id of the snapshot.
         */
        snapshotId: string;
        /**
         * The name of the snapshot.
         */
        snapshotName: string;
        /**
         * The type of the snapshot.
         */
        snapshotType: string;
        /**
         * A list of snapshot group status. Valid values: `creating`, `available`, `failed`.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.ebs.GetSnapshotGroupsSnapshotGroupSnapshotTag[];
        /**
         * The volume id of the snapshot.
         */
        volumeId: string;
        /**
         * The volume kind of the snapshot.
         */
        volumeKind: string;
        /**
         * The volume name of the snapshot.
         */
        volumeName: string;
        /**
         * The volume size of the snapshot.
         */
        volumeSize: number;
        /**
         * The volume status of the snapshot.
         */
        volumeStatus: string;
        /**
         * The volume type of the snapshot.
         */
        volumeType: string;
        /**
         * The zone id of the snapshot.
         */
        zoneId: string;
    }

    export interface GetSnapshotGroupsSnapshotGroupSnapshotTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetSnapshotGroupsSnapshotGroupTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetSnapshotsSnapshot {
        /**
         * The creation time of the snapshot.
         */
        creationTime: string;
        /**
         * The description of the snapshot.
         */
        description: string;
        /**
         * The id of the snapshot.
         */
        id: string;
        /**
         * The project name of snapshot.
         */
        projectName: string;
        /**
         * The retention days of the snapshot.
         */
        retentionDays: number;
        /**
         * The id of the snapshot.
         */
        snapshotId: string;
        /**
         * The name of the snapshot.
         */
        snapshotName: string;
        /**
         * The type of the snapshot.
         */
        snapshotType: string;
        /**
         * The status of the snapshot.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.ebs.GetSnapshotsSnapshotTag[];
        /**
         * The volume id of the snapshot.
         */
        volumeId: string;
        /**
         * The volume kind of the snapshot.
         */
        volumeKind: string;
        /**
         * The volume name of the snapshot.
         */
        volumeName: string;
        /**
         * The volume size of the snapshot.
         */
        volumeSize: number;
        /**
         * The volume status of the snapshot.
         */
        volumeStatus: string;
        /**
         * The volume type of the snapshot.
         */
        volumeType: string;
        /**
         * The zone id of snapshot.
         */
        zoneId: string;
    }

    export interface GetSnapshotsSnapshotTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetSnapshotsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetVolumesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetVolumesVolume {
        /**
         * The baseline performance of the volume.
         */
        baselinePerformances: outputs.ebs.GetVolumesVolumeBaselinePerformance[];
        billingType: number;
        createdAt: string;
        deleteWithInstance: boolean;
        description: string;
        deviceName: string;
        expiredTime: string;
        /**
         * The extra performance of the volume.
         */
        extraPerformances: outputs.ebs.GetVolumesVolumeExtraPerformance[];
        id: string;
        imageId: string;
        /**
         * The Id of instance.
         */
        instanceId: string;
        /**
         * The Kind of Volume.
         */
        kind: string;
        payType: string;
        renewType: number;
        size: number;
        status: string;
        /**
         * Tags.
         */
        tags: outputs.ebs.GetVolumesVolumeTag[];
        /**
         * The baseline performance of the volume.
         */
        totalPerformances: outputs.ebs.GetVolumesVolumeTotalPerformance[];
        tradeStatus: number;
        updatedAt: string;
        volumeId: string;
        /**
         * The name of Volume.
         */
        volumeName: string;
        /**
         * The type of Volume.
         */
        volumeType: string;
        /**
         * The Id of Zone.
         */
        zoneId: string;
    }

    export interface GetVolumesVolumeBaselinePerformance {
        /**
         * The total IOPS performance size for volume.
         */
        iops: number;
        /**
         * The total Throughput performance size for volume. Unit: MB/s.
         */
        throughput: number;
    }

    export interface GetVolumesVolumeExtraPerformance {
        /**
         * The type of extra performance for volume.
         */
        extraPerformanceTypeId: string;
        /**
         * The total IOPS performance size for volume.
         */
        iops: number;
        /**
         * The total Throughput performance size for volume. Unit: MB/s.
         */
        throughput: number;
    }

    export interface GetVolumesVolumeTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetVolumesVolumeTotalPerformance {
        /**
         * The total IOPS performance size for volume.
         */
        iops: number;
        /**
         * The total Throughput performance size for volume. Unit: MB/s.
         */
        throughput: number;
    }

    export interface MaxExtraPerformancesPerformance {
        /**
         * The baseline of the performance.
         */
        baselines: outputs.ebs.MaxExtraPerformancesPerformanceBaseline[];
        /**
         * The limit of the extra performance.
         */
        limits: outputs.ebs.MaxExtraPerformancesPerformanceLimit[];
        /**
         * The max extra performance can purchase.
         */
        maxExtraPerformanceCanPurchases: outputs.ebs.MaxExtraPerformancesPerformanceMaxExtraPerformanceCanPurchase[];
    }

    export interface MaxExtraPerformancesPerformanceBaseline {
        /**
         * The limit of the iops.
         */
        iops: number;
        /**
         * The limit of the throughput.
         */
        throughput: number;
    }

    export interface MaxExtraPerformancesPerformanceLimit {
        /**
         * The limit of the iops.
         */
        iops: number;
        /**
         * The limit of the throughput.
         */
        throughput: number;
    }

    export interface MaxExtraPerformancesPerformanceMaxExtraPerformanceCanPurchase {
        /**
         * The type of the extra performance.
         */
        extraPerformanceTypeId: string;
        /**
         * The limit of the extra performance.
         */
        limit: number;
    }

    export interface SnapshotGroupTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface SnapshotGroupsSnapshotGroup {
        /**
         * The creation time of the snapshot.
         */
        creationTime: string;
        /**
         * The description of the snapshot.
         */
        description: string;
        /**
         * The id of the snapshot group.
         */
        id: string;
        /**
         * The image id of the snapshot.
         */
        imageId: string;
        /**
         * The instance id of snapshot group.
         */
        instanceId: string;
        /**
         * The name of snapshot group.
         */
        name: string;
        /**
         * The project name of snapshot group.
         */
        projectName: string;
        /**
         * The id of the snapshot group.
         */
        snapshotGroupId: string;
        /**
         * The snapshots of the snapshot group.
         */
        snapshots: outputs.ebs.SnapshotGroupsSnapshotGroupSnapshot[];
        /**
         * A list of snapshot group status. Valid values: `creating`, `available`, `failed`.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.ebs.SnapshotGroupsSnapshotGroupTag[];
    }

    export interface SnapshotGroupsSnapshotGroupSnapshot {
        /**
         * The creation time of the snapshot.
         */
        creationTime: string;
        /**
         * The description of the snapshot.
         */
        description: string;
        /**
         * The image id of the snapshot.
         */
        imageId: string;
        /**
         * The progress of the snapshot.
         */
        progress: number;
        /**
         * The project name of snapshot group.
         */
        projectName: string;
        /**
         * The id of the snapshot.
         */
        retentionDays: number;
        /**
         * The id of the snapshot.
         */
        snapshotId: string;
        /**
         * The name of the snapshot.
         */
        snapshotName: string;
        /**
         * The type of the snapshot.
         */
        snapshotType: string;
        /**
         * A list of snapshot group status. Valid values: `creating`, `available`, `failed`.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.ebs.SnapshotGroupsSnapshotGroupSnapshotTag[];
        /**
         * The volume id of the snapshot.
         */
        volumeId: string;
        /**
         * The volume kind of the snapshot.
         */
        volumeKind: string;
        /**
         * The volume name of the snapshot.
         */
        volumeName: string;
        /**
         * The volume size of the snapshot.
         */
        volumeSize: number;
        /**
         * The volume status of the snapshot.
         */
        volumeStatus: string;
        /**
         * The volume type of the snapshot.
         */
        volumeType: string;
        /**
         * The zone id of the snapshot.
         */
        zoneId: string;
    }

    export interface SnapshotGroupsSnapshotGroupSnapshotTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface SnapshotGroupsSnapshotGroupTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface SnapshotTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface SnapshotsSnapshot {
        /**
         * The creation time of the snapshot.
         */
        creationTime: string;
        /**
         * The description of the snapshot.
         */
        description: string;
        /**
         * The id of the snapshot.
         */
        id: string;
        /**
         * The project name of snapshot.
         */
        projectName: string;
        /**
         * The retention days of the snapshot.
         */
        retentionDays: number;
        /**
         * The id of the snapshot.
         */
        snapshotId: string;
        /**
         * The name of the snapshot.
         */
        snapshotName: string;
        /**
         * The type of the snapshot.
         */
        snapshotType: string;
        /**
         * The status of the snapshot.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.ebs.SnapshotsSnapshotTag[];
        /**
         * The volume id of the snapshot.
         */
        volumeId: string;
        /**
         * The volume kind of the snapshot.
         */
        volumeKind: string;
        /**
         * The volume name of the snapshot.
         */
        volumeName: string;
        /**
         * The volume size of the snapshot.
         */
        volumeSize: number;
        /**
         * The volume status of the snapshot.
         */
        volumeStatus: string;
        /**
         * The volume type of the snapshot.
         */
        volumeType: string;
        /**
         * The zone id of snapshot.
         */
        zoneId: string;
    }

    export interface SnapshotsSnapshotTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface SnapshotsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface VolumeTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface VolumesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface VolumesVolume {
        /**
         * The baseline performance of the volume.
         */
        baselinePerformances: outputs.ebs.VolumesVolumeBaselinePerformance[];
        billingType: number;
        createdAt: string;
        deleteWithInstance: boolean;
        description: string;
        deviceName: string;
        expiredTime: string;
        /**
         * The extra performance of the volume.
         */
        extraPerformances: outputs.ebs.VolumesVolumeExtraPerformance[];
        id: string;
        imageId: string;
        /**
         * The Id of instance.
         */
        instanceId: string;
        /**
         * The Kind of Volume.
         */
        kind: string;
        payType: string;
        renewType: number;
        size: number;
        status: string;
        /**
         * Tags.
         */
        tags: outputs.ebs.VolumesVolumeTag[];
        /**
         * The baseline performance of the volume.
         */
        totalPerformances: outputs.ebs.VolumesVolumeTotalPerformance[];
        tradeStatus: number;
        updatedAt: string;
        volumeId: string;
        /**
         * The name of Volume.
         */
        volumeName: string;
        /**
         * The type of Volume.
         */
        volumeType: string;
        /**
         * The Id of Zone.
         */
        zoneId: string;
    }

    export interface VolumesVolumeBaselinePerformance {
        /**
         * The total IOPS performance size for volume.
         */
        iops: number;
        /**
         * The total Throughput performance size for volume. Unit: MB/s.
         */
        throughput: number;
    }

    export interface VolumesVolumeExtraPerformance {
        /**
         * The type of extra performance for volume.
         */
        extraPerformanceTypeId: string;
        /**
         * The total IOPS performance size for volume.
         */
        iops: number;
        /**
         * The total Throughput performance size for volume. Unit: MB/s.
         */
        throughput: number;
    }

    export interface VolumesVolumeTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface VolumesVolumeTotalPerformance {
        /**
         * The total IOPS performance size for volume.
         */
        iops: number;
        /**
         * The total Throughput performance size for volume. Unit: MB/s.
         */
        throughput: number;
    }

}

export namespace ecs {
    export interface AvailableResourcesAvailableZone {
        /**
         * The resource information of the available zone.
         */
        availableResources: outputs.ecs.AvailableResourcesAvailableZoneAvailableResource[];
        /**
         * The id of the region.
         */
        regionId: string;
        /**
         * The resource status of the available zone. Valid values: `Available`, `SoldOut`.
         */
        status: string;
        /**
         * The id of available zone.
         */
        zoneId: string;
    }

    export interface AvailableResourcesAvailableZoneAvailableResource {
        /**
         * The supported resource information.
         */
        supportedResources: outputs.ecs.AvailableResourcesAvailableZoneAvailableResourceSupportedResource[];
        /**
         * The type of resource. Valid values: `InstanceType`, `DedicatedHost`.
         */
        type: string;
    }

    export interface AvailableResourcesAvailableZoneAvailableResourceSupportedResource {
        /**
         * The resource status of the available zone. Valid values: `Available`, `SoldOut`.
         */
        status: string;
        /**
         * The value of the resource.
         */
        value: string;
    }

    export interface CommandParameterDefinition {
        /**
         * The decimal precision of the custom parameter. This field is required when the parameter type is `Digit`.
         */
        decimalPrecision: number;
        /**
         * The default value of the custom parameter.
         */
        defaultValue: string;
        /**
         * The maximum length of the custom parameter. This field is required when the parameter type is `String`.
         */
        maxLength: number;
        /**
         * The maximum value of the custom parameter. This field is required when the parameter type is `Digit`.
         */
        maxValue: string;
        /**
         * The minimum length of the custom parameter. This field is required when the parameter type is `String`.
         */
        minLength: number;
        /**
         * The minimum value of the custom parameter. This field is required when the parameter type is `Digit`.
         */
        minValue: string;
        /**
         * The name of the custom parameter.
         */
        name: string;
        /**
         * Whether the custom parameter is required.
         */
        required: boolean;
        /**
         * The type of the custom parameter. Valid values: `String`, `Digit`.
         */
        type: string;
    }

    export interface CommandTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface CommandsCommand {
        /**
         * The base64 encoded content of the ecs command.
         */
        commandContent: string;
        /**
         * The id of ecs command.
         */
        commandId: string;
        /**
         * The provider of public command. When this field is not specified, query for custom commands.
         */
        commandProvider: string;
        /**
         * Whether the command content is base64 encoded. Valid values: `Base64`, `PlainText`. Default is `Base64`.
         */
        contentEncoding: string;
        /**
         * The create time of the ecs command.
         */
        createdAt: string;
        /**
         * The description of the ecs command.
         */
        description: string;
        /**
         * Whether to enable custom parameter. Default is `false`.
         */
        enableParameter: boolean;
        /**
         * The id of the ecs command.
         */
        id: string;
        /**
         * The invocation times of the ecs command. Public commands do not display the invocation times.
         */
        invocationTimes: number;
        /**
         * The name of ecs command. This field support fuzzy query.
         */
        name: string;
        /**
         * The custom parameter definitions of the ecs command.
         */
        parameterDefinitions: outputs.ecs.CommandsCommandParameterDefinition[];
        /**
         * The project name of ecs command.
         */
        projectName: string;
        /**
         * Tags.
         */
        tags: outputs.ecs.CommandsCommandTag[];
        /**
         * The timeout of the ecs command.
         */
        timeout: number;
        /**
         * The type of ecs command. Valid values: `Shell`.
         */
        type: string;
        /**
         * The update time of the ecs command.
         */
        updatedAt: string;
        /**
         * The username of the ecs command.
         */
        username: string;
        /**
         * The working directory of the ecs command.
         */
        workingDir: string;
    }

    export interface CommandsCommandParameterDefinition {
        /**
         * The decimal precision of the custom parameter. This field is required when the parameter type is `Digit`.
         */
        decimalPrecision: number;
        /**
         * The default value of the custom parameter.
         */
        defaultValue: string;
        /**
         * The maximum length of the custom parameter. This field is required when the parameter type is `String`.
         */
        maxLength: number;
        /**
         * The maximum value of the custom parameter. This field is required when the parameter type is `Digit`.
         */
        maxValue: string;
        /**
         * The minimum length of the custom parameter. This field is required when the parameter type is `String`.
         */
        minLength: number;
        /**
         * The minimum value of the custom parameter. This field is required when the parameter type is `Digit`.
         */
        minValue: string;
        /**
         * The name of ecs command. This field support fuzzy query.
         */
        name: string;
        /**
         * Whether the custom parameter is required.
         */
        required: boolean;
        /**
         * The type of ecs command. Valid values: `Shell`.
         */
        type: string;
    }

    export interface CommandsCommandTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface CommandsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface DeploymentSetsDeploymentSet {
        /**
         * The ID of ECS DeploymentSet.
         */
        deploymentSetId: string;
        /**
         * The name of ECS DeploymentSet.
         */
        deploymentSetName: string;
        /**
         * The description of ECS DeploymentSet.
         */
        description: string;
        /**
         * The granularity of ECS DeploymentSet.Valid values: switch, host, rack.
         */
        granularity: string;
        /**
         * The strategy of ECS DeploymentSet.
         */
        strategy: string;
    }

    export interface GetAvailableResourcesAvailableZone {
        /**
         * The resource information of the available zone.
         */
        availableResources: outputs.ecs.GetAvailableResourcesAvailableZoneAvailableResource[];
        /**
         * The id of the region.
         */
        regionId: string;
        /**
         * The resource status of the available zone. Valid values: `Available`, `SoldOut`.
         */
        status: string;
        /**
         * The id of available zone.
         */
        zoneId: string;
    }

    export interface GetAvailableResourcesAvailableZoneAvailableResource {
        /**
         * The supported resource information.
         */
        supportedResources: outputs.ecs.GetAvailableResourcesAvailableZoneAvailableResourceSupportedResource[];
        /**
         * The type of resource. Valid values: `InstanceType`, `DedicatedHost`.
         */
        type: string;
    }

    export interface GetAvailableResourcesAvailableZoneAvailableResourceSupportedResource {
        /**
         * The resource status of the available zone. Valid values: `Available`, `SoldOut`.
         */
        status: string;
        /**
         * The value of the resource.
         */
        value: string;
    }

    export interface GetCommandsCommand {
        /**
         * The base64 encoded content of the ecs command.
         */
        commandContent: string;
        /**
         * The id of ecs command.
         */
        commandId: string;
        /**
         * The provider of public command. When this field is not specified, query for custom commands.
         */
        commandProvider: string;
        /**
         * Whether the command content is base64 encoded. Valid values: `Base64`, `PlainText`. Default is `Base64`.
         */
        contentEncoding: string;
        /**
         * The create time of the ecs command.
         */
        createdAt: string;
        /**
         * The description of the ecs command.
         */
        description: string;
        /**
         * Whether to enable custom parameter. Default is `false`.
         */
        enableParameter: boolean;
        /**
         * The id of the ecs command.
         */
        id: string;
        /**
         * The invocation times of the ecs command. Public commands do not display the invocation times.
         */
        invocationTimes: number;
        /**
         * The name of ecs command. This field support fuzzy query.
         */
        name: string;
        /**
         * The custom parameter definitions of the ecs command.
         */
        parameterDefinitions: outputs.ecs.GetCommandsCommandParameterDefinition[];
        /**
         * The project name of ecs command.
         */
        projectName: string;
        /**
         * Tags.
         */
        tags: outputs.ecs.GetCommandsCommandTag[];
        /**
         * The timeout of the ecs command.
         */
        timeout: number;
        /**
         * The type of ecs command. Valid values: `Shell`.
         */
        type: string;
        /**
         * The update time of the ecs command.
         */
        updatedAt: string;
        /**
         * The username of the ecs command.
         */
        username: string;
        /**
         * The working directory of the ecs command.
         */
        workingDir: string;
    }

    export interface GetCommandsCommandParameterDefinition {
        /**
         * The decimal precision of the custom parameter. This field is required when the parameter type is `Digit`.
         */
        decimalPrecision: number;
        /**
         * The default value of the custom parameter.
         */
        defaultValue: string;
        /**
         * The maximum length of the custom parameter. This field is required when the parameter type is `String`.
         */
        maxLength: number;
        /**
         * The maximum value of the custom parameter. This field is required when the parameter type is `Digit`.
         */
        maxValue: string;
        /**
         * The minimum length of the custom parameter. This field is required when the parameter type is `String`.
         */
        minLength: number;
        /**
         * The minimum value of the custom parameter. This field is required when the parameter type is `Digit`.
         */
        minValue: string;
        /**
         * The name of ecs command. This field support fuzzy query.
         */
        name: string;
        /**
         * Whether the custom parameter is required.
         */
        required: boolean;
        /**
         * The type of ecs command. Valid values: `Shell`.
         */
        type: string;
    }

    export interface GetCommandsCommandTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetCommandsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetDeploymentSetsDeploymentSet {
        /**
         * The ID of ECS DeploymentSet.
         */
        deploymentSetId: string;
        /**
         * The name of ECS DeploymentSet.
         */
        deploymentSetName: string;
        /**
         * The description of ECS DeploymentSet.
         */
        description: string;
        /**
         * The granularity of ECS DeploymentSet.Valid values: switch, host, rack.
         */
        granularity: string;
        /**
         * The strategy of ECS DeploymentSet.
         */
        strategy: string;
    }

    export interface GetHpcClustersHpcCluster {
        /**
         * The created time of the hpc cluster.
         */
        createdAt: string;
        /**
         * The description of the hpc cluster.
         */
        description: string;
        /**
         * The id of the hpc cluster.
         */
        hpcClusterId: string;
        /**
         * The id of the hpc cluster.
         */
        id: string;
        /**
         * The name of the hpc cluster.
         */
        name: string;
        /**
         * The updated time of the hpc cluster.
         */
        updatedAt: string;
        /**
         * The vpc id of the hpc cluster.
         */
        vpcId: string;
        /**
         * The zone id of the hpc cluster.
         */
        zoneId: string;
    }

    export interface GetImageSharePermissionsAccount {
        /**
         * The shared account id of the image.
         */
        accountId: string;
    }

    export interface GetImagesImage {
        /**
         * The architecture of Image.
         */
        architecture: string;
        /**
         * The boot mode of Image.
         */
        bootMode: string;
        /**
         * The create time of Image.
         */
        createdAt: string;
        /**
         * The description of Image.
         */
        description: string;
        /**
         * The ID of Image.
         */
        imageId: string;
        /**
         * The name of Image.
         */
        imageName: string;
        /**
         * Whether the Image support cloud-init.
         */
        isSupportCloudInit: boolean;
        /**
         * The name of Image operating system.
         */
        osName: string;
        /**
         * The operating system type of Image.
         */
        osType: string;
        /**
         * The platform of Image.
         */
        platform: string;
        /**
         * The platform version of Image.
         */
        platformVersion: string;
        /**
         * The share mode of Image.
         */
        shareStatus: string;
        /**
         * The size(GiB) of Image.
         */
        size: number;
        /**
         * A list of Image status, the value can be `available` or `creating` or `error`.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.ecs.GetImagesImageTag[];
        /**
         * The update time of Image.
         */
        updatedAt: string;
        /**
         * The visibility of Image.
         */
        visibility: string;
    }

    export interface GetImagesImageTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetImagesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetInstanceTypesInstanceType {
        /**
         * The CPU benchmark performance that can be provided steadily by on-demand instances is determined by the instance type.
         */
        baselineCredit: number;
        /**
         * The GPU device info of Instance.
         */
        gpus: outputs.ecs.GetInstanceTypesInstanceTypeGpus[];
        /**
         * The CPU credits obtained at once when creating a on-demand performance instance are fixed at 30 credits per vCPU.
         */
        initialCredit: number;
        /**
         * The instance type family.
         */
        instanceTypeFamily: string;
        /**
         * The id of the instance type.
         */
        instanceTypeId: string;
        /**
         * Local disk configuration information corresponding to instance specifications.
         */
        localVolumes: outputs.ecs.GetInstanceTypesInstanceTypeLocalVolume[];
        /**
         * Memory information of instance specifications.
         */
        memories: outputs.ecs.GetInstanceTypesInstanceTypeMemory[];
        /**
         * Network information of instance specifications.
         */
        networks: outputs.ecs.GetInstanceTypesInstanceTypeNetwork[];
        /**
         * CPU information of instance specifications.
         */
        processors: outputs.ecs.GetInstanceTypesInstanceTypeProcessor[];
        /**
         * RDMA Specification Information.
         */
        rdmas: outputs.ecs.GetInstanceTypesInstanceTypeRdma[];
        /**
         * Cloud disk information for instance specifications.
         */
        volumes: outputs.ecs.GetInstanceTypesInstanceTypeVolume[];
    }

    export interface GetInstanceTypesInstanceTypeGpus {
        /**
         * GPU device information list.
         */
        gpuDevices: outputs.ecs.GetInstanceTypesInstanceTypeGpusGpuDevice[];
    }

    export interface GetInstanceTypesInstanceTypeGpusGpuDevice {
        /**
         * The number of local disks mounted on the instance.
         */
        count: number;
        /**
         * Memory information of instance specifications.
         */
        memories: outputs.ecs.GetInstanceTypesInstanceTypeGpusGpuDeviceMemory[];
        /**
         * The Product Name of GPU device.
         */
        productName: string;
    }

    export interface GetInstanceTypesInstanceTypeGpusGpuDeviceMemory {
        /**
         * The Encrypted Memory Size of GPU device.
         */
        encryptedSize: number;
        /**
         * Memory size, unit: MiB.
         */
        size: number;
    }

    export interface GetInstanceTypesInstanceTypeLocalVolume {
        /**
         * The number of local disks mounted on the instance.
         */
        count: number;
        /**
         * Memory size, unit: MiB.
         */
        size: number;
        /**
         * The type of volume.
         */
        volumeType: string;
    }

    export interface GetInstanceTypesInstanceTypeMemory {
        /**
         * The Encrypted Memory Size of GPU device.
         */
        encryptedSize: number;
        /**
         * Memory size, unit: MiB.
         */
        size: number;
    }

    export interface GetInstanceTypesInstanceTypeNetwork {
        /**
         * Network benchmark bandwidth capacity (out/in), unit: Mbps.
         */
        baselineBandwidthMbps: number;
        /**
         * Peak network bandwidth capacity (out/in), unit: Mbps.
         */
        maximumBandwidthMbps: number;
        /**
         * Maximum number of elastic network interfaces supported for attachment.
         */
        maximumNetworkInterfaces: number;
        /**
         * Maximum number of IPv4 addresses for a single elastic network interface.
         */
        maximumPrivateIpv4AddressesPerNetworkInterface: number;
        /**
         * Maximum queue number for a single elastic network interface, including the queue number supported by the primary network interface and the auxiliary network interface.
         */
        maximumQueuesPerNetworkInterface: number;
        /**
         * Network packet sending and receiving capacity (in+out), unit: Kpps.
         */
        maximumThroughputKpps: number;
    }

    export interface GetInstanceTypesInstanceTypeProcessor {
        /**
         * CPU clock speed, unit: GHz.
         */
        baseFrequency: number;
        /**
         * The number of ECS instance CPU cores.
         */
        cpus: number;
        /**
         * CPU model.
         */
        model: string;
        /**
         * CPU Turbo Boost, unit: GHz.
         */
        turboFrequency: number;
    }

    export interface GetInstanceTypesInstanceTypeRdma {
        /**
         * Number of RDMA network cards.
         */
        rdmaNetworkInterfaces: number;
    }

    export interface GetInstanceTypesInstanceTypeVolume {
        /**
         * The maximum number of volumes.
         */
        maximumCount: number;
        /**
         * List of supported volume types.
         */
        supportedVolumeTypes: string[];
    }

    export interface GetInstancesInstance {
        /**
         * The number of ECS instance CPU cores.
         */
        cpus: number;
        /**
         * The create time of ECS instance.
         */
        createdAt: string;
        /**
         * The ID of DeploymentSet.
         */
        deploymentSetId: string;
        /**
         * The description of ECS instance.
         */
        description: string;
        /**
         * The EIP address of the ECS instance.
         */
        eipAddresses: outputs.ecs.GetInstancesInstanceEipAddress[];
        /**
         * The GPU device info of Instance.
         */
        gpuDevices: outputs.ecs.GetInstancesInstanceGpuDevice[];
        /**
         * The host name of ECS instance.
         */
        hostName: string;
        /**
         * The image ID of ECS instance.
         */
        imageId: string;
        /**
         * The charge type of ECS instance.
         */
        instanceChargeType: string;
        /**
         * The ID of ECS instance.
         */
        instanceId: string;
        /**
         * The name of ECS instance. This field support fuzzy query.
         */
        instanceName: string;
        /**
         * The spec type of ECS instance.
         */
        instanceType: string;
        /**
         * The number of IPv6 addresses of the ECS instance.
         */
        ipv6AddressCount: number;
        /**
         * A list of ipv6 addresses.
         */
        ipv6Addresses: string[];
        /**
         * The Flag of GPU instance.If the instance is GPU,The flag is true.
         */
        isGpu: boolean;
        /**
         * The ssh key ID of ECS instance.
         */
        keyPairId: string;
        /**
         * The key pair name of ECS instance.
         */
        keyPairName: string;
        /**
         * The memory size of ECS instance.
         */
        memorySize: number;
        /**
         * The networkInterface detail collection of ECS instance.
         */
        networkInterfaces: outputs.ecs.GetInstancesInstanceNetworkInterface[];
        /**
         * The os name of ECS instance.
         */
        osName: string;
        /**
         * The os type of ECS instance.
         */
        osType: string;
        /**
         * The ProjectName of ECS instance.
         */
        projectName: string;
        /**
         * The spot price limit of ECS instance.
         */
        spotPriceLimit: number;
        /**
         * The spot strategy of ECS instance.
         */
        spotStrategy: string;
        /**
         * The status of ECS instance.
         */
        status: string;
        /**
         * The stop mode of ECS instance.
         */
        stoppedMode: string;
        /**
         * Tags.
         */
        tags: outputs.ecs.GetInstancesInstanceTag[];
        /**
         * The update time of ECS instance.
         */
        updatedAt: string;
        /**
         * The volume ID list of ECS instance.
         */
        volumeIds: string[];
        /**
         * The volume detail collection of volume.
         */
        volumes: outputs.ecs.GetInstancesInstanceVolume[];
        /**
         * The VPC ID of ECS instance.
         */
        vpcId: string;
        /**
         * The available zone ID of ECS instance.
         */
        zoneId: string;
    }

    export interface GetInstancesInstanceEipAddress {
        /**
         * The EIP ID of the ECS instance.
         */
        allocationId: string;
        /**
         * The EIP address of the ECS instance.
         */
        ipAddress: string;
    }

    export interface GetInstancesInstanceGpuDevice {
        /**
         * The Count of GPU device.
         */
        count: number;
        /**
         * The Encrypted Memory Size of GPU device.
         */
        encryptedMemorySize: number;
        /**
         * The memory size of ECS instance.
         */
        memorySize: number;
        /**
         * The Product Name of GPU device.
         */
        productName: string;
    }

    export interface GetInstancesInstanceNetworkInterface {
        /**
         * The mac address of networkInterface.
         */
        macAddress: string;
        /**
         * The ID of networkInterface.
         */
        networkInterfaceId: string;
        /**
         * The primary ip address of ECS instance.
         */
        primaryIpAddress: string;
        /**
         * The subnet ID of networkInterface.
         */
        subnetId: string;
        /**
         * The type of networkInterface.
         */
        type: string;
        /**
         * The VPC ID of ECS instance.
         */
        vpcId: string;
    }

    export interface GetInstancesInstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetInstancesInstanceVolume {
        /**
         * The delete with instance flag of volume.
         */
        deleteWithInstance: boolean;
        /**
         * The size of volume.
         */
        size: number;
        /**
         * The ID of volume.
         */
        volumeId: string;
        /**
         * The Name of volume.
         */
        volumeName: string;
        /**
         * The type of volume.
         */
        volumeType: string;
    }

    export interface GetInstancesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetInvocationResultsInvocationResult {
        /**
         * The id of ecs command.
         */
        commandId: string;
        /**
         * The end time of the ecs invocation in the instance.
         */
        endTime: string;
        /**
         * The error code of the ecs invocation.
         */
        errorCode: string;
        /**
         * The error message of the ecs invocation.
         */
        errorMessage: string;
        /**
         * The exit code of the ecs command.
         */
        exitCode: number;
        /**
         * The id of the ecs invocation result.
         */
        id: string;
        /**
         * The id of ecs instance.
         */
        instanceId: string;
        /**
         * The id of ecs invocation.
         */
        invocationId: string;
        /**
         * The id of the ecs invocation result.
         */
        invocationResultId: string;
        /**
         * The list of status of ecs invocation in a single instance. Valid values: `Pending`, `Running`, `Success`, `Failed`, `Timeout`.
         */
        invocationResultStatus: string;
        /**
         * The base64 encoded output message of the ecs invocation.
         */
        output: string;
        /**
         * The start time of the ecs invocation in the instance.
         */
        startTime: string;
        /**
         * The username of the ecs command.
         */
        username: string;
    }

    export interface GetInvocationsInvocation {
        /**
         * The base64 encoded content of the ecs command.
         */
        commandContent: string;
        /**
         * The description of the ecs command.
         */
        commandDescription: string;
        /**
         * The id of ecs command.
         */
        commandId: string;
        /**
         * The name of ecs command. This field support fuzzy query.
         */
        commandName: string;
        /**
         * The provider of the ecs command.
         */
        commandProvider: string;
        /**
         * The type of ecs command. Valid values: `Shell`.
         */
        commandType: string;
        /**
         * The end time of the ecs invocation.
         */
        endTime: string;
        /**
         * The frequency of the ecs invocation.
         */
        frequency: string;
        /**
         * The id of the ecs invocation.
         */
        id: string;
        /**
         * The list of ECS instance IDs.
         */
        instanceIds: string[];
        /**
         * The instance number of the ecs invocation.
         */
        instanceNumber: number;
        /**
         * The description of the ecs invocation.
         */
        invocationDescription: string;
        /**
         * The id of ecs invocation.
         */
        invocationId: string;
        /**
         * The name of ecs invocation. This field support fuzzy query.
         */
        invocationName: string;
        /**
         * The list of status of ecs invocation. Valid values: `Pending`, `Scheduled`, `Running`, `Success`, `Failed`, `Stopped`, `PartialFailed`, `Finished`.
         */
        invocationStatus: string;
        /**
         * The launch time of the ecs invocation.
         */
        launchTime: string;
        /**
         * The custom parameters of the ecs invocation.
         */
        parameters: string;
        /**
         * The project name of ecs invocation.
         */
        projectName: string;
        /**
         * The recurrence end time of the ecs invocation.
         */
        recurrenceEndTime: string;
        /**
         * The repeat mode of ecs invocation. Valid values: `Once`, `Rate`, `Fixed`.
         */
        repeatMode: string;
        /**
         * The start time of the ecs invocation.
         */
        startTime: string;
        /**
         * Tags.
         */
        tags: outputs.ecs.GetInvocationsInvocationTag[];
        /**
         * The timeout of the ecs command.
         */
        timeout: number;
        /**
         * The username of the ecs command.
         */
        username: string;
        /**
         * The working directory of the ecs command.
         */
        workingDir: string;
    }

    export interface GetInvocationsInvocationTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetInvocationsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetKeyPairsKeyPair {
        /**
         * The creation time of key pair.
         */
        createdAt: string;
        /**
         * The description of key pair.
         */
        description: string;
        /**
         * The finger print info.
         */
        fingerPrint: string;
        /**
         * The id of key pair.
         */
        id: string;
        /**
         * The id of key pair.
         */
        keyPairId: string;
        /**
         * Name of key pair.
         */
        keyPairName: string;
        /**
         * The update time of key pair.
         */
        updatedAt: string;
    }

    export interface GetLaunchTemplatesLaunchTemplate {
        /**
         * The created time of the launch template.
         */
        createdAt: string;
        /**
         * The default version of the launch template.
         */
        defaultVersionNumber: number;
        /**
         * The description of the instance.
         */
        description: string;
        /**
         * The EIP bandwidth which the scaling configuration set.
         */
        eipBandwidth: number;
        /**
         * The EIP billing type which the scaling configuration set. Valid values: PostPaidByBandwidth, PostPaidByTraffic.
         */
        eipBillingType: string;
        /**
         * The EIP ISP which the scaling configuration set. Valid values: BGP, ChinaMobile, ChinaUnicom, ChinaTelecom.
         */
        eipIsp: string;
        /**
         * The host name of the instance.
         */
        hostName: string;
        /**
         * The hpc cluster id.
         */
        hpcClusterId: string;
        /**
         * The id of the launch template.
         */
        id: string;
        /**
         * The image id.
         */
        imageId: string;
        /**
         * The charge type of the instance and volume.
         */
        instanceChargeType: string;
        /**
         * The name of the instance.
         */
        instanceName: string;
        /**
         * When you log in to the instance using the SSH key pair, enter the name of the key pair.
         */
        keyPairName: string;
        /**
         * The latest version of the launch template.
         */
        latestVersionNumber: number;
        /**
         * The id of the launch template.
         */
        launchTemplateId: string;
        /**
         * The name of the launch template.
         */
        launchTemplateName: string;
        /**
         * The list of network interfaces.
         */
        networkInterfaces: outputs.ecs.GetLaunchTemplatesLaunchTemplateNetworkInterface[];
        /**
         * Whether to open the security reinforcement.
         */
        securityEnhancementStrategy: string;
        /**
         * The index of the ordered suffix.
         */
        suffixIndex: number;
        /**
         * Indicates whether the ordered suffix is automatically added to Hostname and InstanceName when multiple instances are created.
         */
        uniqueSuffix: boolean;
        /**
         * The updated time of the launch template.
         */
        updatedAt: string;
        /**
         * The latest version description of the launch template.
         */
        versionDescription: string;
        /**
         * The list of volume of the scaling configuration.
         */
        volumes: outputs.ecs.GetLaunchTemplatesLaunchTemplateVolume[];
        /**
         * The vpc id.
         */
        vpcId: string;
        /**
         * The zone ID of the instance.
         */
        zoneId: string;
    }

    export interface GetLaunchTemplatesLaunchTemplateNetworkInterface {
        /**
         * The security group ID associated with the NIC.
         */
        securityGroupIds: string[];
        /**
         * The private network subnet ID of the instance, when creating the instance, supports binding the secondary NIC at the same time.
         */
        subnetId: string;
    }

    export interface GetLaunchTemplatesLaunchTemplateVolume {
        /**
         * The delete with instance flag of volume. Valid values: true, false. Default value: true.
         */
        deleteWithInstance: boolean;
        /**
         * The size of volume.
         */
        size: number;
        /**
         * The type of volume.
         */
        volumeType: string;
    }

    export interface GetRegionsRegion {
        /**
         * The id of the region.
         */
        id: string;
        /**
         * The id of the region.
         */
        regionId: string;
    }

    export interface GetZonesZone {
        /**
         * The id of the zone.
         */
        id: string;
        /**
         * The id of the zone.
         */
        zoneId: string;
    }

    export interface HpcClustersHpcCluster {
        /**
         * The created time of the hpc cluster.
         */
        createdAt: string;
        /**
         * The description of the hpc cluster.
         */
        description: string;
        /**
         * The id of the hpc cluster.
         */
        hpcClusterId: string;
        /**
         * The id of the hpc cluster.
         */
        id: string;
        /**
         * The name of the hpc cluster.
         */
        name: string;
        /**
         * The updated time of the hpc cluster.
         */
        updatedAt: string;
        /**
         * The vpc id of the hpc cluster.
         */
        vpcId: string;
        /**
         * The zone id of the hpc cluster.
         */
        zoneId: string;
    }

    export interface ImageImportTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface ImageSharePermissionsAccount {
        /**
         * The shared account id of the image.
         */
        accountId: string;
    }

    export interface ImageTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface ImagesImage {
        /**
         * The architecture of Image.
         */
        architecture: string;
        /**
         * The boot mode of Image.
         */
        bootMode: string;
        /**
         * The create time of Image.
         */
        createdAt: string;
        /**
         * The description of Image.
         */
        description: string;
        /**
         * The ID of Image.
         */
        imageId: string;
        /**
         * The name of Image.
         */
        imageName: string;
        /**
         * Whether the Image support cloud-init.
         */
        isSupportCloudInit: boolean;
        /**
         * The name of Image operating system.
         */
        osName: string;
        /**
         * The operating system type of Image.
         */
        osType: string;
        /**
         * The platform of Image.
         */
        platform: string;
        /**
         * The platform version of Image.
         */
        platformVersion: string;
        /**
         * The share mode of Image.
         */
        shareStatus: string;
        /**
         * The size(GiB) of Image.
         */
        size: number;
        /**
         * A list of Image status, the value can be `available` or `creating` or `error`.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.ecs.ImagesImageTag[];
        /**
         * The update time of Image.
         */
        updatedAt: string;
        /**
         * The visibility of Image.
         */
        visibility: string;
    }

    export interface ImagesImageTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface ImagesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface InstanceCpuOptions {
        /**
         * The number of subnuma in socket, only support for ebm. `1` indicates disabling SNC/NPS function. When importing resources, this attribute will not be imported. If this attribute is set, please use lifecycle and ignoreChanges ignore changes in fields.
         */
        numaPerSocket?: number;
        /**
         * The per core of threads, only support for ebm. `1` indicates disabling hyper threading function.
         */
        threadsPerCore: number;
    }

    export interface InstanceDataVolume {
        /**
         * The delete with instance flag of volume.
         */
        deleteWithInstance?: boolean;
        /**
         * The size of volume. The value range of the data volume size is ESSD_PL0: 10~32768, ESSD_FlexPL: 10~32768, PTSSD: 20~8192.
         */
        size: number;
        /**
         * The type of volume, the value is `PTSSD` or `ESSD_PL0` or `ESSD_PL1` or `ESSD_PL2` or `ESSD_FlexPL`.
         */
        volumeType: string;
    }

    export interface InstanceEipAddress {
        /**
         * The peek bandwidth of the EIP. The value range in 1~500 for PostPaidByBandwidth, and 1~200 for PostPaidByTraffic. Default is 1.
         */
        bandwidthMbps?: number;
        /**
         * The id of the bandwidth package, indicates that the public IP address will be added to the bandwidth package.
         */
        bandwidthPackageId?: string;
        /**
         * The billing type of the EIP Address. Valid values: `PayByBandwidth`, `PayByTraffic`. Default is `PayByBandwidth`.
         */
        chargeType?: string;
        /**
         * The ISP of the EIP. Valid values: `BGP`, `ChinaMobile`, `ChinaUnicom`, `ChinaTelecom`, `SingleLine_BGP`, `Static_BGP`.
         */
        isp?: string;
    }

    export interface InstanceGpuDevice {
        /**
         * The Count of GPU device.
         */
        count: number;
        /**
         * The Encrypted Memory Size of GPU device.
         */
        encryptedMemorySize: number;
        /**
         * The memory size of ECS instance.
         */
        memorySize: number;
        /**
         * The Product Name of GPU device.
         */
        productName: string;
    }

    export interface InstanceSecondaryNetworkInterface {
        /**
         * The private ip address of secondary networkInterface.
         */
        primaryIpAddress: string;
        /**
         * The security group ID set of secondary networkInterface.
         */
        securityGroupIds: string[];
        /**
         * The subnet ID of secondary networkInterface.
         */
        subnetId: string;
    }

    export interface InstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface InstanceTypesInstanceType {
        /**
         * The CPU benchmark performance that can be provided steadily by on-demand instances is determined by the instance type.
         */
        baselineCredit: number;
        /**
         * The GPU device info of Instance.
         */
        gpus: outputs.ecs.InstanceTypesInstanceTypeGpus[];
        /**
         * The CPU credits obtained at once when creating a on-demand performance instance are fixed at 30 credits per vCPU.
         */
        initialCredit: number;
        /**
         * The instance type family.
         */
        instanceTypeFamily: string;
        /**
         * The id of the instance type.
         */
        instanceTypeId: string;
        /**
         * Local disk configuration information corresponding to instance specifications.
         */
        localVolumes: outputs.ecs.InstanceTypesInstanceTypeLocalVolume[];
        /**
         * Memory information of instance specifications.
         */
        memories: outputs.ecs.InstanceTypesInstanceTypeMemory[];
        /**
         * Network information of instance specifications.
         */
        networks: outputs.ecs.InstanceTypesInstanceTypeNetwork[];
        /**
         * CPU information of instance specifications.
         */
        processors: outputs.ecs.InstanceTypesInstanceTypeProcessor[];
        /**
         * RDMA Specification Information.
         */
        rdmas: outputs.ecs.InstanceTypesInstanceTypeRdma[];
        /**
         * Cloud disk information for instance specifications.
         */
        volumes: outputs.ecs.InstanceTypesInstanceTypeVolume[];
    }

    export interface InstanceTypesInstanceTypeGpus {
        /**
         * GPU device information list.
         */
        gpuDevices: outputs.ecs.InstanceTypesInstanceTypeGpusGpuDevice[];
    }

    export interface InstanceTypesInstanceTypeGpusGpuDevice {
        /**
         * The number of local disks mounted on the instance.
         */
        count: number;
        /**
         * Memory information of instance specifications.
         */
        memories: outputs.ecs.InstanceTypesInstanceTypeGpusGpuDeviceMemory[];
        /**
         * The Product Name of GPU device.
         */
        productName: string;
    }

    export interface InstanceTypesInstanceTypeGpusGpuDeviceMemory {
        /**
         * The Encrypted Memory Size of GPU device.
         */
        encryptedSize: number;
        /**
         * Memory size, unit: MiB.
         */
        size: number;
    }

    export interface InstanceTypesInstanceTypeLocalVolume {
        /**
         * The number of local disks mounted on the instance.
         */
        count: number;
        /**
         * Memory size, unit: MiB.
         */
        size: number;
        /**
         * The type of volume.
         */
        volumeType: string;
    }

    export interface InstanceTypesInstanceTypeMemory {
        /**
         * The Encrypted Memory Size of GPU device.
         */
        encryptedSize: number;
        /**
         * Memory size, unit: MiB.
         */
        size: number;
    }

    export interface InstanceTypesInstanceTypeNetwork {
        /**
         * Network benchmark bandwidth capacity (out/in), unit: Mbps.
         */
        baselineBandwidthMbps: number;
        /**
         * Peak network bandwidth capacity (out/in), unit: Mbps.
         */
        maximumBandwidthMbps: number;
        /**
         * Maximum number of elastic network interfaces supported for attachment.
         */
        maximumNetworkInterfaces: number;
        /**
         * Maximum number of IPv4 addresses for a single elastic network interface.
         */
        maximumPrivateIpv4AddressesPerNetworkInterface: number;
        /**
         * Maximum queue number for a single elastic network interface, including the queue number supported by the primary network interface and the auxiliary network interface.
         */
        maximumQueuesPerNetworkInterface: number;
        /**
         * Network packet sending and receiving capacity (in+out), unit: Kpps.
         */
        maximumThroughputKpps: number;
    }

    export interface InstanceTypesInstanceTypeProcessor {
        /**
         * CPU clock speed, unit: GHz.
         */
        baseFrequency: number;
        /**
         * The number of ECS instance CPU cores.
         */
        cpus: number;
        /**
         * CPU model.
         */
        model: string;
        /**
         * CPU Turbo Boost, unit: GHz.
         */
        turboFrequency: number;
    }

    export interface InstanceTypesInstanceTypeRdma {
        /**
         * Number of RDMA network cards.
         */
        rdmaNetworkInterfaces: number;
    }

    export interface InstanceTypesInstanceTypeVolume {
        /**
         * The maximum number of volumes.
         */
        maximumCount: number;
        /**
         * List of supported volume types.
         */
        supportedVolumeTypes: string[];
    }

    export interface InstancesInstance {
        /**
         * The number of ECS instance CPU cores.
         */
        cpus: number;
        /**
         * The create time of ECS instance.
         */
        createdAt: string;
        /**
         * The ID of DeploymentSet.
         */
        deploymentSetId: string;
        /**
         * The description of ECS instance.
         */
        description: string;
        /**
         * The EIP address of the ECS instance.
         */
        eipAddresses: outputs.ecs.InstancesInstanceEipAddress[];
        /**
         * The GPU device info of Instance.
         */
        gpuDevices: outputs.ecs.InstancesInstanceGpuDevice[];
        /**
         * The host name of ECS instance.
         */
        hostName: string;
        /**
         * The image ID of ECS instance.
         */
        imageId: string;
        /**
         * The charge type of ECS instance.
         */
        instanceChargeType: string;
        /**
         * The ID of ECS instance.
         */
        instanceId: string;
        /**
         * The name of ECS instance. This field support fuzzy query.
         */
        instanceName: string;
        /**
         * The spec type of ECS instance.
         */
        instanceType: string;
        /**
         * The number of IPv6 addresses of the ECS instance.
         */
        ipv6AddressCount: number;
        /**
         * A list of ipv6 addresses.
         */
        ipv6Addresses: string[];
        /**
         * The Flag of GPU instance.If the instance is GPU,The flag is true.
         */
        isGpu: boolean;
        /**
         * The ssh key ID of ECS instance.
         */
        keyPairId: string;
        /**
         * The key pair name of ECS instance.
         */
        keyPairName: string;
        /**
         * The memory size of ECS instance.
         */
        memorySize: number;
        /**
         * The networkInterface detail collection of ECS instance.
         */
        networkInterfaces: outputs.ecs.InstancesInstanceNetworkInterface[];
        /**
         * The os name of ECS instance.
         */
        osName: string;
        /**
         * The os type of ECS instance.
         */
        osType: string;
        /**
         * The ProjectName of ECS instance.
         */
        projectName: string;
        /**
         * The spot price limit of ECS instance.
         */
        spotPriceLimit: number;
        /**
         * The spot strategy of ECS instance.
         */
        spotStrategy: string;
        /**
         * The status of ECS instance.
         */
        status: string;
        /**
         * The stop mode of ECS instance.
         */
        stoppedMode: string;
        /**
         * Tags.
         */
        tags: outputs.ecs.InstancesInstanceTag[];
        /**
         * The update time of ECS instance.
         */
        updatedAt: string;
        /**
         * The volume ID list of ECS instance.
         */
        volumeIds: string[];
        /**
         * The volume detail collection of volume.
         */
        volumes: outputs.ecs.InstancesInstanceVolume[];
        /**
         * The VPC ID of ECS instance.
         */
        vpcId: string;
        /**
         * The available zone ID of ECS instance.
         */
        zoneId: string;
    }

    export interface InstancesInstanceEipAddress {
        /**
         * The EIP ID of the ECS instance.
         */
        allocationId: string;
        /**
         * The EIP address of the ECS instance.
         */
        ipAddress: string;
    }

    export interface InstancesInstanceGpuDevice {
        /**
         * The Count of GPU device.
         */
        count: number;
        /**
         * The Encrypted Memory Size of GPU device.
         */
        encryptedMemorySize: number;
        /**
         * The memory size of ECS instance.
         */
        memorySize: number;
        /**
         * The Product Name of GPU device.
         */
        productName: string;
    }

    export interface InstancesInstanceNetworkInterface {
        /**
         * The mac address of networkInterface.
         */
        macAddress: string;
        /**
         * The ID of networkInterface.
         */
        networkInterfaceId: string;
        /**
         * The primary ip address of ECS instance.
         */
        primaryIpAddress: string;
        /**
         * The subnet ID of networkInterface.
         */
        subnetId: string;
        /**
         * The type of networkInterface.
         */
        type: string;
        /**
         * The VPC ID of ECS instance.
         */
        vpcId: string;
    }

    export interface InstancesInstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface InstancesInstanceVolume {
        /**
         * The delete with instance flag of volume.
         */
        deleteWithInstance: boolean;
        /**
         * The size of volume.
         */
        size: number;
        /**
         * The ID of volume.
         */
        volumeId: string;
        /**
         * The Name of volume.
         */
        volumeName: string;
        /**
         * The type of volume.
         */
        volumeType: string;
    }

    export interface InstancesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface InvocationParameter {
        /**
         * The name of the parameter.
         */
        name: string;
        /**
         * The value of the parameter.
         */
        value: string;
    }

    export interface InvocationResultsInvocationResult {
        /**
         * The id of ecs command.
         */
        commandId: string;
        /**
         * The end time of the ecs invocation in the instance.
         */
        endTime: string;
        /**
         * The error code of the ecs invocation.
         */
        errorCode: string;
        /**
         * The error message of the ecs invocation.
         */
        errorMessage: string;
        /**
         * The exit code of the ecs command.
         */
        exitCode: number;
        /**
         * The id of the ecs invocation result.
         */
        id: string;
        /**
         * The id of ecs instance.
         */
        instanceId: string;
        /**
         * The id of ecs invocation.
         */
        invocationId: string;
        /**
         * The id of the ecs invocation result.
         */
        invocationResultId: string;
        /**
         * The list of status of ecs invocation in a single instance. Valid values: `Pending`, `Running`, `Success`, `Failed`, `Timeout`.
         */
        invocationResultStatus: string;
        /**
         * The base64 encoded output message of the ecs invocation.
         */
        output: string;
        /**
         * The start time of the ecs invocation in the instance.
         */
        startTime: string;
        /**
         * The username of the ecs command.
         */
        username: string;
    }

    export interface InvocationTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface InvocationsInvocation {
        /**
         * The base64 encoded content of the ecs command.
         */
        commandContent: string;
        /**
         * The description of the ecs command.
         */
        commandDescription: string;
        /**
         * The id of ecs command.
         */
        commandId: string;
        /**
         * The name of ecs command. This field support fuzzy query.
         */
        commandName: string;
        /**
         * The provider of the ecs command.
         */
        commandProvider: string;
        /**
         * The type of ecs command. Valid values: `Shell`.
         */
        commandType: string;
        /**
         * The end time of the ecs invocation.
         */
        endTime: string;
        /**
         * The frequency of the ecs invocation.
         */
        frequency: string;
        /**
         * The id of the ecs invocation.
         */
        id: string;
        /**
         * The list of ECS instance IDs.
         */
        instanceIds: string[];
        /**
         * The instance number of the ecs invocation.
         */
        instanceNumber: number;
        /**
         * The description of the ecs invocation.
         */
        invocationDescription: string;
        /**
         * The id of ecs invocation.
         */
        invocationId: string;
        /**
         * The name of ecs invocation. This field support fuzzy query.
         */
        invocationName: string;
        /**
         * The list of status of ecs invocation. Valid values: `Pending`, `Scheduled`, `Running`, `Success`, `Failed`, `Stopped`, `PartialFailed`, `Finished`.
         */
        invocationStatus: string;
        /**
         * The launch time of the ecs invocation.
         */
        launchTime: string;
        /**
         * The custom parameters of the ecs invocation.
         */
        parameters: string;
        /**
         * The project name of ecs invocation.
         */
        projectName: string;
        /**
         * The recurrence end time of the ecs invocation.
         */
        recurrenceEndTime: string;
        /**
         * The repeat mode of ecs invocation. Valid values: `Once`, `Rate`, `Fixed`.
         */
        repeatMode: string;
        /**
         * The start time of the ecs invocation.
         */
        startTime: string;
        /**
         * Tags.
         */
        tags: outputs.ecs.InvocationsInvocationTag[];
        /**
         * The timeout of the ecs command.
         */
        timeout: number;
        /**
         * The username of the ecs command.
         */
        username: string;
        /**
         * The working directory of the ecs command.
         */
        workingDir: string;
    }

    export interface InvocationsInvocationTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface InvocationsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface KeyPairsKeyPair {
        /**
         * The creation time of key pair.
         */
        createdAt: string;
        /**
         * The description of key pair.
         */
        description: string;
        /**
         * The finger print info.
         */
        fingerPrint: string;
        /**
         * The id of key pair.
         */
        id: string;
        /**
         * The id of key pair.
         */
        keyPairId: string;
        /**
         * Name of key pair.
         */
        keyPairName: string;
        /**
         * The update time of key pair.
         */
        updatedAt: string;
    }

    export interface LaunchTemplateNetworkInterface {
        /**
         * The security group ID associated with the NIC.
         */
        securityGroupIds?: string[];
        /**
         * The private network subnet ID of the instance, when creating the instance, supports binding the secondary NIC at the same time.
         */
        subnetId?: string;
    }

    export interface LaunchTemplateVolume {
        /**
         * The delete with instance flag of volume. Valid values: true, false. Default value: true.
         */
        deleteWithInstance?: boolean;
        /**
         * The size of volume.
         */
        size?: number;
        /**
         * The type of volume.
         */
        volumeType?: string;
    }

    export interface LaunchTemplatesLaunchTemplate {
        /**
         * The created time of the launch template.
         */
        createdAt: string;
        /**
         * The default version of the launch template.
         */
        defaultVersionNumber: number;
        /**
         * The description of the instance.
         */
        description: string;
        /**
         * The EIP bandwidth which the scaling configuration set.
         */
        eipBandwidth: number;
        /**
         * The EIP billing type which the scaling configuration set. Valid values: PostPaidByBandwidth, PostPaidByTraffic.
         */
        eipBillingType: string;
        /**
         * The EIP ISP which the scaling configuration set. Valid values: BGP, ChinaMobile, ChinaUnicom, ChinaTelecom.
         */
        eipIsp: string;
        /**
         * The host name of the instance.
         */
        hostName: string;
        /**
         * The hpc cluster id.
         */
        hpcClusterId: string;
        /**
         * The id of the launch template.
         */
        id: string;
        /**
         * The image id.
         */
        imageId: string;
        /**
         * The charge type of the instance and volume.
         */
        instanceChargeType: string;
        /**
         * The name of the instance.
         */
        instanceName: string;
        /**
         * When you log in to the instance using the SSH key pair, enter the name of the key pair.
         */
        keyPairName: string;
        /**
         * The latest version of the launch template.
         */
        latestVersionNumber: number;
        /**
         * The id of the launch template.
         */
        launchTemplateId: string;
        /**
         * The name of the launch template.
         */
        launchTemplateName: string;
        /**
         * The list of network interfaces.
         */
        networkInterfaces: outputs.ecs.LaunchTemplatesLaunchTemplateNetworkInterface[];
        /**
         * Whether to open the security reinforcement.
         */
        securityEnhancementStrategy: string;
        /**
         * The index of the ordered suffix.
         */
        suffixIndex: number;
        /**
         * Indicates whether the ordered suffix is automatically added to Hostname and InstanceName when multiple instances are created.
         */
        uniqueSuffix: boolean;
        /**
         * The updated time of the launch template.
         */
        updatedAt: string;
        /**
         * The latest version description of the launch template.
         */
        versionDescription: string;
        /**
         * The list of volume of the scaling configuration.
         */
        volumes: outputs.ecs.LaunchTemplatesLaunchTemplateVolume[];
        /**
         * The vpc id.
         */
        vpcId: string;
        /**
         * The zone ID of the instance.
         */
        zoneId: string;
    }

    export interface LaunchTemplatesLaunchTemplateNetworkInterface {
        /**
         * The security group ID associated with the NIC.
         */
        securityGroupIds: string[];
        /**
         * The private network subnet ID of the instance, when creating the instance, supports binding the secondary NIC at the same time.
         */
        subnetId: string;
    }

    export interface LaunchTemplatesLaunchTemplateVolume {
        /**
         * The delete with instance flag of volume. Valid values: true, false. Default value: true.
         */
        deleteWithInstance: boolean;
        /**
         * The size of volume.
         */
        size: number;
        /**
         * The type of volume.
         */
        volumeType: string;
    }

    export interface RegionsRegion {
        /**
         * The id of the region.
         */
        id: string;
        /**
         * The id of the region.
         */
        regionId: string;
    }

    export interface ZonesZone {
        /**
         * The id of the zone.
         */
        id: string;
        /**
         * The id of the zone.
         */
        zoneId: string;
    }

}

export namespace eip {
    export interface AddressTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface AddressesAddress {
        /**
         * The id of the EIP address.
         */
        allocationId: string;
        /**
         * The allocation time of the EIP.
         */
        allocationTime: string;
        /**
         * The peek bandwidth of the EIP.
         */
        bandwidth: number;
        /**
         * The id of the bandwidth package.
         */
        bandwidthPackageId: string;
        /**
         * The billing type of the EIP.
         */
        billingType: string;
        /**
         * The business status of the EIP.
         */
        businessStatus: string;
        /**
         * The deleted time of the EIP.
         */
        deletedTime: string;
        /**
         * The description of the EIP.
         */
        description: string;
        /**
         * The EIP ip address of the EIP.
         */
        eipAddress: string;
        /**
         * The expired time of the EIP.
         */
        expiredTime: string;
        /**
         * The id of the EIP address.
         */
        id: string;
        /**
         * The instance id which be associated to the EIP.
         */
        instanceId: string;
        /**
         * The type of the associated instance.
         */
        instanceType: string;
        /**
         * An ISP of EIP Address, the value can be `BGP` or `ChinaMobile` or `ChinaUnicom` or `ChinaTelecom`.
         */
        isp: string;
        /**
         * The lock reason of the EIP.
         */
        lockReason: string;
        /**
         * A name of EIP.
         */
        name: string;
        /**
         * The overdue time of the EIP.
         */
        overdueTime: string;
        /**
         * The ProjectName of EIP.
         */
        projectName: string;
        /**
         * Security protection types for shared bandwidth packages. Parameter - N: Indicates the number of security protection types, currently only supports taking 1. Value: `AntiDDoS_Enhanced`.
         */
        securityProtectionTypes: string[];
        /**
         * A status of EIP, the value can be `Attaching` or `Detaching` or `Attached` or `Available`.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.eip.AddressesAddressTag[];
        /**
         * The last update time of the EIP.
         */
        updatedAt: string;
    }

    export interface AddressesAddressTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface AddressesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetAddressesAddress {
        /**
         * The id of the EIP address.
         */
        allocationId: string;
        /**
         * The allocation time of the EIP.
         */
        allocationTime: string;
        /**
         * The peek bandwidth of the EIP.
         */
        bandwidth: number;
        /**
         * The id of the bandwidth package.
         */
        bandwidthPackageId: string;
        /**
         * The billing type of the EIP.
         */
        billingType: string;
        /**
         * The business status of the EIP.
         */
        businessStatus: string;
        /**
         * The deleted time of the EIP.
         */
        deletedTime: string;
        /**
         * The description of the EIP.
         */
        description: string;
        /**
         * The EIP ip address of the EIP.
         */
        eipAddress: string;
        /**
         * The expired time of the EIP.
         */
        expiredTime: string;
        /**
         * The id of the EIP address.
         */
        id: string;
        /**
         * The instance id which be associated to the EIP.
         */
        instanceId: string;
        /**
         * The type of the associated instance.
         */
        instanceType: string;
        /**
         * An ISP of EIP Address, the value can be `BGP` or `ChinaMobile` or `ChinaUnicom` or `ChinaTelecom`.
         */
        isp: string;
        /**
         * The lock reason of the EIP.
         */
        lockReason: string;
        /**
         * A name of EIP.
         */
        name: string;
        /**
         * The overdue time of the EIP.
         */
        overdueTime: string;
        /**
         * The ProjectName of EIP.
         */
        projectName: string;
        /**
         * Security protection types for shared bandwidth packages. Parameter - N: Indicates the number of security protection types, currently only supports taking 1. Value: `AntiDDoS_Enhanced`.
         */
        securityProtectionTypes: string[];
        /**
         * A status of EIP, the value can be `Attaching` or `Detaching` or `Attached` or `Available`.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.eip.GetAddressesAddressTag[];
        /**
         * The last update time of the EIP.
         */
        updatedAt: string;
    }

    export interface GetAddressesAddressTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetAddressesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

}

export namespace escloud {
    export interface GetInstancesInstance {
        /**
         * The charge status of instance.
         */
        chargeEnabled: boolean;
        /**
         * The create time of instance.
         */
        createTime: string;
        /**
         * whether enable es private network.
         */
        enableEsPrivateNetwork: boolean;
        /**
         * whether enable es public network.
         */
        enableEsPublicNetwork: boolean;
        /**
         * whether enable kibana private network.
         */
        enableKibanaPrivateNetwork: boolean;
        /**
         * whether enable kibana public network.
         */
        enableKibanaPublicNetwork: boolean;
        /**
         * The es inner endpoint of instance.
         */
        esInnerEndpoint: string;
        /**
         * The es private domain of instance.
         */
        esPrivateDomain: string;
        /**
         * The es private endpoint of instance.
         */
        esPrivateEndpoint: string;
        /**
         * The es public domain of instance.
         */
        esPublicDomain: string;
        /**
         * The es public endpoint of instance.
         */
        esPublicEndpoint: string;
        /**
         * The expire time of instance.
         */
        expireDate: string;
        /**
         * The Id of instance.
         */
        id: string;
        /**
         * The configuration of instance.
         */
        instanceConfiguration: outputs.escloud.GetInstancesInstanceInstanceConfiguration;
        /**
         * The Id of instance.
         */
        instanceId: string;
        /**
         * The kibana private domain of instance.
         */
        kibanaPrivateDomain: string;
        /**
         * The kibana public domain of instance.
         */
        kibanaPublicDomain: string;
        /**
         * The maintenance day of instance.
         */
        maintenanceDays: string[];
        /**
         * The maintenance time of instance.
         */
        maintenanceTime: string;
        /**
         * The namespace of instance.
         */
        namespace: string;
        /**
         * The nodes info of instance.
         */
        nodes: outputs.escloud.GetInstancesInstanceNode[];
        /**
         * The plugin info of instance.
         */
        plugins: outputs.escloud.GetInstancesInstancePlugin[];
        /**
         * The status of instance.
         */
        status: string;
        /**
         * The total nodes of instance.
         */
        totalNodes: number;
        /**
         * The user id of instance.
         */
        userId: string;
    }

    export interface GetInstancesInstanceInstanceConfiguration {
        /**
         * The user name of instance.
         */
        adminUserName: string;
        /**
         * The charge type of instance.
         */
        chargeType: string;
        /**
         * whether enable https.
         */
        enableHttps: boolean;
        /**
         * Whether enable pure master.
         */
        enablePureMaster: boolean;
        /**
         * The node number of host.
         */
        hotNodeNumber: number;
        /**
         * The node resource spec of host.
         */
        hotNodeResourceSpec: outputs.escloud.GetInstancesInstanceInstanceConfigurationHotNodeResourceSpec;
        /**
         * The node storage spec of host.
         */
        hotNodeStorageSpec: outputs.escloud.GetInstancesInstanceInstanceConfigurationHotNodeStorageSpec;
        /**
         * The name of instance.
         */
        instanceName: string;
        /**
         * The node number of kibana.
         */
        kibanaNodeNumber: number;
        /**
         * The node resource spec of kibana.
         */
        kibanaNodeResourceSpec: outputs.escloud.GetInstancesInstanceInstanceConfigurationKibanaNodeResourceSpec;
        /**
         * The node storage spec of kibana.
         */
        kibanaNodeStorageSpec: outputs.escloud.GetInstancesInstanceInstanceConfigurationKibanaNodeStorageSpec;
        /**
         * The node number of master.
         */
        masterNodeNumber: number;
        /**
         * The node resource spec of master.
         */
        masterNodeResourceSpec: outputs.escloud.GetInstancesInstanceInstanceConfigurationMasterNodeResourceSpec;
        /**
         * The node storage spec of master.
         */
        masterNodeStorageSpec: outputs.escloud.GetInstancesInstanceInstanceConfigurationMasterNodeStorageSpec;
        /**
         * The period of project.
         */
        period: number;
        /**
         * The name of project.
         */
        projectName: string;
        /**
         * The region info of instance.
         */
        regionId: string;
        /**
         * The subnet info.
         */
        subnet: outputs.escloud.GetInstancesInstanceInstanceConfigurationSubnet;
        /**
         * The version of plugin.
         */
        version: string;
        /**
         * The vpc info.
         */
        vpc: outputs.escloud.GetInstancesInstanceInstanceConfigurationVpc;
        /**
         * The zoneId of instance.
         */
        zoneId: string;
        /**
         * The zone number of instance.
         */
        zoneNumber: number;
    }

    export interface GetInstancesInstanceInstanceConfigurationHotNodeResourceSpec {
        /**
         * The cpu info of resource spec.
         */
        cpu: number;
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The memory info of resource spec.
         */
        memory: number;
        /**
         * The name of storage spec.
         */
        name: string;
    }

    export interface GetInstancesInstanceInstanceConfigurationHotNodeStorageSpec {
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The max size of storage spec.
         */
        maxSize: number;
        /**
         * The min size of storage spec.
         */
        minSize: number;
        /**
         * The name of storage spec.
         */
        name: string;
        /**
         * The size of storage spec.
         */
        size: number;
        /**
         * The type of storage spec.
         */
        type: string;
    }

    export interface GetInstancesInstanceInstanceConfigurationKibanaNodeResourceSpec {
        /**
         * The cpu info of resource spec.
         */
        cpu: number;
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The memory info of resource spec.
         */
        memory: number;
        /**
         * The name of storage spec.
         */
        name: string;
    }

    export interface GetInstancesInstanceInstanceConfigurationKibanaNodeStorageSpec {
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The max size of storage spec.
         */
        maxSize: number;
        /**
         * The min size of storage spec.
         */
        minSize: number;
        /**
         * The name of storage spec.
         */
        name: string;
        /**
         * The size of storage spec.
         */
        size: number;
        /**
         * The type of storage spec.
         */
        type: string;
    }

    export interface GetInstancesInstanceInstanceConfigurationMasterNodeResourceSpec {
        /**
         * The cpu info of resource spec.
         */
        cpu: number;
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The memory info of resource spec.
         */
        memory: number;
        /**
         * The name of storage spec.
         */
        name: string;
    }

    export interface GetInstancesInstanceInstanceConfigurationMasterNodeStorageSpec {
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The max size of storage spec.
         */
        maxSize: number;
        /**
         * The min size of storage spec.
         */
        minSize: number;
        /**
         * The name of storage spec.
         */
        name: string;
        /**
         * The size of storage spec.
         */
        size: number;
        /**
         * The type of storage spec.
         */
        type: string;
    }

    export interface GetInstancesInstanceInstanceConfigurationSubnet {
        /**
         * The id of subnet.
         */
        subnetId: string;
        /**
         * The name of subnet.
         */
        subnetName: string;
    }

    export interface GetInstancesInstanceInstanceConfigurationVpc {
        /**
         * The id of vpc.
         */
        vpcId: string;
        /**
         * The name of vpc.
         */
        vpcName: string;
    }

    export interface GetInstancesInstanceNode {
        /**
         * Is cold node.
         */
        isCold: boolean;
        /**
         * Is hot node.
         */
        isHot: boolean;
        /**
         * Is kibana node.
         */
        isKibana: boolean;
        /**
         * Is master node.
         */
        isMaster: boolean;
        /**
         * Is warm node.
         */
        isWarm: boolean;
        /**
         * The show name of node.
         */
        nodeDisplayName: string;
        /**
         * The name of node.
         */
        nodeName: string;
        /**
         * The node resource spec of master.
         */
        resourceSpec: outputs.escloud.GetInstancesInstanceNodeResourceSpec;
        /**
         * The restart times of node.
         */
        restartNumber: number;
        /**
         * The start time of node.
         */
        startTime: string;
        /**
         * The status of instance.
         */
        status: string;
        /**
         * The node storage spec of master.
         */
        storageSpec: outputs.escloud.GetInstancesInstanceNodeStorageSpec;
    }

    export interface GetInstancesInstanceNodeResourceSpec {
        /**
         * The cpu info of resource spec.
         */
        cpu: number;
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The memory info of resource spec.
         */
        memory: number;
        /**
         * The name of storage spec.
         */
        name: string;
    }

    export interface GetInstancesInstanceNodeStorageSpec {
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The max size of storage spec.
         */
        maxSize: number;
        /**
         * The min size of storage spec.
         */
        minSize: number;
        /**
         * The name of storage spec.
         */
        name: string;
        /**
         * The size of storage spec.
         */
        size: number;
        /**
         * The type of storage spec.
         */
        type: string;
    }

    export interface GetInstancesInstancePlugin {
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The name of plugin.
         */
        pluginName: string;
        /**
         * The version of plugin.
         */
        version: string;
    }

    export interface GetRegionsRegion {
        /**
         * The id of the region.
         */
        regionId: string;
        /**
         * The name of region.
         */
        regionName: string;
    }

    export interface GetZonesZone {
        /**
         * The id of the zone.
         */
        id: string;
        /**
         * The id of the zone.
         */
        zoneId: string;
        /**
         * The name of the zone.
         */
        zoneName: string;
    }

    export interface InstanceInstanceConfiguration {
        /**
         * The password of administrator account. When importing resources, this attribute will not be imported. If this attribute is set, please use lifecycle and ignoreChanges ignore changes in fields.
         */
        adminPassword: string;
        /**
         * The name of administrator account(should be admin).
         */
        adminUserName: string;
        /**
         * The charge type of ESCloud instance, the value can be PostPaid or PrePaid.
         */
        chargeType: string;
        /**
         * Configuration code used for billing.
         */
        configurationCode: string;
        /**
         * Whether Https access is enabled.
         */
        enableHttps: boolean;
        /**
         * Whether the Master node is independent.
         */
        enablePureMaster: boolean;
        /**
         * Whether to force restart when changes are made. If true, it means that the cluster will be forced to restart without paying attention to instance availability. Works only on modified the nodeSpecsAssigns field.
         */
        forceRestartAfterScale?: boolean;
        /**
         * The name of ESCloud instance.
         */
        instanceName?: string;
        /**
         * The maintainable date for the instance. Works only on modified scenes.
         */
        maintenanceDays: string[];
        /**
         * The maintainable time period for the instance. Works only on modified scenes.
         */
        maintenanceTime: string;
        /**
         * The number and configuration of various ESCloud instance node. Kibana NodeSpecsAssign should not be modified.
         */
        nodeSpecsAssigns: outputs.escloud.InstanceInstanceConfigurationNodeSpecsAssign[];
        /**
         * The project name  to which the ESCloud instance belongs.
         */
        projectName: string;
        /**
         * The region ID of ESCloud instance.
         */
        regionId: string;
        /**
         * The ID of subnet, the subnet must belong to the AZ selected.
         */
        subnetId: string;
        /**
         * The version of ESCloud instance, the value is V6_7 or V7_10.
         */
        version: string;
        /**
         * The available zone ID of ESCloud instance.
         */
        zoneId: string;
        /**
         * The zone count of the ESCloud instance used.
         */
        zoneNumber: number;
    }

    export interface InstanceInstanceConfigurationNodeSpecsAssign {
        /**
         * The number of node.
         */
        number: number;
        /**
         * The name of compute resource spec, the value is `kibana.x2.small` or `es.x4.medium` or `es.x4.large` or `es.x4.xlarge` or `es.x2.2xlarge` or `es.x4.2xlarge` or `es.x2.3xlarge`.
         */
        resourceSpecName: string;
        /**
         * The size of storage. Kibana NodeSpecsAssign should not specify this field.
         */
        storageSize?: number;
        /**
         * The name of storage spec. Kibana NodeSpecsAssign should not specify this field.
         */
        storageSpecName?: string;
        /**
         * The type of node, the value is `Master` or `Hot` or `Kibana`.
         */
        type: string;
    }

    export interface InstancesInstance {
        /**
         * The charge status of instance.
         */
        chargeEnabled: boolean;
        /**
         * The create time of instance.
         */
        createTime: string;
        /**
         * whether enable es private network.
         */
        enableEsPrivateNetwork: boolean;
        /**
         * whether enable es public network.
         */
        enableEsPublicNetwork: boolean;
        /**
         * whether enable kibana private network.
         */
        enableKibanaPrivateNetwork: boolean;
        /**
         * whether enable kibana public network.
         */
        enableKibanaPublicNetwork: boolean;
        /**
         * The es inner endpoint of instance.
         */
        esInnerEndpoint: string;
        /**
         * The es private domain of instance.
         */
        esPrivateDomain: string;
        /**
         * The es private endpoint of instance.
         */
        esPrivateEndpoint: string;
        /**
         * The es public domain of instance.
         */
        esPublicDomain: string;
        /**
         * The es public endpoint of instance.
         */
        esPublicEndpoint: string;
        /**
         * The expire time of instance.
         */
        expireDate: string;
        /**
         * The Id of instance.
         */
        id: string;
        /**
         * The configuration of instance.
         */
        instanceConfiguration: outputs.escloud.InstancesInstanceInstanceConfiguration;
        /**
         * The Id of instance.
         */
        instanceId: string;
        /**
         * The kibana private domain of instance.
         */
        kibanaPrivateDomain: string;
        /**
         * The kibana public domain of instance.
         */
        kibanaPublicDomain: string;
        /**
         * The maintenance day of instance.
         */
        maintenanceDays: string[];
        /**
         * The maintenance time of instance.
         */
        maintenanceTime: string;
        /**
         * The namespace of instance.
         */
        namespace: string;
        /**
         * The nodes info of instance.
         */
        nodes: outputs.escloud.InstancesInstanceNode[];
        /**
         * The plugin info of instance.
         */
        plugins: outputs.escloud.InstancesInstancePlugin[];
        /**
         * The status of instance.
         */
        status: string;
        /**
         * The total nodes of instance.
         */
        totalNodes: number;
        /**
         * The user id of instance.
         */
        userId: string;
    }

    export interface InstancesInstanceInstanceConfiguration {
        /**
         * The user name of instance.
         */
        adminUserName: string;
        /**
         * The charge type of instance.
         */
        chargeType: string;
        /**
         * whether enable https.
         */
        enableHttps: boolean;
        /**
         * Whether enable pure master.
         */
        enablePureMaster: boolean;
        /**
         * The node number of host.
         */
        hotNodeNumber: number;
        /**
         * The node resource spec of host.
         */
        hotNodeResourceSpec: outputs.escloud.InstancesInstanceInstanceConfigurationHotNodeResourceSpec;
        /**
         * The node storage spec of host.
         */
        hotNodeStorageSpec: outputs.escloud.InstancesInstanceInstanceConfigurationHotNodeStorageSpec;
        /**
         * The name of instance.
         */
        instanceName: string;
        /**
         * The node number of kibana.
         */
        kibanaNodeNumber: number;
        /**
         * The node resource spec of kibana.
         */
        kibanaNodeResourceSpec: outputs.escloud.InstancesInstanceInstanceConfigurationKibanaNodeResourceSpec;
        /**
         * The node storage spec of kibana.
         */
        kibanaNodeStorageSpec: outputs.escloud.InstancesInstanceInstanceConfigurationKibanaNodeStorageSpec;
        /**
         * The node number of master.
         */
        masterNodeNumber: number;
        /**
         * The node resource spec of master.
         */
        masterNodeResourceSpec: outputs.escloud.InstancesInstanceInstanceConfigurationMasterNodeResourceSpec;
        /**
         * The node storage spec of master.
         */
        masterNodeStorageSpec: outputs.escloud.InstancesInstanceInstanceConfigurationMasterNodeStorageSpec;
        /**
         * The period of project.
         */
        period: number;
        /**
         * The name of project.
         */
        projectName: string;
        /**
         * The region info of instance.
         */
        regionId: string;
        /**
         * The subnet info.
         */
        subnet: outputs.escloud.InstancesInstanceInstanceConfigurationSubnet;
        /**
         * The version of plugin.
         */
        version: string;
        /**
         * The vpc info.
         */
        vpc: outputs.escloud.InstancesInstanceInstanceConfigurationVpc;
        /**
         * The zoneId of instance.
         */
        zoneId: string;
        /**
         * The zone number of instance.
         */
        zoneNumber: number;
    }

    export interface InstancesInstanceInstanceConfigurationHotNodeResourceSpec {
        /**
         * The cpu info of resource spec.
         */
        cpu: number;
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The memory info of resource spec.
         */
        memory: number;
        /**
         * The name of storage spec.
         */
        name: string;
    }

    export interface InstancesInstanceInstanceConfigurationHotNodeStorageSpec {
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The max size of storage spec.
         */
        maxSize: number;
        /**
         * The min size of storage spec.
         */
        minSize: number;
        /**
         * The name of storage spec.
         */
        name: string;
        /**
         * The size of storage spec.
         */
        size: number;
        /**
         * The type of storage spec.
         */
        type: string;
    }

    export interface InstancesInstanceInstanceConfigurationKibanaNodeResourceSpec {
        /**
         * The cpu info of resource spec.
         */
        cpu: number;
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The memory info of resource spec.
         */
        memory: number;
        /**
         * The name of storage spec.
         */
        name: string;
    }

    export interface InstancesInstanceInstanceConfigurationKibanaNodeStorageSpec {
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The max size of storage spec.
         */
        maxSize: number;
        /**
         * The min size of storage spec.
         */
        minSize: number;
        /**
         * The name of storage spec.
         */
        name: string;
        /**
         * The size of storage spec.
         */
        size: number;
        /**
         * The type of storage spec.
         */
        type: string;
    }

    export interface InstancesInstanceInstanceConfigurationMasterNodeResourceSpec {
        /**
         * The cpu info of resource spec.
         */
        cpu: number;
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The memory info of resource spec.
         */
        memory: number;
        /**
         * The name of storage spec.
         */
        name: string;
    }

    export interface InstancesInstanceInstanceConfigurationMasterNodeStorageSpec {
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The max size of storage spec.
         */
        maxSize: number;
        /**
         * The min size of storage spec.
         */
        minSize: number;
        /**
         * The name of storage spec.
         */
        name: string;
        /**
         * The size of storage spec.
         */
        size: number;
        /**
         * The type of storage spec.
         */
        type: string;
    }

    export interface InstancesInstanceInstanceConfigurationSubnet {
        /**
         * The id of subnet.
         */
        subnetId: string;
        /**
         * The name of subnet.
         */
        subnetName: string;
    }

    export interface InstancesInstanceInstanceConfigurationVpc {
        /**
         * The id of vpc.
         */
        vpcId: string;
        /**
         * The name of vpc.
         */
        vpcName: string;
    }

    export interface InstancesInstanceNode {
        /**
         * Is cold node.
         */
        isCold: boolean;
        /**
         * Is hot node.
         */
        isHot: boolean;
        /**
         * Is kibana node.
         */
        isKibana: boolean;
        /**
         * Is master node.
         */
        isMaster: boolean;
        /**
         * Is warm node.
         */
        isWarm: boolean;
        /**
         * The show name of node.
         */
        nodeDisplayName: string;
        /**
         * The name of node.
         */
        nodeName: string;
        /**
         * The node resource spec of master.
         */
        resourceSpec: outputs.escloud.InstancesInstanceNodeResourceSpec;
        /**
         * The restart times of node.
         */
        restartNumber: number;
        /**
         * The start time of node.
         */
        startTime: string;
        /**
         * The status of instance.
         */
        status: string;
        /**
         * The node storage spec of master.
         */
        storageSpec: outputs.escloud.InstancesInstanceNodeStorageSpec;
    }

    export interface InstancesInstanceNodeResourceSpec {
        /**
         * The cpu info of resource spec.
         */
        cpu: number;
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The memory info of resource spec.
         */
        memory: number;
        /**
         * The name of storage spec.
         */
        name: string;
    }

    export interface InstancesInstanceNodeStorageSpec {
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The max size of storage spec.
         */
        maxSize: number;
        /**
         * The min size of storage spec.
         */
        minSize: number;
        /**
         * The name of storage spec.
         */
        name: string;
        /**
         * The size of storage spec.
         */
        size: number;
        /**
         * The type of storage spec.
         */
        type: string;
    }

    export interface InstancesInstancePlugin {
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The name of plugin.
         */
        pluginName: string;
        /**
         * The version of plugin.
         */
        version: string;
    }

    export interface RegionsRegion {
        /**
         * The id of the region.
         */
        regionId: string;
        /**
         * The name of region.
         */
        regionName: string;
    }

    export interface ZonesZone {
        /**
         * The id of the zone.
         */
        id: string;
        /**
         * The id of the zone.
         */
        zoneId: string;
        /**
         * The name of the zone.
         */
        zoneName: string;
    }

}

export namespace escloud_v2 {
    export interface EscloudInstanceV2NetworkSpec {
        /**
         * The bandwidth of the eip. Unit: Mbps.
         */
        bandwidth: number;
        /**
         * Whether the eip is opened.
         */
        isOpen: boolean;
        /**
         * The spec name of public network.
         */
        specName: string;
        /**
         * The type of public network, valid values: `Elasticsearch`, `Kibana`.
         */
        type: string;
    }

    export interface EscloudInstanceV2NodeSpecsAssign {
        /**
         * The extra performance of FlexPL storage spec.
         */
        extraPerformance?: outputs.escloud_v2.EscloudInstanceV2NodeSpecsAssignExtraPerformance;
        /**
         * The number of node.
         */
        number: number;
        /**
         * The name of compute resource spec.
         */
        resourceSpecName: string;
        /**
         * The size of storage. Unit: GiB. the adjustment step size is 10GiB. Default is 100 GiB. Kibana NodeSpecsAssign should specify this field to 0.
         */
        storageSize: number;
        /**
         * The name of storage spec. Kibana NodeSpecsAssign should specify this field to ``.
         */
        storageSpecName: string;
        /**
         * The type of node, valid values: `Master`, `Hot`, `Cold`, `Warm`, `Kibana`, `Coordinator`.
         */
        type: string;
    }

    export interface EscloudInstanceV2NodeSpecsAssignExtraPerformance {
        /**
         * When your data node chooses to use FlexPL storage type and the storage specification configuration is 500GiB or above, it supports purchasing bandwidth packages to increase disk bandwidth.
         * The unit is MiB, and the adjustment step size is 10MiB.
         */
        throughput: number;
    }

    export interface EscloudInstanceV2Tag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface EscloudInstancesV2Instance {
        /**
         * Whether to enable cerebro.
         */
        cerebroEnabled: boolean;
        /**
         * The cerebro private domain of instance.
         */
        cerebroPrivateDomain: string;
        /**
         * The cerebro public domain of instance.
         */
        cerebroPublicDomain: string;
        /**
         * The charge status of instance.
         */
        chargeEnabled: boolean;
        /**
         * The cluster id of instance.
         */
        clusterId: string;
        /**
         * The create time of instance.
         */
        createTime: string;
        /**
         * Whether enable deletion protection for ESCloud instance.
         */
        deletionProtection: boolean;
        /**
         * whether enable es private domain public.
         */
        enableEsPrivateDomainPublic: boolean;
        /**
         * whether enable es private network.
         */
        enableEsPrivateNetwork: boolean;
        /**
         * whether enable es public network.
         */
        enableEsPublicNetwork: boolean;
        /**
         * whether enable kibana private domain public.
         */
        enableKibanaPrivateDomainPublic: boolean;
        /**
         * whether enable kibana private network.
         */
        enableKibanaPrivateNetwork: boolean;
        /**
         * whether enable kibana public network.
         */
        enableKibanaPublicNetwork: boolean;
        /**
         * The eip address of instance.
         */
        esEip: string;
        /**
         * The eip id associated with the instance.
         */
        esEipId: string;
        /**
         * The es inner endpoint of instance.
         */
        esInnerEndpoint: string;
        /**
         * The es private domain of instance.
         */
        esPrivateDomain: string;
        /**
         * The es private endpoint of instance.
         */
        esPrivateEndpoint: string;
        /**
         * The whitelist of es private ip.
         */
        esPrivateIpWhitelist: string;
        /**
         * The es public domain of instance.
         */
        esPublicDomain: string;
        /**
         * The es public endpoint of instance.
         */
        esPublicEndpoint: string;
        /**
         * The whitelist of es public ip.
         */
        esPublicIpWhitelist: string;
        /**
         * The expire time of instance.
         */
        expireDate: string;
        /**
         * The id of instance.
         */
        id: string;
        /**
         * The configuration of instance.
         */
        instanceConfigurations: outputs.escloud_v2.EscloudInstancesV2InstanceInstanceConfiguration[];
        /**
         * The id of instance.
         */
        instanceId: string;
        /**
         * The eip address of kibana.
         */
        kibanaEip: string;
        /**
         * The eip id associated with kibana.
         */
        kibanaEipId: string;
        /**
         * The kibana private domain of instance.
         */
        kibanaPrivateDomain: string;
        /**
         * The whitelist of kibana private ip.
         */
        kibanaPrivateIpWhitelist: string;
        /**
         * The kibana public domain of instance.
         */
        kibanaPublicDomain: string;
        /**
         * The whitelist of kibana public ip.
         */
        kibanaPublicIpWhitelist: string;
        /**
         * The main zone id of instance.
         */
        mainZoneId: string;
        /**
         * The maintenance day of instance.
         */
        maintenanceDays: string[];
        /**
         * The maintenance time of instance.
         */
        maintenanceTime: string;
        /**
         * The nodes info of instance.
         */
        nodes: outputs.escloud_v2.EscloudInstancesV2InstanceNode[];
        /**
         * The plugin info of instance.
         */
        plugins: outputs.escloud_v2.EscloudInstancesV2InstancePlugin[];
        /**
         * The status of instance.
         */
        status: string;
        /**
         * Whether support code node.
         */
        supportCodeNode: boolean;
        /**
         * The tags of instance.
         */
        tags: outputs.escloud_v2.EscloudInstancesV2InstanceTag[];
        /**
         * The total nodes of instance.
         */
        totalNodes: number;
        /**
         * The user id of instance.
         */
        userId: string;
    }

    export interface EscloudInstancesV2InstanceInstanceConfiguration {
        /**
         * The user name of instance.
         */
        adminUserName: string;
        /**
         * The charge type of instance.
         */
        chargeType: string;
        /**
         * The node number of cold.
         */
        coldNodeNumber: number;
        /**
         * The node resource spec of cold.
         */
        coldNodeResourceSpecs: outputs.escloud_v2.EscloudInstancesV2InstanceInstanceConfigurationColdNodeResourceSpec[];
        /**
         * The node storage spec of cold.
         */
        coldNodeStorageSpecs: outputs.escloud_v2.EscloudInstancesV2InstanceInstanceConfigurationColdNodeStorageSpec[];
        /**
         * The node number of coordinator.
         */
        coordinatorNodeNumber: number;
        /**
         * The node resource spec of coordinator.
         */
        coordinatorNodeResourceSpecs: outputs.escloud_v2.EscloudInstancesV2InstanceInstanceConfigurationCoordinatorNodeResourceSpec[];
        /**
         * The node storage spec of coordinator.
         */
        coordinatorNodeStorageSpecs: outputs.escloud_v2.EscloudInstancesV2InstanceInstanceConfigurationCoordinatorNodeStorageSpec[];
        /**
         * whether enable https.
         */
        enableHttps: boolean;
        /**
         * Whether enable pure master.
         */
        enablePureMaster: boolean;
        /**
         * The node number of hot.
         */
        hotNodeNumber: number;
        /**
         * The node resource spec of hot.
         */
        hotNodeResourceSpecs: outputs.escloud_v2.EscloudInstancesV2InstanceInstanceConfigurationHotNodeResourceSpec[];
        /**
         * The node storage spec of hot.
         */
        hotNodeStorageSpecs: outputs.escloud_v2.EscloudInstancesV2InstanceInstanceConfigurationHotNodeStorageSpec[];
        /**
         * The name of instance.
         */
        instanceName: string;
        /**
         * The node number of kibana.
         */
        kibanaNodeNumber: number;
        /**
         * The node resource spec of kibana.
         */
        kibanaNodeResourceSpecs: outputs.escloud_v2.EscloudInstancesV2InstanceInstanceConfigurationKibanaNodeResourceSpec[];
        /**
         * The node storage spec of kibana.
         */
        kibanaNodeStorageSpecs: outputs.escloud_v2.EscloudInstancesV2InstanceInstanceConfigurationKibanaNodeStorageSpec[];
        /**
         * The node number of master.
         */
        masterNodeNumber: number;
        /**
         * The node resource spec of master.
         */
        masterNodeResourceSpecs: outputs.escloud_v2.EscloudInstancesV2InstanceInstanceConfigurationMasterNodeResourceSpec[];
        /**
         * The node storage spec of master.
         */
        masterNodeStorageSpecs: outputs.escloud_v2.EscloudInstancesV2InstanceInstanceConfigurationMasterNodeStorageSpec[];
        /**
         * The period of project.
         */
        period: number;
        /**
         * The project name of instance.
         */
        projectName: string;
        /**
         * The region info of instance.
         */
        regionId: string;
        /**
         * The subnet info.
         */
        subnets: outputs.escloud_v2.EscloudInstancesV2InstanceInstanceConfigurationSubnet[];
        /**
         * The version of plugin.
         */
        version: string;
        /**
         * The vpc info.
         */
        vpcs: outputs.escloud_v2.EscloudInstancesV2InstanceInstanceConfigurationVpc[];
        /**
         * The node number of warm.
         */
        warmNodeNumber: number;
        /**
         * The node resource spec of warm.
         */
        warmNodeResourceSpecs: outputs.escloud_v2.EscloudInstancesV2InstanceInstanceConfigurationWarmNodeResourceSpec[];
        /**
         * The node storage spec of warm.
         */
        warmNodeStorageSpecs: outputs.escloud_v2.EscloudInstancesV2InstanceInstanceConfigurationWarmNodeStorageSpec[];
        /**
         * The zoneId of instance.
         */
        zoneId: string;
        /**
         * The zone number of instance.
         */
        zoneNumber: number;
    }

    export interface EscloudInstancesV2InstanceInstanceConfigurationColdNodeResourceSpec {
        /**
         * The cpu info of resource spec.
         */
        cpu: number;
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The memory info of resource spec.
         */
        memory: number;
        /**
         * The name of storage spec.
         */
        name: string;
    }

    export interface EscloudInstancesV2InstanceInstanceConfigurationColdNodeStorageSpec {
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The max size of storage spec.
         */
        maxSize: number;
        /**
         * The min size of storage spec.
         */
        minSize: number;
        /**
         * The name of storage spec.
         */
        name: string;
        /**
         * The size of storage spec.
         */
        size: number;
    }

    export interface EscloudInstancesV2InstanceInstanceConfigurationCoordinatorNodeResourceSpec {
        /**
         * The cpu info of resource spec.
         */
        cpu: number;
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The memory info of resource spec.
         */
        memory: number;
        /**
         * The name of storage spec.
         */
        name: string;
    }

    export interface EscloudInstancesV2InstanceInstanceConfigurationCoordinatorNodeStorageSpec {
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The max size of storage spec.
         */
        maxSize: number;
        /**
         * The min size of storage spec.
         */
        minSize: number;
        /**
         * The name of storage spec.
         */
        name: string;
        /**
         * The size of storage spec.
         */
        size: number;
    }

    export interface EscloudInstancesV2InstanceInstanceConfigurationHotNodeResourceSpec {
        /**
         * The cpu info of resource spec.
         */
        cpu: number;
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The memory info of resource spec.
         */
        memory: number;
        /**
         * The name of storage spec.
         */
        name: string;
    }

    export interface EscloudInstancesV2InstanceInstanceConfigurationHotNodeStorageSpec {
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The max size of storage spec.
         */
        maxSize: number;
        /**
         * The min size of storage spec.
         */
        minSize: number;
        /**
         * The name of storage spec.
         */
        name: string;
        /**
         * The size of storage spec.
         */
        size: number;
    }

    export interface EscloudInstancesV2InstanceInstanceConfigurationKibanaNodeResourceSpec {
        /**
         * The cpu info of resource spec.
         */
        cpu: number;
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The memory info of resource spec.
         */
        memory: number;
        /**
         * The name of storage spec.
         */
        name: string;
    }

    export interface EscloudInstancesV2InstanceInstanceConfigurationKibanaNodeStorageSpec {
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The max size of storage spec.
         */
        maxSize: number;
        /**
         * The min size of storage spec.
         */
        minSize: number;
        /**
         * The name of storage spec.
         */
        name: string;
        /**
         * The size of storage spec.
         */
        size: number;
    }

    export interface EscloudInstancesV2InstanceInstanceConfigurationMasterNodeResourceSpec {
        /**
         * The cpu info of resource spec.
         */
        cpu: number;
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The memory info of resource spec.
         */
        memory: number;
        /**
         * The name of storage spec.
         */
        name: string;
    }

    export interface EscloudInstancesV2InstanceInstanceConfigurationMasterNodeStorageSpec {
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The max size of storage spec.
         */
        maxSize: number;
        /**
         * The min size of storage spec.
         */
        minSize: number;
        /**
         * The name of storage spec.
         */
        name: string;
        /**
         * The size of storage spec.
         */
        size: number;
    }

    export interface EscloudInstancesV2InstanceInstanceConfigurationSubnet {
        /**
         * The id of subnet.
         */
        subnetId: string;
        /**
         * The name of subnet.
         */
        subnetName: string;
    }

    export interface EscloudInstancesV2InstanceInstanceConfigurationVpc {
        /**
         * The id of vpc.
         */
        vpcId: string;
        /**
         * The name of vpc.
         */
        vpcName: string;
    }

    export interface EscloudInstancesV2InstanceInstanceConfigurationWarmNodeResourceSpec {
        /**
         * The cpu info of resource spec.
         */
        cpu: number;
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The memory info of resource spec.
         */
        memory: number;
        /**
         * The name of storage spec.
         */
        name: string;
    }

    export interface EscloudInstancesV2InstanceInstanceConfigurationWarmNodeStorageSpec {
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The max size of storage spec.
         */
        maxSize: number;
        /**
         * The min size of storage spec.
         */
        minSize: number;
        /**
         * The name of storage spec.
         */
        name: string;
        /**
         * The size of storage spec.
         */
        size: number;
    }

    export interface EscloudInstancesV2InstanceNode {
        /**
         * Is cold node.
         */
        isCold: boolean;
        /**
         * Is coordinator node.
         */
        isCoordinator: boolean;
        /**
         * Is hot node.
         */
        isHot: boolean;
        /**
         * Is kibana node.
         */
        isKibana: boolean;
        /**
         * Is master node.
         */
        isMaster: boolean;
        /**
         * Is warm node.
         */
        isWarm: boolean;
        /**
         * The show name of node.
         */
        nodeDisplayName: string;
        /**
         * The name of node.
         */
        nodeName: string;
        /**
         * The node resource spec of master.
         */
        resourceSpecs: outputs.escloud_v2.EscloudInstancesV2InstanceNodeResourceSpec[];
        /**
         * The restart times of node.
         */
        restartNumber: number;
        /**
         * The start time of node.
         */
        startTime: string;
        /**
         * The status of instance.
         */
        status: string;
        /**
         * The node storage spec of master.
         */
        storageSpecs: outputs.escloud_v2.EscloudInstancesV2InstanceNodeStorageSpec[];
    }

    export interface EscloudInstancesV2InstanceNodeResourceSpec {
        /**
         * The cpu info of resource spec.
         */
        cpu: number;
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The memory info of resource spec.
         */
        memory: number;
    }

    export interface EscloudInstancesV2InstanceNodeStorageSpec {
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The max size of storage spec.
         */
        maxSize: number;
        /**
         * The min size of storage spec.
         */
        minSize: number;
    }

    export interface EscloudInstancesV2InstancePlugin {
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The name of plugin.
         */
        pluginName: string;
        /**
         * The status of instance.
         */
        status: string;
        /**
         * The version of plugin.
         */
        version: string;
    }

    export interface EscloudInstancesV2InstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface EscloudInstancesV2Tag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        values: string[];
    }

    export interface EscloudNodeAvailableSpecsNodeSpec {
        /**
         * The available specs sold out.
         */
        azAvailableSpecsSoldOut: {[key: string]: string};
        /**
         * The configuration code.
         */
        configurationCode: string;
        /**
         * The network specs.
         */
        networkSpecs: outputs.escloud_v2.EscloudNodeAvailableSpecsNodeSpecNetworkSpec[];
        /**
         * The node available specs.
         */
        nodeAvailableSpecs: outputs.escloud_v2.EscloudNodeAvailableSpecsNodeSpecNodeAvailableSpec[];
        /**
         * The resource specs.
         */
        resourceSpecs: outputs.escloud_v2.EscloudNodeAvailableSpecsNodeSpecResourceSpec[];
        /**
         * The storage specs.
         */
        storageSpecs: outputs.escloud_v2.EscloudNodeAvailableSpecsNodeSpecStorageSpec[];
    }

    export interface EscloudNodeAvailableSpecsNodeSpecNetworkSpec {
        /**
         * The network role.
         */
        networkRole: string;
        /**
         * The spec name.
         */
        specName: string;
    }

    export interface EscloudNodeAvailableSpecsNodeSpecNodeAvailableSpec {
        /**
         * The resource spec names of node.
         */
        resourceSpecNames: string[];
        /**
         * The storage spec names of node.
         */
        storageSpecNames: string[];
        /**
         * The type of node.
         */
        type: string;
    }

    export interface EscloudNodeAvailableSpecsNodeSpecResourceSpec {
        /**
         * The cpu of resource spec. Unit: Core.
         */
        cpu: number;
        /**
         * The description of storage spec.
         */
        description: string;
        /**
         * The display name of storage spec.
         */
        displayName: string;
        /**
         * The memory of resource spec. Unit: GiB.
         */
        memory: number;
        /**
         * The name of storage spec.
         */
        name: string;
    }

    export interface EscloudNodeAvailableSpecsNodeSpecStorageSpec {
        /**
         * The description of storage spec.
         */
        description: string;
        /**
         * The display name of storage spec.
         */
        displayName: string;
        /**
         * The max size of storage spec. Unit: GiB.
         */
        maxSize: number;
        /**
         * The min size of storage spec. Unit: GiB.
         */
        minSize: number;
        /**
         * The name of storage spec.
         */
        name: string;
        /**
         * The size of storage spec.
         */
        size: number;
    }

    export interface EscloudZonesV2Zone {
        /**
         * The region ID of zone.
         */
        regionId: string;
        /**
         * The ID of zone.
         */
        zoneId: string;
        /**
         * The name of zone.
         */
        zoneName: string;
        /**
         * The status of zone.
         */
        zoneStatus: string;
    }

    export interface GetEscloudInstancesV2Instance {
        /**
         * Whether to enable cerebro.
         */
        cerebroEnabled: boolean;
        /**
         * The cerebro private domain of instance.
         */
        cerebroPrivateDomain: string;
        /**
         * The cerebro public domain of instance.
         */
        cerebroPublicDomain: string;
        /**
         * The charge status of instance.
         */
        chargeEnabled: boolean;
        /**
         * The cluster id of instance.
         */
        clusterId: string;
        /**
         * The create time of instance.
         */
        createTime: string;
        /**
         * Whether enable deletion protection for ESCloud instance.
         */
        deletionProtection: boolean;
        /**
         * whether enable es private domain public.
         */
        enableEsPrivateDomainPublic: boolean;
        /**
         * whether enable es private network.
         */
        enableEsPrivateNetwork: boolean;
        /**
         * whether enable es public network.
         */
        enableEsPublicNetwork: boolean;
        /**
         * whether enable kibana private domain public.
         */
        enableKibanaPrivateDomainPublic: boolean;
        /**
         * whether enable kibana private network.
         */
        enableKibanaPrivateNetwork: boolean;
        /**
         * whether enable kibana public network.
         */
        enableKibanaPublicNetwork: boolean;
        /**
         * The eip address of instance.
         */
        esEip: string;
        /**
         * The eip id associated with the instance.
         */
        esEipId: string;
        /**
         * The es inner endpoint of instance.
         */
        esInnerEndpoint: string;
        /**
         * The es private domain of instance.
         */
        esPrivateDomain: string;
        /**
         * The es private endpoint of instance.
         */
        esPrivateEndpoint: string;
        /**
         * The whitelist of es private ip.
         */
        esPrivateIpWhitelist: string;
        /**
         * The es public domain of instance.
         */
        esPublicDomain: string;
        /**
         * The es public endpoint of instance.
         */
        esPublicEndpoint: string;
        /**
         * The whitelist of es public ip.
         */
        esPublicIpWhitelist: string;
        /**
         * The expire time of instance.
         */
        expireDate: string;
        /**
         * The id of instance.
         */
        id: string;
        /**
         * The configuration of instance.
         */
        instanceConfigurations: outputs.escloud_v2.GetEscloudInstancesV2InstanceInstanceConfiguration[];
        /**
         * The id of instance.
         */
        instanceId: string;
        /**
         * The eip address of kibana.
         */
        kibanaEip: string;
        /**
         * The eip id associated with kibana.
         */
        kibanaEipId: string;
        /**
         * The kibana private domain of instance.
         */
        kibanaPrivateDomain: string;
        /**
         * The whitelist of kibana private ip.
         */
        kibanaPrivateIpWhitelist: string;
        /**
         * The kibana public domain of instance.
         */
        kibanaPublicDomain: string;
        /**
         * The whitelist of kibana public ip.
         */
        kibanaPublicIpWhitelist: string;
        /**
         * The main zone id of instance.
         */
        mainZoneId: string;
        /**
         * The maintenance day of instance.
         */
        maintenanceDays: string[];
        /**
         * The maintenance time of instance.
         */
        maintenanceTime: string;
        /**
         * The nodes info of instance.
         */
        nodes: outputs.escloud_v2.GetEscloudInstancesV2InstanceNode[];
        /**
         * The plugin info of instance.
         */
        plugins: outputs.escloud_v2.GetEscloudInstancesV2InstancePlugin[];
        /**
         * The status of instance.
         */
        status: string;
        /**
         * Whether support code node.
         */
        supportCodeNode: boolean;
        /**
         * The tags of instance.
         */
        tags: outputs.escloud_v2.GetEscloudInstancesV2InstanceTag[];
        /**
         * The total nodes of instance.
         */
        totalNodes: number;
        /**
         * The user id of instance.
         */
        userId: string;
    }

    export interface GetEscloudInstancesV2InstanceInstanceConfiguration {
        /**
         * The user name of instance.
         */
        adminUserName: string;
        /**
         * The charge type of instance.
         */
        chargeType: string;
        /**
         * The node number of cold.
         */
        coldNodeNumber: number;
        /**
         * The node resource spec of cold.
         */
        coldNodeResourceSpecs: outputs.escloud_v2.GetEscloudInstancesV2InstanceInstanceConfigurationColdNodeResourceSpec[];
        /**
         * The node storage spec of cold.
         */
        coldNodeStorageSpecs: outputs.escloud_v2.GetEscloudInstancesV2InstanceInstanceConfigurationColdNodeStorageSpec[];
        /**
         * The node number of coordinator.
         */
        coordinatorNodeNumber: number;
        /**
         * The node resource spec of coordinator.
         */
        coordinatorNodeResourceSpecs: outputs.escloud_v2.GetEscloudInstancesV2InstanceInstanceConfigurationCoordinatorNodeResourceSpec[];
        /**
         * The node storage spec of coordinator.
         */
        coordinatorNodeStorageSpecs: outputs.escloud_v2.GetEscloudInstancesV2InstanceInstanceConfigurationCoordinatorNodeStorageSpec[];
        /**
         * whether enable https.
         */
        enableHttps: boolean;
        /**
         * Whether enable pure master.
         */
        enablePureMaster: boolean;
        /**
         * The node number of hot.
         */
        hotNodeNumber: number;
        /**
         * The node resource spec of hot.
         */
        hotNodeResourceSpecs: outputs.escloud_v2.GetEscloudInstancesV2InstanceInstanceConfigurationHotNodeResourceSpec[];
        /**
         * The node storage spec of hot.
         */
        hotNodeStorageSpecs: outputs.escloud_v2.GetEscloudInstancesV2InstanceInstanceConfigurationHotNodeStorageSpec[];
        /**
         * The name of instance.
         */
        instanceName: string;
        /**
         * The node number of kibana.
         */
        kibanaNodeNumber: number;
        /**
         * The node resource spec of kibana.
         */
        kibanaNodeResourceSpecs: outputs.escloud_v2.GetEscloudInstancesV2InstanceInstanceConfigurationKibanaNodeResourceSpec[];
        /**
         * The node storage spec of kibana.
         */
        kibanaNodeStorageSpecs: outputs.escloud_v2.GetEscloudInstancesV2InstanceInstanceConfigurationKibanaNodeStorageSpec[];
        /**
         * The node number of master.
         */
        masterNodeNumber: number;
        /**
         * The node resource spec of master.
         */
        masterNodeResourceSpecs: outputs.escloud_v2.GetEscloudInstancesV2InstanceInstanceConfigurationMasterNodeResourceSpec[];
        /**
         * The node storage spec of master.
         */
        masterNodeStorageSpecs: outputs.escloud_v2.GetEscloudInstancesV2InstanceInstanceConfigurationMasterNodeStorageSpec[];
        /**
         * The period of project.
         */
        period: number;
        /**
         * The project name of instance.
         */
        projectName: string;
        /**
         * The region info of instance.
         */
        regionId: string;
        /**
         * The subnet info.
         */
        subnets: outputs.escloud_v2.GetEscloudInstancesV2InstanceInstanceConfigurationSubnet[];
        /**
         * The version of plugin.
         */
        version: string;
        /**
         * The vpc info.
         */
        vpcs: outputs.escloud_v2.GetEscloudInstancesV2InstanceInstanceConfigurationVpc[];
        /**
         * The node number of warm.
         */
        warmNodeNumber: number;
        /**
         * The node resource spec of warm.
         */
        warmNodeResourceSpecs: outputs.escloud_v2.GetEscloudInstancesV2InstanceInstanceConfigurationWarmNodeResourceSpec[];
        /**
         * The node storage spec of warm.
         */
        warmNodeStorageSpecs: outputs.escloud_v2.GetEscloudInstancesV2InstanceInstanceConfigurationWarmNodeStorageSpec[];
        /**
         * The zoneId of instance.
         */
        zoneId: string;
        /**
         * The zone number of instance.
         */
        zoneNumber: number;
    }

    export interface GetEscloudInstancesV2InstanceInstanceConfigurationColdNodeResourceSpec {
        /**
         * The cpu info of resource spec.
         */
        cpu: number;
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The memory info of resource spec.
         */
        memory: number;
        /**
         * The name of storage spec.
         */
        name: string;
    }

    export interface GetEscloudInstancesV2InstanceInstanceConfigurationColdNodeStorageSpec {
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The max size of storage spec.
         */
        maxSize: number;
        /**
         * The min size of storage spec.
         */
        minSize: number;
        /**
         * The name of storage spec.
         */
        name: string;
        /**
         * The size of storage spec.
         */
        size: number;
    }

    export interface GetEscloudInstancesV2InstanceInstanceConfigurationCoordinatorNodeResourceSpec {
        /**
         * The cpu info of resource spec.
         */
        cpu: number;
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The memory info of resource spec.
         */
        memory: number;
        /**
         * The name of storage spec.
         */
        name: string;
    }

    export interface GetEscloudInstancesV2InstanceInstanceConfigurationCoordinatorNodeStorageSpec {
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The max size of storage spec.
         */
        maxSize: number;
        /**
         * The min size of storage spec.
         */
        minSize: number;
        /**
         * The name of storage spec.
         */
        name: string;
        /**
         * The size of storage spec.
         */
        size: number;
    }

    export interface GetEscloudInstancesV2InstanceInstanceConfigurationHotNodeResourceSpec {
        /**
         * The cpu info of resource spec.
         */
        cpu: number;
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The memory info of resource spec.
         */
        memory: number;
        /**
         * The name of storage spec.
         */
        name: string;
    }

    export interface GetEscloudInstancesV2InstanceInstanceConfigurationHotNodeStorageSpec {
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The max size of storage spec.
         */
        maxSize: number;
        /**
         * The min size of storage spec.
         */
        minSize: number;
        /**
         * The name of storage spec.
         */
        name: string;
        /**
         * The size of storage spec.
         */
        size: number;
    }

    export interface GetEscloudInstancesV2InstanceInstanceConfigurationKibanaNodeResourceSpec {
        /**
         * The cpu info of resource spec.
         */
        cpu: number;
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The memory info of resource spec.
         */
        memory: number;
        /**
         * The name of storage spec.
         */
        name: string;
    }

    export interface GetEscloudInstancesV2InstanceInstanceConfigurationKibanaNodeStorageSpec {
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The max size of storage spec.
         */
        maxSize: number;
        /**
         * The min size of storage spec.
         */
        minSize: number;
        /**
         * The name of storage spec.
         */
        name: string;
        /**
         * The size of storage spec.
         */
        size: number;
    }

    export interface GetEscloudInstancesV2InstanceInstanceConfigurationMasterNodeResourceSpec {
        /**
         * The cpu info of resource spec.
         */
        cpu: number;
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The memory info of resource spec.
         */
        memory: number;
        /**
         * The name of storage spec.
         */
        name: string;
    }

    export interface GetEscloudInstancesV2InstanceInstanceConfigurationMasterNodeStorageSpec {
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The max size of storage spec.
         */
        maxSize: number;
        /**
         * The min size of storage spec.
         */
        minSize: number;
        /**
         * The name of storage spec.
         */
        name: string;
        /**
         * The size of storage spec.
         */
        size: number;
    }

    export interface GetEscloudInstancesV2InstanceInstanceConfigurationSubnet {
        /**
         * The id of subnet.
         */
        subnetId: string;
        /**
         * The name of subnet.
         */
        subnetName: string;
    }

    export interface GetEscloudInstancesV2InstanceInstanceConfigurationVpc {
        /**
         * The id of vpc.
         */
        vpcId: string;
        /**
         * The name of vpc.
         */
        vpcName: string;
    }

    export interface GetEscloudInstancesV2InstanceInstanceConfigurationWarmNodeResourceSpec {
        /**
         * The cpu info of resource spec.
         */
        cpu: number;
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The memory info of resource spec.
         */
        memory: number;
        /**
         * The name of storage spec.
         */
        name: string;
    }

    export interface GetEscloudInstancesV2InstanceInstanceConfigurationWarmNodeStorageSpec {
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The max size of storage spec.
         */
        maxSize: number;
        /**
         * The min size of storage spec.
         */
        minSize: number;
        /**
         * The name of storage spec.
         */
        name: string;
        /**
         * The size of storage spec.
         */
        size: number;
    }

    export interface GetEscloudInstancesV2InstanceNode {
        /**
         * Is cold node.
         */
        isCold: boolean;
        /**
         * Is coordinator node.
         */
        isCoordinator: boolean;
        /**
         * Is hot node.
         */
        isHot: boolean;
        /**
         * Is kibana node.
         */
        isKibana: boolean;
        /**
         * Is master node.
         */
        isMaster: boolean;
        /**
         * Is warm node.
         */
        isWarm: boolean;
        /**
         * The show name of node.
         */
        nodeDisplayName: string;
        /**
         * The name of node.
         */
        nodeName: string;
        /**
         * The node resource spec of master.
         */
        resourceSpecs: outputs.escloud_v2.GetEscloudInstancesV2InstanceNodeResourceSpec[];
        /**
         * The restart times of node.
         */
        restartNumber: number;
        /**
         * The start time of node.
         */
        startTime: string;
        /**
         * The status of instance.
         */
        status: string;
        /**
         * The node storage spec of master.
         */
        storageSpecs: outputs.escloud_v2.GetEscloudInstancesV2InstanceNodeStorageSpec[];
    }

    export interface GetEscloudInstancesV2InstanceNodeResourceSpec {
        /**
         * The cpu info of resource spec.
         */
        cpu: number;
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The memory info of resource spec.
         */
        memory: number;
    }

    export interface GetEscloudInstancesV2InstanceNodeStorageSpec {
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The max size of storage spec.
         */
        maxSize: number;
        /**
         * The min size of storage spec.
         */
        minSize: number;
    }

    export interface GetEscloudInstancesV2InstancePlugin {
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The name of plugin.
         */
        pluginName: string;
        /**
         * The status of instance.
         */
        status: string;
        /**
         * The version of plugin.
         */
        version: string;
    }

    export interface GetEscloudInstancesV2InstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetEscloudInstancesV2Tag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        values: string[];
    }

    export interface GetEscloudNodeAvailableSpecsNodeSpec {
        /**
         * The available specs sold out.
         */
        azAvailableSpecsSoldOut: {[key: string]: string};
        /**
         * The configuration code.
         */
        configurationCode: string;
        /**
         * The network specs.
         */
        networkSpecs: outputs.escloud_v2.GetEscloudNodeAvailableSpecsNodeSpecNetworkSpec[];
        /**
         * The node available specs.
         */
        nodeAvailableSpecs: outputs.escloud_v2.GetEscloudNodeAvailableSpecsNodeSpecNodeAvailableSpec[];
        /**
         * The resource specs.
         */
        resourceSpecs: outputs.escloud_v2.GetEscloudNodeAvailableSpecsNodeSpecResourceSpec[];
        /**
         * The storage specs.
         */
        storageSpecs: outputs.escloud_v2.GetEscloudNodeAvailableSpecsNodeSpecStorageSpec[];
    }

    export interface GetEscloudNodeAvailableSpecsNodeSpecNetworkSpec {
        /**
         * The network role.
         */
        networkRole: string;
        /**
         * The spec name.
         */
        specName: string;
    }

    export interface GetEscloudNodeAvailableSpecsNodeSpecNodeAvailableSpec {
        /**
         * The resource spec names of node.
         */
        resourceSpecNames: string[];
        /**
         * The storage spec names of node.
         */
        storageSpecNames: string[];
        /**
         * The type of node.
         */
        type: string;
    }

    export interface GetEscloudNodeAvailableSpecsNodeSpecResourceSpec {
        /**
         * The cpu of resource spec. Unit: Core.
         */
        cpu: number;
        /**
         * The description of storage spec.
         */
        description: string;
        /**
         * The display name of storage spec.
         */
        displayName: string;
        /**
         * The memory of resource spec. Unit: GiB.
         */
        memory: number;
        /**
         * The name of storage spec.
         */
        name: string;
    }

    export interface GetEscloudNodeAvailableSpecsNodeSpecStorageSpec {
        /**
         * The description of storage spec.
         */
        description: string;
        /**
         * The display name of storage spec.
         */
        displayName: string;
        /**
         * The max size of storage spec. Unit: GiB.
         */
        maxSize: number;
        /**
         * The min size of storage spec. Unit: GiB.
         */
        minSize: number;
        /**
         * The name of storage spec.
         */
        name: string;
        /**
         * The size of storage spec.
         */
        size: number;
    }

    export interface GetEscloudZonesV2Zone {
        /**
         * The region ID of zone.
         */
        regionId: string;
        /**
         * The ID of zone.
         */
        zoneId: string;
        /**
         * The name of zone.
         */
        zoneName: string;
        /**
         * The status of zone.
         */
        zoneStatus: string;
    }

}

export namespace financial_relation {
    export interface FinancialRelationsFinancialRelation {
        /**
         * The display name of the sub account.
         */
        accountAlias: string;
        /**
         * The authorization info of the financial relation.
         */
        authInfos: outputs.financial_relation.FinancialRelationsFinancialRelationAuthInfo[];
        /**
         * The filiation of the financial relation.
         */
        filiation: number;
        /**
         * The filiation description of the financial relation.
         */
        filiationDesc: string;
        /**
         * The id of the major account.
         */
        majorAccountId: number;
        /**
         * The name of the major account.
         */
        majorAccountName: string;
        /**
         * A list of relation. Valid values: `1`, `4`.
         */
        relation: number;
        /**
         * The relation description of the financial.
         */
        relationDesc: string;
        /**
         * The id of the financial relation.
         */
        relationId: string;
        /**
         * A list of status. Valid values: `100`, `200`, `250`, `300`, `400`, `500`.
         */
        status: number;
        /**
         * The status description of the financial relation.
         */
        statusDesc: string;
        /**
         * The id of the sub account.
         */
        subAccountId: number;
        /**
         * The name of the sub account.
         */
        subAccountName: string;
        /**
         * The update time of the financial relation.
         */
        updateTime: string;
    }

    export interface FinancialRelationsFinancialRelationAuthInfo {
        /**
         * The auth id of the financial relation.
         */
        authId: string;
        /**
         * The auth list of the financial relation.
         */
        authLists: number[];
        /**
         * The auth status of the financial relation.
         */
        authStatus: number;
    }

    export interface GetFinancialRelationsFinancialRelation {
        /**
         * The display name of the sub account.
         */
        accountAlias: string;
        /**
         * The authorization info of the financial relation.
         */
        authInfos: outputs.financial_relation.GetFinancialRelationsFinancialRelationAuthInfo[];
        /**
         * The filiation of the financial relation.
         */
        filiation: number;
        /**
         * The filiation description of the financial relation.
         */
        filiationDesc: string;
        /**
         * The id of the major account.
         */
        majorAccountId: number;
        /**
         * The name of the major account.
         */
        majorAccountName: string;
        /**
         * A list of relation. Valid values: `1`, `4`.
         */
        relation: number;
        /**
         * The relation description of the financial.
         */
        relationDesc: string;
        /**
         * The id of the financial relation.
         */
        relationId: string;
        /**
         * A list of status. Valid values: `100`, `200`, `250`, `300`, `400`, `500`.
         */
        status: number;
        /**
         * The status description of the financial relation.
         */
        statusDesc: string;
        /**
         * The id of the sub account.
         */
        subAccountId: number;
        /**
         * The name of the sub account.
         */
        subAccountName: string;
        /**
         * The update time of the financial relation.
         */
        updateTime: string;
    }

    export interface GetFinancialRelationsFinancialRelationAuthInfo {
        /**
         * The auth id of the financial relation.
         */
        authId: string;
        /**
         * The auth list of the financial relation.
         */
        authLists: number[];
        /**
         * The auth status of the financial relation.
         */
        authStatus: number;
    }

}

export namespace iam {
    export interface AccessKeysAccessKeyMetadata {
        /**
         * The user access key id.
         */
        accessKeyId: string;
        /**
         * The user access key create date.
         */
        createDate: string;
        /**
         * The user access key status.
         */
        status: string;
        /**
         * The user access key update date.
         */
        updateDate: string;
        /**
         * The user names.
         */
        userName: string;
    }

    export interface GetAccessKeysAccessKeyMetadata {
        /**
         * The user access key id.
         */
        accessKeyId: string;
        /**
         * The user access key create date.
         */
        createDate: string;
        /**
         * The user access key status.
         */
        status: string;
        /**
         * The user access key update date.
         */
        updateDate: string;
        /**
         * The user names.
         */
        userName: string;
    }

    export interface GetOidcProvidersOidcProvider {
        /**
         * The client IDs of the OIDC provider.
         */
        clientIds: string[];
        /**
         * The create date of the OIDC provider.
         */
        createDate: string;
        /**
         * The description of the OIDC provider.
         */
        description: string;
        /**
         * The issuance limit time of the OIDC provider.
         */
        issuanceLimitTime: number;
        /**
         * The URL of the OIDC provider.
         */
        issuerUrl: string;
        /**
         * The name of the OIDC provider.
         */
        providerName: string;
        /**
         * The thumbprints of the OIDC provider.
         */
        thumbprints: string[];
        /**
         * The trn of OIDC provider.
         */
        trn: string;
        /**
         * The update date of the OIDC provider.
         */
        updateDate: string;
    }

    export interface GetPoliciesPolicy {
        /**
         * The create time of the Policy.
         */
        createDate: string;
        /**
         * The description of the Policy.
         */
        description: string;
        /**
         * The ID of the Policy.
         */
        id: string;
        /**
         * The document of the Policy.
         */
        policyDocument: string;
        /**
         * The name of the Policy.
         */
        policyName: string;
        /**
         * The resource name of the Policy.
         */
        policyTrn: string;
        /**
         * The type of the Policy.
         */
        policyType: string;
        /**
         * The role attach time of the Policy.The data show only query with role_name.
         */
        roleAttachDate: string;
        /**
         * The name of the IAM role.
         */
        roleName: string;
        /**
         * The update time of the Policy.
         */
        updateDate: string;
        /**
         * The user attach time of the Policy.The data show only query with user_name.
         */
        userAttachDate: string;
        /**
         * The name of the IAM user.
         */
        userName: string;
    }

    export interface GetRolesRole {
        /**
         * The create time of the Role.
         */
        createDate: string;
        /**
         * The description of the Role.
         */
        description: string;
        /**
         * The ID of the Role.
         */
        id: string;
        /**
         * The name of the Role, comma separated.
         */
        roleName: string;
        /**
         * The resource name of the Role.
         */
        trn: string;
        /**
         * The trust policy document of the Role.
         */
        trustPolicyDocument: string;
    }

    export interface GetSamlProvidersProvider {
        /**
         * Identity provider creation time, such as 20150123T123318Z.
         */
        createDate: string;
        /**
         * The description of the SAML provider.
         */
        description: string;
        /**
         * Metadata document, encoded in Base64.
         */
        encodedSamlMetadataDocument: string;
        /**
         * The name of the SAML provider.
         */
        samlProviderName: string;
        /**
         * SSO types, 1. Role-based SSO, 2. User-based SSO.
         */
        ssoType: number;
        /**
         * User SSO status, 1. Enabled, 2. Disable other console login methods after enabling, 3. Disabled, is a required field when creating user SSO.
         */
        status: number;
        /**
         * The format for the resource name of an identity provider is trn:iam::${accountID}:saml-provider/{$SAMLProviderName}.
         */
        trn: string;
        /**
         * Identity provider update time, such as: 20150123T123318Z.
         */
        updateDate: string;
    }

    export interface GetUserGroupPolicyAttachmentsPolicy {
        /**
         * Attached time.
         */
        attachDate: string;
        /**
         * The description.
         */
        description: string;
        /**
         * Name of the policy.
         */
        policyName: string;
        /**
         * Resource name of the strategy.
         */
        policyTrn: string;
        /**
         * The type of the policy.
         */
        policyType: string;
    }

    export interface GetUserGroupsUserGroup {
        /**
         * The id of the account.
         */
        accountId: number;
        /**
         * The creation date of the user group.
         */
        createDate: string;
        /**
         * The description of the user group.
         */
        description: string;
        /**
         * The display name of the user group.
         */
        displayName: string;
        /**
         * The update date of the user group.
         */
        updateDate: string;
        /**
         * The name of the user group.
         */
        userGroupName: string;
    }

    export interface GetUsersUser {
        /**
         * Main account ID to which the sub-user belongs.
         */
        accountId: string;
        /**
         * The create date of the user.
         */
        createDate: string;
        /**
         * The description of the user.
         */
        description: string;
        /**
         * The display name of the user.
         */
        displayName: string;
        /**
         * The email of the user.
         */
        email: string;
        /**
         * Whether the email has been verified.
         */
        emailIsVerify: boolean;
        /**
         * The mobile phone of the user.
         */
        mobilePhone: string;
        /**
         * Whether the phone number has been verified.
         */
        mobilePhoneIsVerify: boolean;
        /**
         * The trn of the user.
         */
        trn: string;
        /**
         * The update date of the user.
         */
        updateDate: string;
        /**
         * The id of the user.
         */
        userId: string;
        /**
         * The name of the user.
         */
        userName: string;
    }

    export interface OidcProvidersOidcProvider {
        /**
         * The client IDs of the OIDC provider.
         */
        clientIds: string[];
        /**
         * The create date of the OIDC provider.
         */
        createDate: string;
        /**
         * The description of the OIDC provider.
         */
        description: string;
        /**
         * The issuance limit time of the OIDC provider.
         */
        issuanceLimitTime: number;
        /**
         * The URL of the OIDC provider.
         */
        issuerUrl: string;
        /**
         * The name of the OIDC provider.
         */
        providerName: string;
        /**
         * The thumbprints of the OIDC provider.
         */
        thumbprints: string[];
        /**
         * The trn of OIDC provider.
         */
        trn: string;
        /**
         * The update date of the OIDC provider.
         */
        updateDate: string;
    }

    export interface PoliciesPolicy {
        /**
         * The create time of the Policy.
         */
        createDate: string;
        /**
         * The description of the Policy.
         */
        description: string;
        /**
         * The ID of the Policy.
         */
        id: string;
        /**
         * The document of the Policy.
         */
        policyDocument: string;
        /**
         * The name of the Policy.
         */
        policyName: string;
        /**
         * The resource name of the Policy.
         */
        policyTrn: string;
        /**
         * The type of the Policy.
         */
        policyType: string;
        /**
         * The role attach time of the Policy.The data show only query with role_name.
         */
        roleAttachDate: string;
        /**
         * The name of the IAM role.
         */
        roleName: string;
        /**
         * The update time of the Policy.
         */
        updateDate: string;
        /**
         * The user attach time of the Policy.The data show only query with user_name.
         */
        userAttachDate: string;
        /**
         * The name of the IAM user.
         */
        userName: string;
    }

    export interface RolesRole {
        /**
         * The create time of the Role.
         */
        createDate: string;
        /**
         * The description of the Role.
         */
        description: string;
        /**
         * The ID of the Role.
         */
        id: string;
        /**
         * The name of the Role, comma separated.
         */
        roleName: string;
        /**
         * The resource name of the Role.
         */
        trn: string;
        /**
         * The trust policy document of the Role.
         */
        trustPolicyDocument: string;
    }

    export interface SamlProvidersProvider {
        /**
         * Identity provider creation time, such as 20150123T123318Z.
         */
        createDate: string;
        /**
         * The description of the SAML provider.
         */
        description: string;
        /**
         * Metadata document, encoded in Base64.
         */
        encodedSamlMetadataDocument: string;
        /**
         * The name of the SAML provider.
         */
        samlProviderName: string;
        /**
         * SSO types, 1. Role-based SSO, 2. User-based SSO.
         */
        ssoType: number;
        /**
         * User SSO status, 1. Enabled, 2. Disable other console login methods after enabling, 3. Disabled, is a required field when creating user SSO.
         */
        status: number;
        /**
         * The format for the resource name of an identity provider is trn:iam::${accountID}:saml-provider/{$SAMLProviderName}.
         */
        trn: string;
        /**
         * Identity provider update time, such as: 20150123T123318Z.
         */
        updateDate: string;
    }

    export interface UserGroupPolicyAttachmentsPolicy {
        /**
         * Attached time.
         */
        attachDate: string;
        /**
         * The description.
         */
        description: string;
        /**
         * Name of the policy.
         */
        policyName: string;
        /**
         * Resource name of the strategy.
         */
        policyTrn: string;
        /**
         * The type of the policy.
         */
        policyType: string;
    }

    export interface UserGroupsUserGroup {
        /**
         * The id of the account.
         */
        accountId: number;
        /**
         * The creation date of the user group.
         */
        createDate: string;
        /**
         * The description of the user group.
         */
        description: string;
        /**
         * The display name of the user group.
         */
        displayName: string;
        /**
         * The update date of the user group.
         */
        updateDate: string;
        /**
         * The name of the user group.
         */
        userGroupName: string;
    }

    export interface UsersUser {
        /**
         * Main account ID to which the sub-user belongs.
         */
        accountId: string;
        /**
         * The create date of the user.
         */
        createDate: string;
        /**
         * The description of the user.
         */
        description: string;
        /**
         * The display name of the user.
         */
        displayName: string;
        /**
         * The email of the user.
         */
        email: string;
        /**
         * Whether the email has been verified.
         */
        emailIsVerify: boolean;
        /**
         * The mobile phone of the user.
         */
        mobilePhone: string;
        /**
         * Whether the phone number has been verified.
         */
        mobilePhoneIsVerify: boolean;
        /**
         * The trn of the user.
         */
        trn: string;
        /**
         * The update date of the user.
         */
        updateDate: string;
        /**
         * The id of the user.
         */
        userId: string;
        /**
         * The name of the user.
         */
        userName: string;
    }

}

export namespace kafka {
    export interface AllowListsAllowList {
        /**
         * The description of the allow list.
         */
        allowListDesc: string;
        /**
         * The id of the allow list.
         */
        allowListId: string;
        /**
         * The number of rules specified in the whitelist.
         */
        allowListIpNum: number;
        /**
         * The name of the allow list.
         */
        allowListName: string;
        /**
         * Whitelist rule list.
         */
        allowLists: string[];
        /**
         * The number of instances bound to the whitelist.
         */
        associatedInstanceNum: number;
        /**
         * The list of associated instances.
         */
        associatedInstances: outputs.kafka.AllowListsAllowListAssociatedInstance[];
    }

    export interface AllowListsAllowListAssociatedInstance {
        /**
         * The instance ID to query.
         */
        instanceId: string;
        /**
         * The name of the instance.
         */
        instanceName: string;
    }

    export interface ConsumedPartitionsConsumedPartition {
        /**
         * The total amount of message accumulation in this topic partition for the consumer group.
         */
        accumulation: number;
        /**
         * The consumed client info of partition.
         */
        consumedClient: string;
        /**
         * The consumed offset of partition.
         */
        consumedOffset: number;
        /**
         * The end offset of partition.
         */
        endOffset: number;
        /**
         * The index number of partition.
         */
        partitionId: number;
        /**
         * The start offset of partition.
         */
        startOffset: number;
    }

    export interface ConsumedTopicsConsumedTopic {
        /**
         * The total amount of message accumulation in this topic for the consumer group.
         */
        accumulation: number;
        /**
         * The name of kafka topic. This field supports fuzzy query.
         */
        topicName: string;
    }

    export interface GetAllowListsAllowList {
        /**
         * The description of the allow list.
         */
        allowListDesc: string;
        /**
         * The id of the allow list.
         */
        allowListId: string;
        /**
         * The number of rules specified in the whitelist.
         */
        allowListIpNum: number;
        /**
         * The name of the allow list.
         */
        allowListName: string;
        /**
         * Whitelist rule list.
         */
        allowLists: string[];
        /**
         * The number of instances bound to the whitelist.
         */
        associatedInstanceNum: number;
        /**
         * The list of associated instances.
         */
        associatedInstances: outputs.kafka.GetAllowListsAllowListAssociatedInstance[];
    }

    export interface GetAllowListsAllowListAssociatedInstance {
        /**
         * The instance ID to query.
         */
        instanceId: string;
        /**
         * The name of the instance.
         */
        instanceName: string;
    }

    export interface GetConsumedPartitionsConsumedPartition {
        /**
         * The total amount of message accumulation in this topic partition for the consumer group.
         */
        accumulation: number;
        /**
         * The consumed client info of partition.
         */
        consumedClient: string;
        /**
         * The consumed offset of partition.
         */
        consumedOffset: number;
        /**
         * The end offset of partition.
         */
        endOffset: number;
        /**
         * The index number of partition.
         */
        partitionId: number;
        /**
         * The start offset of partition.
         */
        startOffset: number;
    }

    export interface GetConsumedTopicsConsumedTopic {
        /**
         * The total amount of message accumulation in this topic for the consumer group.
         */
        accumulation: number;
        /**
         * The name of kafka topic. This field supports fuzzy query.
         */
        topicName: string;
    }

    export interface GetGroupsGroup {
        /**
         * The id of kafka group, support fuzzy matching.
         */
        groupId: string;
        /**
         * The state of kafka group.
         */
        state: string;
    }

    export interface GetInstancesInstance {
        /**
         * The id of account.
         */
        accountId: string;
        /**
         * The auto renew status of instance.
         */
        autoRenew: boolean;
        /**
         * The charge expire time of instance.
         */
        chargeExpireTime: string;
        /**
         * The charge start time of instance.
         */
        chargeStartTime: string;
        /**
         * The charge status of instance.
         */
        chargeStatus: string;
        /**
         * The charge type of instance.
         */
        chargeType: string;
        /**
         * The compute spec of instance.
         */
        computeSpec: string;
        /**
         * Connection info of the instance.
         */
        connectionInfos: outputs.kafka.GetInstancesInstanceConnectionInfo[];
        /**
         * The create time of instance.
         */
        createTime: string;
        /**
         * The id of eip.
         */
        eipId: string;
        /**
         * The id of instance.
         */
        id: string;
        /**
         * The description of instance.
         */
        instanceDescription: string;
        /**
         * The id of instance.
         */
        instanceId: string;
        /**
         * The name of instance.
         */
        instanceName: string;
        /**
         * The status of instance.
         */
        instanceStatus: string;
        /**
         * The overdue reclaim time of instance.
         */
        overdueReclaimTime: string;
        /**
         * The overdue time of instance.
         */
        overdueTime: string;
        /**
         * Parameters of the instance.
         */
        parameters: outputs.kafka.GetInstancesInstanceParameter[];
        /**
         * The period unit of instance.
         */
        periodUnit: string;
        /**
         * Whether enable private domain on public.
         */
        privateDomainOnPublic: boolean;
        /**
         * The name of project.
         */
        projectName: string;
        /**
         * The id of region.
         */
        regionId: string;
        /**
         * The storage space of instance.
         */
        storageSpace: number;
        /**
         * The storage type of instance.
         */
        storageType: string;
        /**
         * The id of subnet.
         */
        subnetId: string;
        /**
         * The tags of instance.
         */
        tags: outputs.kafka.GetInstancesInstanceTag[];
        /**
         * The usable partition number of instance.
         */
        usablePartitionNumber: number;
        /**
         * The used group number of instance.
         */
        usedGroupNumber: number;
        /**
         * The used partition number of instance.
         */
        usedPartitionNumber: number;
        /**
         * The used storage space of instance.
         */
        usedStorageSpace: number;
        /**
         * The used topic number of instance.
         */
        usedTopicNumber: number;
        /**
         * The version of instance.
         */
        version: string;
        /**
         * The id of vpc.
         */
        vpcId: string;
        /**
         * The zone id of instance.
         */
        zoneId: string;
    }

    export interface GetInstancesInstanceConnectionInfo {
        /**
         * The endpoint type of instance.
         */
        endpointType: string;
        /**
         * The internal endpoint of instance.
         */
        internalEndpoint: string;
        /**
         * The network type of instance.
         */
        networkType: string;
        /**
         * The public endpoint of instance.
         */
        publicEndpoint: string;
    }

    export interface GetInstancesInstanceParameter {
        /**
         * Parameter name.
         */
        parameterName: string;
        /**
         * Parameter value.
         */
        parameterValue: string;
    }

    export interface GetInstancesInstanceTag {
        /**
         * The key of tag.
         */
        key: string;
        /**
         * The value of tag.
         */
        value: string;
    }

    export interface GetInstancesTag {
        /**
         * The key of tag.
         */
        key: string;
        /**
         * The value of tag.
         */
        value: string;
    }

    export interface GetRegionsRegion {
        /**
         * The description of region.
         */
        description: string;
        /**
         * The id of the region.
         */
        regionId: string;
        /**
         * The name of region.
         */
        regionName: string;
        /**
         * The status of region.
         */
        status: string;
    }

    export interface GetSaslUsersUser {
        /**
         * Whether this user has read and write permissions for all topics.
         */
        allAuthority: boolean;
        /**
         * The create time.
         */
        createTime: string;
        /**
         * The description of user.
         */
        description: string;
        /**
         * The type of password.
         */
        passwordType: string;
        /**
         * The user name, support fuzzy matching.
         */
        userName: string;
    }

    export interface GetTopicPartitionsPartition {
        /**
         * The end offset of partition leader.
         */
        endOffset: number;
        /**
         * The insync replica info.
         */
        insyncReplicas: number[];
        /**
         * The leader info of partition.
         */
        leader: number;
        /**
         * The count of message.
         */
        messageCount: number;
        /**
         * The index number of partition.
         */
        partitionId: number;
        /**
         * The replica info.
         */
        replicas: number[];
        /**
         * The start offset of partition leader.
         */
        startOffset: number;
        /**
         * The under insync replica info.
         */
        underInsyncReplicas: number[];
    }

    export interface GetTopicsTopic {
        /**
         * The access policies info of the kafka topic.
         */
        accessPolicies: outputs.kafka.GetTopicsTopicAccessPolicy[];
        /**
         * Whether the kafka topic is configured to be accessible by all users.
         */
        allAuthority: boolean;
        /**
         * The create time of the kafka topic.
         */
        createTime: string;
        /**
         * The description of the kafka topic.
         */
        description: string;
        /**
         * The parameters of the kafka topic.
         */
        parameters: outputs.kafka.GetTopicsTopicParameters;
        /**
         * The number of partition in kafka topic.
         */
        partitionNumber: number;
        /**
         * The number of replica in kafka topic.
         */
        replicaNumber: number;
        /**
         * The status of the kafka topic.
         */
        status: string;
        /**
         * The name of kafka topic. This field supports fuzzy query.
         */
        topicName: string;
    }

    export interface GetTopicsTopicAccessPolicy {
        /**
         * The access policy of SASL user.
         */
        accessPolicy: string;
        /**
         * When a user name is specified, only the access policy of the specified user for this Topic will be returned.
         */
        userName: string;
    }

    export interface GetTopicsTopicParameters {
        /**
         * The retention hours of log.
         */
        logRetentionHours: number;
        /**
         * The max byte of message.
         */
        messageMaxByte: number;
        /**
         * The min number of sync replica.
         */
        minInsyncReplicaNumber: number;
    }

    export interface GetZonesZone {
        /**
         * The description of the zone.
         */
        description: string;
        /**
         * The id of the zone.
         */
        id: string;
        /**
         * The status of the zone.
         */
        status: string;
        /**
         * The id of the zone.
         */
        zoneId: string;
        /**
         * The name of the zone.
         */
        zoneName: string;
    }

    export interface GroupsGroup {
        /**
         * The id of kafka group, support fuzzy matching.
         */
        groupId: string;
        /**
         * The state of kafka group.
         */
        state: string;
    }

    export interface InstanceParameter {
        /**
         * Parameter name.
         */
        parameterName: string;
        /**
         * Parameter value.
         */
        parameterValue: string;
    }

    export interface InstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface InstancesInstance {
        /**
         * The id of account.
         */
        accountId: string;
        /**
         * The auto renew status of instance.
         */
        autoRenew: boolean;
        /**
         * The charge expire time of instance.
         */
        chargeExpireTime: string;
        /**
         * The charge start time of instance.
         */
        chargeStartTime: string;
        /**
         * The charge status of instance.
         */
        chargeStatus: string;
        /**
         * The charge type of instance.
         */
        chargeType: string;
        /**
         * The compute spec of instance.
         */
        computeSpec: string;
        /**
         * Connection info of the instance.
         */
        connectionInfos: outputs.kafka.InstancesInstanceConnectionInfo[];
        /**
         * The create time of instance.
         */
        createTime: string;
        /**
         * The id of eip.
         */
        eipId: string;
        /**
         * The id of instance.
         */
        id: string;
        /**
         * The description of instance.
         */
        instanceDescription: string;
        /**
         * The id of instance.
         */
        instanceId: string;
        /**
         * The name of instance.
         */
        instanceName: string;
        /**
         * The status of instance.
         */
        instanceStatus: string;
        /**
         * The overdue reclaim time of instance.
         */
        overdueReclaimTime: string;
        /**
         * The overdue time of instance.
         */
        overdueTime: string;
        /**
         * Parameters of the instance.
         */
        parameters: outputs.kafka.InstancesInstanceParameter[];
        /**
         * The period unit of instance.
         */
        periodUnit: string;
        /**
         * Whether enable private domain on public.
         */
        privateDomainOnPublic: boolean;
        /**
         * The name of project.
         */
        projectName: string;
        /**
         * The id of region.
         */
        regionId: string;
        /**
         * The storage space of instance.
         */
        storageSpace: number;
        /**
         * The storage type of instance.
         */
        storageType: string;
        /**
         * The id of subnet.
         */
        subnetId: string;
        /**
         * The tags of instance.
         */
        tags: outputs.kafka.InstancesInstanceTag[];
        /**
         * The usable partition number of instance.
         */
        usablePartitionNumber: number;
        /**
         * The used group number of instance.
         */
        usedGroupNumber: number;
        /**
         * The used partition number of instance.
         */
        usedPartitionNumber: number;
        /**
         * The used storage space of instance.
         */
        usedStorageSpace: number;
        /**
         * The used topic number of instance.
         */
        usedTopicNumber: number;
        /**
         * The version of instance.
         */
        version: string;
        /**
         * The id of vpc.
         */
        vpcId: string;
        /**
         * The zone id of instance.
         */
        zoneId: string;
    }

    export interface InstancesInstanceConnectionInfo {
        /**
         * The endpoint type of instance.
         */
        endpointType: string;
        /**
         * The internal endpoint of instance.
         */
        internalEndpoint: string;
        /**
         * The network type of instance.
         */
        networkType: string;
        /**
         * The public endpoint of instance.
         */
        publicEndpoint: string;
    }

    export interface InstancesInstanceParameter {
        /**
         * Parameter name.
         */
        parameterName: string;
        /**
         * Parameter value.
         */
        parameterValue: string;
    }

    export interface InstancesInstanceTag {
        /**
         * The key of tag.
         */
        key: string;
        /**
         * The value of tag.
         */
        value: string;
    }

    export interface InstancesTag {
        /**
         * The key of tag.
         */
        key: string;
        /**
         * The value of tag.
         */
        value: string;
    }

    export interface RegionsRegion {
        /**
         * The description of region.
         */
        description: string;
        /**
         * The id of the region.
         */
        regionId: string;
        /**
         * The name of region.
         */
        regionName: string;
        /**
         * The status of region.
         */
        status: string;
    }

    export interface SaslUsersUser {
        /**
         * Whether this user has read and write permissions for all topics.
         */
        allAuthority: boolean;
        /**
         * The create time.
         */
        createTime: string;
        /**
         * The description of user.
         */
        description: string;
        /**
         * The type of password.
         */
        passwordType: string;
        /**
         * The user name, support fuzzy matching.
         */
        userName: string;
    }

    export interface TopicAccessPolicy {
        /**
         * The access policy of SASL user. Valid values: `PubSub`, `Pub`, `Sub`.
         */
        accessPolicy: string;
        /**
         * The name of SASL user.
         */
        userName: string;
    }

    export interface TopicParameters {
        /**
         * The retention hours of log. Unit: hour. Valid values: 0-2160. Default is 72.
         */
        logRetentionHours?: number;
        /**
         * The max byte of message. Unit: MB. Valid values: 1-12. Default is 10.
         */
        messageMaxByte?: number;
        /**
         * The min number of sync replica. The default value is the replica number minus 1.
         */
        minInsyncReplicaNumber: number;
    }

    export interface TopicPartitionsPartition {
        /**
         * The end offset of partition leader.
         */
        endOffset: number;
        /**
         * The insync replica info.
         */
        insyncReplicas: number[];
        /**
         * The leader info of partition.
         */
        leader: number;
        /**
         * The count of message.
         */
        messageCount: number;
        /**
         * The index number of partition.
         */
        partitionId: number;
        /**
         * The replica info.
         */
        replicas: number[];
        /**
         * The start offset of partition leader.
         */
        startOffset: number;
        /**
         * The under insync replica info.
         */
        underInsyncReplicas: number[];
    }

    export interface TopicsTopic {
        /**
         * The access policies info of the kafka topic.
         */
        accessPolicies: outputs.kafka.TopicsTopicAccessPolicy[];
        /**
         * Whether the kafka topic is configured to be accessible by all users.
         */
        allAuthority: boolean;
        /**
         * The create time of the kafka topic.
         */
        createTime: string;
        /**
         * The description of the kafka topic.
         */
        description: string;
        /**
         * The parameters of the kafka topic.
         */
        parameters: outputs.kafka.TopicsTopicParameters;
        /**
         * The number of partition in kafka topic.
         */
        partitionNumber: number;
        /**
         * The number of replica in kafka topic.
         */
        replicaNumber: number;
        /**
         * The status of the kafka topic.
         */
        status: string;
        /**
         * The name of kafka topic. This field supports fuzzy query.
         */
        topicName: string;
    }

    export interface TopicsTopicAccessPolicy {
        /**
         * The access policy of SASL user.
         */
        accessPolicy: string;
        /**
         * When a user name is specified, only the access policy of the specified user for this Topic will be returned.
         */
        userName: string;
    }

    export interface TopicsTopicParameters {
        /**
         * The retention hours of log.
         */
        logRetentionHours: number;
        /**
         * The max byte of message.
         */
        messageMaxByte: number;
        /**
         * The min number of sync replica.
         */
        minInsyncReplicaNumber: number;
    }

    export interface ZonesZone {
        /**
         * The description of the zone.
         */
        description: string;
        /**
         * The id of the zone.
         */
        id: string;
        /**
         * The status of the zone.
         */
        status: string;
        /**
         * The id of the zone.
         */
        zoneId: string;
        /**
         * The name of the zone.
         */
        zoneName: string;
    }

}

export namespace kms {
    export interface GetKeyringsKeyring {
        /**
         * The date when the keyring was created.
         */
        creationDate: number;
        /**
         * The description of the keyring.
         */
        description: string;
        /**
         * The unique ID of the keyring. The value is in the UUID format.
         */
        id: string;
        /**
         * Key ring key count.
         */
        keyCount: number;
        /**
         * The name of the keyring.
         */
        keyringName: string;
        /**
         * The type of the keyring.
         */
        keyringType: string;
        /**
         * The information about the tenant resource name (TRN).
         */
        trn: string;
        /**
         * The tenant ID of the keyring.
         */
        uid: string;
        /**
         * The date when the keyring was updated.
         */
        updateDate: number;
    }

    export interface GetKeysKey {
        /**
         * The date when the keyring was created.
         */
        creationDate: number;
        /**
         * The description of the key.
         */
        description: string;
        /**
         * The unique ID of the key.
         */
        id: string;
        /**
         * The time when the key material will expire.
         */
        keyMaterialExpireTime: string;
        /**
         * The name of the key.
         */
        keyName: string;
        /**
         * The algorithm used in the key.
         */
        keySpec: string;
        /**
         * The state of the key.
         */
        keyState: string;
        /**
         * The usage of the key.
         */
        keyUsage: string;
        /**
         * The last time the key was rotated.
         */
        lastRotationTime: string;
        /**
         * Whether it is the master key of the Multi-region type.
         */
        multiRegion: boolean;
        /**
         * The configuration of Multi-region key.
         */
        multiRegionConfiguration: outputs.kms.GetKeysKeyMultiRegionConfiguration;
        /**
         * The origin of the key.
         */
        origin: string;
        /**
         * The protection level of the key.
         */
        protectionLevel: string;
        /**
         * The rotation configuration of the key.
         */
        rotationState: string;
        /**
         * The time when the key will be deleted.
         */
        scheduleDeleteTime: string;
        /**
         * The next time the key will be rotated.
         */
        scheduleRotationTime: string;
        /**
         * A list of tags.
         */
        tags: outputs.kms.GetKeysKeyTag[];
        /**
         * The name of the resource.
         */
        trn: string;
        /**
         * The date when the keyring was updated.
         */
        updateDate: number;
    }

    export interface GetKeysKeyMultiRegionConfiguration {
        /**
         * The type of the multi-region key.
         */
        multiRegionKeyType: string;
        /**
         * Trn and region id of the primary multi-region key.
         */
        primaryKey: outputs.kms.GetKeysKeyMultiRegionConfigurationPrimaryKey;
        /**
         * Trn and region id of replica multi-region keys.
         */
        replicaKeys: outputs.kms.GetKeysKeyMultiRegionConfigurationReplicaKey[];
    }

    export interface GetKeysKeyMultiRegionConfigurationPrimaryKey {
        /**
         * The region id of multi-region key.
         */
        region: string;
        /**
         * The name of the resource.
         */
        trn: string;
    }

    export interface GetKeysKeyMultiRegionConfigurationReplicaKey {
        /**
         * The region id of multi-region key.
         */
        region: string;
        /**
         * The name of the resource.
         */
        trn: string;
    }

    export interface GetKeysKeyTag {
        /**
         * The key of the tag.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetKeysTag {
        /**
         * The key of the tag.
         */
        key: string;
        /**
         * The values of the tag.
         */
        values: string[];
    }

    export interface GetSecretsSecret {
        /**
         * The date when the keyring was created.
         */
        creationDate: number;
        /**
         * The description of the secret.
         */
        description: string;
        /**
         * The TRN of the KMS key used to encrypt the secret value.
         */
        encryptionKey: string;
        /**
         * The extended configurations of the secret.
         */
        extendedConfig: string;
        /**
         * The unique ID of the secret. The value is in the UUID format.
         */
        id: string;
        /**
         * The last time the secret was rotated.
         */
        lastRotationTime: string;
        /**
         * Indicates whether the secret is hosted.
         */
        managed: boolean;
        /**
         * The name of the project to which the secret belongs.
         */
        projectName: string;
        /**
         * The interval at which automatic rotation is performed.
         */
        rotationInterval: number;
        /**
         * The state of the rotation.
         */
        rotationState: string;
        /**
         * The time when the secret will be deleted.
         */
        scheduleDeleteTime: string;
        /**
         * The next time the secret will be rotated.
         */
        scheduleRotationTime: string;
        /**
         * The name of the secret.
         */
        secretName: string;
        /**
         * The state of the secret.
         */
        secretState: string;
        /**
         * The type of the secret.
         */
        secretType: string;
        /**
         * The trn of the secret.
         */
        trn: string;
        /**
         * The tenant ID of the secret.
         */
        uid: string;
        /**
         * The date when the keyring was updated.
         */
        updateDate: number;
    }

    export interface KeyMultiRegionConfiguration {
        /**
         * The type of the multi-region key.
         */
        multiRegionKeyType: string;
        /**
         * Trn and region id of the primary multi-region key.
         */
        primaryKey: outputs.kms.KeyMultiRegionConfigurationPrimaryKey;
        /**
         * Trn and region id of replica multi-region keys.
         */
        replicaKeys: outputs.kms.KeyMultiRegionConfigurationReplicaKey[];
    }

    export interface KeyMultiRegionConfigurationPrimaryKey {
        /**
         * The region id of multi-region key.
         */
        region: string;
        /**
         * The name of the resource.
         */
        trn: string;
    }

    export interface KeyMultiRegionConfigurationReplicaKey {
        /**
         * The region id of multi-region key.
         */
        region: string;
        /**
         * The name of the resource.
         */
        trn: string;
    }

    export interface KeyTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface KeyringsKeyring {
        /**
         * The date when the keyring was created.
         */
        creationDate: number;
        /**
         * The description of the keyring.
         */
        description: string;
        /**
         * The unique ID of the keyring. The value is in the UUID format.
         */
        id: string;
        /**
         * Key ring key count.
         */
        keyCount: number;
        /**
         * The name of the keyring.
         */
        keyringName: string;
        /**
         * The type of the keyring.
         */
        keyringType: string;
        /**
         * The information about the tenant resource name (TRN).
         */
        trn: string;
        /**
         * The tenant ID of the keyring.
         */
        uid: string;
        /**
         * The date when the keyring was updated.
         */
        updateDate: number;
    }

    export interface KeysKey {
        /**
         * The date when the keyring was created.
         */
        creationDate: number;
        /**
         * The description of the key.
         */
        description: string;
        /**
         * The unique ID of the key.
         */
        id: string;
        /**
         * The time when the key material will expire.
         */
        keyMaterialExpireTime: string;
        /**
         * The name of the key.
         */
        keyName: string;
        /**
         * The algorithm used in the key.
         */
        keySpec: string;
        /**
         * The state of the key.
         */
        keyState: string;
        /**
         * The usage of the key.
         */
        keyUsage: string;
        /**
         * The last time the key was rotated.
         */
        lastRotationTime: string;
        /**
         * Whether it is the master key of the Multi-region type.
         */
        multiRegion: boolean;
        /**
         * The configuration of Multi-region key.
         */
        multiRegionConfiguration: outputs.kms.KeysKeyMultiRegionConfiguration;
        /**
         * The origin of the key.
         */
        origin: string;
        /**
         * The protection level of the key.
         */
        protectionLevel: string;
        /**
         * The rotation configuration of the key.
         */
        rotationState: string;
        /**
         * The time when the key will be deleted.
         */
        scheduleDeleteTime: string;
        /**
         * The next time the key will be rotated.
         */
        scheduleRotationTime: string;
        /**
         * A list of tags.
         */
        tags: outputs.kms.KeysKeyTag[];
        /**
         * The name of the resource.
         */
        trn: string;
        /**
         * The date when the keyring was updated.
         */
        updateDate: number;
    }

    export interface KeysKeyMultiRegionConfiguration {
        /**
         * The type of the multi-region key.
         */
        multiRegionKeyType: string;
        /**
         * Trn and region id of the primary multi-region key.
         */
        primaryKey: outputs.kms.KeysKeyMultiRegionConfigurationPrimaryKey;
        /**
         * Trn and region id of replica multi-region keys.
         */
        replicaKeys: outputs.kms.KeysKeyMultiRegionConfigurationReplicaKey[];
    }

    export interface KeysKeyMultiRegionConfigurationPrimaryKey {
        /**
         * The region id of multi-region key.
         */
        region: string;
        /**
         * The name of the resource.
         */
        trn: string;
    }

    export interface KeysKeyMultiRegionConfigurationReplicaKey {
        /**
         * The region id of multi-region key.
         */
        region: string;
        /**
         * The name of the resource.
         */
        trn: string;
    }

    export interface KeysKeyTag {
        /**
         * The key of the tag.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface KeysTag {
        /**
         * The key of the tag.
         */
        key: string;
        /**
         * The values of the tag.
         */
        values: string[];
    }

    export interface SecretsSecret {
        /**
         * The date when the keyring was created.
         */
        creationDate: number;
        /**
         * The description of the secret.
         */
        description: string;
        /**
         * The TRN of the KMS key used to encrypt the secret value.
         */
        encryptionKey: string;
        /**
         * The extended configurations of the secret.
         */
        extendedConfig: string;
        /**
         * The unique ID of the secret. The value is in the UUID format.
         */
        id: string;
        /**
         * The last time the secret was rotated.
         */
        lastRotationTime: string;
        /**
         * Indicates whether the secret is hosted.
         */
        managed: boolean;
        /**
         * The name of the project to which the secret belongs.
         */
        projectName: string;
        /**
         * The interval at which automatic rotation is performed.
         */
        rotationInterval: number;
        /**
         * The state of the rotation.
         */
        rotationState: string;
        /**
         * The time when the secret will be deleted.
         */
        scheduleDeleteTime: string;
        /**
         * The next time the secret will be rotated.
         */
        scheduleRotationTime: string;
        /**
         * The name of the secret.
         */
        secretName: string;
        /**
         * The state of the secret.
         */
        secretState: string;
        /**
         * The type of the secret.
         */
        secretType: string;
        /**
         * The trn of the secret.
         */
        trn: string;
        /**
         * The tenant ID of the secret.
         */
        uid: string;
        /**
         * The date when the keyring was updated.
         */
        updateDate: number;
    }

}

export namespace mongodb {
    export interface AccountAccountPrivilege {
        /**
         * The name of database.
         */
        dbName: string;
        /**
         * The role names of the account.
         */
        roleNames: string[];
    }

    export interface AccountsAccount {
        /**
         * The description of account.
         */
        accountDesc: string;
        /**
         * The name of account. This field support fuzzy query.
         */
        accountName: string;
        /**
         * The privilege info of mongo instance.
         */
        accountPrivileges: outputs.mongodb.AccountsAccountAccountPrivilege[];
        /**
         * The type of account.
         */
        accountType: string;
        /**
         * The database of account. This field support fuzzy query.
         */
        authDb: string;
        /**
         * The create time of account.
         */
        createTime: string;
        /**
         * The modify time of account.
         */
        modifyTime: string;
    }

    export interface AccountsAccountAccountPrivilege {
        /**
         * The Name of DB.
         */
        dbName: string;
        /**
         * The Name of role.
         */
        roleName: string;
    }

    export interface EndpointsEndpoint {
        /**
         * The list of mongodb addresses.
         */
        dbAddresses: outputs.mongodb.EndpointsEndpointDbAddress[];
        /**
         * The ID of endpoint.
         */
        endpointId: string;
        /**
         * The endpoint information.
         */
        endpointStr: string;
        /**
         * The node type corresponding to the endpoint.
         */
        endpointType: string;
        /**
         * The network type of endpoint.
         */
        networkType: string;
        /**
         * The object ID corresponding to the endpoint.
         */
        objectId: string;
        /**
         * The subnet ID.
         */
        subnetId: string;
        /**
         * The VPC ID.
         */
        vpcId: string;
    }

    export interface EndpointsEndpointDbAddress {
        /**
         * The domain of mongodb connection.
         */
        addressDomain: string;
        /**
         * The IP of mongodb connection.
         */
        addressIp: string;
        /**
         * The port of mongodb connection.
         */
        addressPort: string;
        /**
         * The connection type of mongodb.
         */
        addressType: string;
        /**
         * The EIP ID bound to the instance's public network address.
         */
        eipId: string;
        /**
         * The node ID.
         */
        nodeId: string;
    }

    export interface GetAccountsAccount {
        /**
         * The description of account.
         */
        accountDesc: string;
        /**
         * The name of account. This field support fuzzy query.
         */
        accountName: string;
        /**
         * The privilege info of mongo instance.
         */
        accountPrivileges: outputs.mongodb.GetAccountsAccountAccountPrivilege[];
        /**
         * The type of account.
         */
        accountType: string;
        /**
         * The database of account. This field support fuzzy query.
         */
        authDb: string;
        /**
         * The create time of account.
         */
        createTime: string;
        /**
         * The modify time of account.
         */
        modifyTime: string;
    }

    export interface GetAccountsAccountAccountPrivilege {
        /**
         * The Name of DB.
         */
        dbName: string;
        /**
         * The Name of role.
         */
        roleName: string;
    }

    export interface GetEndpointsEndpoint {
        /**
         * The list of mongodb addresses.
         */
        dbAddresses: outputs.mongodb.GetEndpointsEndpointDbAddress[];
        /**
         * The ID of endpoint.
         */
        endpointId: string;
        /**
         * The endpoint information.
         */
        endpointStr: string;
        /**
         * The node type corresponding to the endpoint.
         */
        endpointType: string;
        /**
         * The network type of endpoint.
         */
        networkType: string;
        /**
         * The object ID corresponding to the endpoint.
         */
        objectId: string;
        /**
         * The subnet ID.
         */
        subnetId: string;
        /**
         * The VPC ID.
         */
        vpcId: string;
    }

    export interface GetEndpointsEndpointDbAddress {
        /**
         * The domain of mongodb connection.
         */
        addressDomain: string;
        /**
         * The IP of mongodb connection.
         */
        addressIp: string;
        /**
         * The port of mongodb connection.
         */
        addressPort: string;
        /**
         * The connection type of mongodb.
         */
        addressType: string;
        /**
         * The EIP ID bound to the instance's public network address.
         */
        eipId: string;
        /**
         * The node ID.
         */
        nodeId: string;
    }

    export interface GetInstanceParameterLogsParameterChangeLog {
        /**
         * The modifying time of parameter.
         */
        modifyTime: string;
        /**
         * The new parameter value.
         */
        newParameterValue: string;
        /**
         * The old parameter value.
         */
        oldParameterValue: string;
        /**
         * The parameter name.
         */
        parameterName: string;
        /**
         * The node type to which the parameter belongs.
         */
        parameterRole: string;
        /**
         * The status of parameter change.
         */
        parameterStatus: string;
    }

    export interface GetInstanceParametersInstanceParameter {
        /**
         * The checking code of parameter.
         */
        checkingCode: string;
        /**
         * Whether the parameter supports modifying.
         */
        forceModify: boolean;
        /**
         * Does the new parameter value need to restart the instance to take effect after modification.
         */
        forceRestart: boolean;
        /**
         * The default value of parameter.
         */
        parameterDefaultValue: string;
        /**
         * The description of parameter.
         */
        parameterDescription: string;
        /**
         * The name of parameter.
         */
        parameterName: string;
        /**
         * The node type of instance parameter, valid value contains `Node`, `Shard`, `ConfigServer`, `Mongos`.
         */
        parameterRole: string;
        /**
         * The type of parameter value.
         */
        parameterType: string;
        /**
         * The value of parameter.
         */
        parameterValue: string;
    }

    export interface GetInstanceParametersParameter {
        /**
         * The database engine.
         */
        dbEngine: string;
        /**
         * The database engine version.
         */
        dbEngineVersion: string;
        /**
         * The instance ID to query.
         */
        instanceId: string;
        /**
         * The list of parameters.
         */
        instanceParameters: outputs.mongodb.GetInstanceParametersParameterInstanceParameter[];
        /**
         * The total parameters queried.
         */
        total: string;
    }

    export interface GetInstanceParametersParameterInstanceParameter {
        /**
         * The checking code of parameter.
         */
        checkingCode: string;
        /**
         * Whether the parameter supports modifying.
         */
        forceModify: boolean;
        /**
         * Does the new parameter value need to restart the instance to take effect after modification.
         */
        forceRestart: boolean;
        /**
         * The default value of parameter.
         */
        parameterDefaultValue: string;
        /**
         * The description of parameter.
         */
        parameterDescription: string;
        /**
         * The name of parameter.
         */
        parameterName: string;
        /**
         * The node type of instance parameter, valid value contains `Node`, `Shard`, `ConfigServer`, `Mongos`.
         */
        parameterRole: string;
        /**
         * The type of parameter value.
         */
        parameterType: string;
        /**
         * The value of parameter.
         */
        parameterValue: string;
    }

    export interface GetInstancesInstance {
        /**
         * Whether to enable automatic renewal.
         */
        autoRenew: boolean;
        /**
         * The charge status.
         */
        chargeStatus: string;
        /**
         * The charge type of instance.
         */
        chargeType: string;
        /**
         * The planned close time.
         */
        closedTime: string;
        /**
         * The list of config servers.
         */
        configServers: outputs.mongodb.GetInstancesInstanceConfigServer[];
        /**
         * The ID of config servers.
         */
        configServersId: string;
        /**
         * The creation time of instance.
         */
        createTime: string;
        /**
         * The db engine to query, valid value contains `MongoDB`.
         */
        dbEngine: string;
        /**
         * The version of db engine to query, valid value contains `MongoDB_4_0`.
         */
        dbEngineVersion: string;
        /**
         * The version string of database engine.
         */
        dbEngineVersionStr: string;
        /**
         * The expired time of instance.
         */
        expiredTime: string;
        /**
         * The instance ID to query.
         */
        instanceId: string;
        /**
         * The instance name to query.
         */
        instanceName: string;
        /**
         * The instance status to query.
         */
        instanceStatus: string;
        /**
         * The type of instance to query, the valid value contains `ReplicaSet` or `ShardedCluster`.
         */
        instanceType: string;
        /**
         * The list of mongos.
         */
        mongos: outputs.mongodb.GetInstancesInstanceMongo[];
        /**
         * The ID of mongos.
         */
        mongosId: string;
        /**
         * The node information.
         */
        nodes: outputs.mongodb.GetInstancesInstanceNode[];
        /**
         * The private endpoint address of instance.
         */
        privateEndpoint: string;
        /**
         * The project name to query.
         */
        projectName: string;
        /**
         * The number of readonly node in instance.
         */
        readOnlyNodeNumber: number;
        /**
         * The planned reclaim time of instance.
         */
        reclaimTime: string;
        /**
         * The list of shards.
         */
        shards: outputs.mongodb.GetInstancesInstanceShard[];
        /**
         * Whether ssl enabled.
         */
        sslEnable: boolean;
        /**
         * The ssl expire time.
         */
        sslExpireTime: string;
        /**
         * Whether ssl is valid.
         */
        sslIsValid: boolean;
        /**
         * The storage type of instance.
         */
        storageType: string;
        /**
         * The subnet id of instance.
         */
        subnetId: string;
        /**
         * Tags.
         */
        tags: outputs.mongodb.GetInstancesInstanceTag[];
        /**
         * The update time of instance.
         */
        updateTime: string;
        /**
         * The vpc id of instance to query.
         */
        vpcId: string;
        /**
         * The zone ID to query.
         */
        zoneId: string;
    }

    export interface GetInstancesInstanceConfigServer {
        /**
         * The config server node ID.
         */
        configServerNodeId: string;
        /**
         * The nod role.
         */
        nodeRole: string;
        /**
         * The node status.
         */
        nodeStatus: string;
        /**
         * The total memory in GB.
         */
        totalMemoryGb: number;
        /**
         * The total vCPU.
         */
        totalVcpu: number;
        /**
         * The used memory in GB.
         */
        usedMemoryGb: number;
        /**
         * The used vCPU.
         */
        usedVcpu: number;
        /**
         * The zone ID to query.
         */
        zoneId: string;
    }

    export interface GetInstancesInstanceMongo {
        /**
         * The mongos node ID.
         */
        mongosNodeId: string;
        /**
         * The node spec.
         */
        nodeSpec: string;
        /**
         * The node status.
         */
        nodeStatus: string;
        /**
         * The total memory in GB.
         */
        totalMemoryGb: number;
        /**
         * The total vCPU.
         */
        totalVcpu: number;
        /**
         * The used memory in GB.
         */
        usedMemoryGb: number;
        /**
         * The used vCPU.
         */
        usedVcpu: number;
        /**
         * The zone ID to query.
         */
        zoneId: string;
    }

    export interface GetInstancesInstanceNode {
        /**
         * The master-slave delay time.
         */
        nodeDelayTime: number;
        /**
         * The node ID.
         */
        nodeId: string;
        /**
         * The nod role.
         */
        nodeRole: string;
        /**
         * The node spec.
         */
        nodeSpec: string;
        /**
         * The node status.
         */
        nodeStatus: string;
        /**
         * The total memory in GB.
         */
        totalMemoryGb: number;
        /**
         * The total storage in GB.
         */
        totalStorageGb: number;
        /**
         * The total vCPU.
         */
        totalVcpu: number;
        /**
         * The used memory in GB.
         */
        usedMemoryGb: number;
        /**
         * The used storage in GB.
         */
        usedStorageGb: number;
        /**
         * The used vCPU.
         */
        usedVcpu: number;
        /**
         * The zone ID to query.
         */
        zoneId: string;
    }

    export interface GetInstancesInstanceShard {
        /**
         * The node information.
         */
        nodes: outputs.mongodb.GetInstancesInstanceShardNode[];
        /**
         * The shard ID.
         */
        shardId: string;
    }

    export interface GetInstancesInstanceShardNode {
        /**
         * The master-slave delay time.
         */
        nodeDelayTime: number;
        /**
         * The node ID.
         */
        nodeId: string;
        /**
         * The nod role.
         */
        nodeRole: string;
        /**
         * The node spec.
         */
        nodeSpec: string;
        /**
         * The node status.
         */
        nodeStatus: string;
        /**
         * The total memory in GB.
         */
        totalMemoryGb: number;
        /**
         * The total storage in GB.
         */
        totalStorageGb: number;
        /**
         * The total vCPU.
         */
        totalVcpu: number;
        /**
         * The used memory in GB.
         */
        usedMemoryGb: number;
        /**
         * The used storage in GB.
         */
        usedStorageGb: number;
        /**
         * The used vCPU.
         */
        usedVcpu: number;
        /**
         * The zone ID to query.
         */
        zoneId: string;
    }

    export interface GetInstancesInstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetInstancesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetMongoAllowListsAllowList {
        /**
         * The list of IP address in allow list.
         */
        allowList: string;
        /**
         * The description of allow list.
         */
        allowListDesc: string;
        /**
         * The ID of allow list.
         */
        allowListId: string;
        /**
         * The number of allow list IPs.
         */
        allowListIpNum: number;
        /**
         * The allow list name.
         */
        allowListName: string;
        /**
         * The IP address type in allow list.
         */
        allowListType: string;
        /**
         * The total number of instances bound under the allow list.
         */
        associatedInstanceNum: number;
        /**
         * The list of associated instances.
         */
        associatedInstances: outputs.mongodb.GetMongoAllowListsAllowListAssociatedInstance[];
        /**
         * The project name of the allow list.
         */
        projectName: string;
    }

    export interface GetMongoAllowListsAllowListAssociatedInstance {
        /**
         * The instance ID to query.
         */
        instanceId: string;
        /**
         * The instance name that bound to the allow list.
         */
        instanceName: string;
        /**
         * The project name of the allow list.
         */
        projectName: string;
        /**
         * The VPC ID.
         */
        vpc: string;
    }

    export interface GetRegionsRegion {
        /**
         * The id of the region.
         */
        regionId: string;
        /**
         * The name of region.
         */
        regionName: string;
    }

    export interface GetSpecsSpecs {
        /**
         * The collection of config server node specs.
         */
        configServerNodeSpecs: outputs.mongodb.GetSpecsSpecsConfigServerNodeSpec[];
        /**
         * The collection of mongos node specs.
         */
        mongosNodeSpecs: outputs.mongodb.GetSpecsSpecsMongosNodeSpec[];
        /**
         * The collection of node specs.
         */
        nodeSpecs: outputs.mongodb.GetSpecsSpecsNodeSpec[];
        /**
         * The collection of shard node specs.
         */
        shardNodeSpecs: outputs.mongodb.GetSpecsSpecsShardNodeSpec[];
    }

    export interface GetSpecsSpecsConfigServerNodeSpec {
        /**
         * The cpu cores.
         */
        cpuNum: number;
        /**
         * The max connections.
         */
        maxConn: number;
        /**
         * The max storage.
         */
        maxStorage: number;
        /**
         * The memory in GB.
         */
        memInGb: number;
        /**
         * The min storage.
         */
        minStorage: number;
        /**
         * The shard node spec name.
         */
        specName: string;
    }

    export interface GetSpecsSpecsMongosNodeSpec {
        /**
         * The cpu cores.
         */
        cpuNum: number;
        /**
         * The max connections.
         */
        maxConn: number;
        /**
         * The memory in GB.
         */
        memInGb: number;
        /**
         * The shard node spec name.
         */
        specName: string;
    }

    export interface GetSpecsSpecsNodeSpec {
        /**
         * The cpu cores.
         */
        cpuNum: number;
        /**
         * The max connections.
         */
        maxConn: number;
        /**
         * The max storage.
         */
        maxStorage: number;
        /**
         * The memory in GB.
         */
        memInDb: number;
        /**
         * The min storage.
         */
        minStorage: number;
        /**
         * The shard node spec name.
         */
        specName: string;
    }

    export interface GetSpecsSpecsShardNodeSpec {
        /**
         * The cpu cores.
         */
        cpuNum: number;
        /**
         * The max connections.
         */
        maxConn: number;
        /**
         * The max storage.
         */
        maxStorage: number;
        /**
         * The memory in GB.
         */
        memInGb: number;
        /**
         * The min storage.
         */
        minStorage: number;
        /**
         * The shard node spec name.
         */
        specName: string;
    }

    export interface GetSslStatesSslState {
        /**
         * The mongodb instance ID to query.
         */
        instanceId: string;
        /**
         * Whetehr SSL is valid.
         */
        isValid: boolean;
        /**
         * Whether SSL is enabled.
         */
        sslEnable: boolean;
        /**
         * The expire time of SSL.
         */
        sslExpiredTime: string;
    }

    export interface GetZonesZone {
        /**
         * The id of the zone.
         */
        id: string;
        /**
         * The id of the zone.
         */
        zoneId: string;
        /**
         * The name of the zone.
         */
        zoneName: string;
    }

    export interface InstanceMongo {
        /**
         * The mongos node ID.
         */
        mongosNodeId: string;
        /**
         * The spec of node. When the instanceType is ReplicaSet, this parameter represents the computing node specification of the replica set instance. When the instanceType is ShardedCluster, this parameter represents the specification of the Shard node.
         */
        nodeSpec: string;
        /**
         * The node status.
         */
        nodeStatus: string;
    }

    export interface InstanceNodeAvailabilityZone {
        /**
         * The number of readonly nodes in current zone. Currently, only ReplicaSet instances and Shard in ShardedCluster instances support adding readonly nodes.
         * When the instanceType is ReplicaSet, this value represents the total number of readonly nodes in a single replica set instance. Each instance of the replica set supports adding up to 5 readonly nodes.
         * When the instanceType is ShardedCluster, this value represents the number of readonly nodes in each shard. Each shard can add up to 5 readonly nodes.
         */
        nodeNumber: number;
        /**
         * The zone id of readonly nodes.
         */
        zoneId: string;
    }

    export interface InstanceParameterLogsParameterChangeLog {
        /**
         * The modifying time of parameter.
         */
        modifyTime: string;
        /**
         * The new parameter value.
         */
        newParameterValue: string;
        /**
         * The old parameter value.
         */
        oldParameterValue: string;
        /**
         * The parameter name.
         */
        parameterName: string;
        /**
         * The node type to which the parameter belongs.
         */
        parameterRole: string;
        /**
         * The status of parameter change.
         */
        parameterStatus: string;
    }

    export interface InstanceParametersInstanceParameter {
        /**
         * The checking code of parameter.
         */
        checkingCode: string;
        /**
         * Whether the parameter supports modifying.
         */
        forceModify: boolean;
        /**
         * Does the new parameter value need to restart the instance to take effect after modification.
         */
        forceRestart: boolean;
        /**
         * The default value of parameter.
         */
        parameterDefaultValue: string;
        /**
         * The description of parameter.
         */
        parameterDescription: string;
        /**
         * The name of parameter.
         */
        parameterName: string;
        /**
         * The node type of instance parameter, valid value contains `Node`, `Shard`, `ConfigServer`, `Mongos`.
         */
        parameterRole: string;
        /**
         * The type of parameter value.
         */
        parameterType: string;
        /**
         * The value of parameter.
         */
        parameterValue: string;
    }

    export interface InstanceParametersParameter {
        /**
         * The database engine.
         */
        dbEngine: string;
        /**
         * The database engine version.
         */
        dbEngineVersion: string;
        /**
         * The instance ID to query.
         */
        instanceId: string;
        /**
         * The list of parameters.
         */
        instanceParameters: outputs.mongodb.InstanceParametersParameterInstanceParameter[];
        /**
         * The total parameters queried.
         */
        total: string;
    }

    export interface InstanceParametersParameterInstanceParameter {
        /**
         * The checking code of parameter.
         */
        checkingCode: string;
        /**
         * Whether the parameter supports modifying.
         */
        forceModify: boolean;
        /**
         * Does the new parameter value need to restart the instance to take effect after modification.
         */
        forceRestart: boolean;
        /**
         * The default value of parameter.
         */
        parameterDefaultValue: string;
        /**
         * The description of parameter.
         */
        parameterDescription: string;
        /**
         * The name of parameter.
         */
        parameterName: string;
        /**
         * The node type of instance parameter, valid value contains `Node`, `Shard`, `ConfigServer`, `Mongos`.
         */
        parameterRole: string;
        /**
         * The type of parameter value.
         */
        parameterType: string;
        /**
         * The value of parameter.
         */
        parameterValue: string;
    }

    export interface InstanceShard {
        /**
         * The shard id.
         */
        shardId: string;
    }

    export interface InstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface InstancesInstance {
        /**
         * Whether to enable automatic renewal.
         */
        autoRenew: boolean;
        /**
         * The charge status.
         */
        chargeStatus: string;
        /**
         * The charge type of instance.
         */
        chargeType: string;
        /**
         * The planned close time.
         */
        closedTime: string;
        /**
         * The list of config servers.
         */
        configServers: outputs.mongodb.InstancesInstanceConfigServer[];
        /**
         * The ID of config servers.
         */
        configServersId: string;
        /**
         * The creation time of instance.
         */
        createTime: string;
        /**
         * The db engine to query, valid value contains `MongoDB`.
         */
        dbEngine: string;
        /**
         * The version of db engine to query, valid value contains `MongoDB_4_0`.
         */
        dbEngineVersion: string;
        /**
         * The version string of database engine.
         */
        dbEngineVersionStr: string;
        /**
         * The expired time of instance.
         */
        expiredTime: string;
        /**
         * The instance ID to query.
         */
        instanceId: string;
        /**
         * The instance name to query.
         */
        instanceName: string;
        /**
         * The instance status to query.
         */
        instanceStatus: string;
        /**
         * The type of instance to query, the valid value contains `ReplicaSet` or `ShardedCluster`.
         */
        instanceType: string;
        /**
         * The list of mongos.
         */
        mongos: outputs.mongodb.InstancesInstanceMongo[];
        /**
         * The ID of mongos.
         */
        mongosId: string;
        /**
         * The node information.
         */
        nodes: outputs.mongodb.InstancesInstanceNode[];
        /**
         * The private endpoint address of instance.
         */
        privateEndpoint: string;
        /**
         * The project name to query.
         */
        projectName: string;
        /**
         * The number of readonly node in instance.
         */
        readOnlyNodeNumber: number;
        /**
         * The planned reclaim time of instance.
         */
        reclaimTime: string;
        /**
         * The list of shards.
         */
        shards: outputs.mongodb.InstancesInstanceShard[];
        /**
         * Whether ssl enabled.
         */
        sslEnable: boolean;
        /**
         * The ssl expire time.
         */
        sslExpireTime: string;
        /**
         * Whether ssl is valid.
         */
        sslIsValid: boolean;
        /**
         * The storage type of instance.
         */
        storageType: string;
        /**
         * The subnet id of instance.
         */
        subnetId: string;
        /**
         * Tags.
         */
        tags: outputs.mongodb.InstancesInstanceTag[];
        /**
         * The update time of instance.
         */
        updateTime: string;
        /**
         * The vpc id of instance to query.
         */
        vpcId: string;
        /**
         * The zone ID to query.
         */
        zoneId: string;
    }

    export interface InstancesInstanceConfigServer {
        /**
         * The config server node ID.
         */
        configServerNodeId: string;
        /**
         * The nod role.
         */
        nodeRole: string;
        /**
         * The node status.
         */
        nodeStatus: string;
        /**
         * The total memory in GB.
         */
        totalMemoryGb: number;
        /**
         * The total vCPU.
         */
        totalVcpu: number;
        /**
         * The used memory in GB.
         */
        usedMemoryGb: number;
        /**
         * The used vCPU.
         */
        usedVcpu: number;
        /**
         * The zone ID to query.
         */
        zoneId: string;
    }

    export interface InstancesInstanceMongo {
        /**
         * The mongos node ID.
         */
        mongosNodeId: string;
        /**
         * The node spec.
         */
        nodeSpec: string;
        /**
         * The node status.
         */
        nodeStatus: string;
        /**
         * The total memory in GB.
         */
        totalMemoryGb: number;
        /**
         * The total vCPU.
         */
        totalVcpu: number;
        /**
         * The used memory in GB.
         */
        usedMemoryGb: number;
        /**
         * The used vCPU.
         */
        usedVcpu: number;
        /**
         * The zone ID to query.
         */
        zoneId: string;
    }

    export interface InstancesInstanceNode {
        /**
         * The master-slave delay time.
         */
        nodeDelayTime: number;
        /**
         * The node ID.
         */
        nodeId: string;
        /**
         * The nod role.
         */
        nodeRole: string;
        /**
         * The node spec.
         */
        nodeSpec: string;
        /**
         * The node status.
         */
        nodeStatus: string;
        /**
         * The total memory in GB.
         */
        totalMemoryGb: number;
        /**
         * The total storage in GB.
         */
        totalStorageGb: number;
        /**
         * The total vCPU.
         */
        totalVcpu: number;
        /**
         * The used memory in GB.
         */
        usedMemoryGb: number;
        /**
         * The used storage in GB.
         */
        usedStorageGb: number;
        /**
         * The used vCPU.
         */
        usedVcpu: number;
        /**
         * The zone ID to query.
         */
        zoneId: string;
    }

    export interface InstancesInstanceShard {
        /**
         * The node information.
         */
        nodes: outputs.mongodb.InstancesInstanceShardNode[];
        /**
         * The shard ID.
         */
        shardId: string;
    }

    export interface InstancesInstanceShardNode {
        /**
         * The master-slave delay time.
         */
        nodeDelayTime: number;
        /**
         * The node ID.
         */
        nodeId: string;
        /**
         * The nod role.
         */
        nodeRole: string;
        /**
         * The node spec.
         */
        nodeSpec: string;
        /**
         * The node status.
         */
        nodeStatus: string;
        /**
         * The total memory in GB.
         */
        totalMemoryGb: number;
        /**
         * The total storage in GB.
         */
        totalStorageGb: number;
        /**
         * The total vCPU.
         */
        totalVcpu: number;
        /**
         * The used memory in GB.
         */
        usedMemoryGb: number;
        /**
         * The used storage in GB.
         */
        usedStorageGb: number;
        /**
         * The used vCPU.
         */
        usedVcpu: number;
        /**
         * The zone ID to query.
         */
        zoneId: string;
    }

    export interface InstancesInstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface InstancesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface MongoAllowListAssociatedInstance {
        /**
         * The instance id that bound to the allow list.
         */
        instanceId: string;
        /**
         * The instance name that bound to the allow list.
         */
        instanceName: string;
        /**
         * The project name of the allow list.
         */
        projectName: string;
        /**
         * The VPC ID.
         */
        vpc: string;
    }

    export interface MongoAllowListsAllowList {
        /**
         * The list of IP address in allow list.
         */
        allowList: string;
        /**
         * The description of allow list.
         */
        allowListDesc: string;
        /**
         * The ID of allow list.
         */
        allowListId: string;
        /**
         * The number of allow list IPs.
         */
        allowListIpNum: number;
        /**
         * The allow list name.
         */
        allowListName: string;
        /**
         * The IP address type in allow list.
         */
        allowListType: string;
        /**
         * The total number of instances bound under the allow list.
         */
        associatedInstanceNum: number;
        /**
         * The list of associated instances.
         */
        associatedInstances: outputs.mongodb.MongoAllowListsAllowListAssociatedInstance[];
        /**
         * The project name of the allow list.
         */
        projectName: string;
    }

    export interface MongoAllowListsAllowListAssociatedInstance {
        /**
         * The instance ID to query.
         */
        instanceId: string;
        /**
         * The instance name that bound to the allow list.
         */
        instanceName: string;
        /**
         * The project name of the allow list.
         */
        projectName: string;
        /**
         * The VPC ID.
         */
        vpc: string;
    }

    export interface RegionsRegion {
        /**
         * The id of the region.
         */
        regionId: string;
        /**
         * The name of region.
         */
        regionName: string;
    }

    export interface SpecsSpecs {
        /**
         * The collection of config server node specs.
         */
        configServerNodeSpecs: outputs.mongodb.SpecsSpecsConfigServerNodeSpec[];
        /**
         * The collection of mongos node specs.
         */
        mongosNodeSpecs: outputs.mongodb.SpecsSpecsMongosNodeSpec[];
        /**
         * The collection of node specs.
         */
        nodeSpecs: outputs.mongodb.SpecsSpecsNodeSpec[];
        /**
         * The collection of shard node specs.
         */
        shardNodeSpecs: outputs.mongodb.SpecsSpecsShardNodeSpec[];
    }

    export interface SpecsSpecsConfigServerNodeSpec {
        /**
         * The cpu cores.
         */
        cpuNum: number;
        /**
         * The max connections.
         */
        maxConn: number;
        /**
         * The max storage.
         */
        maxStorage: number;
        /**
         * The memory in GB.
         */
        memInGb: number;
        /**
         * The min storage.
         */
        minStorage: number;
        /**
         * The shard node spec name.
         */
        specName: string;
    }

    export interface SpecsSpecsMongosNodeSpec {
        /**
         * The cpu cores.
         */
        cpuNum: number;
        /**
         * The max connections.
         */
        maxConn: number;
        /**
         * The memory in GB.
         */
        memInGb: number;
        /**
         * The shard node spec name.
         */
        specName: string;
    }

    export interface SpecsSpecsNodeSpec {
        /**
         * The cpu cores.
         */
        cpuNum: number;
        /**
         * The max connections.
         */
        maxConn: number;
        /**
         * The max storage.
         */
        maxStorage: number;
        /**
         * The memory in GB.
         */
        memInDb: number;
        /**
         * The min storage.
         */
        minStorage: number;
        /**
         * The shard node spec name.
         */
        specName: string;
    }

    export interface SpecsSpecsShardNodeSpec {
        /**
         * The cpu cores.
         */
        cpuNum: number;
        /**
         * The max connections.
         */
        maxConn: number;
        /**
         * The max storage.
         */
        maxStorage: number;
        /**
         * The memory in GB.
         */
        memInGb: number;
        /**
         * The min storage.
         */
        minStorage: number;
        /**
         * The shard node spec name.
         */
        specName: string;
    }

    export interface SslStatesSslState {
        /**
         * The mongodb instance ID to query.
         */
        instanceId: string;
        /**
         * Whetehr SSL is valid.
         */
        isValid: boolean;
        /**
         * Whether SSL is enabled.
         */
        sslEnable: boolean;
        /**
         * The expire time of SSL.
         */
        sslExpiredTime: string;
    }

    export interface ZonesZone {
        /**
         * The id of the zone.
         */
        id: string;
        /**
         * The id of the zone.
         */
        zoneId: string;
        /**
         * The name of the zone.
         */
        zoneName: string;
    }

}

export namespace nas {
    export interface AutoSnapshotPoliciesAutoSnapshotPolice {
        /**
         * The id of auto snapshot policy.
         */
        autoSnapshotPolicyId: string;
        /**
         * The name of auto snapshot policy.
         */
        autoSnapshotPolicyName: string;
        /**
         * The create time of auto snapshot policy.
         */
        createTime: string;
        /**
         * The count of file system which auto snapshot policy bind.
         */
        fileSystemCount: number;
        /**
         * The ID of auto snapshot policy.
         */
        id: string;
        /**
         * The repeat weekdays of auto snapshot policy. Unit: day.
         */
        repeatWeekdays: string;
        /**
         * The retention days of auto snapshot policy. Unit: day.
         */
        retentionDays: number;
        /**
         * The status of auto snapshot policy.
         */
        status: string;
        /**
         * The time points of auto snapshot policy. Unit: hour.
         */
        timePoints: string;
    }

    export interface FileSystemTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface FileSystemsFileSystem {
        /**
         * The capacity of the nas file system.
         */
        capacities: outputs.nas.FileSystemsFileSystemCapacity[];
        /**
         * The charge type of nas file system.
         */
        chargeType: string;
        /**
         * The create time of the nas file system.
         */
        createTime: string;
        /**
         * The description of the nas file system.
         */
        description: string;
        /**
         * The id of the nas file system.
         */
        fileSystemId: string;
        /**
         * The name of nas file system. This field supports fuzzy queries.
         */
        fileSystemName: string;
        /**
         * The type of the nas file system.
         */
        fileSystemType: string;
        /**
         * The id of the nas file system.
         */
        id: string;
        /**
         * The project name of nas file system.
         */
        projectName: string;
        /**
         * The protocol type of nas file system.
         */
        protocolType: string;
        /**
         * The region id of the nas file system.
         */
        regionId: string;
        /**
         * The snapshot count of the nas file system.
         */
        snapshotCount: number;
        /**
         * The status of nas file system.
         */
        status: string;
        /**
         * The storage type of nas file system.
         */
        storageType: string;
        /**
         * Tags.
         */
        tags: outputs.nas.FileSystemsFileSystemTag[];
        /**
         * The update time of the nas file system.
         */
        updateTime: string;
        /**
         * The version of the nas file system.
         */
        version: string;
        /**
         * The zone id of nas file system.
         */
        zoneId: string;
        /**
         * The zone name of the nas file system.
         */
        zoneName: string;
    }

    export interface FileSystemsFileSystemCapacity {
        /**
         * The total capacity of the nas file system. Unit: GiB.
         */
        total: number;
        /**
         * The used capacity of the nas file system. Unit: MiB.
         */
        used: number;
    }

    export interface FileSystemsFileSystemTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Type of Tags.
         */
        type: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface FileSystemsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetAutoSnapshotPoliciesAutoSnapshotPolice {
        /**
         * The id of auto snapshot policy.
         */
        autoSnapshotPolicyId: string;
        /**
         * The name of auto snapshot policy.
         */
        autoSnapshotPolicyName: string;
        /**
         * The create time of auto snapshot policy.
         */
        createTime: string;
        /**
         * The count of file system which auto snapshot policy bind.
         */
        fileSystemCount: number;
        /**
         * The ID of auto snapshot policy.
         */
        id: string;
        /**
         * The repeat weekdays of auto snapshot policy. Unit: day.
         */
        repeatWeekdays: string;
        /**
         * The retention days of auto snapshot policy. Unit: day.
         */
        retentionDays: number;
        /**
         * The status of auto snapshot policy.
         */
        status: string;
        /**
         * The time points of auto snapshot policy. Unit: hour.
         */
        timePoints: string;
    }

    export interface GetFileSystemsFileSystem {
        /**
         * The capacity of the nas file system.
         */
        capacities: outputs.nas.GetFileSystemsFileSystemCapacity[];
        /**
         * The charge type of nas file system.
         */
        chargeType: string;
        /**
         * The create time of the nas file system.
         */
        createTime: string;
        /**
         * The description of the nas file system.
         */
        description: string;
        /**
         * The id of the nas file system.
         */
        fileSystemId: string;
        /**
         * The name of nas file system. This field supports fuzzy queries.
         */
        fileSystemName: string;
        /**
         * The type of the nas file system.
         */
        fileSystemType: string;
        /**
         * The id of the nas file system.
         */
        id: string;
        /**
         * The project name of nas file system.
         */
        projectName: string;
        /**
         * The protocol type of nas file system.
         */
        protocolType: string;
        /**
         * The region id of the nas file system.
         */
        regionId: string;
        /**
         * The snapshot count of the nas file system.
         */
        snapshotCount: number;
        /**
         * The status of nas file system.
         */
        status: string;
        /**
         * The storage type of nas file system.
         */
        storageType: string;
        /**
         * Tags.
         */
        tags: outputs.nas.GetFileSystemsFileSystemTag[];
        /**
         * The update time of the nas file system.
         */
        updateTime: string;
        /**
         * The version of the nas file system.
         */
        version: string;
        /**
         * The zone id of nas file system.
         */
        zoneId: string;
        /**
         * The zone name of the nas file system.
         */
        zoneName: string;
    }

    export interface GetFileSystemsFileSystemCapacity {
        /**
         * The total capacity of the nas file system. Unit: GiB.
         */
        total: number;
        /**
         * The used capacity of the nas file system. Unit: MiB.
         */
        used: number;
    }

    export interface GetFileSystemsFileSystemTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Type of Tags.
         */
        type: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetFileSystemsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetMountPointsMountPoint {
        /**
         * The creation time of the permission group.
         */
        createTime: string;
        /**
         * The dns address.
         */
        domain: string;
        /**
         * The address of the mount point.
         */
        ip: string;
        /**
         * The id of the mount point.
         */
        mountPointId: string;
        /**
         * The name of the mount point.
         */
        mountPointName: string;
        /**
         * The struct of the permission group.
         */
        permissionGroups: outputs.nas.GetMountPointsMountPointPermissionGroup[];
        /**
         * The status of the mount point.
         */
        status: string;
        /**
         * The id of the subnet.
         */
        subnetId: string;
        /**
         * The name of the subnet.
         */
        subnetName: string;
        /**
         * The update time of the mount point.
         */
        updateTime: string;
        /**
         * The id of the vpc.
         */
        vpcId: string;
        /**
         * The name of the vpc.
         */
        vpcName: string;
    }

    export interface GetMountPointsMountPointPermissionGroup {
        /**
         * The creation time of the permission group.
         */
        createTime: string;
        /**
         * The description of the permission group.
         */
        description: string;
        /**
         * The number of the file system.
         */
        fileSystemCount: number;
        /**
         * The file system type of the permission group.
         */
        fileSystemType: string;
        /**
         * The list of the mount point.
         */
        mountPoints: outputs.nas.GetMountPointsMountPointPermissionGroupMountPoint[];
        /**
         * The id of the permission group.
         */
        permissionGroupId: string;
        /**
         * The name of the permission group.
         */
        permissionGroupName: string;
        /**
         * The number of the permission rule.
         */
        permissionRuleCount: number;
    }

    export interface GetMountPointsMountPointPermissionGroupMountPoint {
        /**
         * The id of the file system.
         */
        fileSystemId: string;
        /**
         * The id of the mount point.
         */
        mountPointId: string;
        /**
         * The name of the mount point.
         */
        mountPointName: string;
    }

    export interface GetPermissionGroupsFilter {
        /**
         * Filters permission groups for specified characteristics based on attributes. The parameters that support filtering are as follows: `PermissionGroupName`, `PermissionGroupId`.
         */
        key: string;
        /**
         * The value of the filter item.
         */
        value: string;
    }

    export interface GetPermissionGroupsPermissionGroup {
        /**
         * The creation time of the permission group.
         */
        createTime: string;
        /**
         * The description of the permission group.
         */
        description: string;
        /**
         * The number of the file system.
         */
        fileSystemCount: number;
        /**
         * The file system type of the permission group.
         */
        fileSystemType: string;
        /**
         * The list of the mount point.
         */
        mountPoints: outputs.nas.GetPermissionGroupsPermissionGroupMountPoint[];
        /**
         * The id of the permission group.
         */
        permissionGroupId: string;
        /**
         * The name of the permission group.
         */
        permissionGroupName: string;
        /**
         * The number of the permission rule.
         */
        permissionRuleCount: number;
        /**
         * The list of permissions rules.
         */
        permissionRules: outputs.nas.GetPermissionGroupsPermissionGroupPermissionRule[];
    }

    export interface GetPermissionGroupsPermissionGroupMountPoint {
        /**
         * The id of the file system.
         */
        fileSystemId: string;
        /**
         * The id of the mount point.
         */
        mountPointId: string;
        /**
         * The name of the mount point.
         */
        mountPointName: string;
    }

    export interface GetPermissionGroupsPermissionGroupPermissionRule {
        /**
         * Client IP addresses that are allowed access.
         */
        cidrIp: string;
        /**
         * The id of the permission rule.
         */
        permissionRuleId: string;
        /**
         * Permission group read and write rules.
         */
        rwMode: string;
        /**
         * Permission group user permissions.
         */
        userMode: string;
    }

    export interface GetRegionsRegion {
        /**
         * The id of the region.
         */
        regionId: string;
        /**
         * The name of region.
         */
        regionName: string;
        /**
         * The status info of region.
         */
        status: string;
    }

    export interface GetSnapshotsSnapshot {
        /**
         * The create time of snapshot.
         */
        createTime: string;
        /**
         * The description of snapshot.
         */
        description: string;
        /**
         * The ID of file system.
         */
        fileSystemId: string;
        /**
         * The name of file system.
         */
        fileSystemName: string;
        /**
         * The ID of snapshot.
         */
        id: string;
        /**
         * Whether is encrypt.
         */
        isEncrypt: boolean;
        /**
         * The progress of snapshot.
         */
        progress: string;
        /**
         * The retention days of snapshot.
         */
        retentionDays: number;
        /**
         * The ID of snapshot.
         */
        snapshotId: string;
        /**
         * The name of snapshot.
         */
        snapshotName: string;
        /**
         * The type of snapshot.
         */
        snapshotType: string;
        /**
         * The size of source.
         */
        sourceSize: number;
        /**
         * The source version info.
         */
        sourceVersion: string;
        /**
         * The status of snapshot.
         */
        status: string;
        /**
         * The ID of zone.
         */
        zoneId: string;
    }

    export interface GetZonesZone {
        /**
         * The id of the zone.
         */
        id: string;
        /**
         * The collection of sales info.
         */
        sales: outputs.nas.GetZonesZoneSale[];
        /**
         * The status info.
         */
        status: string;
        /**
         * The id of the zone.
         */
        zoneId: string;
        /**
         * The name of the zone.
         */
        zoneName: string;
    }

    export interface GetZonesZoneSale {
        /**
         * The type of file system.
         */
        fileSystemType: string;
        /**
         * The type of protocol.
         */
        protocolType: string;
        /**
         * The status info.
         */
        status: string;
        /**
         * The type of storage.
         */
        storageType: string;
    }

    export interface MountPointsMountPoint {
        /**
         * The creation time of the permission group.
         */
        createTime: string;
        /**
         * The dns address.
         */
        domain: string;
        /**
         * The address of the mount point.
         */
        ip: string;
        /**
         * The id of the mount point.
         */
        mountPointId: string;
        /**
         * The name of the mount point.
         */
        mountPointName: string;
        /**
         * The struct of the permission group.
         */
        permissionGroups: outputs.nas.MountPointsMountPointPermissionGroup[];
        /**
         * The status of the mount point.
         */
        status: string;
        /**
         * The id of the subnet.
         */
        subnetId: string;
        /**
         * The name of the subnet.
         */
        subnetName: string;
        /**
         * The update time of the mount point.
         */
        updateTime: string;
        /**
         * The id of the vpc.
         */
        vpcId: string;
        /**
         * The name of the vpc.
         */
        vpcName: string;
    }

    export interface MountPointsMountPointPermissionGroup {
        /**
         * The creation time of the permission group.
         */
        createTime: string;
        /**
         * The description of the permission group.
         */
        description: string;
        /**
         * The number of the file system.
         */
        fileSystemCount: number;
        /**
         * The file system type of the permission group.
         */
        fileSystemType: string;
        /**
         * The list of the mount point.
         */
        mountPoints: outputs.nas.MountPointsMountPointPermissionGroupMountPoint[];
        /**
         * The id of the permission group.
         */
        permissionGroupId: string;
        /**
         * The name of the permission group.
         */
        permissionGroupName: string;
        /**
         * The number of the permission rule.
         */
        permissionRuleCount: number;
    }

    export interface MountPointsMountPointPermissionGroupMountPoint {
        /**
         * The id of the file system.
         */
        fileSystemId: string;
        /**
         * The id of the mount point.
         */
        mountPointId: string;
        /**
         * The name of the mount point.
         */
        mountPointName: string;
    }

    export interface PermissionGroupPermissionRule {
        /**
         * Client IP addresses that are allowed access.
         */
        cidrIp: string;
        /**
         * Permission group read and write rules. The value description is as follows:
         * `RW`: Allows reading and writing.
         * `RO`: read-only mode.
         */
        rwMode: string;
        /**
         * Permission group user permissions. The value description is as follows:
         * `All_squash`: All access users are mapped to anonymous users or user groups.
         * `No_all_squash`: The access user is first matched with the local user, and then mapped to an anonymous user or user group after the match fails.
         * `Root_squash`: Map the Root user as an anonymous user or user group.
         * `No_root_squash`: The Root user maintains the Root account authority.
         */
        useMode: string;
    }

    export interface PermissionGroupsFilter {
        /**
         * Filters permission groups for specified characteristics based on attributes. The parameters that support filtering are as follows: `PermissionGroupName`, `PermissionGroupId`.
         */
        key: string;
        /**
         * The value of the filter item.
         */
        value: string;
    }

    export interface PermissionGroupsPermissionGroup {
        /**
         * The creation time of the permission group.
         */
        createTime: string;
        /**
         * The description of the permission group.
         */
        description: string;
        /**
         * The number of the file system.
         */
        fileSystemCount: number;
        /**
         * The file system type of the permission group.
         */
        fileSystemType: string;
        /**
         * The list of the mount point.
         */
        mountPoints: outputs.nas.PermissionGroupsPermissionGroupMountPoint[];
        /**
         * The id of the permission group.
         */
        permissionGroupId: string;
        /**
         * The name of the permission group.
         */
        permissionGroupName: string;
        /**
         * The number of the permission rule.
         */
        permissionRuleCount: number;
        /**
         * The list of permissions rules.
         */
        permissionRules: outputs.nas.PermissionGroupsPermissionGroupPermissionRule[];
    }

    export interface PermissionGroupsPermissionGroupMountPoint {
        /**
         * The id of the file system.
         */
        fileSystemId: string;
        /**
         * The id of the mount point.
         */
        mountPointId: string;
        /**
         * The name of the mount point.
         */
        mountPointName: string;
    }

    export interface PermissionGroupsPermissionGroupPermissionRule {
        /**
         * Client IP addresses that are allowed access.
         */
        cidrIp: string;
        /**
         * The id of the permission rule.
         */
        permissionRuleId: string;
        /**
         * Permission group read and write rules.
         */
        rwMode: string;
        /**
         * Permission group user permissions.
         */
        userMode: string;
    }

    export interface RegionsRegion {
        /**
         * The id of the region.
         */
        regionId: string;
        /**
         * The name of region.
         */
        regionName: string;
        /**
         * The status info of region.
         */
        status: string;
    }

    export interface SnapshotsSnapshot {
        /**
         * The create time of snapshot.
         */
        createTime: string;
        /**
         * The description of snapshot.
         */
        description: string;
        /**
         * The ID of file system.
         */
        fileSystemId: string;
        /**
         * The name of file system.
         */
        fileSystemName: string;
        /**
         * The ID of snapshot.
         */
        id: string;
        /**
         * Whether is encrypt.
         */
        isEncrypt: boolean;
        /**
         * The progress of snapshot.
         */
        progress: string;
        /**
         * The retention days of snapshot.
         */
        retentionDays: number;
        /**
         * The ID of snapshot.
         */
        snapshotId: string;
        /**
         * The name of snapshot.
         */
        snapshotName: string;
        /**
         * The type of snapshot.
         */
        snapshotType: string;
        /**
         * The size of source.
         */
        sourceSize: number;
        /**
         * The source version info.
         */
        sourceVersion: string;
        /**
         * The status of snapshot.
         */
        status: string;
        /**
         * The ID of zone.
         */
        zoneId: string;
    }

    export interface ZonesZone {
        /**
         * The id of the zone.
         */
        id: string;
        /**
         * The collection of sales info.
         */
        sales: outputs.nas.ZonesZoneSale[];
        /**
         * The status info.
         */
        status: string;
        /**
         * The id of the zone.
         */
        zoneId: string;
        /**
         * The name of the zone.
         */
        zoneName: string;
    }

    export interface ZonesZoneSale {
        /**
         * The type of file system.
         */
        fileSystemType: string;
        /**
         * The type of protocol.
         */
        protocolType: string;
        /**
         * The status info.
         */
        status: string;
        /**
         * The type of storage.
         */
        storageType: string;
    }

}

export namespace nat {
    export interface DnatEntriesDnatEntry {
        /**
         * The ID of the DNAT entry.
         */
        dnatEntryId: string;
        /**
         * The name of the DNAT entry.
         */
        dnatEntryName: string;
        /**
         * Provides the public IP address for public network access.
         */
        externalIp: string;
        /**
         * The port or port segment that receives requests from the public network. If InternalPort is passed into the port segment, ExternalPort must also be passed into the port segment.
         */
        externalPort: string;
        /**
         * Provides the internal IP address.
         */
        internalIp: string;
        /**
         * The port or port segment on which the cloud server instance provides services to the public network.
         */
        internalPort: string;
        /**
         * The id of the NAT gateway.
         */
        natGatewayId: string;
        /**
         * The network protocol.
         */
        protocol: string;
        /**
         * The network status.
         */
        status: string;
    }

    export interface GatewayTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GatewaysNatGateway {
        /**
         * The billing type of the NatGateway.
         */
        billingType: string;
        /**
         * Whether the NatGateway is locked.
         */
        businessStatus: string;
        /**
         * The creation time of the NatGateway.
         */
        creationTime: string;
        /**
         * The deleted time of the NatGateway.
         */
        deletedTime: string;
        /**
         * The description of the NatGateway.
         */
        description: string;
        /**
         * The eip addresses of the NatGateway.
         */
        eipAddresses: outputs.nat.GatewaysNatGatewayEipAddress[];
        /**
         * The ID of the NatGateway.
         */
        id: string;
        /**
         * The reason why locking NatGateway.
         */
        lockReason: string;
        /**
         * The ID of the NatGateway.
         */
        natGatewayId: string;
        /**
         * The name of the NatGateway.
         */
        natGatewayName: string;
        /**
         * The ID of the network interface.
         */
        networkInterfaceId: string;
        /**
         * The overdue time of the NatGateway.
         */
        overdueTime: string;
        /**
         * The specification of the NatGateway.
         */
        spec: string;
        /**
         * The status of the NatGateway.
         */
        status: string;
        /**
         * The id of the Subnet.
         */
        subnetId: string;
        /**
         * Tags.
         */
        tags: outputs.nat.GatewaysNatGatewayTag[];
        /**
         * The update time of the NatGateway.
         */
        updatedAt: string;
        /**
         * The id of the VPC.
         */
        vpcId: string;
    }

    export interface GatewaysNatGatewayEipAddress {
        /**
         * The ID of Eip.
         */
        allocationId: string;
        /**
         * The address of Eip.
         */
        eipAddress: string;
        /**
         * The using status of Eip.
         */
        usingStatus: string;
    }

    export interface GatewaysNatGatewayTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GatewaysTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetDnatEntriesDnatEntry {
        /**
         * The ID of the DNAT entry.
         */
        dnatEntryId: string;
        /**
         * The name of the DNAT entry.
         */
        dnatEntryName: string;
        /**
         * Provides the public IP address for public network access.
         */
        externalIp: string;
        /**
         * The port or port segment that receives requests from the public network. If InternalPort is passed into the port segment, ExternalPort must also be passed into the port segment.
         */
        externalPort: string;
        /**
         * Provides the internal IP address.
         */
        internalIp: string;
        /**
         * The port or port segment on which the cloud server instance provides services to the public network.
         */
        internalPort: string;
        /**
         * The id of the NAT gateway.
         */
        natGatewayId: string;
        /**
         * The network protocol.
         */
        protocol: string;
        /**
         * The network status.
         */
        status: string;
    }

    export interface GetGatewaysNatGateway {
        /**
         * The billing type of the NatGateway.
         */
        billingType: string;
        /**
         * Whether the NatGateway is locked.
         */
        businessStatus: string;
        /**
         * The creation time of the NatGateway.
         */
        creationTime: string;
        /**
         * The deleted time of the NatGateway.
         */
        deletedTime: string;
        /**
         * The description of the NatGateway.
         */
        description: string;
        /**
         * The eip addresses of the NatGateway.
         */
        eipAddresses: outputs.nat.GetGatewaysNatGatewayEipAddress[];
        /**
         * The ID of the NatGateway.
         */
        id: string;
        /**
         * The reason why locking NatGateway.
         */
        lockReason: string;
        /**
         * The ID of the NatGateway.
         */
        natGatewayId: string;
        /**
         * The name of the NatGateway.
         */
        natGatewayName: string;
        /**
         * The ID of the network interface.
         */
        networkInterfaceId: string;
        /**
         * The overdue time of the NatGateway.
         */
        overdueTime: string;
        /**
         * The specification of the NatGateway.
         */
        spec: string;
        /**
         * The status of the NatGateway.
         */
        status: string;
        /**
         * The id of the Subnet.
         */
        subnetId: string;
        /**
         * Tags.
         */
        tags: outputs.nat.GetGatewaysNatGatewayTag[];
        /**
         * The update time of the NatGateway.
         */
        updatedAt: string;
        /**
         * The id of the VPC.
         */
        vpcId: string;
    }

    export interface GetGatewaysNatGatewayEipAddress {
        /**
         * The ID of Eip.
         */
        allocationId: string;
        /**
         * The address of Eip.
         */
        eipAddress: string;
        /**
         * The using status of Eip.
         */
        usingStatus: string;
    }

    export interface GetGatewaysNatGatewayTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetGatewaysTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetSnatEntriesSnatEntry {
        /**
         * The public ip address used by the SNAT entry.
         */
        eipAddress: string;
        /**
         * An id of the public ip address used by the SNAT entry.
         */
        eipId: string;
        /**
         * The id of the SNAT entry.
         */
        id: string;
        /**
         * An id of the nat gateway to which the entry belongs.
         */
        natGatewayId: string;
        /**
         * The id of the SNAT entry.
         */
        snatEntryId: string;
        /**
         * A name of SNAT entry.
         */
        snatEntryName: string;
        /**
         * The SourceCidr of SNAT entry.
         */
        sourceCidr: string;
        /**
         * The status of the SNAT entry.
         */
        status: string;
        /**
         * An id of the subnet that is required to access the Internet.
         */
        subnetId: string;
    }

    export interface SnatEntriesSnatEntry {
        /**
         * The public ip address used by the SNAT entry.
         */
        eipAddress: string;
        /**
         * An id of the public ip address used by the SNAT entry.
         */
        eipId: string;
        /**
         * The id of the SNAT entry.
         */
        id: string;
        /**
         * An id of the nat gateway to which the entry belongs.
         */
        natGatewayId: string;
        /**
         * The id of the SNAT entry.
         */
        snatEntryId: string;
        /**
         * A name of SNAT entry.
         */
        snatEntryName: string;
        /**
         * The SourceCidr of SNAT entry.
         */
        sourceCidr: string;
        /**
         * The status of the SNAT entry.
         */
        status: string;
        /**
         * An id of the subnet that is required to access the Internet.
         */
        subnetId: string;
    }

}

export namespace organization {
    export interface AccountTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface AccountsAccount {
        /**
         * The id of the account.
         */
        accountId: string;
        /**
         * The name of the account.
         */
        accountName: string;
        /**
         * Whether to allow the account enable console. `0` means allowed, `1` means not allowed.
         */
        allowConsole: number;
        /**
         * Whether to allow exit the organization. `0` means allowed, `1` means not allowed.
         */
        allowExit: number;
        /**
         * The created time of the account.
         */
        createdTime: string;
        /**
         * The delete uk of the account.
         */
        deleteUk: string;
        /**
         * The deleted time of the account.
         */
        deletedTime: string;
        /**
         * The description of the account.
         */
        description: string;
        /**
         * The name of the iam role.
         */
        iamRole: string;
        /**
         * The id of the account.
         */
        id: string;
        /**
         * Whether the account is owner. `0` means not owner, `1` means owner.
         */
        isOwner: number;
        /**
         * The join type of the account. `0` means create, `1` means invitation.
         */
        joinType: number;
        /**
         * The id of the organization.
         */
        orgId: string;
        /**
         * The type of the organization. `1` means business organization.
         */
        orgType: number;
        /**
         * The id of the organization unit.
         */
        orgUnitId: string;
        /**
         * The name of the organization unit.
         */
        orgUnitName: string;
        /**
         * The id of the organization verification.
         */
        orgVerificationId: string;
        /**
         * The owner id of the account.
         */
        owner: string;
        /**
         * The show name of the account.
         */
        showName: string;
        /**
         * Tags.
         */
        tags: outputs.organization.AccountsAccountTag[];
        /**
         * The updated time of the account.
         */
        updatedTime: string;
    }

    export interface AccountsAccountTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetAccountsAccount {
        /**
         * The id of the account.
         */
        accountId: string;
        /**
         * The name of the account.
         */
        accountName: string;
        /**
         * Whether to allow the account enable console. `0` means allowed, `1` means not allowed.
         */
        allowConsole: number;
        /**
         * Whether to allow exit the organization. `0` means allowed, `1` means not allowed.
         */
        allowExit: number;
        /**
         * The created time of the account.
         */
        createdTime: string;
        /**
         * The delete uk of the account.
         */
        deleteUk: string;
        /**
         * The deleted time of the account.
         */
        deletedTime: string;
        /**
         * The description of the account.
         */
        description: string;
        /**
         * The name of the iam role.
         */
        iamRole: string;
        /**
         * The id of the account.
         */
        id: string;
        /**
         * Whether the account is owner. `0` means not owner, `1` means owner.
         */
        isOwner: number;
        /**
         * The join type of the account. `0` means create, `1` means invitation.
         */
        joinType: number;
        /**
         * The id of the organization.
         */
        orgId: string;
        /**
         * The type of the organization. `1` means business organization.
         */
        orgType: number;
        /**
         * The id of the organization unit.
         */
        orgUnitId: string;
        /**
         * The name of the organization unit.
         */
        orgUnitName: string;
        /**
         * The id of the organization verification.
         */
        orgVerificationId: string;
        /**
         * The owner id of the account.
         */
        owner: string;
        /**
         * The show name of the account.
         */
        showName: string;
        /**
         * Tags.
         */
        tags: outputs.organization.GetAccountsAccountTag[];
        /**
         * The updated time of the account.
         */
        updatedTime: string;
    }

    export interface GetAccountsAccountTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetOrganizationsOrganization {
        /**
         * The account id of the organization owner.
         */
        accountId: number;
        /**
         * The account name of the organization owner.
         */
        accountName: string;
        /**
         * The created time of the organization.
         */
        createdTime: string;
        /**
         * The delete uk of the organization.
         */
        deleteUk: string;
        /**
         * The deleted time of the organization.
         */
        deletedTime: string;
        /**
         * The description of the organization.
         */
        description: string;
        /**
         * The id of the organization.
         */
        id: string;
        /**
         * The main name of the organization owner.
         */
        mainName: string;
        /**
         * The name of the organization.
         */
        name: string;
        /**
         * The owner id of the organization.
         */
        owner: string;
        /**
         * The status of the organization.
         */
        status: number;
        /**
         * The type of the organization.
         */
        type: number;
        /**
         * The updated time of the organization.
         */
        updatedTime: string;
    }

    export interface GetServiceControlPoliciesPolicy {
        /**
         * The create time of the Policy.
         */
        createDate: string;
        /**
         * The description of the Policy.
         */
        description: string;
        /**
         * The ID of the Policy.
         */
        id: string;
        /**
         * The name of the Policy.
         */
        policyName: string;
        /**
         * The type of policy. The value can be System or Custom.
         */
        policyType: string;
        /**
         * The statement of the Policy.
         */
        statement: string;
        /**
         * The update time of the Policy.
         */
        updateDate: string;
    }

    export interface GetUnitsUnit {
        /**
         * The created time of the organization unit.
         */
        createdTime: string;
        /**
         * Delete marker.
         */
        deleteUk: string;
        /**
         * The deleted time of the organization unit.
         */
        deletedTime: string;
        /**
         * The depth of the organization unit.
         */
        depth: number;
        /**
         * The description of the organization unit.
         */
        description: string;
        /**
         * The id of the organization unit.
         */
        id: string;
        /**
         * The name of the organization unit.
         */
        name: string;
        /**
         * The id of the organization.
         */
        orgId: string;
        /**
         * The organization type.
         */
        orgType: number;
        /**
         * The owner of the organization unit.
         */
        owner: string;
        /**
         * Parent Unit ID.
         */
        parentId: string;
        /**
         * The updated time of the organization unit.
         */
        updatedTime: string;
    }

    export interface OrganizationsOrganization {
        /**
         * The account id of the organization owner.
         */
        accountId: number;
        /**
         * The account name of the organization owner.
         */
        accountName: string;
        /**
         * The created time of the organization.
         */
        createdTime: string;
        /**
         * The delete uk of the organization.
         */
        deleteUk: string;
        /**
         * The deleted time of the organization.
         */
        deletedTime: string;
        /**
         * The description of the organization.
         */
        description: string;
        /**
         * The id of the organization.
         */
        id: string;
        /**
         * The main name of the organization owner.
         */
        mainName: string;
        /**
         * The name of the organization.
         */
        name: string;
        /**
         * The owner id of the organization.
         */
        owner: string;
        /**
         * The status of the organization.
         */
        status: number;
        /**
         * The type of the organization.
         */
        type: number;
        /**
         * The updated time of the organization.
         */
        updatedTime: string;
    }

    export interface ServiceControlPoliciesPolicy {
        /**
         * The create time of the Policy.
         */
        createDate: string;
        /**
         * The description of the Policy.
         */
        description: string;
        /**
         * The ID of the Policy.
         */
        id: string;
        /**
         * The name of the Policy.
         */
        policyName: string;
        /**
         * The type of policy. The value can be System or Custom.
         */
        policyType: string;
        /**
         * The statement of the Policy.
         */
        statement: string;
        /**
         * The update time of the Policy.
         */
        updateDate: string;
    }

    export interface UnitsUnit {
        /**
         * The created time of the organization unit.
         */
        createdTime: string;
        /**
         * Delete marker.
         */
        deleteUk: string;
        /**
         * The deleted time of the organization unit.
         */
        deletedTime: string;
        /**
         * The depth of the organization unit.
         */
        depth: number;
        /**
         * The description of the organization unit.
         */
        description: string;
        /**
         * The id of the organization unit.
         */
        id: string;
        /**
         * The name of the organization unit.
         */
        name: string;
        /**
         * The id of the organization.
         */
        orgId: string;
        /**
         * The organization type.
         */
        orgType: number;
        /**
         * The owner of the organization unit.
         */
        owner: string;
        /**
         * Parent Unit ID.
         */
        parentId: string;
        /**
         * The updated time of the organization unit.
         */
        updatedTime: string;
    }

}

export namespace private_zone {
    export interface GetPrivateZonesPrivateZone {
        /**
         * The Bind vpc info of the private zone.
         */
        bindVpcs: outputs.private_zone.GetPrivateZonesPrivateZoneBindVpc[];
        /**
         * The created time of the private zone.
         */
        createdAt: string;
        /**
         * The id of the private zone.
         */
        id: string;
        /**
         * The account id of the last operator who created the private zone.
         */
        lastOperator: string;
        /**
         * The line mode of Private Zone, specified whether the intelligent mode and the load balance function is enabled.
         */
        lineMode: number;
        /**
         * The project name of the private zone.
         */
        projectName: string;
        /**
         * The record count of the private zone.
         */
        recordCount: number;
        /**
         * Whether the recursion mode of Private Zone is enabled.
         */
        recursionMode: boolean;
        /**
         * The region of Private Zone.
         */
        regions: string[];
        /**
         * The remark of the private zone.
         */
        remark: string;
        /**
         * Tags.
         */
        tags: outputs.private_zone.GetPrivateZonesPrivateZoneTag[];
        /**
         * The updated time of the private zone.
         */
        updatedAt: string;
        /**
         * The zid of Private Zone.
         */
        zid: number;
        /**
         * The name of Private Zone.
         */
        zoneName: string;
    }

    export interface GetPrivateZonesPrivateZoneBindVpc {
        /**
         * The account id of the bind vpc.
         */
        accountId: string;
        /**
         * The id of the private zone.
         */
        id: string;
        /**
         * The region of Private Zone.
         */
        region: string;
        /**
         * The region name of the bind vpc.
         */
        regionName: string;
    }

    export interface GetPrivateZonesPrivateZoneTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetPrivateZonesTagFilter {
        /**
         * The key of the tag.
         */
        key?: string;
        /**
         * The values of the tag.
         */
        values?: string[];
    }

    export interface GetRecordSetsRecordSet {
        /**
         * The Complete domain name of the private zone record.
         */
        fqdn: string;
        /**
         * The host of Private Zone Record Set.
         */
        host: string;
        /**
         * The subnet id of the private zone record. This field is only effected when the `intelligentMode` of the private zone is true.
         */
        line: string;
        /**
         * The id of Private Zone Record Set.
         */
        recordSetId: string;
        /**
         * The type of the private zone record.
         */
        type: string;
        /**
         * Whether to enable the load balance of the private zone record set.
         */
        weightEnabled: boolean;
    }

    export interface GetRecordsRecord {
        /**
         * The created time of the private zone record.
         */
        createdAt: string;
        /**
         * Whether the private zone record is enabling.
         */
        enable: boolean;
        /**
         * The host of Private Zone Record.
         */
        host: string;
        /**
         * The last operator account id of Private Zone Record.
         */
        lastOperator: string;
        /**
         * The subnet id of Private Zone Record.
         */
        line: string;
        /**
         * This field is deprecated, please use `recordIds` instead. The id of Private Zone Record.
         */
        recordId: string;
        /**
         * The remark of the private zone record.
         */
        remark: string;
        /**
         * The ttl of the private zone record. Unit: second.
         */
        ttl: number;
        /**
         * The type of Private Zone Record.
         */
        type: string;
        /**
         * The updated time of the private zone record.
         */
        updatedAt: string;
        /**
         * The value of Private Zone Record.
         */
        value: string;
        /**
         * The weight of the private zone record.
         */
        weight: number;
        /**
         * The zid of Private Zone.
         */
        zid: number;
    }

    export interface GetResolverEndpointsEndpoint {
        /**
         * The created time of the endpoint.
         */
        createdAt: string;
        /**
         * The direction of the private zone resolver endpoint.
         */
        direction: string;
        /**
         * The endpoint id.
         */
        endpointId: number;
        /**
         * The id of the endpoint.
         */
        id: string;
        /**
         * List of IP configurations.
         */
        ipConfigs: outputs.private_zone.GetResolverEndpointsEndpointIpConfig[];
        /**
         * The name of the private zone resolver endpoint.
         */
        name: string;
        /**
         * The project name of the private zone resolver endpoint.
         */
        projectName: string;
        /**
         * The security group id of the endpoint.
         */
        securityGroupId: string;
        /**
         * The status of the private zone resolver endpoint.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.private_zone.GetResolverEndpointsEndpointTag[];
        /**
         * The updated time of the endpoint.
         */
        updatedAt: string;
        /**
         * The vpc ID of the private zone resolver endpoint.
         */
        vpcId: string;
        /**
         * The vpc region of the endpoint.
         */
        vpcRegion: string;
    }

    export interface GetResolverEndpointsEndpointIpConfig {
        /**
         * The availability zone id of the endpoint.
         */
        azId: string;
        /**
         * The IP address of the endpoint.
         */
        ip: string;
        /**
         * The subnet id of the endpoint.
         */
        subnetId: string;
    }

    export interface GetResolverEndpointsEndpointTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetResolverEndpointsTagFilter {
        /**
         * The key of the tag.
         */
        key?: string;
        /**
         * The values of the tag.
         */
        values?: string[];
    }

    export interface GetResolverRulesRule {
        bindVpcs: outputs.private_zone.GetResolverRulesRuleBindVpc[];
        /**
         * The created time of the rule.
         */
        createdAt: string;
        /**
         * ID of the exit terminal node.
         */
        endpointId: number;
        /**
         * The IP address and port of the DNS server outside of the VPC.
         */
        forwardIps: outputs.private_zone.GetResolverRulesRuleForwardIp[];
        /**
         * The id of the rule.
         */
        id: string;
        /**
         * The ISP of the exit IP address of the recursive DNS server.
         */
        line: string;
        /**
         * The name of the rule.
         */
        name: string;
        /**
         * The project name of the private zone resolver rule.
         */
        projectName: string;
        /**
         * The id of the rule.
         */
        ruleId: number;
        /**
         * Tags.
         */
        tags: outputs.private_zone.GetResolverRulesRuleTag[];
        /**
         * The type of the rule.
         */
        type: string;
        /**
         * The updated time of the rule.
         */
        updatedAt: string;
        /**
         * The main domain associated with the forwarding rule. For example, if you set this parameter to example.com, DNS requests for example.com and all subdomains of example.com will be forwarded.
         */
        zoneNames: string[];
    }

    export interface GetResolverRulesRuleBindVpc {
        /**
         * The account id of the bind vpc.
         */
        accountId: string;
        /**
         * The id of the rule.
         */
        id: string;
        /**
         * The region of the bind vpc.
         */
        region: string;
        /**
         * The region name of the bind vpc.
         */
        regionName: string;
    }

    export interface GetResolverRulesRuleForwardIp {
        /**
         * The IP address of the DNS server outside of the VPC.
         */
        ip: string;
        /**
         * The port of the DNS server outside of the VPC.
         */
        port: number;
    }

    export interface GetResolverRulesRuleTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetResolverRulesTagFilter {
        /**
         * The key of the tag.
         */
        key?: string;
        /**
         * The values of the tag.
         */
        values?: string[];
    }

    export interface PrivateZoneTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface PrivateZoneVpc {
        /**
         * The region of the bind vpc. The default value is the region of the default provider config.
         */
        region: string;
        /**
         * The id of the bind vpc.
         */
        vpcId: string;
    }

    export interface PrivateZonesPrivateZone {
        /**
         * The Bind vpc info of the private zone.
         */
        bindVpcs: outputs.private_zone.PrivateZonesPrivateZoneBindVpc[];
        /**
         * The created time of the private zone.
         */
        createdAt: string;
        /**
         * The id of the private zone.
         */
        id: string;
        /**
         * The account id of the last operator who created the private zone.
         */
        lastOperator: string;
        /**
         * The line mode of Private Zone, specified whether the intelligent mode and the load balance function is enabled.
         */
        lineMode: number;
        /**
         * The project name of the private zone.
         */
        projectName: string;
        /**
         * The record count of the private zone.
         */
        recordCount: number;
        /**
         * Whether the recursion mode of Private Zone is enabled.
         */
        recursionMode: boolean;
        /**
         * The region of Private Zone.
         */
        regions: string[];
        /**
         * The remark of the private zone.
         */
        remark: string;
        /**
         * Tags.
         */
        tags: outputs.private_zone.PrivateZonesPrivateZoneTag[];
        /**
         * The updated time of the private zone.
         */
        updatedAt: string;
        /**
         * The zid of Private Zone.
         */
        zid: number;
        /**
         * The name of Private Zone.
         */
        zoneName: string;
    }

    export interface PrivateZonesPrivateZoneBindVpc {
        /**
         * The account id of the bind vpc.
         */
        accountId: string;
        /**
         * The id of the private zone.
         */
        id: string;
        /**
         * The region of Private Zone.
         */
        region: string;
        /**
         * The region name of the bind vpc.
         */
        regionName: string;
    }

    export interface PrivateZonesPrivateZoneTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface PrivateZonesTagFilter {
        /**
         * The key of the tag.
         */
        key?: string;
        /**
         * The values of the tag.
         */
        values?: string[];
    }

    export interface RecordSetsRecordSet {
        /**
         * The Complete domain name of the private zone record.
         */
        fqdn: string;
        /**
         * The host of Private Zone Record Set.
         */
        host: string;
        /**
         * The subnet id of the private zone record. This field is only effected when the `intelligentMode` of the private zone is true.
         */
        line: string;
        /**
         * The id of Private Zone Record Set.
         */
        recordSetId: string;
        /**
         * The type of the private zone record.
         */
        type: string;
        /**
         * Whether to enable the load balance of the private zone record set.
         */
        weightEnabled: boolean;
    }

    export interface RecordsRecord {
        /**
         * The created time of the private zone record.
         */
        createdAt: string;
        /**
         * Whether the private zone record is enabling.
         */
        enable: boolean;
        /**
         * The host of Private Zone Record.
         */
        host: string;
        /**
         * The last operator account id of Private Zone Record.
         */
        lastOperator: string;
        /**
         * The subnet id of Private Zone Record.
         */
        line: string;
        /**
         * This field is deprecated, please use `recordIds` instead. The id of Private Zone Record.
         */
        recordId: string;
        /**
         * The remark of the private zone record.
         */
        remark: string;
        /**
         * The ttl of the private zone record. Unit: second.
         */
        ttl: number;
        /**
         * The type of Private Zone Record.
         */
        type: string;
        /**
         * The updated time of the private zone record.
         */
        updatedAt: string;
        /**
         * The value of Private Zone Record.
         */
        value: string;
        /**
         * The weight of the private zone record.
         */
        weight: number;
        /**
         * The zid of Private Zone.
         */
        zid: number;
    }

    export interface ResolverEndpointIpConfig {
        /**
         * Id of the availability zone.
         */
        azId: string;
        /**
         * Source IP address of traffic. You can add up to 6 IP addresses at most. To ensure high availability, you must add at least two IP addresses.
         */
        ip: string;
        /**
         * Id of the subnet.
         */
        subnetId: string;
    }

    export interface ResolverEndpointTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface ResolverEndpointsEndpoint {
        /**
         * The created time of the endpoint.
         */
        createdAt: string;
        /**
         * The direction of the private zone resolver endpoint.
         */
        direction: string;
        /**
         * The endpoint id.
         */
        endpointId: number;
        /**
         * The id of the endpoint.
         */
        id: string;
        /**
         * List of IP configurations.
         */
        ipConfigs: outputs.private_zone.ResolverEndpointsEndpointIpConfig[];
        /**
         * The name of the private zone resolver endpoint.
         */
        name: string;
        /**
         * The project name of the private zone resolver endpoint.
         */
        projectName: string;
        /**
         * The security group id of the endpoint.
         */
        securityGroupId: string;
        /**
         * The status of the private zone resolver endpoint.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.private_zone.ResolverEndpointsEndpointTag[];
        /**
         * The updated time of the endpoint.
         */
        updatedAt: string;
        /**
         * The vpc ID of the private zone resolver endpoint.
         */
        vpcId: string;
        /**
         * The vpc region of the endpoint.
         */
        vpcRegion: string;
    }

    export interface ResolverEndpointsEndpointIpConfig {
        /**
         * The availability zone id of the endpoint.
         */
        azId: string;
        /**
         * The IP address of the endpoint.
         */
        ip: string;
        /**
         * The subnet id of the endpoint.
         */
        subnetId: string;
    }

    export interface ResolverEndpointsEndpointTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface ResolverEndpointsTagFilter {
        /**
         * The key of the tag.
         */
        key?: string;
        /**
         * The values of the tag.
         */
        values?: string[];
    }

    export interface ResolverRuleForwardIp {
        /**
         * IP address of the external DNS server. This parameter is only valid when the Type parameter is OUTBOUND and is a required parameter.
         */
        ip: string;
        /**
         * The port of the external DNS server. Default is 53. This parameter is only valid and optional when the Type parameter is OUTBOUND.
         */
        port: number;
    }

    export interface ResolverRuleTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface ResolverRuleVpc {
        /**
         * The region of the bind vpc. The default value is the region of the default provider config.
         */
        region: string;
        /**
         * The id of the bind vpc.
         */
        vpcId: string;
    }

    export interface ResolverRulesRule {
        bindVpcs: outputs.private_zone.ResolverRulesRuleBindVpc[];
        /**
         * The created time of the rule.
         */
        createdAt: string;
        /**
         * ID of the exit terminal node.
         */
        endpointId: number;
        /**
         * The IP address and port of the DNS server outside of the VPC.
         */
        forwardIps: outputs.private_zone.ResolverRulesRuleForwardIp[];
        /**
         * The id of the rule.
         */
        id: string;
        /**
         * The ISP of the exit IP address of the recursive DNS server.
         */
        line: string;
        /**
         * The name of the rule.
         */
        name: string;
        /**
         * The project name of the private zone resolver rule.
         */
        projectName: string;
        /**
         * The id of the rule.
         */
        ruleId: number;
        /**
         * Tags.
         */
        tags: outputs.private_zone.ResolverRulesRuleTag[];
        /**
         * The type of the rule.
         */
        type: string;
        /**
         * The updated time of the rule.
         */
        updatedAt: string;
        /**
         * The main domain associated with the forwarding rule. For example, if you set this parameter to example.com, DNS requests for example.com and all subdomains of example.com will be forwarded.
         */
        zoneNames: string[];
    }

    export interface ResolverRulesRuleBindVpc {
        /**
         * The account id of the bind vpc.
         */
        accountId: string;
        /**
         * The id of the rule.
         */
        id: string;
        /**
         * The region of the bind vpc.
         */
        region: string;
        /**
         * The region name of the bind vpc.
         */
        regionName: string;
    }

    export interface ResolverRulesRuleForwardIp {
        /**
         * The IP address of the DNS server outside of the VPC.
         */
        ip: string;
        /**
         * The port of the DNS server outside of the VPC.
         */
        port: number;
    }

    export interface ResolverRulesRuleTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface ResolverRulesTagFilter {
        /**
         * The key of the tag.
         */
        key?: string;
        /**
         * The values of the tag.
         */
        values?: string[];
    }

}

export namespace privatelink {
    export interface GetVpcEndpointConnectionsConnection {
        /**
         * The status of the connection.
         */
        connectionStatus: string;
        /**
         * The create time of the connection.
         */
        creationTime: string;
        /**
         * The id of the vpc endpoint.
         */
        endpointId: string;
        /**
         * The account id of the vpc endpoint.
         */
        endpointOwnerAccountId: string;
        /**
         * The vpc id of the vpc endpoint.
         */
        endpointVpcId: string;
        /**
         * The id of the vpc endpoint service.
         */
        serviceId: string;
        /**
         * The update time of the connection.
         */
        updateTime: string;
        /**
         * The available zones.
         */
        zones: outputs.privatelink.GetVpcEndpointConnectionsConnectionZone[];
    }

    export interface GetVpcEndpointConnectionsConnectionZone {
        /**
         * The id of the network interface.
         */
        networkInterfaceId: string;
        /**
         * The ip address of the network interface.
         */
        networkInterfaceIp: string;
        /**
         * The id of the resource.
         */
        resourceId: string;
        /**
         * The id of the subnet.
         */
        subnetId: string;
        /**
         * The domain of the zone.
         */
        zoneDomain: string;
        /**
         * The id of the zone.
         */
        zoneId: string;
        /**
         * The status of the zone.
         */
        zoneStatus: string;
    }

    export interface GetVpcEndpointServicePermissionsPermission {
        /**
         * The Id of permit account.
         */
        permitAccountId: string;
    }

    export interface GetVpcEndpointServicesService {
        /**
         * Whether auto accept node connect.
         */
        autoAcceptEnabled: boolean;
        /**
         * The create time of service.
         */
        creationTime: string;
        /**
         * The description of service.
         */
        description: string;
        /**
         * The Id of service.
         */
        id: string;
        /**
         * The resources info.
         */
        resources: outputs.privatelink.GetVpcEndpointServicesServiceResource[];
        /**
         * The domain of service.
         */
        serviceDomain: string;
        /**
         * The Id of service.
         */
        serviceId: string;
        /**
         * The name of vpc endpoint service.
         */
        serviceName: string;
        /**
         * The resource type of service.
         */
        serviceResourceType: string;
        /**
         * The type of service.
         */
        serviceType: string;
        /**
         * The status of service.
         */
        status: string;
        /**
         * The update time of service.
         */
        updateTime: string;
        /**
         * The IDs of zones.
         */
        zoneIds: string[];
    }

    export interface GetVpcEndpointServicesServiceResource {
        /**
         * The id of resource.
         */
        resourceId: string;
        /**
         * The type of resource.
         */
        resourceType: string;
        /**
         * The zone id of resource.
         */
        zoneId: string;
    }

    export interface GetVpcEndpointZonesVpcEndpointZone {
        /**
         * The Id of vpc endpoint zone.
         */
        id: string;
        /**
         * The network interface id of vpc endpoint.
         */
        networkInterfaceId: string;
        /**
         * The network interface ip of vpc endpoint.
         */
        networkInterfaceIp: string;
        /**
         * The status of vpc endpoint service.
         */
        serviceStatus: string;
        /**
         * The subnet id of vpc endpoint.
         */
        subnetId: string;
        /**
         * The domain of vpc endpoint zone.
         */
        zoneDomain: string;
        /**
         * The Id of vpc endpoint zone.
         */
        zoneId: string;
        /**
         * The status of vpc endpoint zone.
         */
        zoneStatus: string;
    }

    export interface GetVpcEndpointsVpcEndpoint {
        /**
         * Whether the vpc endpoint is locked.
         */
        businessStatus: string;
        /**
         * The connection  status of vpc endpoint.
         */
        connectionStatus: string;
        /**
         * The create time of vpc endpoint.
         */
        creationTime: string;
        /**
         * The delete time of vpc endpoint.
         */
        deletedTime: string;
        /**
         * The description of vpc endpoint.
         */
        description: string;
        /**
         * The domain of vpc endpoint.
         */
        endpointDomain: string;
        /**
         * The Id of vpc endpoint.
         */
        endpointId: string;
        /**
         * The name of vpc endpoint.
         */
        endpointName: string;
        /**
         * The type of vpc endpoint.
         */
        endpointType: string;
        /**
         * The Id of vpc endpoint.
         */
        id: string;
        /**
         * Whether to enable private dns name.
         */
        privateDnsEnabled: boolean;
        /**
         * The private dns name of vpc endpoint.
         */
        privateDnsName: string;
        /**
         * The Id of vpc endpoint service.
         */
        serviceId: string;
        /**
         * The name of vpc endpoint service.
         */
        serviceName: string;
        /**
         * The status of vpc endpoint. Valid values: `Creating`, `Pending`, `Available`, `Deleting`, `Inactive`.
         */
        status: string;
        /**
         * The update time of vpc endpoint.
         */
        updateTime: string;
        /**
         * The vpc id of vpc endpoint.
         */
        vpcId: string;
    }

    export interface VpcEndpointConnectionZone {
        /**
         * The id of the network interface.
         */
        networkInterfaceId: string;
        /**
         * The ip address of the network interface.
         */
        networkInterfaceIp: string;
        /**
         * The id of the resource.
         */
        resourceId: string;
        /**
         * The id of the subnet.
         */
        subnetId: string;
        /**
         * The domain of the zone.
         */
        zoneDomain: string;
        /**
         * The id of the zone.
         */
        zoneId: string;
        /**
         * The status of the zone.
         */
        zoneStatus: string;
    }

    export interface VpcEndpointConnectionsConnection {
        /**
         * The status of the connection.
         */
        connectionStatus: string;
        /**
         * The create time of the connection.
         */
        creationTime: string;
        /**
         * The id of the vpc endpoint.
         */
        endpointId: string;
        /**
         * The account id of the vpc endpoint.
         */
        endpointOwnerAccountId: string;
        /**
         * The vpc id of the vpc endpoint.
         */
        endpointVpcId: string;
        /**
         * The id of the vpc endpoint service.
         */
        serviceId: string;
        /**
         * The update time of the connection.
         */
        updateTime: string;
        /**
         * The available zones.
         */
        zones: outputs.privatelink.VpcEndpointConnectionsConnectionZone[];
    }

    export interface VpcEndpointConnectionsConnectionZone {
        /**
         * The id of the network interface.
         */
        networkInterfaceId: string;
        /**
         * The ip address of the network interface.
         */
        networkInterfaceIp: string;
        /**
         * The id of the resource.
         */
        resourceId: string;
        /**
         * The id of the subnet.
         */
        subnetId: string;
        /**
         * The domain of the zone.
         */
        zoneDomain: string;
        /**
         * The id of the zone.
         */
        zoneId: string;
        /**
         * The status of the zone.
         */
        zoneStatus: string;
    }

    export interface VpcEndpointServicePermissionsPermission {
        /**
         * The Id of permit account.
         */
        permitAccountId: string;
    }

    export interface VpcEndpointServiceResource {
        /**
         * The id of resource.
         */
        resourceId: string;
        /**
         * The type of resource.
         */
        resourceType: string;
    }

    export interface VpcEndpointServicesService {
        /**
         * Whether auto accept node connect.
         */
        autoAcceptEnabled: boolean;
        /**
         * The create time of service.
         */
        creationTime: string;
        /**
         * The description of service.
         */
        description: string;
        /**
         * The Id of service.
         */
        id: string;
        /**
         * The resources info.
         */
        resources: outputs.privatelink.VpcEndpointServicesServiceResource[];
        /**
         * The domain of service.
         */
        serviceDomain: string;
        /**
         * The Id of service.
         */
        serviceId: string;
        /**
         * The name of vpc endpoint service.
         */
        serviceName: string;
        /**
         * The resource type of service.
         */
        serviceResourceType: string;
        /**
         * The type of service.
         */
        serviceType: string;
        /**
         * The status of service.
         */
        status: string;
        /**
         * The update time of service.
         */
        updateTime: string;
        /**
         * The IDs of zones.
         */
        zoneIds: string[];
    }

    export interface VpcEndpointServicesServiceResource {
        /**
         * The id of resource.
         */
        resourceId: string;
        /**
         * The type of resource.
         */
        resourceType: string;
        /**
         * The zone id of resource.
         */
        zoneId: string;
    }

    export interface VpcEndpointZonesVpcEndpointZone {
        /**
         * The Id of vpc endpoint zone.
         */
        id: string;
        /**
         * The network interface id of vpc endpoint.
         */
        networkInterfaceId: string;
        /**
         * The network interface ip of vpc endpoint.
         */
        networkInterfaceIp: string;
        /**
         * The status of vpc endpoint service.
         */
        serviceStatus: string;
        /**
         * The subnet id of vpc endpoint.
         */
        subnetId: string;
        /**
         * The domain of vpc endpoint zone.
         */
        zoneDomain: string;
        /**
         * The Id of vpc endpoint zone.
         */
        zoneId: string;
        /**
         * The status of vpc endpoint zone.
         */
        zoneStatus: string;
    }

    export interface VpcEndpointsVpcEndpoint {
        /**
         * Whether the vpc endpoint is locked.
         */
        businessStatus: string;
        /**
         * The connection  status of vpc endpoint.
         */
        connectionStatus: string;
        /**
         * The create time of vpc endpoint.
         */
        creationTime: string;
        /**
         * The delete time of vpc endpoint.
         */
        deletedTime: string;
        /**
         * The description of vpc endpoint.
         */
        description: string;
        /**
         * The domain of vpc endpoint.
         */
        endpointDomain: string;
        /**
         * The Id of vpc endpoint.
         */
        endpointId: string;
        /**
         * The name of vpc endpoint.
         */
        endpointName: string;
        /**
         * The type of vpc endpoint.
         */
        endpointType: string;
        /**
         * The Id of vpc endpoint.
         */
        id: string;
        /**
         * Whether to enable private dns name.
         */
        privateDnsEnabled: boolean;
        /**
         * The private dns name of vpc endpoint.
         */
        privateDnsName: string;
        /**
         * The Id of vpc endpoint service.
         */
        serviceId: string;
        /**
         * The name of vpc endpoint service.
         */
        serviceName: string;
        /**
         * The status of vpc endpoint. Valid values: `Creating`, `Pending`, `Available`, `Deleting`, `Inactive`.
         */
        status: string;
        /**
         * The update time of vpc endpoint.
         */
        updateTime: string;
        /**
         * The vpc id of vpc endpoint.
         */
        vpcId: string;
    }

}

export namespace rabbitmq {
    export interface GetInstancePluginsPlugin {
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The disable prompt of plugin.
         */
        disablePrompt: string;
        /**
         * The enable prompt of plugin.
         */
        enablePrompt: string;
        /**
         * Whether plugin is enabled.
         */
        enabled: boolean;
        /**
         * Will changing the enabled state of the plugin cause a reboot of the rabbitmq instance.
         */
        needRebootOnChange: boolean;
        /**
         * The name of plugin.
         */
        pluginName: string;
        /**
         * The port of plugin.
         */
        port: number;
        /**
         * The version of plugin.
         */
        version: string;
    }

    export interface GetInstancesRabbitmqInstance {
        /**
         * The account id of the rabbitmq instance.
         */
        accountId: string;
        /**
         * Whether enable the public network parsing function of the rabbitmq instance.
         */
        applyPrivateDnsToPublic: boolean;
        /**
         * The type of the rabbitmq instance.
         */
        archType: string;
        /**
         * The charge detail information of the rabbitmq instance.
         */
        chargeDetails: outputs.rabbitmq.GetInstancesRabbitmqInstanceChargeDetail[];
        /**
         * The compute specification of the rabbitmq instance.
         */
        computeSpec: string;
        /**
         * The create time of the rabbitmq instance.
         */
        createTime: string;
        /**
         * The eip id of the rabbitmq instance.
         */
        eipId: string;
        /**
         * The endpoint info of the rabbitmq instance.
         */
        endpoints: outputs.rabbitmq.GetInstancesRabbitmqInstanceEndpoint[];
        /**
         * The id of the rabbitmq instance.
         */
        id: string;
        /**
         * The WebUI admin user name of the rabbitmq instance.
         */
        initUserName: string;
        /**
         * The description of the rabbitmq instance.
         */
        instanceDescription: string;
        /**
         * The id of rabbitmq instance. This field supports fuzzy query.
         */
        instanceId: string;
        /**
         * The name of rabbitmq instance. This field supports fuzzy query.
         */
        instanceName: string;
        /**
         * The status of rabbitmq instance.
         */
        instanceStatus: string;
        /**
         * The project name of rabbitmq instance.
         */
        projectName: string;
        /**
         * The region description of the rabbitmq instance.
         */
        regionDescription: string;
        /**
         * The region id of the rabbitmq instance.
         */
        regionId: string;
        /**
         * The total storage space of the rabbitmq instance. Unit: GiB.
         */
        storageSpace: number;
        /**
         * The subnet id of the rabbitmq instance.
         */
        subnetId: string;
        /**
         * Tags.
         */
        tags: outputs.rabbitmq.GetInstancesRabbitmqInstanceTag[];
        /**
         * The used storage space of the rabbitmq instance. Unit: GiB.
         */
        usedStorageSpace: number;
        /**
         * The version of the rabbitmq instance.
         */
        version: string;
        /**
         * The vpc id of rabbitmq instance. This field supports fuzzy query.
         */
        vpcId: string;
        /**
         * The zone description of the rabbitmq instance.
         */
        zoneDescription: string;
        /**
         * The zone id of rabbitmq instance. This field supports fuzzy query.
         */
        zoneId: string;
    }

    export interface GetInstancesRabbitmqInstanceChargeDetail {
        /**
         * Whether to automatically renew in prepaid scenarios.
         */
        autoRenew: boolean;
        /**
         * The charge end time of the rabbitmq instance.
         */
        chargeEndTime: string;
        /**
         * The charge expire time of the rabbitmq instance.
         */
        chargeExpireTime: string;
        /**
         * The charge start time of the rabbitmq instance.
         */
        chargeStartTime: string;
        /**
         * The charge status of the rabbitmq instance.
         */
        chargeStatus: string;
        /**
         * The charge type of rabbitmq instance.
         */
        chargeType: string;
        /**
         * The overdue reclaim time of the rabbitmq instance.
         */
        overdueReclaimTime: string;
        /**
         * The overdue time of the rabbitmq instance.
         */
        overdueTime: string;
    }

    export interface GetInstancesRabbitmqInstanceEndpoint {
        /**
         * The endpoint type of the rabbitmq instance.
         */
        endpointType: string;
        /**
         * The internal endpoint of the rabbitmq instance.
         */
        internalEndpoint: string;
        /**
         * The network type of the rabbitmq instance.
         */
        networkType: string;
        /**
         * The public endpoint of the rabbitmq instance.
         */
        publicEndpoint: string;
    }

    export interface GetInstancesRabbitmqInstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetInstancesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetRegionsRegion {
        /**
         * The description of region.
         */
        description: string;
        /**
         * The ID of region.
         */
        regionId: string;
        /**
         * The name of region.
         */
        regionName: string;
        /**
         * The status of region.
         */
        status: string;
    }

    export interface GetZonesZone {
        /**
         * The description of zone.
         */
        description: string;
        /**
         * The status of zone.
         */
        status: string;
        /**
         * The ID of zone.
         */
        zoneId: string;
        /**
         * The name of zone.
         */
        zoneName: string;
    }

    export interface InstanceChargeInfo {
        /**
         * Whether to automatically renew in prepaid scenarios. Default is false.
         */
        autoRenew?: boolean;
        /**
         * The charge type of the rabbitmq instance. Valid values: `PostPaid`, `PrePaid`.
         */
        chargeType: string;
        /**
         * Purchase duration in prepaid scenarios. When PeriodUnit is specified as `Month`, the value range is 1-9. When PeriodUnit is specified as `Year`, the value range is 1-3. Default is 1.
         */
        period?: number;
        /**
         * The purchase cycle in the prepaid scenario. Valid values: `Month`, `Year`. Default is `Month`.
         */
        periodUnit?: string;
    }

    export interface InstanceEndpoint {
        /**
         * The endpoint type of the rabbitmq instance.
         */
        endpointType: string;
        /**
         * The internal endpoint of the rabbitmq instance.
         */
        internalEndpoint: string;
        /**
         * The network type of the rabbitmq instance.
         */
        networkType: string;
        /**
         * The public endpoint of the rabbitmq instance.
         */
        publicEndpoint: string;
    }

    export interface InstancePluginsPlugin {
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The disable prompt of plugin.
         */
        disablePrompt: string;
        /**
         * The enable prompt of plugin.
         */
        enablePrompt: string;
        /**
         * Whether plugin is enabled.
         */
        enabled: boolean;
        /**
         * Will changing the enabled state of the plugin cause a reboot of the rabbitmq instance.
         */
        needRebootOnChange: boolean;
        /**
         * The name of plugin.
         */
        pluginName: string;
        /**
         * The port of plugin.
         */
        port: number;
        /**
         * The version of plugin.
         */
        version: string;
    }

    export interface InstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface InstancesRabbitmqInstance {
        /**
         * The account id of the rabbitmq instance.
         */
        accountId: string;
        /**
         * Whether enable the public network parsing function of the rabbitmq instance.
         */
        applyPrivateDnsToPublic: boolean;
        /**
         * The type of the rabbitmq instance.
         */
        archType: string;
        /**
         * The charge detail information of the rabbitmq instance.
         */
        chargeDetails: outputs.rabbitmq.InstancesRabbitmqInstanceChargeDetail[];
        /**
         * The compute specification of the rabbitmq instance.
         */
        computeSpec: string;
        /**
         * The create time of the rabbitmq instance.
         */
        createTime: string;
        /**
         * The eip id of the rabbitmq instance.
         */
        eipId: string;
        /**
         * The endpoint info of the rabbitmq instance.
         */
        endpoints: outputs.rabbitmq.InstancesRabbitmqInstanceEndpoint[];
        /**
         * The id of the rabbitmq instance.
         */
        id: string;
        /**
         * The WebUI admin user name of the rabbitmq instance.
         */
        initUserName: string;
        /**
         * The description of the rabbitmq instance.
         */
        instanceDescription: string;
        /**
         * The id of rabbitmq instance. This field supports fuzzy query.
         */
        instanceId: string;
        /**
         * The name of rabbitmq instance. This field supports fuzzy query.
         */
        instanceName: string;
        /**
         * The status of rabbitmq instance.
         */
        instanceStatus: string;
        /**
         * The project name of rabbitmq instance.
         */
        projectName: string;
        /**
         * The region description of the rabbitmq instance.
         */
        regionDescription: string;
        /**
         * The region id of the rabbitmq instance.
         */
        regionId: string;
        /**
         * The total storage space of the rabbitmq instance. Unit: GiB.
         */
        storageSpace: number;
        /**
         * The subnet id of the rabbitmq instance.
         */
        subnetId: string;
        /**
         * Tags.
         */
        tags: outputs.rabbitmq.InstancesRabbitmqInstanceTag[];
        /**
         * The used storage space of the rabbitmq instance. Unit: GiB.
         */
        usedStorageSpace: number;
        /**
         * The version of the rabbitmq instance.
         */
        version: string;
        /**
         * The vpc id of rabbitmq instance. This field supports fuzzy query.
         */
        vpcId: string;
        /**
         * The zone description of the rabbitmq instance.
         */
        zoneDescription: string;
        /**
         * The zone id of rabbitmq instance. This field supports fuzzy query.
         */
        zoneId: string;
    }

    export interface InstancesRabbitmqInstanceChargeDetail {
        /**
         * Whether to automatically renew in prepaid scenarios.
         */
        autoRenew: boolean;
        /**
         * The charge end time of the rabbitmq instance.
         */
        chargeEndTime: string;
        /**
         * The charge expire time of the rabbitmq instance.
         */
        chargeExpireTime: string;
        /**
         * The charge start time of the rabbitmq instance.
         */
        chargeStartTime: string;
        /**
         * The charge status of the rabbitmq instance.
         */
        chargeStatus: string;
        /**
         * The charge type of rabbitmq instance.
         */
        chargeType: string;
        /**
         * The overdue reclaim time of the rabbitmq instance.
         */
        overdueReclaimTime: string;
        /**
         * The overdue time of the rabbitmq instance.
         */
        overdueTime: string;
    }

    export interface InstancesRabbitmqInstanceEndpoint {
        /**
         * The endpoint type of the rabbitmq instance.
         */
        endpointType: string;
        /**
         * The internal endpoint of the rabbitmq instance.
         */
        internalEndpoint: string;
        /**
         * The network type of the rabbitmq instance.
         */
        networkType: string;
        /**
         * The public endpoint of the rabbitmq instance.
         */
        publicEndpoint: string;
    }

    export interface InstancesRabbitmqInstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface InstancesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface RegionsRegion {
        /**
         * The description of region.
         */
        description: string;
        /**
         * The ID of region.
         */
        regionId: string;
        /**
         * The name of region.
         */
        regionName: string;
        /**
         * The status of region.
         */
        status: string;
    }

    export interface ZonesZone {
        /**
         * The description of zone.
         */
        description: string;
        /**
         * The status of zone.
         */
        status: string;
        /**
         * The ID of zone.
         */
        zoneId: string;
        /**
         * The name of zone.
         */
        zoneName: string;
    }

}

export namespace rds {
    export interface AccountPrivilegeDbPrivilege {
        /**
         * The privilege type of the account.
         */
        accountPrivilege: string;
        /**
         * The privilege string of the account.
         */
        accountPrivilegeStr: string;
        /**
         * The name of database.
         */
        dbName: string;
    }

    export interface AccountsRdsAccount {
        /**
         * The name of the database account.
         */
        accountName: string;
        /**
         * The status of the database account.
         */
        accountStatus: string;
        /**
         * The type of the database account.
         */
        accountType: string;
        /**
         * The privilege detail list of RDS instance account.
         */
        dbPrivileges: outputs.rds.AccountsRdsAccountDbPrivilege[];
        /**
         * The ID of the RDS instance account.
         */
        id: string;
    }

    export interface AccountsRdsAccountDbPrivilege {
        /**
         * The privilege type of the account.
         */
        accountPrivilege: string;
        /**
         * The privilege string of the account.
         */
        accountPrivilegeStr: string;
        /**
         * The name of database.
         */
        dbName: string;
    }

    export interface DatabasesRdsDatabase {
        /**
         * The account names of the RDS database.
         */
        accountNames: string;
        /**
         * The character set of the RDS database.
         */
        characterSetName: string;
        /**
         * The name of the RDS database.
         */
        dbName: string;
        /**
         * The status of the RDS database.
         */
        dbStatus: string;
        /**
         * The ID of the RDS database.
         */
        id: string;
    }

    export interface GetAccountsRdsAccount {
        /**
         * The name of the database account.
         */
        accountName: string;
        /**
         * The status of the database account.
         */
        accountStatus: string;
        /**
         * The type of the database account.
         */
        accountType: string;
        /**
         * The privilege detail list of RDS instance account.
         */
        dbPrivileges: outputs.rds.GetAccountsRdsAccountDbPrivilege[];
        /**
         * The ID of the RDS instance account.
         */
        id: string;
    }

    export interface GetAccountsRdsAccountDbPrivilege {
        /**
         * The privilege type of the account.
         */
        accountPrivilege: string;
        /**
         * The privilege string of the account.
         */
        accountPrivilegeStr: string;
        /**
         * The name of database.
         */
        dbName: string;
    }

    export interface GetDatabasesRdsDatabase {
        /**
         * The account names of the RDS database.
         */
        accountNames: string;
        /**
         * The character set of the RDS database.
         */
        characterSetName: string;
        /**
         * The name of the RDS database.
         */
        dbName: string;
        /**
         * The status of the RDS database.
         */
        dbStatus: string;
        /**
         * The ID of the RDS database.
         */
        id: string;
    }

    export interface GetInstancesRdsInstance {
        /**
         * The charge status of the RDS instance.
         */
        chargeStatus: string;
        /**
         * The charge type of the RDS instance.
         */
        chargeType: string;
        /**
         * The connection info ot the RDS instance.
         */
        connectionInfo: outputs.rds.GetInstancesRdsInstanceConnectionInfo;
        /**
         * The create time of the RDS instance.
         */
        createTime: string;
        /**
         * The engine of the RDS instance.
         */
        dbEngine: string;
        /**
         * The engine version of the RDS instance.
         */
        dbEngineVersion: string;
        /**
         * The ID of the RDS instance.
         */
        id: string;
        /**
         * The id of the RDS instance.
         */
        instanceId: string;
        /**
         * The name of the RDS instance.
         */
        instanceName: string;
        /**
         * The spec type detail of RDS instance.
         */
        instanceSpec: outputs.rds.GetInstancesRdsInstanceInstanceSpec;
        /**
         * The status of the RDS instance.
         */
        instanceStatus: string;
        /**
         * The type of the RDS instance.
         */
        instanceType: string;
        /**
         * The ID list of read only instance.
         */
        readOnlyInstanceIds?: string[];
        /**
         * The region of the RDS instance.
         */
        region: string;
        /**
         * The total storage GB of the RDS instance.
         */
        storageSpaceGb: number;
        /**
         * The update time of the RDS instance.
         */
        updateTime: string;
        /**
         * The vpc ID of the RDS instance.
         */
        vpcId: string;
        /**
         * The available zone of the RDS instance.
         */
        zone: string;
    }

    export interface GetInstancesRdsInstanceConnectionInfo {
        /**
         * Whether global read-only is enabled.
         */
        enableReadOnly: string;
        /**
         * Whether read-write separation is enabled.
         */
        enableReadWriteSplitting: string;
        /**
         * The internal domain of the RDS instance.
         */
        internalDomain: string;
        /**
         * The interval port of the RDS instance.
         */
        internalPort: string;
        /**
         * The public domain of the RDS instance.
         */
        publicDomain: string;
        /**
         * The public port of the RDS instance.
         */
        publicPort: string;
    }

    export interface GetInstancesRdsInstanceInstanceSpec {
        /**
         * The cpu core count of spec type.
         */
        cpuNum: number;
        /**
         * The memory size(GB) of spec type.
         */
        memInGb: number;
        /**
         * The name of spec type.
         */
        specName: string;
    }

    export interface GetIpListsRdsIpList {
        /**
         * The name of the RDS ip list.
         */
        groupName: string;
        /**
         * The ID of the RDS ip list.
         */
        id: string;
        /**
         * The list of IP address.
         */
        ipLists: string[];
    }

    export interface GetParameterTemplatesRdsParameterTemplate {
        /**
         * Creation time.
         */
        createTime: string;
        /**
         * The ID of the RDS parameter template.
         */
        id: string;
        /**
         * Whether the template contains parameters that need to be restarted.
         */
        needRestart: boolean;
        /**
         * The number of parameters the template contains.
         */
        parameterNum: number;
        /**
         * The description of the RDS parameter template.
         */
        templateDesc: string;
        /**
         * The ID of the RDS parameter template.
         */
        templateId: string;
        /**
         * The name of the RDS parameter template.
         */
        templateName: string;
        /**
         * Parameters contained in the template.
         */
        templateParams: outputs.rds.GetParameterTemplatesRdsParameterTemplateTemplateParam[];
        /**
         * Parameter template database type, range of values:
         * MySQL - MySQL database.
         */
        templateType: string;
        /**
         * Parameter template database version, value range:
         * MySQL_Community_5_7 - MySQL 5.7
         * MySQL_8_0 - MySQL 8.0.
         */
        templateTypeVersion: string;
        /**
         * Update time.
         */
        updateTime: string;
    }

    export interface GetParameterTemplatesRdsParameterTemplateTemplateParam {
        /**
         * Parameter default value.
         */
        defaultValue: string;
        /**
         * Parameter description.
         */
        description: string;
        /**
         * Parameter name.
         */
        name: string;
        /**
         * Whether the modified parameters need to be restarted to take effect.
         */
        restart: boolean;
        /**
         * Parameter running value.
         */
        runningValue: string;
        /**
         * Parameter value range.
         */
        valueRange: string;
    }

    export interface InstanceConnectionInfo {
        /**
         * Whether global read-only is enabled.
         */
        enableReadOnly: string;
        /**
         * Whether read-write separation is enabled.
         */
        enableReadWriteSplitting: string;
        /**
         * The internal domain of the RDS instance.
         */
        internalDomain: string;
        /**
         * The interval port of the RDS instance.
         */
        internalPort: string;
        /**
         * The public domain of the RDS instance.
         */
        publicDomain: string;
        /**
         * The public port of the RDS instance.
         */
        publicPort: string;
    }

    export interface InstancesRdsInstance {
        /**
         * The charge status of the RDS instance.
         */
        chargeStatus: string;
        /**
         * The charge type of the RDS instance.
         */
        chargeType: string;
        /**
         * The connection info ot the RDS instance.
         */
        connectionInfo: outputs.rds.InstancesRdsInstanceConnectionInfo;
        /**
         * The create time of the RDS instance.
         */
        createTime: string;
        /**
         * The engine of the RDS instance.
         */
        dbEngine: string;
        /**
         * The engine version of the RDS instance.
         */
        dbEngineVersion: string;
        /**
         * The ID of the RDS instance.
         */
        id: string;
        /**
         * The id of the RDS instance.
         */
        instanceId: string;
        /**
         * The name of the RDS instance.
         */
        instanceName: string;
        /**
         * The spec type detail of RDS instance.
         */
        instanceSpec: outputs.rds.InstancesRdsInstanceInstanceSpec;
        /**
         * The status of the RDS instance.
         */
        instanceStatus: string;
        /**
         * The type of the RDS instance.
         */
        instanceType: string;
        /**
         * The ID list of read only instance.
         */
        readOnlyInstanceIds?: string[];
        /**
         * The region of the RDS instance.
         */
        region: string;
        /**
         * The total storage GB of the RDS instance.
         */
        storageSpaceGb: number;
        /**
         * The update time of the RDS instance.
         */
        updateTime: string;
        /**
         * The vpc ID of the RDS instance.
         */
        vpcId: string;
        /**
         * The available zone of the RDS instance.
         */
        zone: string;
    }

    export interface InstancesRdsInstanceConnectionInfo {
        /**
         * Whether global read-only is enabled.
         */
        enableReadOnly: string;
        /**
         * Whether read-write separation is enabled.
         */
        enableReadWriteSplitting: string;
        /**
         * The internal domain of the RDS instance.
         */
        internalDomain: string;
        /**
         * The interval port of the RDS instance.
         */
        internalPort: string;
        /**
         * The public domain of the RDS instance.
         */
        publicDomain: string;
        /**
         * The public port of the RDS instance.
         */
        publicPort: string;
    }

    export interface InstancesRdsInstanceInstanceSpec {
        /**
         * The cpu core count of spec type.
         */
        cpuNum: number;
        /**
         * The memory size(GB) of spec type.
         */
        memInGb: number;
        /**
         * The name of spec type.
         */
        specName: string;
    }

    export interface IpListsRdsIpList {
        /**
         * The name of the RDS ip list.
         */
        groupName: string;
        /**
         * The ID of the RDS ip list.
         */
        id: string;
        /**
         * The list of IP address.
         */
        ipLists: string[];
    }

    export interface ParameterTemplateTemplateParam {
        /**
         * Parameter name.
         */
        name?: string;
        /**
         * Parameter running value.
         */
        runningValue?: string;
    }

    export interface ParameterTemplatesRdsParameterTemplate {
        /**
         * Creation time.
         */
        createTime: string;
        /**
         * The ID of the RDS parameter template.
         */
        id: string;
        /**
         * Whether the template contains parameters that need to be restarted.
         */
        needRestart: boolean;
        /**
         * The number of parameters the template contains.
         */
        parameterNum: number;
        /**
         * The description of the RDS parameter template.
         */
        templateDesc: string;
        /**
         * The ID of the RDS parameter template.
         */
        templateId: string;
        /**
         * The name of the RDS parameter template.
         */
        templateName: string;
        /**
         * Parameters contained in the template.
         */
        templateParams: outputs.rds.ParameterTemplatesRdsParameterTemplateTemplateParam[];
        /**
         * Parameter template database type, range of values:
         * MySQL - MySQL database.
         */
        templateType: string;
        /**
         * Parameter template database version, value range:
         * MySQL_Community_5_7 - MySQL 5.7
         * MySQL_8_0 - MySQL 8.0.
         */
        templateTypeVersion: string;
        /**
         * Update time.
         */
        updateTime: string;
    }

    export interface ParameterTemplatesRdsParameterTemplateTemplateParam {
        /**
         * Parameter default value.
         */
        defaultValue: string;
        /**
         * Parameter description.
         */
        description: string;
        /**
         * Parameter name.
         */
        name: string;
        /**
         * Whether the modified parameters need to be restarted to take effect.
         */
        restart: boolean;
        /**
         * Parameter running value.
         */
        runningValue: string;
        /**
         * Parameter value range.
         */
        valueRange: string;
    }

}

export namespace rds_mssql {
    export interface BackupBackupMeta {
        /**
         * The name of the database.
         */
        dbName: string;
    }

    export interface BackupsBackup {
        /**
         * The detail of the database.
         */
        backupDatabaseDetails: outputs.rds_mssql.BackupsBackupBackupDatabaseDetail[];
        /**
         * The end time of the backup.
         */
        backupEndTime: string;
        /**
         * The size of the backup file.
         */
        backupFileSize: number;
        /**
         * The id of the backup.
         */
        backupId: string;
        /**
         * The name of the backup method.
         */
        backupMethod: string;
        /**
         * The start time of the backup.
         */
        backupStartTime: string;
        /**
         * The status of the backup.
         */
        backupStatus: string;
        /**
         * The type of the backup.
         */
        backupType: string;
        /**
         * The type of the backup create.
         */
        createType: string;
        /**
         * The id of the backup.
         */
        id: string;
    }

    export interface BackupsBackupBackupDatabaseDetail {
        /**
         * External backup download link.
         */
        backupDownloadLinkEip: string;
        /**
         * Intranet backup download link.
         */
        backupDownloadLinkInner: string;
        /**
         * The end time of the backup.
         */
        backupEndTime: string;
        /**
         * The name of the backup file.
         */
        backupFileName: string;
        /**
         * The size of the backup file.
         */
        backupFileSize: number;
        /**
         * The start time of the backup.
         */
        backupStartTime: string;
        /**
         * The type of the backup.
         */
        backupType: string;
        /**
         * The name of the database.
         */
        databaseName: string;
        /**
         * Backup file preparation progress, unit: %.
         */
        downloadProgress: number;
        /**
         * Download status.
         */
        downloadStatus: string;
        /**
         * Download link expiration time.
         */
        linkExpiredTime: string;
    }

    export interface GetBackupsBackup {
        /**
         * The detail of the database.
         */
        backupDatabaseDetails: outputs.rds_mssql.GetBackupsBackupBackupDatabaseDetail[];
        /**
         * The end time of the backup.
         */
        backupEndTime: string;
        /**
         * The size of the backup file.
         */
        backupFileSize: number;
        /**
         * The id of the backup.
         */
        backupId: string;
        /**
         * The name of the backup method.
         */
        backupMethod: string;
        /**
         * The start time of the backup.
         */
        backupStartTime: string;
        /**
         * The status of the backup.
         */
        backupStatus: string;
        /**
         * The type of the backup.
         */
        backupType: string;
        /**
         * The type of the backup create.
         */
        createType: string;
        /**
         * The id of the backup.
         */
        id: string;
    }

    export interface GetBackupsBackupBackupDatabaseDetail {
        /**
         * External backup download link.
         */
        backupDownloadLinkEip: string;
        /**
         * Intranet backup download link.
         */
        backupDownloadLinkInner: string;
        /**
         * The end time of the backup.
         */
        backupEndTime: string;
        /**
         * The name of the backup file.
         */
        backupFileName: string;
        /**
         * The size of the backup file.
         */
        backupFileSize: number;
        /**
         * The start time of the backup.
         */
        backupStartTime: string;
        /**
         * The type of the backup.
         */
        backupType: string;
        /**
         * The name of the database.
         */
        databaseName: string;
        /**
         * Backup file preparation progress, unit: %.
         */
        downloadProgress: number;
        /**
         * Download status.
         */
        downloadStatus: string;
        /**
         * Download link expiration time.
         */
        linkExpiredTime: string;
    }

    export interface GetInstancesInstance {
        /**
         * The used backup space of the instance. Unit: GiB.
         */
        backupUse: number;
        /**
         * The charge detail.
         */
        chargeDetails: outputs.rds_mssql.GetInstancesInstanceChargeDetail[];
        /**
         * The connection info of the instance.
         */
        connectionInfos: outputs.rds_mssql.GetInstancesInstanceConnectionInfo[];
        /**
         * Node creation time.
         */
        createTime: string;
        /**
         * Compatible version. Valid values: `SQLServer_2019_Std`, `SQLServer_2019_Web`, `SQLServer_2019_Ent`.
         */
        dbEngineVersion: string;
        /**
         * The id of the instance.
         */
        id: string;
        /**
         * The inner version of the instance.
         */
        innerVersion: string;
        /**
         * The instance category.
         */
        instanceCategory: string;
        /**
         * Id of the instance.
         */
        instanceId: string;
        /**
         * Name of the instance.
         */
        instanceName: string;
        /**
         * Status of the instance.
         */
        instanceStatus: string;
        /**
         * Instance type. Valid values: `HA`, `Basic`, `Cluster`.
         */
        instanceType: string;
        /**
         * The Memory.
         */
        memory: number;
        /**
         * Node detail information.
         */
        nodeDetailInfos: outputs.rds_mssql.GetInstancesInstanceNodeDetailInfo[];
        /**
         * The node spec.
         */
        nodeSpec: string;
        /**
         * The count of instance parameters.
         */
        parameterCount: number;
        /**
         * The list of instance parameters.
         */
        parameters: outputs.rds_mssql.GetInstancesInstanceParameter[];
        /**
         * The port of the instance.
         */
        port: string;
        /**
         * The id of the primary instance.
         */
        primaryInstanceId: string;
        /**
         * The project name.
         */
        projectName: string;
        /**
         * The number of read only instance.
         */
        readOnlyNumber: number;
        /**
         * The region id.
         */
        regionId: string;
        /**
         * Server sorting rules.
         */
        serverCollation: string;
        /**
         * Whether to enable slow query function.
         */
        slowQueryEnable: boolean;
        /**
         * The slow query time. Unit: second.
         */
        slowQueryTime: string;
        /**
         * The storage space.
         */
        storageSpace: number;
        /**
         * The storage type.
         */
        storageType: string;
        /**
         * The used storage space.
         */
        storageUse: number;
        /**
         * The subnet id.
         */
        subnetId: string;
        /**
         * Tags.
         */
        tags: outputs.rds_mssql.GetInstancesInstanceTag[];
        /**
         * The time zone.
         */
        timeZone: string;
        /**
         * The update time of the instance.
         */
        updateTime: string;
        /**
         * The CPU size of the instance. For example: 1 represents 1U.
         */
        vCpu: number;
        /**
         * The vpc id.
         */
        vpcId: string;
        /**
         * The id of the zone.
         */
        zoneId: string;
    }

    export interface GetInstancesInstanceChargeDetail {
        /**
         * Whether to enable automatic renewal in the prepaid scenario. This parameter can be set when ChargeType is Prepaid.
         */
        autoRenew: boolean;
        /**
         * Charge end time.
         */
        chargeEndTime: string;
        /**
         * Charge start time.
         */
        chargeStartTime: string;
        /**
         * The charge status.
         */
        chargeStatus: string;
        /**
         * The charge type. Valid values: `PostPaid`, `PrePaid`.
         */
        chargeType: string;
        /**
         * Expected release time when overdue fees are shut down.
         */
        overdueReclaimTime: string;
        /**
         * Time for Disconnection due to Unpaid Fees.
         */
        overdueTime: string;
        /**
         * Purchase duration in a prepaid scenario.
         */
        period: number;
        /**
         * Purchase cycle in prepaid scenarios. This parameter can be set when ChargeType is Prepaid.
         */
        periodUnit: string;
    }

    export interface GetInstancesInstanceConnectionInfo {
        /**
         * The address info.
         */
        addresses: outputs.rds_mssql.GetInstancesInstanceConnectionInfoAddress[];
        /**
         * The description.
         */
        description: string;
        /**
         * The endpoint id.
         */
        endpointId: string;
        /**
         * The endpoint name.
         */
        endpointName: string;
        /**
         * The endpoint type.
         */
        endpointType: string;
    }

    export interface GetInstancesInstanceConnectionInfoAddress {
        /**
         * Whether to enable private to public network resolution.
         */
        dnsVisibility: boolean;
        /**
         * The domain.
         */
        domain: string;
        /**
         * The eip id for public address.
         */
        eipId: string;
        /**
         * The ip address.
         */
        ipAddress: string;
        /**
         * The network type.
         */
        networkType: string;
        /**
         * The port of the instance.
         */
        port: string;
        /**
         * The subnet id.
         */
        subnetId: string;
    }

    export interface GetInstancesInstanceNodeDetailInfo {
        /**
         * Node creation time.
         */
        createTime: string;
        /**
         * Id of the instance.
         */
        instanceId: string;
        /**
         * The Memory.
         */
        memory: number;
        /**
         * The Node ID.
         */
        nodeId: string;
        /**
         * The node ip.
         */
        nodeIp: string;
        /**
         * The node spec.
         */
        nodeSpec: string;
        /**
         * The node status.
         */
        nodeStatus: string;
        /**
         * The node type.
         */
        nodeType: string;
        /**
         * The region id.
         */
        regionId: string;
        /**
         * The update time of the instance.
         */
        updateTime: string;
        /**
         * The CPU size of the instance. For example: 1 represents 1U.
         */
        vCpu: number;
        /**
         * The id of the zone.
         */
        zoneId: string;
    }

    export interface GetInstancesInstanceParameter {
        /**
         * The valid value range of the parameter.
         */
        checkingCode: string;
        /**
         * Indicates whether the parameter running value can be modified.
         */
        forceModify: boolean;
        /**
         * Indicates whether the instance needs to be restarted to take effect after modifying the running value of the parameter.
         */
        forceRestart: boolean;
        /**
         * The default value of the parameter.
         */
        parameterDefaultValue: string;
        /**
         * The description of the parameter.
         */
        parameterDescription: string;
        /**
         * The name of the parameter.
         */
        parameterName: string;
        /**
         * The type of the parameter.
         */
        parameterType: string;
        /**
         * The value of the parameter.
         */
        parameterValue: string;
    }

    export interface GetInstancesInstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetInstancesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetRegionsRegion {
        /**
         * The id of the region.
         */
        regionId: string;
        /**
         * The name of region.
         */
        regionName: string;
    }

    export interface GetZonesZone {
        /**
         * The description of the zone.
         */
        description: string;
        /**
         * The id of the zone.
         */
        id: string;
        /**
         * The id of the zone.
         */
        zoneId: string;
        /**
         * The name of the zone.
         */
        zoneName: string;
    }

    export interface InstanceChargeInfo {
        /**
         * Whether to enable automatic renewal in the prepaid scenario. This parameter can be set when the ChargeType is `Prepaid`.
         */
        autoRenew: boolean;
        /**
         * Charge end time.
         */
        chargeEndTime: string;
        /**
         * Charge start time.
         */
        chargeStartTime: string;
        /**
         * The charge status.
         */
        chargeStatus: string;
        /**
         * The charge type. Valid values: `PostPaid`, `PrePaid`.
         */
        chargeType: string;
        /**
         * Expected release time when overdue fees are shut down.
         */
        overdueReclaimTime: string;
        /**
         * Time for Disconnection due to Unpaid Fees.
         */
        overdueTime: string;
        /**
         * Purchase duration in a prepaid scenario. This parameter is required when the ChargeType is `Prepaid`.
         */
        period: number;
    }

    export interface InstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface InstancesInstance {
        /**
         * The used backup space of the instance. Unit: GiB.
         */
        backupUse: number;
        /**
         * The charge detail.
         */
        chargeDetails: outputs.rds_mssql.InstancesInstanceChargeDetail[];
        /**
         * The connection info of the instance.
         */
        connectionInfos: outputs.rds_mssql.InstancesInstanceConnectionInfo[];
        /**
         * Node creation time.
         */
        createTime: string;
        /**
         * Compatible version. Valid values: `SQLServer_2019_Std`, `SQLServer_2019_Web`, `SQLServer_2019_Ent`.
         */
        dbEngineVersion: string;
        /**
         * The id of the instance.
         */
        id: string;
        /**
         * The inner version of the instance.
         */
        innerVersion: string;
        /**
         * The instance category.
         */
        instanceCategory: string;
        /**
         * Id of the instance.
         */
        instanceId: string;
        /**
         * Name of the instance.
         */
        instanceName: string;
        /**
         * Status of the instance.
         */
        instanceStatus: string;
        /**
         * Instance type. Valid values: `HA`, `Basic`, `Cluster`.
         */
        instanceType: string;
        /**
         * The Memory.
         */
        memory: number;
        /**
         * Node detail information.
         */
        nodeDetailInfos: outputs.rds_mssql.InstancesInstanceNodeDetailInfo[];
        /**
         * The node spec.
         */
        nodeSpec: string;
        /**
         * The count of instance parameters.
         */
        parameterCount: number;
        /**
         * The list of instance parameters.
         */
        parameters: outputs.rds_mssql.InstancesInstanceParameter[];
        /**
         * The port of the instance.
         */
        port: string;
        /**
         * The id of the primary instance.
         */
        primaryInstanceId: string;
        /**
         * The project name.
         */
        projectName: string;
        /**
         * The number of read only instance.
         */
        readOnlyNumber: number;
        /**
         * The region id.
         */
        regionId: string;
        /**
         * Server sorting rules.
         */
        serverCollation: string;
        /**
         * Whether to enable slow query function.
         */
        slowQueryEnable: boolean;
        /**
         * The slow query time. Unit: second.
         */
        slowQueryTime: string;
        /**
         * The storage space.
         */
        storageSpace: number;
        /**
         * The storage type.
         */
        storageType: string;
        /**
         * The used storage space.
         */
        storageUse: number;
        /**
         * The subnet id.
         */
        subnetId: string;
        /**
         * Tags.
         */
        tags: outputs.rds_mssql.InstancesInstanceTag[];
        /**
         * The time zone.
         */
        timeZone: string;
        /**
         * The update time of the instance.
         */
        updateTime: string;
        /**
         * The CPU size of the instance. For example: 1 represents 1U.
         */
        vCpu: number;
        /**
         * The vpc id.
         */
        vpcId: string;
        /**
         * The id of the zone.
         */
        zoneId: string;
    }

    export interface InstancesInstanceChargeDetail {
        /**
         * Whether to enable automatic renewal in the prepaid scenario. This parameter can be set when ChargeType is Prepaid.
         */
        autoRenew: boolean;
        /**
         * Charge end time.
         */
        chargeEndTime: string;
        /**
         * Charge start time.
         */
        chargeStartTime: string;
        /**
         * The charge status.
         */
        chargeStatus: string;
        /**
         * The charge type. Valid values: `PostPaid`, `PrePaid`.
         */
        chargeType: string;
        /**
         * Expected release time when overdue fees are shut down.
         */
        overdueReclaimTime: string;
        /**
         * Time for Disconnection due to Unpaid Fees.
         */
        overdueTime: string;
        /**
         * Purchase duration in a prepaid scenario.
         */
        period: number;
        /**
         * Purchase cycle in prepaid scenarios. This parameter can be set when ChargeType is Prepaid.
         */
        periodUnit: string;
    }

    export interface InstancesInstanceConnectionInfo {
        /**
         * The address info.
         */
        addresses: outputs.rds_mssql.InstancesInstanceConnectionInfoAddress[];
        /**
         * The description.
         */
        description: string;
        /**
         * The endpoint id.
         */
        endpointId: string;
        /**
         * The endpoint name.
         */
        endpointName: string;
        /**
         * The endpoint type.
         */
        endpointType: string;
    }

    export interface InstancesInstanceConnectionInfoAddress {
        /**
         * Whether to enable private to public network resolution.
         */
        dnsVisibility: boolean;
        /**
         * The domain.
         */
        domain: string;
        /**
         * The eip id for public address.
         */
        eipId: string;
        /**
         * The ip address.
         */
        ipAddress: string;
        /**
         * The network type.
         */
        networkType: string;
        /**
         * The port of the instance.
         */
        port: string;
        /**
         * The subnet id.
         */
        subnetId: string;
    }

    export interface InstancesInstanceNodeDetailInfo {
        /**
         * Node creation time.
         */
        createTime: string;
        /**
         * Id of the instance.
         */
        instanceId: string;
        /**
         * The Memory.
         */
        memory: number;
        /**
         * The Node ID.
         */
        nodeId: string;
        /**
         * The node ip.
         */
        nodeIp: string;
        /**
         * The node spec.
         */
        nodeSpec: string;
        /**
         * The node status.
         */
        nodeStatus: string;
        /**
         * The node type.
         */
        nodeType: string;
        /**
         * The region id.
         */
        regionId: string;
        /**
         * The update time of the instance.
         */
        updateTime: string;
        /**
         * The CPU size of the instance. For example: 1 represents 1U.
         */
        vCpu: number;
        /**
         * The id of the zone.
         */
        zoneId: string;
    }

    export interface InstancesInstanceParameter {
        /**
         * The valid value range of the parameter.
         */
        checkingCode: string;
        /**
         * Indicates whether the parameter running value can be modified.
         */
        forceModify: boolean;
        /**
         * Indicates whether the instance needs to be restarted to take effect after modifying the running value of the parameter.
         */
        forceRestart: boolean;
        /**
         * The default value of the parameter.
         */
        parameterDefaultValue: string;
        /**
         * The description of the parameter.
         */
        parameterDescription: string;
        /**
         * The name of the parameter.
         */
        parameterName: string;
        /**
         * The type of the parameter.
         */
        parameterType: string;
        /**
         * The value of the parameter.
         */
        parameterValue: string;
    }

    export interface InstancesInstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface InstancesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface RegionsRegion {
        /**
         * The id of the region.
         */
        regionId: string;
        /**
         * The name of region.
         */
        regionName: string;
    }

    export interface ZonesZone {
        /**
         * The description of the zone.
         */
        description: string;
        /**
         * The id of the zone.
         */
        id: string;
        /**
         * The id of the zone.
         */
        zoneId: string;
        /**
         * The name of the zone.
         */
        zoneName: string;
    }

}

export namespace rds_mysql {
    export interface AccountAccountPrivilege {
        /**
         * The privilege type of the account.
         */
        accountPrivilege: string;
        /**
         * The privilege detail of the account.
         */
        accountPrivilegeDetail?: string;
        /**
         * The name of database.
         */
        dbName: string;
    }

    export interface AccountTableColumnInfosTableInfo {
        /**
         * The column privileges of the account.
         */
        accountPrivileges: string[];
        /**
         * The column permission information of the account.
         */
        columnInfos: outputs.rds_mysql.AccountTableColumnInfosTableInfoColumnInfo[];
        /**
         * The name of the table.
         */
        tableName: string;
    }

    export interface AccountTableColumnInfosTableInfoColumnInfo {
        /**
         * The column privileges of the account.
         */
        accountPrivileges: string[];
        /**
         * The name of the column.
         */
        columnName: string;
    }

    export interface AccountTableColumnPrivilege {
        /**
         * Column permission information of the account.
         */
        columnPrivileges?: outputs.rds_mysql.AccountTableColumnPrivilegeColumnPrivilege[];
        /**
         * Settings for table column permissions of the account.
         */
        dbName: string;
        /**
         * Table permission information of the account.
         */
        tablePrivileges?: outputs.rds_mysql.AccountTableColumnPrivilegeTablePrivilege[];
    }

    export interface AccountTableColumnPrivilegeColumnPrivilege {
        /**
         * Table privileges of the account.
         */
        accountPrivilegeDetail: string;
        /**
         * The name of the column for setting permissions on the account.
         */
        columnName: string;
        /**
         * The name of the table for setting permissions on the account.
         */
        tableName: string;
    }

    export interface AccountTableColumnPrivilegeTablePrivilege {
        /**
         * Table privileges of the account.
         */
        accountPrivilegeDetail: string;
        /**
         * The name of the table for setting permissions on the account.
         */
        tableName: string;
    }

    export interface AccountsAccount {
        /**
         * The description information of the account.
         */
        accountDesc: string;
        /**
         * The name of the database account. This field supports fuzzy query.
         */
        accountName: string;
        /**
         * The privilege detail list of RDS mysql instance account.
         */
        accountPrivileges: outputs.rds_mysql.AccountsAccountAccountPrivilege[];
        /**
         * The SQL statement of the account privileges.
         */
        accountPrivilegesSqls: string[];
        /**
         * The status of the database account.
         */
        accountStatus: string;
        /**
         * The type of the database account.
         */
        accountType: string;
        /**
         * The global privileges of the account.
         */
        globalAccountPrivileges: string[];
        /**
         * The databases to which the table column permissions owned by the account belong. Description: If the account does not have table column permissions, this field will not be returned.
         */
        hasTableColumnPrivilegeDbNames: string[];
        /**
         * The host of the account.
         */
        host: string;
    }

    export interface AccountsAccountAccountPrivilege {
        /**
         * The privilege type of the account.
         */
        accountPrivilege: string;
        /**
         * The privilege detail of the account.
         */
        accountPrivilegeDetail: string;
        /**
         * The name of database.
         */
        dbName: string;
    }

    export interface AllowlistSecurityGroupBindInfo {
        /**
         * The schema for the associated security group.
         * IngressDirectionIp: Incoming Direction IP.
         * AssociateEcsIp: Associate ECSIP.
         * explain: In the CreateAllowList interface, SecurityGroupBindInfoObject BindMode and SecurityGroupId fields are required.
         */
        bindMode: string;
        /**
         * The security group id of the allow list.
         */
        securityGroupId: string;
    }

    export interface AllowlistsAllowList {
        /**
         * White list category. Values:
         * Ordinary: Ordinary white list. Default: Default white list. Description: When this parameter is used as a request parameter, the default value is Ordinary.
         */
        allowListCategory: string;
        /**
         * The description of the allow list.
         */
        allowListDesc: string;
        /**
         * The id of the allow list.
         */
        allowListId: string;
        /**
         * The total number of IP addresses (or address ranges) in the whitelist.
         */
        allowListIpNum: number;
        /**
         * The name of the allow list.
         */
        allowListName: string;
        /**
         * The type of the allow list.
         */
        allowListType: string;
        /**
         * The IP address or a range of IP addresses in CIDR format.
         */
        allowLists: string[];
        /**
         * The total number of instances bound under the whitelist.
         */
        associatedInstanceNum: number;
        /**
         * The list of instances.
         */
        associatedInstances: outputs.rds_mysql.AllowlistsAllowListAssociatedInstance[];
        /**
         * Whitelist information for the associated security group.
         */
        securityGroupBindInfos: outputs.rds_mysql.AllowlistsAllowListSecurityGroupBindInfo[];
        /**
         * IP addresses outside the security group that need to be added to the whitelist. IP addresses or IP address segments in CIDR format can be entered. Note: This field cannot be used simultaneously with AllowList.
         */
        userAllowLists: string[];
    }

    export interface AllowlistsAllowListAssociatedInstance {
        /**
         * Instance ID. When an InstanceId is specified, the DescribeAllowLists interface will return the whitelist bound to the specified instance.
         */
        instanceId: string;
        /**
         * The name of the instance.
         */
        instanceName: string;
        /**
         * The id of the vpc.
         */
        vpc: string;
    }

    export interface AllowlistsAllowListSecurityGroupBindInfo {
        /**
         * The schema for the associated security group.
         * IngressDirectionIp: Incoming Direction IP.
         * AssociateEcsIp: Associate ECSIP.
         * explain: In the CreateAllowList interface, SecurityGroupBindInfoObject BindMode and SecurityGroupId fields are required.
         */
        bindMode: string;
        /**
         * The ip list of the security group.
         */
        ipLists: string[];
        /**
         * The security group id of the allow list.
         */
        securityGroupId: string;
        /**
         * The name of the security group.
         */
        securityGroupName: string;
    }

    export interface BackupBackupMeta {
        /**
         * Specify the database that needs to be backed up.
         */
        dbName: string;
        /**
         * Specify the tables to be backed up in the specified database. When this field is empty, it defaults to full database backup.
         */
        tableNames?: string[];
    }

    export interface BackupPolicyCrossBackupPolicy {
        /**
         * Whether to enable cross-region backup.
         * true: Enable.
         * false: Disable. Default value.
         */
        backupEnabled: boolean;
        /**
         * The destination region ID for cross-region backup. When the value of BackupEnabled is true, this parameter is required.
         */
        crossBackupRegion?: string;
        /**
         * Whether to enable cross-region log backup. true: Enable. false: Disable. Default value. Description: Cross-region log backup can only be enabled when cross-region backup is enabled.
         */
        logBackupEnabled: boolean;
        /**
         * The number of days to retain cross - region backups, with a value range of 7 to 1825 days.
         */
        retention: number;
    }

    export interface BackupsBackup {
        /**
         * The end time of the backup.
         */
        backupEndTime: string;
        /**
         * Backup file name.
         */
        backupFileName: string;
        /**
         * Backup file size, in bytes.
         */
        backupFileSize: number;
        /**
         * The id of the backup.
         */
        backupId: string;
        /**
         * Backup type, value: Physical: Physical backup. Default value. Logical: Logical backup. Description: There is no default value. When this field is not passed, backups of all states under the query conditions limited by other fields are returned.
         */
        backupMethod: string;
        /**
         * The region where the backup is located.
         */
        backupRegion: string;
        /**
         * The start time of the backup.
         */
        backupStartTime: string;
        /**
         * Backup status, values: Success: Success. Failed: Failed. Running: In progress. Description: There is no default value. When this field is not passed, all backups in all states under the query conditions limited by other fields are returned.
         */
        backupStatus: string;
        /**
         * Backup method, value: Full: Full backup under physical backup type or library table backup under logical backup type. Increment: Incremental backup under physical backup type. DumpAll: Full database backup under logical backup type. Description: There is no default value. When this field is not passed, all backups of all methods under the query conditions limited by other fields are returned.
         */
        backupType: string;
        /**
         * The time point of a consistent snapshot is in the format of yyyy-MM-ddTHH:mm:ss.sssZ (UTC time).
         */
        consistentTime: string;
        /**
         * Creator of backup. Values: System: System. User: User. Description: There is no default value. When this field is not passed, all types of backups under the query conditions limited by other fields are returned.
         */
        createType: string;
        /**
         * The database table information contained in the backup set can include up to 10,000 tables.
         * Explanation:
         * When the database is empty, this field is not returned.
         */
        dbTableInfos: outputs.rds_mysql.BackupsBackupDbTableInfo[];
        /**
         * The decryption key of the backup.
         */
        decryptionKey: string;
        /**
         * Download status. Values:
         * NotDownload: Not downloaded.
         * Success: Downloaded.
         * Failed: Download failed.
         * Running: Downloading.
         */
        downloadStatus: string;
        /**
         * Error message.
         */
        errorMessage: string;
        /**
         * Expired time of backup, in the format of yyyy-MM-ddTHH:mm:ss.sssZ (UTC time).
         */
        expiredTime: string;
        /**
         * The id of the backup.
         */
        id: string;
        /**
         * Is the data backup encrypted? Value:
         * true: Encrypted.
         * false: Not encrypted.
         */
        isEncrypted: boolean;
        /**
         * Whether the backup has expired. Value:
         * true: Expired.
         * false: Not expired.
         */
        isExpired: boolean;
        /**
         * Initialization Vector.
         */
        iv: string;
        /**
         * Statistics information about the storage space usage of backups.
         */
        usageStats: outputs.rds_mysql.BackupsBackupUsageStat[];
    }

    export interface BackupsBackupDbTableInfo {
        /**
         * Database name.
         */
        database: string;
        /**
         * Table names.
         */
        tables: string[];
    }

    export interface BackupsBackupUsageStat {
        /**
         * Backup size, in bytes.
         */
        quantity: number;
        /**
         * Statistical time.
         */
        startTime: string;
        /**
         * Statistical items. TotalBasicSpaceUsage: Storage space usage for basic backups. BasicDataBackupUsage: Storage space usage for local data backups. BasicBinlogBackupUsage: Storage space usage for local log backups. TotalCrossRegionSpaceUsage: Storage space usage for cross-region backups. CrossRegionDataBackupUsage: Storage space usage for cross-region data backups. CrossRegionBinlogBackupUsage: Storage space usage for cross-region log backups.
         */
        statItem: string;
    }

    export interface DatabasesDatabase {
        /**
         * The character set of the RDS database.
         */
        characterSetName: string;
        /**
         * The privilege detail list of RDS mysql instance database.
         */
        databasePrivileges: outputs.rds_mysql.DatabasesDatabaseDatabasePrivilege[];
        /**
         * The description information of the RDS database.
         */
        dbDesc: string;
        /**
         * The name of the RDS database.
         */
        dbName: string;
        /**
         * The status of the RDS database.
         */
        dbStatus: string;
    }

    export interface DatabasesDatabaseDatabasePrivilege {
        /**
         * The name of account.
         */
        accountName: string;
        /**
         * The privilege type of the account.
         */
        accountPrivilege: string;
        /**
         * The privilege detail of the account.
         */
        accountPrivilegeDetail: string;
    }

    export interface EndpointReadOnlyNodeWeight {
        /**
         * Read-only nodes require NodeId to be passed, while primary nodes do not require it.
         */
        nodeId?: string;
        /**
         * The primary node needs to pass in the NodeType as Primary, while the read-only node does not need to pass it in.
         */
        nodeType?: string;
        /**
         * The read weight of the node increases by 100, with a maximum value of 10000.
         */
        weight: number;
    }

    export interface EndpointsEndpoint {
        /**
         * Address list.
         */
        addresses: outputs.rds_mysql.EndpointsEndpointAddress[];
        /**
         * When the terminal type is read-write terminal or read-only terminal, it supports setting whether new nodes are automatically added.
         */
        autoAddNewNodes: string;
        /**
         * The description of the mysql endpoint.
         */
        description: string;
        /**
         * Whether global read-only is enabled, value: Enable: Enable. Disable: Disabled.
         */
        enableReadOnly: string;
        /**
         * Whether read-write separation is enabled, value: Enable: Enable. Disable: Disabled.
         */
        enableReadWriteSplitting: string;
        /**
         * The id of the mysql endpoint.
         */
        endpointId: string;
        /**
         * The name of the mysql endpoint.
         */
        endpointName: string;
        /**
         * The endpoint type of the mysql endpoint.
         */
        endpointType: string;
        /**
         * The id of the mysql endpoint.
         */
        id: string;
        /**
         * The list of nodes configured by the connection terminal and the corresponding read-only weights.
         */
        readOnlyNodeWeights: outputs.rds_mysql.EndpointsEndpointReadOnlyNodeWeight[];
        /**
         * The read write mode.
         */
        readWriteMode: string;
    }

    export interface EndpointsEndpointAddress {
        /**
         * DNS Visibility.
         */
        dnsVisibility: boolean;
        /**
         * Connect domain name.
         */
        domain: string;
        /**
         * The ID of the EIP, only valid for Public addresses.
         */
        eipId: string;
        /**
         * The IP Address.
         */
        ipAddress: string;
        /**
         * Network address type, temporarily Private, Public, PublicService.
         */
        networkType: string;
        /**
         * The Port.
         */
        port: string;
        /**
         * Subnet ID, valid only for private addresses.
         */
        subnetId: string;
    }

    export interface EndpointsEndpointReadOnlyNodeWeight {
        /**
         * The ID of the node.
         */
        nodeId: string;
        /**
         * The type of the node.
         */
        nodeType: string;
        /**
         * The weight of the node.
         */
        weight: number;
    }

    export interface GetAccountTableColumnInfosTableInfo {
        /**
         * The column privileges of the account.
         */
        accountPrivileges: string[];
        /**
         * The column permission information of the account.
         */
        columnInfos: outputs.rds_mysql.GetAccountTableColumnInfosTableInfoColumnInfo[];
        /**
         * The name of the table.
         */
        tableName: string;
    }

    export interface GetAccountTableColumnInfosTableInfoColumnInfo {
        /**
         * The column privileges of the account.
         */
        accountPrivileges: string[];
        /**
         * The name of the column.
         */
        columnName: string;
    }

    export interface GetAccountsAccount {
        /**
         * The description information of the account.
         */
        accountDesc: string;
        /**
         * The name of the database account. This field supports fuzzy query.
         */
        accountName: string;
        /**
         * The privilege detail list of RDS mysql instance account.
         */
        accountPrivileges: outputs.rds_mysql.GetAccountsAccountAccountPrivilege[];
        /**
         * The SQL statement of the account privileges.
         */
        accountPrivilegesSqls: string[];
        /**
         * The status of the database account.
         */
        accountStatus: string;
        /**
         * The type of the database account.
         */
        accountType: string;
        /**
         * The global privileges of the account.
         */
        globalAccountPrivileges: string[];
        /**
         * The databases to which the table column permissions owned by the account belong. Description: If the account does not have table column permissions, this field will not be returned.
         */
        hasTableColumnPrivilegeDbNames: string[];
        /**
         * The host of the account.
         */
        host: string;
    }

    export interface GetAccountsAccountAccountPrivilege {
        /**
         * The privilege type of the account.
         */
        accountPrivilege: string;
        /**
         * The privilege detail of the account.
         */
        accountPrivilegeDetail: string;
        /**
         * The name of database.
         */
        dbName: string;
    }

    export interface GetAllowlistsAllowList {
        /**
         * White list category. Values:
         * Ordinary: Ordinary white list. Default: Default white list. Description: When this parameter is used as a request parameter, the default value is Ordinary.
         */
        allowListCategory: string;
        /**
         * The description of the allow list.
         */
        allowListDesc: string;
        /**
         * The id of the allow list.
         */
        allowListId: string;
        /**
         * The total number of IP addresses (or address ranges) in the whitelist.
         */
        allowListIpNum: number;
        /**
         * The name of the allow list.
         */
        allowListName: string;
        /**
         * The type of the allow list.
         */
        allowListType: string;
        /**
         * The IP address or a range of IP addresses in CIDR format.
         */
        allowLists: string[];
        /**
         * The total number of instances bound under the whitelist.
         */
        associatedInstanceNum: number;
        /**
         * The list of instances.
         */
        associatedInstances: outputs.rds_mysql.GetAllowlistsAllowListAssociatedInstance[];
        /**
         * Whitelist information for the associated security group.
         */
        securityGroupBindInfos: outputs.rds_mysql.GetAllowlistsAllowListSecurityGroupBindInfo[];
        /**
         * IP addresses outside the security group that need to be added to the whitelist. IP addresses or IP address segments in CIDR format can be entered. Note: This field cannot be used simultaneously with AllowList.
         */
        userAllowLists: string[];
    }

    export interface GetAllowlistsAllowListAssociatedInstance {
        /**
         * Instance ID. When an InstanceId is specified, the DescribeAllowLists interface will return the whitelist bound to the specified instance.
         */
        instanceId: string;
        /**
         * The name of the instance.
         */
        instanceName: string;
        /**
         * The id of the vpc.
         */
        vpc: string;
    }

    export interface GetAllowlistsAllowListSecurityGroupBindInfo {
        /**
         * The schema for the associated security group.
         * IngressDirectionIp: Incoming Direction IP.
         * AssociateEcsIp: Associate ECSIP.
         * explain: In the CreateAllowList interface, SecurityGroupBindInfoObject BindMode and SecurityGroupId fields are required.
         */
        bindMode: string;
        /**
         * The ip list of the security group.
         */
        ipLists: string[];
        /**
         * The security group id of the allow list.
         */
        securityGroupId: string;
        /**
         * The name of the security group.
         */
        securityGroupName: string;
    }

    export interface GetBackupsBackup {
        /**
         * The end time of the backup.
         */
        backupEndTime: string;
        /**
         * Backup file name.
         */
        backupFileName: string;
        /**
         * Backup file size, in bytes.
         */
        backupFileSize: number;
        /**
         * The id of the backup.
         */
        backupId: string;
        /**
         * Backup type, value: Physical: Physical backup. Default value. Logical: Logical backup. Description: There is no default value. When this field is not passed, backups of all states under the query conditions limited by other fields are returned.
         */
        backupMethod: string;
        /**
         * The region where the backup is located.
         */
        backupRegion: string;
        /**
         * The start time of the backup.
         */
        backupStartTime: string;
        /**
         * Backup status, values: Success: Success. Failed: Failed. Running: In progress. Description: There is no default value. When this field is not passed, all backups in all states under the query conditions limited by other fields are returned.
         */
        backupStatus: string;
        /**
         * Backup method, value: Full: Full backup under physical backup type or library table backup under logical backup type. Increment: Incremental backup under physical backup type. DumpAll: Full database backup under logical backup type. Description: There is no default value. When this field is not passed, all backups of all methods under the query conditions limited by other fields are returned.
         */
        backupType: string;
        /**
         * The time point of a consistent snapshot is in the format of yyyy-MM-ddTHH:mm:ss.sssZ (UTC time).
         */
        consistentTime: string;
        /**
         * Creator of backup. Values: System: System. User: User. Description: There is no default value. When this field is not passed, all types of backups under the query conditions limited by other fields are returned.
         */
        createType: string;
        /**
         * The database table information contained in the backup set can include up to 10,000 tables.
         * Explanation:
         * When the database is empty, this field is not returned.
         */
        dbTableInfos: outputs.rds_mysql.GetBackupsBackupDbTableInfo[];
        /**
         * The decryption key of the backup.
         */
        decryptionKey: string;
        /**
         * Download status. Values:
         * NotDownload: Not downloaded.
         * Success: Downloaded.
         * Failed: Download failed.
         * Running: Downloading.
         */
        downloadStatus: string;
        /**
         * Error message.
         */
        errorMessage: string;
        /**
         * Expired time of backup, in the format of yyyy-MM-ddTHH:mm:ss.sssZ (UTC time).
         */
        expiredTime: string;
        /**
         * The id of the backup.
         */
        id: string;
        /**
         * Is the data backup encrypted? Value:
         * true: Encrypted.
         * false: Not encrypted.
         */
        isEncrypted: boolean;
        /**
         * Whether the backup has expired. Value:
         * true: Expired.
         * false: Not expired.
         */
        isExpired: boolean;
        /**
         * Initialization Vector.
         */
        iv: string;
        /**
         * Statistics information about the storage space usage of backups.
         */
        usageStats: outputs.rds_mysql.GetBackupsBackupUsageStat[];
    }

    export interface GetBackupsBackupDbTableInfo {
        /**
         * Database name.
         */
        database: string;
        /**
         * Table names.
         */
        tables: string[];
    }

    export interface GetBackupsBackupUsageStat {
        /**
         * Backup size, in bytes.
         */
        quantity: number;
        /**
         * Statistical time.
         */
        startTime: string;
        /**
         * Statistical items. TotalBasicSpaceUsage: Storage space usage for basic backups. BasicDataBackupUsage: Storage space usage for local data backups. BasicBinlogBackupUsage: Storage space usage for local log backups. TotalCrossRegionSpaceUsage: Storage space usage for cross-region backups. CrossRegionDataBackupUsage: Storage space usage for cross-region data backups. CrossRegionBinlogBackupUsage: Storage space usage for cross-region log backups.
         */
        statItem: string;
    }

    export interface GetDatabasesDatabase {
        /**
         * The character set of the RDS database.
         */
        characterSetName: string;
        /**
         * The privilege detail list of RDS mysql instance database.
         */
        databasePrivileges: outputs.rds_mysql.GetDatabasesDatabaseDatabasePrivilege[];
        /**
         * The description information of the RDS database.
         */
        dbDesc: string;
        /**
         * The name of the RDS database.
         */
        dbName: string;
        /**
         * The status of the RDS database.
         */
        dbStatus: string;
    }

    export interface GetDatabasesDatabaseDatabasePrivilege {
        /**
         * The name of account.
         */
        accountName: string;
        /**
         * The privilege type of the account.
         */
        accountPrivilege: string;
        /**
         * The privilege detail of the account.
         */
        accountPrivilegeDetail: string;
    }

    export interface GetEndpointsEndpoint {
        /**
         * Address list.
         */
        addresses: outputs.rds_mysql.GetEndpointsEndpointAddress[];
        /**
         * When the terminal type is read-write terminal or read-only terminal, it supports setting whether new nodes are automatically added.
         */
        autoAddNewNodes: string;
        /**
         * The description of the mysql endpoint.
         */
        description: string;
        /**
         * Whether global read-only is enabled, value: Enable: Enable. Disable: Disabled.
         */
        enableReadOnly: string;
        /**
         * Whether read-write separation is enabled, value: Enable: Enable. Disable: Disabled.
         */
        enableReadWriteSplitting: string;
        /**
         * The id of the mysql endpoint.
         */
        endpointId: string;
        /**
         * The name of the mysql endpoint.
         */
        endpointName: string;
        /**
         * The endpoint type of the mysql endpoint.
         */
        endpointType: string;
        /**
         * The id of the mysql endpoint.
         */
        id: string;
        /**
         * The list of nodes configured by the connection terminal and the corresponding read-only weights.
         */
        readOnlyNodeWeights: outputs.rds_mysql.GetEndpointsEndpointReadOnlyNodeWeight[];
        /**
         * The read write mode.
         */
        readWriteMode: string;
    }

    export interface GetEndpointsEndpointAddress {
        /**
         * DNS Visibility.
         */
        dnsVisibility: boolean;
        /**
         * Connect domain name.
         */
        domain: string;
        /**
         * The ID of the EIP, only valid for Public addresses.
         */
        eipId: string;
        /**
         * The IP Address.
         */
        ipAddress: string;
        /**
         * Network address type, temporarily Private, Public, PublicService.
         */
        networkType: string;
        /**
         * The Port.
         */
        port: string;
        /**
         * Subnet ID, valid only for private addresses.
         */
        subnetId: string;
    }

    export interface GetEndpointsEndpointReadOnlyNodeWeight {
        /**
         * The ID of the node.
         */
        nodeId: string;
        /**
         * The type of the node.
         */
        nodeType: string;
        /**
         * The weight of the node.
         */
        weight: number;
    }

    export interface GetInstanceSpecsInstanceSpec {
        /**
         * Default value of maximum number of connections.
         */
        connection: number;
        /**
         * Compatible version. Values:
         * MySQL_5_7: MySQL 5.7 version. Default value.
         * MySQL_8_0: MySQL 8.0 version.
         */
        dbEngineVersion: string;
        /**
         * Instance type. The value is DoubleNode.
         */
        instanceType: string;
        /**
         * Maximum IOPS per second.
         */
        iops: number;
        /**
         * Memory size, in GB.
         */
        memory: number;
        /**
         * Queries Per Second (QPS).
         */
        qps: number;
        /**
         * The id of the region.
         */
        regionId: string;
        /**
         * Instance specification code.
         */
        specCode: string;
        /**
         * Instance specification type. Values:
         * General: Exclusive specification (formerly "General Purpose").
         * Shared: General specification (formerly "Shared Type").
         */
        specFamily: string;
        /**
         * The status of the available zone where the specification is located includes the following statuses:
         * Normal: On sale.
         * Soldout: Sold out.
         */
        specStatus: string;
        /**
         * Maximum storage space, in GB.
         */
        storageMax: number;
        /**
         * Minimum storage space, in GB.
         */
        storageMin: number;
        /**
         * Disk step size, in GB.
         */
        storageStep: number;
        /**
         * Number of vCPUs.
         */
        vcpu: number;
        /**
         * Availability zone ID.
         */
        zoneId: string;
    }

    export interface GetInstancesRdsMysqlInstance {
        /**
         * The version of allow list.
         */
        allowListVersion: string;
        /**
         * Auto - storage scaling configuration.
         */
        autoStorageScalingConfigs: outputs.rds_mysql.GetInstancesRdsMysqlInstanceAutoStorageScalingConfig[];
        /**
         * The upgrade strategy for the minor version of the instance kernel. Values:
         * Auto: Auto upgrade.
         * Manual: Manual upgrade.
         */
        autoUpgradeMinorVersion: string;
        /**
         * The instance has used backup space. Unit: GB.
         */
        backupUse: number;
        /**
         * Does it support the binlog capability? This parameter is returned only when the database proxy is enabled. Values:
         * true: Yes.
         * false: No.
         */
        binlogDump: boolean;
        /**
         * Payment methods.
         */
        chargeDetail: outputs.rds_mysql.GetInstancesRdsMysqlInstanceChargeDetail;
        /**
         * Connection pool type.
         */
        connectionPoolType: string;
        /**
         * Node creation local time.
         */
        createTime: string;
        /**
         * Data synchronization mode.
         */
        dataSyncMode: string;
        /**
         * The version of the RDS instance.
         */
        dbEngineVersion: string;
        /**
         * The running status of the proxy instance. This parameter is returned only when the database proxy is enabled. Values:
         * Creating: The proxy is being started.
         * Running: The proxy is running.
         * Shutdown: The proxy is closed.
         * Deleting: The proxy is being closed.
         */
        dbProxyStatus: string;
        /**
         * Whether to enable the deletion protection function. Values:
         * Enabled: Yes.
         * Disabled: No.
         */
        deletionProtection: string;
        /**
         * The ID of the data synchronization task in DTS for the data synchronization link between the primary instance and the disaster recovery instance.
         */
        drDtsTaskId: string;
        /**
         * The name of the DTS data synchronization task for the data synchronization link between the primary instance and the disaster recovery instance.
         */
        drDtsTaskName: string;
        /**
         * The status of the DTS data synchronization task for the data synchronization link between the primary instance and the disaster recovery instance.
         */
        drDtsTaskStatus: string;
        /**
         * The number of seconds that the disaster recovery instance is behind the primary instance.
         */
        drSecondsBehindMaster: number;
        /**
         * The endpoint info of the RDS instance.
         */
        endpoints: outputs.rds_mysql.GetInstancesRdsMysqlInstanceEndpoint[];
        /**
         * Feature status.
         */
        featureStates: outputs.rds_mysql.GetInstancesRdsMysqlInstanceFeatureState[];
        /**
         * Whether to enable global read-only.
         * true: Yes.
         * false: No.
         */
        globalReadOnly: boolean;
        /**
         * The ID of the RDS instance.
         */
        id: string;
        /**
         * The id of the RDS instance.
         */
        instanceId: string;
        /**
         * The name of the RDS instance.
         */
        instanceName: string;
        /**
         * The status of the RDS instance.
         */
        instanceStatus: string;
        /**
         * The kernel version of the instance.
         */
        kernelVersion: string;
        /**
         * Whether the table name is case sensitive, the default value is 1.
         * Ranges:
         * 0: Table names are stored as fixed and table names are case-sensitive.
         * 1: Table names will be stored in lowercase and table names are not case sensitive.
         */
        lowerCaseTableNames: string;
        /**
         * Maintenance Window.
         */
        maintenanceWindows: outputs.rds_mysql.GetInstancesRdsMysqlInstanceMaintenanceWindow[];
        /**
         * The ID of the primary instance of the disaster recovery instance.
         */
        masterInstanceId: string;
        /**
         * The name of the primary instance of the disaster recovery instance.
         */
        masterInstanceName: string;
        /**
         * The region where the primary instance of the disaster recovery instance is located.
         */
        masterRegion: string;
        /**
         * Memory size in GB.
         */
        memory: number;
        /**
         * Average CPU usage of the instance master node in nearly one minute.
         */
        nodeCpuUsedPercentage: number;
        /**
         * Average memory usage of the instance master node in nearly one minute.
         */
        nodeMemoryUsedPercentage: number;
        /**
         * The number of nodes.
         */
        nodeNumber: number;
        /**
         * Average disk usage of the instance master node in nearly one minute.
         */
        nodeSpaceUsedPercentage: number;
        /**
         * Primary node specification. For detailed information about the node specifications, please refer to Product Specifications.
         */
        nodeSpec: string;
        /**
         * Instance node information.
         */
        nodes: outputs.rds_mysql.GetInstancesRdsMysqlInstanceNode[];
        /**
         * The project name of the RDS instance.
         */
        projectName: string;
        /**
         * The region of the RDS instance.
         */
        regionId: string;
        /**
         * The upper limit of the storage space that can be set for automatic expansion. The value is the upper limit of the storage space value range corresponding to the instance master node specification, with the unit being GB. For detailed information on the selectable storage space value ranges of different specifications, please refer to Product Specifications.
         */
        storageMaxCapacity: number;
        /**
         * The upper limit of the proportion of available storage space that triggers automatic expansion. When supported, the value is 50%.
         */
        storageMaxTriggerThreshold: number;
        /**
         * The lower limit of the storage space that can be set for automatic expansion. The value is the lower limit of the storage space value range corresponding to the instance master node specification, with the unit being GB. For detailed information on the selectable storage space value ranges of different specifications, please refer to Product Specifications.
         */
        storageMinCapacity: number;
        /**
         * The lower limit of the proportion of available storage space that triggers automatic expansion. When supported, the value is 10%.
         */
        storageMinTriggerThreshold: number;
        /**
         * Total instance storage space. Unit: GB.
         */
        storageSpace: number;
        /**
         * Instance storage type. The value is LocalSSD, indicating a local SSD disk.
         */
        storageType: string;
        /**
         * The instance has used storage space. Unit: GB.
         */
        storageUse: number;
        /**
         * The subnet ID of the RDS instance.
         */
        subnetId: string;
        /**
         * Tags.
         */
        tags: outputs.rds_mysql.GetInstancesRdsMysqlInstanceTag[];
        /**
         * Time zone.
         */
        timeZone: string;
        /**
         * The update time of the RDS instance.
         */
        updateTime: string;
        /**
         * CPU size.
         */
        vCpu: number;
        /**
         * The vpc ID of the RDS instance.
         */
        vpcId: string;
        /**
         * The available zone of the RDS instance.
         */
        zoneId: string;
        /**
         * List of availability zones where each node of the instance is located.
         */
        zoneIds: string[];
    }

    export interface GetInstancesRdsMysqlInstanceAutoStorageScalingConfig {
        /**
         * Whether to enable the instance's auto - scaling function. Values:
         * true: Yes.
         * false: No. Description: When StorageConfig is used as a request parameter, if the value of EnableStorageAutoScale is false, the StorageThreshold and StorageUpperBound parameters do not need to be passed in.
         */
        enableStorageAutoScale: boolean;
        /**
         * The proportion of available storage space that triggers automatic expansion. The value range is 10 to 50, and the default value is 10, with the unit being %.
         */
        storageThreshold: number;
        /**
         * The upper limit of the storage space that can be automatically expanded. The lower limit of the value of this field is the instance storage space + 20GB; the upper limit of the value is the upper limit of the storage space value range corresponding to the instance master node specification, with the unit being GB. For detailed information on the selectable storage space value range of different specifications, please refer to Product Specifications.
         */
        storageUpperBound: number;
    }

    export interface GetInstancesRdsMysqlInstanceChargeDetail {
        /**
         * Whether to automatically renew in prepaid scenarios.
         * Autorenew_Enable
         * Autorenew_Disable (default).
         */
        autoRenew: boolean;
        /**
         * Billing expiry time (yearly and monthly only).
         */
        chargeEndTime: string;
        /**
         * Billing start time (pay-as-you-go & monthly subscription).
         */
        chargeStartTime: string;
        /**
         * Pay status. Value:
         * normal - normal
         * overdue - overdue
         * .
         */
        chargeStatus: string;
        /**
         * The charge type of the RDS instance.
         */
        chargeType: string;
        /**
         * Estimated release time when arrears are closed (pay-as-you-go & monthly subscription).
         */
        overdueReclaimTime: string;
        /**
         * Shutdown time in arrears (pay-as-you-go & monthly subscription).
         */
        overdueTime: string;
        /**
         * Purchase duration in prepaid scenarios. Default: 1.
         */
        period: number;
        /**
         * The purchase cycle in the prepaid scenario.
         * Month - monthly subscription (default)
         * Year - Package year.
         */
        periodUnit: string;
        /**
         * Restore time of temporary upgrade.
         */
        tempModifyEndTime: string;
        /**
         * Temporary upgrade start time.
         */
        tempModifyStartTime: string;
    }

    export interface GetInstancesRdsMysqlInstanceEndpoint {
        /**
         * Address list.
         */
        addresses: outputs.rds_mysql.GetInstancesRdsMysqlInstanceEndpointAddress[];
        /**
         * When the terminal type is read-write terminal or read-only terminal, it supports setting whether new nodes are automatically added.
         */
        autoAddNewNodes: string;
        /**
         * Address description.
         */
        description: string;
        /**
         * Whether global read-only is enabled, value: Enable: Enable. Disable: Disabled.
         */
        enableReadOnly: string;
        /**
         * Whether read-write separation is enabled, value: Enable: Enable. Disable: Disabled.
         */
        enableReadWriteSplitting: string;
        /**
         * Instance connection terminal ID.
         */
        endpointId: string;
        /**
         * The instance connection terminal name.
         */
        endpointName: string;
        /**
         * Terminal type:
         * Cluster: The default terminal. (created by default)
         * Primary: Primary node terminal.
         * Custom: Custom terminal.
         * Direct: Direct connection to the terminal. (Only the operation and maintenance side)
         * AllNode: All node terminals. (Only the operation and maintenance side).
         */
        endpointType: string;
        /**
         * Whether the idle connection reclaim function is enabled. true: Enabled. false: Disabled.
         */
        idleConnectionReclaim: boolean;
        /**
         * The list of nodes configured by the connection terminal and the corresponding read-only weights.
         */
        nodeWeights: outputs.rds_mysql.GetInstancesRdsMysqlInstanceEndpointNodeWeight[];
        /**
         * Read and write mode:
         * ReadWrite: read and write
         * ReadOnly: read only (default).
         */
        readWriteMode: string;
    }

    export interface GetInstancesRdsMysqlInstanceEndpointAddress {
        /**
         * DNS Visibility.
         */
        dnsVisibility: boolean;
        /**
         * Connect domain name.
         */
        domain: string;
        /**
         * The ID of the EIP, only valid for Public addresses.
         */
        eipId: string;
        /**
         * The IP Address.
         */
        ipAddress: string;
        /**
         * Network address type, temporarily Private, Public, PublicService.
         */
        networkType: string;
        /**
         * The Port.
         */
        port: string;
        /**
         * The subnet ID of the RDS instance.
         */
        subnetId: string;
    }

    export interface GetInstancesRdsMysqlInstanceEndpointNodeWeight {
        /**
         * Node ID.
         */
        nodeId: string;
        /**
         * Node type. Value: Primary: Primary node.
         * Secondary: Standby node.
         * ReadOnly: Read-only node.
         */
        nodeType: string;
        /**
         * The weight of the node.
         */
        weight: number;
    }

    export interface GetInstancesRdsMysqlInstanceFeatureState {
        /**
         * Whether it is enabled. Values:
         * true: Enabled.
         * false: Disabled.
         */
        enable: boolean;
        /**
         * Feature name.
         */
        featureName: string;
        /**
         * Whether it support this function. Value:
         * true: Supported.
         * false: Not supported.
         */
        support: boolean;
    }

    export interface GetInstancesRdsMysqlInstanceMaintenanceWindow {
        /**
         * DayKind of maintainable window. Value: Week. Month.
         */
        dayKind: string;
        /**
         * Days of maintainable window of the month.
         */
        dayOfMonths: number[];
        /**
         * Days of maintainable window of the week.
         */
        dayOfWeeks: string[];
        /**
         * The maintainable time of the RDS instance.
         */
        maintenanceTime: string;
    }

    export interface GetInstancesRdsMysqlInstanceNode {
        /**
         * Node creation local time.
         */
        createTime: string;
        /**
         * The id of the RDS instance.
         */
        instanceId: string;
        /**
         * Memory size in GB.
         */
        memory: number;
        /**
         * Node ID.
         */
        nodeId: string;
        /**
         * Primary node specification. For detailed information about the node specifications, please refer to Product Specifications.
         */
        nodeSpec: string;
        /**
         * Node state, value: aligned with instance state.
         */
        nodeStatus: string;
        /**
         * Node type. Value: Primary: Primary node.
         * Secondary: Standby node.
         * ReadOnly: Read-only node.
         */
        nodeType: string;
        /**
         * The region of the RDS instance.
         */
        regionId: string;
        /**
         * The update time of the RDS instance.
         */
        updateTime: string;
        /**
         * CPU size.
         */
        vCpu: number;
        /**
         * The available zone of the RDS instance.
         */
        zoneId: string;
    }

    export interface GetInstancesRdsMysqlInstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetInstancesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetParameterTemplatesTemplate {
        /**
         * The account ID.
         */
        accountId: string;
        /**
         * Creation time.
         */
        createTime: string;
        /**
         * Does the template contain parameters that require restart.
         */
        needRestart: boolean;
        /**
         * The number of parameters contained in the template.
         */
        parameterNum: number;
        /**
         * The project to which the template belongs.
         */
        projectName: string;
        /**
         * Template category, with a value of DBEngine (database engine parameters).
         */
        templateCategory: string;
        /**
         * Parameter template description.
         */
        templateDesc: string;
        /**
         * Parameter template ID.
         */
        templateId: string;
        /**
         * Parameter template name.
         */
        templateName: string;
        /**
         * Parameters contained in the template.
         */
        templateParams: outputs.rds_mysql.GetParameterTemplatesTemplateTemplateParam[];
        /**
         * Parameter template source, value range: System. User.
         */
        templateSource: string;
        /**
         * Database type of parameter template. The default value is Mysql.
         */
        templateType: string;
        /**
         * Database version of parameter template. Value range:
         * MySQL_5_7: Default value. MySQL 5.7 version.
         * MySQL_8_0: MySQL 8.0 version.
         */
        templateTypeVersion: string;
        /**
         * Modification time of the template.
         */
        updateTime: string;
    }

    export interface GetParameterTemplatesTemplateTemplateParam {
        /**
         * Parameter default value.
         */
        defaultValue: string;
        /**
         * Parameter description.
         */
        description: string;
        /**
         * Instance parameter name.
         * Description: When using CreateParameterTemplate and ModifyParameterTemplate as request parameters, only Name and RunningValue need to be passed in.
         */
        name: string;
        /**
         * Is it necessary to restart the instance for the changes to take effect.
         */
        restart: boolean;
        /**
         * Parameter running value.
         * Description: When making requests with CreateParameterTemplate and ModifyParameterTemplate as request parameters, only Name and RunningValue need to be passed in.
         */
        runningValue: string;
        /**
         * Value range of parameters.
         */
        valueRange: string;
    }

    export interface GetPlannedEventsPlannedEvent {
        /**
         * The business impact of the planned event.
         */
        businessImpact: string;
        /**
         * The database engine of the planned event.
         */
        dbEngine: string;
        /**
         * The action of the planned event.
         */
        eventAction: string;
        /**
         * The id of the planned event.
         */
        eventId: string;
        /**
         * The name of the planned event.
         */
        eventName: string;
        /**
         * The type of the planned event.
         */
        eventType: string;
        /**
         * The id of the instance.
         */
        instanceId: string;
        /**
         * The name of the instance.
         */
        instanceName: string;
        /**
         * The latest postponable time. The format is yyyy-MM-ddTHH:mm:ssZ (UTC time).
         */
        maxDelayTime: string;
        /**
         * The initially set start time. The format is yyyy-MM-ddTHH:mm:ssZ (UTC time).
         */
        originBeginTime: string;
        /**
         * The start time of the planned execution. The format is yyyy-MM-ddTHH:mm:ssZ (UTC time).
         */
        plannedBeginTime: string;
        /**
         * The end time of the planned execution. The format is yyyy-MM-ddTHH:mm:ssZ (UTC time).
         */
        plannedEndTime: string;
        /**
         * Description information of the operation and maintenance event.
         */
        plannedEventDescription: string;
        /**
         * The reasons for the occurrence of the event, which are provided to help you understand the reasons for the occurrence of unexpected events.
         */
        plannedEventReason: string;
        /**
         * The start time of the planned switch. The format is yyyy-MM-ddTHH:mm:ssZ (UTC time).
         */
        plannedSwitchBeginTime: string;
        /**
         * The end time of the planned switch. The format is yyyy-MM-ddTHH:mm:ssZ (UTC time).
         */
        plannedSwitchEndTime: string;
        /**
         * The region.
         */
        region: string;
        /**
         * The status of the planned event.
         */
        status: string;
    }

    export interface GetRegionsRegion {
        /**
         * The id of the region.
         */
        regionId: string;
        /**
         * The name of region.
         */
        regionName: string;
    }

    export interface GetTasksData {
        /**
         * The creation time of the task.
         */
        createTime: string;
        /**
         * The completion time of the task.
         */
        finishTime: string;
        /**
         * Task progress. The unit is percentage. Description: Only tasks with a task status of In Progress, that is, tasks with a TaskStatus value of Running, will return the task progress.
         */
        progress: number;
        /**
         * The deadline for the planned startup. The time format is yyyy-MM-ddTHH:mm:ssZ (UTC time). Description: This field will only be returned for tasks in the "Waiting to Start", "Waiting to Execute", or "Waiting to Switch" states.
         */
        scheduledExecuteEndTime: string;
        /**
         * The scheduled end time for the switch. The time format is yyyy-MM-ddTHH:mm:ssZ (UTC time). Description: This field will only be returned for tasks in the "Waiting to Start", "Waiting to Execute", or "Waiting to Switch" states.
         */
        scheduledSwitchEndTime: string;
        /**
         * The start time of the scheduled switch. The time format is yyyy-MM-ddTHH:mm:ssZ (UTC time). Description: This field is returned only for tasks in the "Waiting to Start", "Waiting to Execute", or "Waiting to Switch" state.
         */
        scheduledSwitchStartTime: string;
        /**
         * The start time of the task.
         */
        startTime: string;
        /**
         * Task name.
         */
        taskAction: string;
        /**
         * Task Category. The values are as shown in the following list, and multiple values can be selected: BackupRecoveryManagement: Backup and Recovery Management. DatabaseAdminManagement: Database Administration Management. DatabaseProxy: Database Proxy. HighAvailability: High Availability. InstanceAttribute: Instance Attribute. InstanceManagement: Instance Management. NetworkManagement: Network Management. SecurityManagement: Security Management. SystemMaintainManagement: System Operation and Maintenance Management. VersionUpgrade: Version Upgrade.
         */
        taskCategory: string;
        /**
         * The description of the task.
         */
        taskDesc: string;
        /**
         * Detailed information of the task.
         */
        taskDetails: outputs.rds_mysql.GetTasksDataTaskDetail[];
        /**
         * Task ID. Description: For the two groups of parameters, TaskId and task time (CreationStartTime and CreationEndTime), one of them must be selected.
         */
        taskId: string;
        /**
         * Task parameters.
         */
        taskParams: string;
        /**
         * Progress details.
         */
        taskProgresses: outputs.rds_mysql.GetTasksDataTaskProgress[];
        /**
         * Task status. The values are as shown in the following list, and multiple values can be selected: WaitSwitch: Waiting for switching. WaitStart: Waiting for execution. Canceled: Canceled. Stopped: Terminated. Running_BeforeSwitch: Running (before switching). Timeout: Execution Timeout. Success: Execution Success. Failed: Execution Failed. Running: In Execution. Stopping: In Termination.
         */
        taskStatus: string;
    }

    export interface GetTasksDataTaskDetail {
        /**
         * The log of inspection items for the instance major version upgrade.
         */
        checkItemLog: string;
        /**
         * Check results for major version upgrade.
         */
        checkItems: outputs.rds_mysql.GetTasksDataTaskDetailCheckItem[];
        /**
         * Details of the task.
         */
        taskInfos: outputs.rds_mysql.GetTasksDataTaskDetailTaskInfo[];
    }

    export interface GetTasksDataTaskDetailCheckItem {
        /**
         * Details of the failed check items.
         */
        checkDetails: outputs.rds_mysql.GetTasksDataTaskDetailCheckItemCheckDetail[];
        /**
         * The description of the check item.
         */
        description: string;
        /**
         * The name of the check item.
         */
        itemName: string;
        /**
         * The risk level of the failed check items. Values:
         * Notice: Attention.
         * Warning: Warning.
         * Error: Error.
         */
        riskLevel: string;
    }

    export interface GetTasksDataTaskDetailCheckItemCheckDetail {
        /**
         * The impact of the issue that caused the failure of the check item after the upgrade.
         */
        impact: string;
        /**
         * Problems that caused the failure to pass the check items.
         */
        issue: string;
    }

    export interface GetTasksDataTaskDetailTaskInfo {
        /**
         * The creation time of the task.
         */
        createTime: string;
        /**
         * The completion time of the task.
         */
        finishTime: string;
        /**
         * Task progress. The unit is percentage. Description: Only tasks with a task status of In Progress, that is, tasks with a TaskStatus value of Running, will return the task progress.
         */
        progress: number;
        /**
         * Instances related to the task.
         */
        relatedInstanceInfos: outputs.rds_mysql.GetTasksDataTaskDetailTaskInfoRelatedInstanceInfo[];
    }

    export interface GetTasksDataTaskDetailTaskInfoRelatedInstanceInfo {
        /**
         * Instance ID.
         */
        instanceId: string;
    }

    export interface GetTasksDataTaskProgress {
        /**
         * Step Name. Values:
         * InstanceInitialization: Task initialization.
         * InstanceRecoveryPreparation Instance recovery preparation.
         * DataBackupImport: Cold backup import.
         * LogBackupBinlogAdd: Binlog playback.
         * TaskSuccessful: Task success.
         */
        name: string;
        /**
         * Specific information of the step.
         */
        stepExtraInfos: outputs.rds_mysql.GetTasksDataTaskProgressStepExtraInfo[];
        /**
         * Step status. Values:
         * Running: In progress.
         * Success: Successful.
         * Failed: Failed.
         * Unexecuted: Not executed.
         */
        stepStatus: string;
    }

    export interface GetTasksDataTaskProgressStepExtraInfo {
        /**
         * Current stage. CostTime: The time taken for the current stage.
         * CurDataSize: The amount of data imported currently.
         * CurBinlog: The number of Binlog files being replayed currently.
         * RemainCostTime: The remaining time taken.
         * RemainDataSize: The remaining amount of data to be imported. RemainBinlog: The number of Binlog files remaining for playback.
         */
        type: string;
        /**
         * Unit. Values:
         * MS: Milliseconds.
         * Bytes: Bytes.
         * Files: Number of (files).
         */
        unit: string;
        /**
         * The specific value corresponding to the Type field.
         */
        value: number;
    }

    export interface GetZonesZone {
        /**
         * The description of the zone.
         */
        description: string;
        /**
         * The id of the zone.
         */
        id: string;
        /**
         * The id of the zone.
         */
        zoneId: string;
        /**
         * The name of the zone.
         */
        zoneName: string;
    }

    export interface InstanceAutoStorageScalingConfig {
        /**
         * Whether to enable the instance's auto - scaling function. Values:
         * true: Yes.
         * false: No. Description: When StorageConfig is used as a request parameter, if the value of EnableStorageAutoScale is false, the StorageThreshold and StorageUpperBound parameters do not need to be passed in.
         */
        enableStorageAutoScale: boolean;
        /**
         * The proportion of available storage space that triggers automatic expansion. The value range is 10 to 50, and the default value is 10, with the unit being %.
         */
        storageThreshold: number;
        /**
         * The upper limit of the storage space that can be automatically expanded. The lower limit of the value of this field is the instance storage space + 20GB; the upper limit of the value is the upper limit of the storage space value range corresponding to the instance master node specification, with the unit being GB. For detailed information on the selectable storage space value range of different specifications, please refer to Product Specifications.
         */
        storageUpperBound: number;
    }

    export interface InstanceChargeDetail {
        /**
         * Whether to automatically renew in prepaid scenarios.
         * Autorenew_Enable
         * Autorenew_Disable (default).
         */
        autoRenew: boolean;
        /**
         * Billing expiry time (yearly and monthly only).
         */
        chargeEndTime: string;
        /**
         * Billing start time (pay-as-you-go & monthly subscription).
         */
        chargeStartTime: string;
        /**
         * Pay status. Value:
         * normal - normal
         * overdue - overdue
         * .
         */
        chargeStatus: string;
        /**
         * Payment type. Value:
         * PostPaid - Pay-As-You-Go
         * PrePaid - Yearly and monthly (default).
         */
        chargeType: string;
        /**
         * Estimated release time when arrears are closed (pay-as-you-go & monthly subscription).
         */
        overdueReclaimTime: string;
        /**
         * Shutdown time in arrears (pay-as-you-go & monthly subscription).
         */
        overdueTime: string;
        /**
         * Purchase duration in prepaid scenarios. Default: 1.
         */
        period: number;
        /**
         * The purchase cycle in the prepaid scenario.
         * Month - monthly subscription (default)
         * Year - Package year.
         */
        periodUnit: string;
        /**
         * Restore time of temporary upgrade.
         */
        tempModifyEndTime: string;
        /**
         * Temporary upgrade start time.
         */
        tempModifyStartTime: string;
    }

    export interface InstanceChargeInfo {
        /**
         * Whether to automatically renew in prepaid scenarios.
         */
        autoRenew: boolean;
        /**
         * Payment type. Value:
         * PostPaid - Pay-As-You-Go
         * PrePaid - Yearly and monthly (default).
         */
        chargeType: string;
        /**
         * Purchase duration in prepaid scenarios. Default: 1.
         */
        period: number;
        /**
         * The purchase cycle in the prepaid scenario.
         * Month - monthly subscription (default)
         * Year - Package year.
         */
        periodUnit: string;
    }

    export interface InstanceEndpoint {
        /**
         * Address list.
         */
        addresses: outputs.rds_mysql.InstanceEndpointAddress[];
        /**
         * When the terminal type is read-write terminal or read-only terminal, it supports setting whether new nodes are automatically added.
         */
        autoAddNewNodes: string;
        /**
         * Address description.
         */
        description: string;
        /**
         * Whether global read-only is enabled, value: Enable: Enable. Disable: Disabled.
         */
        enableReadOnly: string;
        /**
         * Whether read-write separation is enabled, value: Enable: Enable. Disable: Disabled.
         */
        enableReadWriteSplitting: string;
        /**
         * Instance connection terminal ID.
         */
        endpointId: string;
        /**
         * The instance connection terminal name.
         */
        endpointName: string;
        /**
         * Terminal type:
         * Cluster: The default terminal. (created by default)
         * Primary: Primary node terminal.
         * Custom: Custom terminal.
         * Direct: Direct connection to the terminal. (Only the operation and maintenance side)
         * AllNode: All node terminals. (Only the operation and maintenance side).
         */
        endpointType: string;
        /**
         * Whether the idle connection reclaim function is enabled. true: Enabled. false: Disabled.
         */
        idleConnectionReclaim: boolean;
        /**
         * The list of nodes configured by the connection terminal and the corresponding read-only weights.
         */
        nodeWeights: outputs.rds_mysql.InstanceEndpointNodeWeight[];
        /**
         * Read and write mode:
         * ReadWrite: read and write
         * ReadOnly: read only (default).
         */
        readWriteMode: string;
    }

    export interface InstanceEndpointAddress {
        /**
         * DNS Visibility.
         */
        dnsVisibility: boolean;
        /**
         * Connect domain name.
         */
        domain: string;
        /**
         * The ID of the EIP, only valid for Public addresses.
         */
        eipId: string;
        /**
         * The IP Address.
         */
        ipAddress: string;
        /**
         * Network address type, temporarily Private, Public, PublicService.
         */
        networkType: string;
        /**
         * The Port.
         */
        port: string;
        /**
         * Subnet ID of the RDS instance.
         */
        subnetId: string;
    }

    export interface InstanceEndpointNodeWeight {
        /**
         * Node ID.
         */
        nodeId: string;
        /**
         * Node type. Value: Primary: Primary node.
         * Secondary: Standby node.
         * ReadOnly: Read-only node.
         */
        nodeType: string;
        /**
         * The weight of the node.
         */
        weight: number;
    }

    export interface InstanceFeatureState {
        /**
         * Whether it is enabled. Values:
         * true: Enabled.
         * false: Disabled.
         */
        enable: boolean;
        /**
         * Feature name.
         */
        featureName: string;
        /**
         * Whether it support this function. Value:
         * true: Supported.
         * false: Not supported.
         */
        support: boolean;
    }

    export interface InstanceMaintenanceWindow {
        /**
         * Maintenance cycle granularity, values: Week: Week. Month: Month.
         */
        dayKind?: string;
        /**
         * Specify the maintainable time period of a certain day of the week. The values are: Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday. Multiple selections are allowed. If this value is not specified or is empty, it defaults to specifying all seven days of the week.
         */
        dayOfWeeks?: string[];
        /**
         * Maintenance period of an instance. Format: HH:mmZ-HH:mmZ (UTC time).
         */
        maintenanceTime?: string;
    }

    export interface InstanceNode {
        /**
         * Node creation local time.
         */
        createTime: string;
        /**
         * Instance ID.
         */
        instanceId: string;
        /**
         * Memory size in GB.
         */
        memory: number;
        /**
         * Node ID.
         */
        nodeId: string;
        /**
         * The specification of primary node and secondary node.
         */
        nodeSpec: string;
        /**
         * Node state, value: aligned with instance state.
         */
        nodeStatus: string;
        /**
         * Node type. Value: Primary: Primary node.
         * Secondary: Standby node.
         * ReadOnly: Read-only node.
         */
        nodeType: string;
        /**
         * The region of the RDS instance.
         */
        regionId: string;
        /**
         * The update time of the RDS instance.
         */
        updateTime: string;
        /**
         * CPU size.
         */
        vCpu: number;
        /**
         * The available zone of the RDS instance.
         */
        zoneId: string;
    }

    export interface InstanceParameter {
        /**
         * Parameter name.
         */
        parameterName: string;
        /**
         * Parameter value.
         */
        parameterValue: string;
    }

    export interface InstanceSpecsInstanceSpec {
        /**
         * Default value of maximum number of connections.
         */
        connection: number;
        /**
         * Compatible version. Values:
         * MySQL_5_7: MySQL 5.7 version. Default value.
         * MySQL_8_0: MySQL 8.0 version.
         */
        dbEngineVersion: string;
        /**
         * Instance type. The value is DoubleNode.
         */
        instanceType: string;
        /**
         * Maximum IOPS per second.
         */
        iops: number;
        /**
         * Memory size, in GB.
         */
        memory: number;
        /**
         * Queries Per Second (QPS).
         */
        qps: number;
        /**
         * The id of the region.
         */
        regionId: string;
        /**
         * Instance specification code.
         */
        specCode: string;
        /**
         * Instance specification type. Values:
         * General: Exclusive specification (formerly "General Purpose").
         * Shared: General specification (formerly "Shared Type").
         */
        specFamily: string;
        /**
         * The status of the available zone where the specification is located includes the following statuses:
         * Normal: On sale.
         * Soldout: Sold out.
         */
        specStatus: string;
        /**
         * Maximum storage space, in GB.
         */
        storageMax: number;
        /**
         * Minimum storage space, in GB.
         */
        storageMin: number;
        /**
         * Disk step size, in GB.
         */
        storageStep: number;
        /**
         * Number of vCPUs.
         */
        vcpu: number;
        /**
         * Availability zone ID.
         */
        zoneId: string;
    }

    export interface InstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface InstancesRdsMysqlInstance {
        /**
         * The version of allow list.
         */
        allowListVersion: string;
        /**
         * Auto - storage scaling configuration.
         */
        autoStorageScalingConfigs: outputs.rds_mysql.InstancesRdsMysqlInstanceAutoStorageScalingConfig[];
        /**
         * The upgrade strategy for the minor version of the instance kernel. Values:
         * Auto: Auto upgrade.
         * Manual: Manual upgrade.
         */
        autoUpgradeMinorVersion: string;
        /**
         * The instance has used backup space. Unit: GB.
         */
        backupUse: number;
        /**
         * Does it support the binlog capability? This parameter is returned only when the database proxy is enabled. Values:
         * true: Yes.
         * false: No.
         */
        binlogDump: boolean;
        /**
         * Payment methods.
         */
        chargeDetail: outputs.rds_mysql.InstancesRdsMysqlInstanceChargeDetail;
        /**
         * Connection pool type.
         */
        connectionPoolType: string;
        /**
         * Node creation local time.
         */
        createTime: string;
        /**
         * Data synchronization mode.
         */
        dataSyncMode: string;
        /**
         * The version of the RDS instance.
         */
        dbEngineVersion: string;
        /**
         * The running status of the proxy instance. This parameter is returned only when the database proxy is enabled. Values:
         * Creating: The proxy is being started.
         * Running: The proxy is running.
         * Shutdown: The proxy is closed.
         * Deleting: The proxy is being closed.
         */
        dbProxyStatus: string;
        /**
         * Whether to enable the deletion protection function. Values:
         * Enabled: Yes.
         * Disabled: No.
         */
        deletionProtection: string;
        /**
         * The ID of the data synchronization task in DTS for the data synchronization link between the primary instance and the disaster recovery instance.
         */
        drDtsTaskId: string;
        /**
         * The name of the DTS data synchronization task for the data synchronization link between the primary instance and the disaster recovery instance.
         */
        drDtsTaskName: string;
        /**
         * The status of the DTS data synchronization task for the data synchronization link between the primary instance and the disaster recovery instance.
         */
        drDtsTaskStatus: string;
        /**
         * The number of seconds that the disaster recovery instance is behind the primary instance.
         */
        drSecondsBehindMaster: number;
        /**
         * The endpoint info of the RDS instance.
         */
        endpoints: outputs.rds_mysql.InstancesRdsMysqlInstanceEndpoint[];
        /**
         * Feature status.
         */
        featureStates: outputs.rds_mysql.InstancesRdsMysqlInstanceFeatureState[];
        /**
         * Whether to enable global read-only.
         * true: Yes.
         * false: No.
         */
        globalReadOnly: boolean;
        /**
         * The ID of the RDS instance.
         */
        id: string;
        /**
         * The id of the RDS instance.
         */
        instanceId: string;
        /**
         * The name of the RDS instance.
         */
        instanceName: string;
        /**
         * The status of the RDS instance.
         */
        instanceStatus: string;
        /**
         * The kernel version of the instance.
         */
        kernelVersion: string;
        /**
         * Whether the table name is case sensitive, the default value is 1.
         * Ranges:
         * 0: Table names are stored as fixed and table names are case-sensitive.
         * 1: Table names will be stored in lowercase and table names are not case sensitive.
         */
        lowerCaseTableNames: string;
        /**
         * Maintenance Window.
         */
        maintenanceWindows: outputs.rds_mysql.InstancesRdsMysqlInstanceMaintenanceWindow[];
        /**
         * The ID of the primary instance of the disaster recovery instance.
         */
        masterInstanceId: string;
        /**
         * The name of the primary instance of the disaster recovery instance.
         */
        masterInstanceName: string;
        /**
         * The region where the primary instance of the disaster recovery instance is located.
         */
        masterRegion: string;
        /**
         * Memory size in GB.
         */
        memory: number;
        /**
         * Average CPU usage of the instance master node in nearly one minute.
         */
        nodeCpuUsedPercentage: number;
        /**
         * Average memory usage of the instance master node in nearly one minute.
         */
        nodeMemoryUsedPercentage: number;
        /**
         * The number of nodes.
         */
        nodeNumber: number;
        /**
         * Average disk usage of the instance master node in nearly one minute.
         */
        nodeSpaceUsedPercentage: number;
        /**
         * Primary node specification. For detailed information about the node specifications, please refer to Product Specifications.
         */
        nodeSpec: string;
        /**
         * Instance node information.
         */
        nodes: outputs.rds_mysql.InstancesRdsMysqlInstanceNode[];
        /**
         * The project name of the RDS instance.
         */
        projectName: string;
        /**
         * The region of the RDS instance.
         */
        regionId: string;
        /**
         * The upper limit of the storage space that can be set for automatic expansion. The value is the upper limit of the storage space value range corresponding to the instance master node specification, with the unit being GB. For detailed information on the selectable storage space value ranges of different specifications, please refer to Product Specifications.
         */
        storageMaxCapacity: number;
        /**
         * The upper limit of the proportion of available storage space that triggers automatic expansion. When supported, the value is 50%.
         */
        storageMaxTriggerThreshold: number;
        /**
         * The lower limit of the storage space that can be set for automatic expansion. The value is the lower limit of the storage space value range corresponding to the instance master node specification, with the unit being GB. For detailed information on the selectable storage space value ranges of different specifications, please refer to Product Specifications.
         */
        storageMinCapacity: number;
        /**
         * The lower limit of the proportion of available storage space that triggers automatic expansion. When supported, the value is 10%.
         */
        storageMinTriggerThreshold: number;
        /**
         * Total instance storage space. Unit: GB.
         */
        storageSpace: number;
        /**
         * Instance storage type. The value is LocalSSD, indicating a local SSD disk.
         */
        storageType: string;
        /**
         * The instance has used storage space. Unit: GB.
         */
        storageUse: number;
        /**
         * The subnet ID of the RDS instance.
         */
        subnetId: string;
        /**
         * Tags.
         */
        tags: outputs.rds_mysql.InstancesRdsMysqlInstanceTag[];
        /**
         * Time zone.
         */
        timeZone: string;
        /**
         * The update time of the RDS instance.
         */
        updateTime: string;
        /**
         * CPU size.
         */
        vCpu: number;
        /**
         * The vpc ID of the RDS instance.
         */
        vpcId: string;
        /**
         * The available zone of the RDS instance.
         */
        zoneId: string;
        /**
         * List of availability zones where each node of the instance is located.
         */
        zoneIds: string[];
    }

    export interface InstancesRdsMysqlInstanceAutoStorageScalingConfig {
        /**
         * Whether to enable the instance's auto - scaling function. Values:
         * true: Yes.
         * false: No. Description: When StorageConfig is used as a request parameter, if the value of EnableStorageAutoScale is false, the StorageThreshold and StorageUpperBound parameters do not need to be passed in.
         */
        enableStorageAutoScale: boolean;
        /**
         * The proportion of available storage space that triggers automatic expansion. The value range is 10 to 50, and the default value is 10, with the unit being %.
         */
        storageThreshold: number;
        /**
         * The upper limit of the storage space that can be automatically expanded. The lower limit of the value of this field is the instance storage space + 20GB; the upper limit of the value is the upper limit of the storage space value range corresponding to the instance master node specification, with the unit being GB. For detailed information on the selectable storage space value range of different specifications, please refer to Product Specifications.
         */
        storageUpperBound: number;
    }

    export interface InstancesRdsMysqlInstanceChargeDetail {
        /**
         * Whether to automatically renew in prepaid scenarios.
         * Autorenew_Enable
         * Autorenew_Disable (default).
         */
        autoRenew: boolean;
        /**
         * Billing expiry time (yearly and monthly only).
         */
        chargeEndTime: string;
        /**
         * Billing start time (pay-as-you-go & monthly subscription).
         */
        chargeStartTime: string;
        /**
         * Pay status. Value:
         * normal - normal
         * overdue - overdue
         * .
         */
        chargeStatus: string;
        /**
         * The charge type of the RDS instance.
         */
        chargeType: string;
        /**
         * Estimated release time when arrears are closed (pay-as-you-go & monthly subscription).
         */
        overdueReclaimTime: string;
        /**
         * Shutdown time in arrears (pay-as-you-go & monthly subscription).
         */
        overdueTime: string;
        /**
         * Purchase duration in prepaid scenarios. Default: 1.
         */
        period: number;
        /**
         * The purchase cycle in the prepaid scenario.
         * Month - monthly subscription (default)
         * Year - Package year.
         */
        periodUnit: string;
        /**
         * Restore time of temporary upgrade.
         */
        tempModifyEndTime: string;
        /**
         * Temporary upgrade start time.
         */
        tempModifyStartTime: string;
    }

    export interface InstancesRdsMysqlInstanceEndpoint {
        /**
         * Address list.
         */
        addresses: outputs.rds_mysql.InstancesRdsMysqlInstanceEndpointAddress[];
        /**
         * When the terminal type is read-write terminal or read-only terminal, it supports setting whether new nodes are automatically added.
         */
        autoAddNewNodes: string;
        /**
         * Address description.
         */
        description: string;
        /**
         * Whether global read-only is enabled, value: Enable: Enable. Disable: Disabled.
         */
        enableReadOnly: string;
        /**
         * Whether read-write separation is enabled, value: Enable: Enable. Disable: Disabled.
         */
        enableReadWriteSplitting: string;
        /**
         * Instance connection terminal ID.
         */
        endpointId: string;
        /**
         * The instance connection terminal name.
         */
        endpointName: string;
        /**
         * Terminal type:
         * Cluster: The default terminal. (created by default)
         * Primary: Primary node terminal.
         * Custom: Custom terminal.
         * Direct: Direct connection to the terminal. (Only the operation and maintenance side)
         * AllNode: All node terminals. (Only the operation and maintenance side).
         */
        endpointType: string;
        /**
         * Whether the idle connection reclaim function is enabled. true: Enabled. false: Disabled.
         */
        idleConnectionReclaim: boolean;
        /**
         * The list of nodes configured by the connection terminal and the corresponding read-only weights.
         */
        nodeWeights: outputs.rds_mysql.InstancesRdsMysqlInstanceEndpointNodeWeight[];
        /**
         * Read and write mode:
         * ReadWrite: read and write
         * ReadOnly: read only (default).
         */
        readWriteMode: string;
    }

    export interface InstancesRdsMysqlInstanceEndpointAddress {
        /**
         * DNS Visibility.
         */
        dnsVisibility: boolean;
        /**
         * Connect domain name.
         */
        domain: string;
        /**
         * The ID of the EIP, only valid for Public addresses.
         */
        eipId: string;
        /**
         * The IP Address.
         */
        ipAddress: string;
        /**
         * Network address type, temporarily Private, Public, PublicService.
         */
        networkType: string;
        /**
         * The Port.
         */
        port: string;
        /**
         * The subnet ID of the RDS instance.
         */
        subnetId: string;
    }

    export interface InstancesRdsMysqlInstanceEndpointNodeWeight {
        /**
         * Node ID.
         */
        nodeId: string;
        /**
         * Node type. Value: Primary: Primary node.
         * Secondary: Standby node.
         * ReadOnly: Read-only node.
         */
        nodeType: string;
        /**
         * The weight of the node.
         */
        weight: number;
    }

    export interface InstancesRdsMysqlInstanceFeatureState {
        /**
         * Whether it is enabled. Values:
         * true: Enabled.
         * false: Disabled.
         */
        enable: boolean;
        /**
         * Feature name.
         */
        featureName: string;
        /**
         * Whether it support this function. Value:
         * true: Supported.
         * false: Not supported.
         */
        support: boolean;
    }

    export interface InstancesRdsMysqlInstanceMaintenanceWindow {
        /**
         * DayKind of maintainable window. Value: Week. Month.
         */
        dayKind: string;
        /**
         * Days of maintainable window of the month.
         */
        dayOfMonths: number[];
        /**
         * Days of maintainable window of the week.
         */
        dayOfWeeks: string[];
        /**
         * The maintainable time of the RDS instance.
         */
        maintenanceTime: string;
    }

    export interface InstancesRdsMysqlInstanceNode {
        /**
         * Node creation local time.
         */
        createTime: string;
        /**
         * The id of the RDS instance.
         */
        instanceId: string;
        /**
         * Memory size in GB.
         */
        memory: number;
        /**
         * Node ID.
         */
        nodeId: string;
        /**
         * Primary node specification. For detailed information about the node specifications, please refer to Product Specifications.
         */
        nodeSpec: string;
        /**
         * Node state, value: aligned with instance state.
         */
        nodeStatus: string;
        /**
         * Node type. Value: Primary: Primary node.
         * Secondary: Standby node.
         * ReadOnly: Read-only node.
         */
        nodeType: string;
        /**
         * The region of the RDS instance.
         */
        regionId: string;
        /**
         * The update time of the RDS instance.
         */
        updateTime: string;
        /**
         * CPU size.
         */
        vCpu: number;
        /**
         * The available zone of the RDS instance.
         */
        zoneId: string;
    }

    export interface InstancesRdsMysqlInstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface InstancesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface ParameterTemplateTemplateParam {
        /**
         * Instance parameter name.
         * Description: When using CreateParameterTemplate and ModifyParameterTemplate as request parameters, only Name and RunningValue need to be passed in.
         */
        name: string;
        /**
         * Parameter running value.
         * Description: When making request parameters in CreateParameterTemplate and ModifyParameterTemplate, only Name and RunningValue need to be passed in.
         */
        runningValue: string;
    }

    export interface ParameterTemplatesTemplate {
        /**
         * The account ID.
         */
        accountId: string;
        /**
         * Creation time.
         */
        createTime: string;
        /**
         * Does the template contain parameters that require restart.
         */
        needRestart: boolean;
        /**
         * The number of parameters contained in the template.
         */
        parameterNum: number;
        /**
         * The project to which the template belongs.
         */
        projectName: string;
        /**
         * Template category, with a value of DBEngine (database engine parameters).
         */
        templateCategory: string;
        /**
         * Parameter template description.
         */
        templateDesc: string;
        /**
         * Parameter template ID.
         */
        templateId: string;
        /**
         * Parameter template name.
         */
        templateName: string;
        /**
         * Parameters contained in the template.
         */
        templateParams: outputs.rds_mysql.ParameterTemplatesTemplateTemplateParam[];
        /**
         * Parameter template source, value range: System. User.
         */
        templateSource: string;
        /**
         * Database type of parameter template. The default value is Mysql.
         */
        templateType: string;
        /**
         * Database version of parameter template. Value range:
         * MySQL_5_7: Default value. MySQL 5.7 version.
         * MySQL_8_0: MySQL 8.0 version.
         */
        templateTypeVersion: string;
        /**
         * Modification time of the template.
         */
        updateTime: string;
    }

    export interface ParameterTemplatesTemplateTemplateParam {
        /**
         * Parameter default value.
         */
        defaultValue: string;
        /**
         * Parameter description.
         */
        description: string;
        /**
         * Instance parameter name.
         * Description: When using CreateParameterTemplate and ModifyParameterTemplate as request parameters, only Name and RunningValue need to be passed in.
         */
        name: string;
        /**
         * Is it necessary to restart the instance for the changes to take effect.
         */
        restart: boolean;
        /**
         * Parameter running value.
         * Description: When making requests with CreateParameterTemplate and ModifyParameterTemplate as request parameters, only Name and RunningValue need to be passed in.
         */
        runningValue: string;
        /**
         * Value range of parameters.
         */
        valueRange: string;
    }

    export interface PlannedEventsPlannedEvent {
        /**
         * The business impact of the planned event.
         */
        businessImpact: string;
        /**
         * The database engine of the planned event.
         */
        dbEngine: string;
        /**
         * The action of the planned event.
         */
        eventAction: string;
        /**
         * The id of the planned event.
         */
        eventId: string;
        /**
         * The name of the planned event.
         */
        eventName: string;
        /**
         * The type of the planned event.
         */
        eventType: string;
        /**
         * The id of the instance.
         */
        instanceId: string;
        /**
         * The name of the instance.
         */
        instanceName: string;
        /**
         * The latest postponable time. The format is yyyy-MM-ddTHH:mm:ssZ (UTC time).
         */
        maxDelayTime: string;
        /**
         * The initially set start time. The format is yyyy-MM-ddTHH:mm:ssZ (UTC time).
         */
        originBeginTime: string;
        /**
         * The start time of the planned execution. The format is yyyy-MM-ddTHH:mm:ssZ (UTC time).
         */
        plannedBeginTime: string;
        /**
         * The end time of the planned execution. The format is yyyy-MM-ddTHH:mm:ssZ (UTC time).
         */
        plannedEndTime: string;
        /**
         * Description information of the operation and maintenance event.
         */
        plannedEventDescription: string;
        /**
         * The reasons for the occurrence of the event, which are provided to help you understand the reasons for the occurrence of unexpected events.
         */
        plannedEventReason: string;
        /**
         * The start time of the planned switch. The format is yyyy-MM-ddTHH:mm:ssZ (UTC time).
         */
        plannedSwitchBeginTime: string;
        /**
         * The end time of the planned switch. The format is yyyy-MM-ddTHH:mm:ssZ (UTC time).
         */
        plannedSwitchEndTime: string;
        /**
         * The region.
         */
        region: string;
        /**
         * The status of the planned event.
         */
        status: string;
    }

    export interface RegionsRegion {
        /**
         * The id of the region.
         */
        regionId: string;
        /**
         * The name of region.
         */
        regionName: string;
    }

    export interface TasksData {
        /**
         * The creation time of the task.
         */
        createTime: string;
        /**
         * The completion time of the task.
         */
        finishTime: string;
        /**
         * Task progress. The unit is percentage. Description: Only tasks with a task status of In Progress, that is, tasks with a TaskStatus value of Running, will return the task progress.
         */
        progress: number;
        /**
         * The deadline for the planned startup. The time format is yyyy-MM-ddTHH:mm:ssZ (UTC time). Description: This field will only be returned for tasks in the "Waiting to Start", "Waiting to Execute", or "Waiting to Switch" states.
         */
        scheduledExecuteEndTime: string;
        /**
         * The scheduled end time for the switch. The time format is yyyy-MM-ddTHH:mm:ssZ (UTC time). Description: This field will only be returned for tasks in the "Waiting to Start", "Waiting to Execute", or "Waiting to Switch" states.
         */
        scheduledSwitchEndTime: string;
        /**
         * The start time of the scheduled switch. The time format is yyyy-MM-ddTHH:mm:ssZ (UTC time). Description: This field is returned only for tasks in the "Waiting to Start", "Waiting to Execute", or "Waiting to Switch" state.
         */
        scheduledSwitchStartTime: string;
        /**
         * The start time of the task.
         */
        startTime: string;
        /**
         * Task name.
         */
        taskAction: string;
        /**
         * Task Category. The values are as shown in the following list, and multiple values can be selected: BackupRecoveryManagement: Backup and Recovery Management. DatabaseAdminManagement: Database Administration Management. DatabaseProxy: Database Proxy. HighAvailability: High Availability. InstanceAttribute: Instance Attribute. InstanceManagement: Instance Management. NetworkManagement: Network Management. SecurityManagement: Security Management. SystemMaintainManagement: System Operation and Maintenance Management. VersionUpgrade: Version Upgrade.
         */
        taskCategory: string;
        /**
         * The description of the task.
         */
        taskDesc: string;
        /**
         * Detailed information of the task.
         */
        taskDetails: outputs.rds_mysql.TasksDataTaskDetail[];
        /**
         * Task ID. Description: For the two groups of parameters, TaskId and task time (CreationStartTime and CreationEndTime), one of them must be selected.
         */
        taskId: string;
        /**
         * Task parameters.
         */
        taskParams: string;
        /**
         * Progress details.
         */
        taskProgresses: outputs.rds_mysql.TasksDataTaskProgress[];
        /**
         * Task status. The values are as shown in the following list, and multiple values can be selected: WaitSwitch: Waiting for switching. WaitStart: Waiting for execution. Canceled: Canceled. Stopped: Terminated. Running_BeforeSwitch: Running (before switching). Timeout: Execution Timeout. Success: Execution Success. Failed: Execution Failed. Running: In Execution. Stopping: In Termination.
         */
        taskStatus: string;
    }

    export interface TasksDataTaskDetail {
        /**
         * The log of inspection items for the instance major version upgrade.
         */
        checkItemLog: string;
        /**
         * Check results for major version upgrade.
         */
        checkItems: outputs.rds_mysql.TasksDataTaskDetailCheckItem[];
        /**
         * Details of the task.
         */
        taskInfos: outputs.rds_mysql.TasksDataTaskDetailTaskInfo[];
    }

    export interface TasksDataTaskDetailCheckItem {
        /**
         * Details of the failed check items.
         */
        checkDetails: outputs.rds_mysql.TasksDataTaskDetailCheckItemCheckDetail[];
        /**
         * The description of the check item.
         */
        description: string;
        /**
         * The name of the check item.
         */
        itemName: string;
        /**
         * The risk level of the failed check items. Values:
         * Notice: Attention.
         * Warning: Warning.
         * Error: Error.
         */
        riskLevel: string;
    }

    export interface TasksDataTaskDetailCheckItemCheckDetail {
        /**
         * The impact of the issue that caused the failure of the check item after the upgrade.
         */
        impact: string;
        /**
         * Problems that caused the failure to pass the check items.
         */
        issue: string;
    }

    export interface TasksDataTaskDetailTaskInfo {
        /**
         * The creation time of the task.
         */
        createTime: string;
        /**
         * The completion time of the task.
         */
        finishTime: string;
        /**
         * Task progress. The unit is percentage. Description: Only tasks with a task status of In Progress, that is, tasks with a TaskStatus value of Running, will return the task progress.
         */
        progress: number;
        /**
         * Instances related to the task.
         */
        relatedInstanceInfos: outputs.rds_mysql.TasksDataTaskDetailTaskInfoRelatedInstanceInfo[];
    }

    export interface TasksDataTaskDetailTaskInfoRelatedInstanceInfo {
        /**
         * Instance ID.
         */
        instanceId: string;
    }

    export interface TasksDataTaskProgress {
        /**
         * Step Name. Values:
         * InstanceInitialization: Task initialization.
         * InstanceRecoveryPreparation Instance recovery preparation.
         * DataBackupImport: Cold backup import.
         * LogBackupBinlogAdd: Binlog playback.
         * TaskSuccessful: Task success.
         */
        name: string;
        /**
         * Specific information of the step.
         */
        stepExtraInfos: outputs.rds_mysql.TasksDataTaskProgressStepExtraInfo[];
        /**
         * Step status. Values:
         * Running: In progress.
         * Success: Successful.
         * Failed: Failed.
         * Unexecuted: Not executed.
         */
        stepStatus: string;
    }

    export interface TasksDataTaskProgressStepExtraInfo {
        /**
         * Current stage. CostTime: The time taken for the current stage.
         * CurDataSize: The amount of data imported currently.
         * CurBinlog: The number of Binlog files being replayed currently.
         * RemainCostTime: The remaining time taken.
         * RemainDataSize: The remaining amount of data to be imported. RemainBinlog: The number of Binlog files remaining for playback.
         */
        type: string;
        /**
         * Unit. Values:
         * MS: Milliseconds.
         * Bytes: Bytes.
         * Files: Number of (files).
         */
        unit: string;
        /**
         * The specific value corresponding to the Type field.
         */
        value: number;
    }

    export interface ZonesZone {
        /**
         * The description of the zone.
         */
        description: string;
        /**
         * The id of the zone.
         */
        id: string;
        /**
         * The id of the zone.
         */
        zoneId: string;
        /**
         * The name of the zone.
         */
        zoneName: string;
    }

}

export namespace rds_postgresql {
    export interface AccountsAccount {
        /**
         * The name of the database account. This field supports fuzzy query.
         */
        accountName: string;
        /**
         * The privileges of the database account.
         */
        accountPrivileges: string;
        /**
         * The status of the database account.
         */
        accountStatus: string;
        /**
         * The type of the database account.
         */
        accountType: string;
    }

    export interface AllowlistAssociatedInstance {
        /**
         * The id of the postgresql instance.
         */
        instanceId: string;
        /**
         * The name of the postgresql instance.
         */
        instanceName: string;
        /**
         * The id of the vpc.
         */
        vpc: string;
    }

    export interface AllowlistsPostgresqlAllowList {
        /**
         * The description of the postgresql allow list.
         */
        allowListDesc: string;
        /**
         * The id of the postgresql allow list.
         */
        allowListId: string;
        /**
         * The total number of IP addresses (or address ranges) in the whitelist.
         */
        allowListIpNum: number;
        /**
         * The name of the postgresql allow list.
         */
        allowListName: string;
        /**
         * The type of the postgresql allow list.
         */
        allowListType: string;
        /**
         * The IP address or a range of IP addresses in CIDR format.
         */
        allowLists: string[];
        /**
         * The total number of instances bound under the whitelist.
         */
        associatedInstanceNum: number;
        /**
         * The list of postgresql instances.
         */
        associatedInstances: outputs.rds_postgresql.AllowlistsPostgresqlAllowListAssociatedInstance[];
        /**
         * The id of the postgresql allow list.
         */
        id: string;
    }

    export interface AllowlistsPostgresqlAllowListAssociatedInstance {
        /**
         * The id of the postgresql Instance.
         */
        instanceId: string;
        /**
         * The name of the postgresql instance.
         */
        instanceName: string;
        /**
         * The id of the vpc.
         */
        vpc: string;
    }

    export interface DatabasesDatabase {
        /**
         * Character classification.
         */
        cType: string;
        /**
         * The character set of the RDS database.
         */
        characterSetName: string;
        /**
         * The collate of database.
         */
        collate: string;
        /**
         * The name of the RDS database.
         */
        dbName: string;
        /**
         * The status of the RDS database.
         */
        dbStatus: string;
        /**
         * The owner of database.
         */
        owner: string;
    }

    export interface GetAccountsAccount {
        /**
         * The name of the database account. This field supports fuzzy query.
         */
        accountName: string;
        /**
         * The privileges of the database account.
         */
        accountPrivileges: string;
        /**
         * The status of the database account.
         */
        accountStatus: string;
        /**
         * The type of the database account.
         */
        accountType: string;
    }

    export interface GetAllowlistsPostgresqlAllowList {
        /**
         * The description of the postgresql allow list.
         */
        allowListDesc: string;
        /**
         * The id of the postgresql allow list.
         */
        allowListId: string;
        /**
         * The total number of IP addresses (or address ranges) in the whitelist.
         */
        allowListIpNum: number;
        /**
         * The name of the postgresql allow list.
         */
        allowListName: string;
        /**
         * The type of the postgresql allow list.
         */
        allowListType: string;
        /**
         * The IP address or a range of IP addresses in CIDR format.
         */
        allowLists: string[];
        /**
         * The total number of instances bound under the whitelist.
         */
        associatedInstanceNum: number;
        /**
         * The list of postgresql instances.
         */
        associatedInstances: outputs.rds_postgresql.GetAllowlistsPostgresqlAllowListAssociatedInstance[];
        /**
         * The id of the postgresql allow list.
         */
        id: string;
    }

    export interface GetAllowlistsPostgresqlAllowListAssociatedInstance {
        /**
         * The id of the postgresql Instance.
         */
        instanceId: string;
        /**
         * The name of the postgresql instance.
         */
        instanceName: string;
        /**
         * The id of the vpc.
         */
        vpc: string;
    }

    export interface GetDatabasesDatabase {
        /**
         * Character classification.
         */
        cType: string;
        /**
         * The character set of the RDS database.
         */
        characterSetName: string;
        /**
         * The collate of database.
         */
        collate: string;
        /**
         * The name of the RDS database.
         */
        dbName: string;
        /**
         * The status of the RDS database.
         */
        dbStatus: string;
        /**
         * The owner of database.
         */
        owner: string;
    }

    export interface GetInstancesInstance {
        /**
         * The instance has used backup space. Unit: GB.
         */
        backupUse: number;
        /**
         * Payment methods.
         */
        chargeDetails: outputs.rds_postgresql.GetInstancesInstanceChargeDetail[];
        /**
         * Node creation local time.
         */
        createTime: string;
        /**
         * Data synchronization mode.
         */
        dataSyncMode: string;
        /**
         * The version of the RDS PostgreSQL instance.
         */
        dbEngineVersion: string;
        /**
         * The endpoint info of the RDS instance.
         */
        endpoints: outputs.rds_postgresql.GetInstancesInstanceEndpoint[];
        /**
         * The ID of the RDS PostgreSQL instance.
         */
        id: string;
        /**
         * The id of the RDS PostgreSQL instance.
         */
        instanceId: string;
        /**
         * The name of the RDS PostgreSQL instance.
         */
        instanceName: string;
        /**
         * The status of the RDS PostgreSQL instance.
         */
        instanceStatus: string;
        /**
         * The instance type of the RDS PostgreSQL instance.
         */
        instanceType: string;
        /**
         * Memory size in GB.
         */
        memory: number;
        /**
         * The number of nodes.
         */
        nodeNumber: number;
        /**
         * General instance type, different from Custom instance type.
         */
        nodeSpec: string;
        /**
         * Instance node information.
         */
        nodes: outputs.rds_postgresql.GetInstancesInstanceNode[];
        /**
         * The project name of the RDS PostgreSQL instance.
         */
        projectName: string;
        /**
         * The region of the RDS PostgreSQL instance.
         */
        regionId: string;
        /**
         * Total instance storage space. Unit: GB.
         */
        storageSpace: number;
        /**
         * Instance storage type.
         */
        storageType: string;
        /**
         * The subnet ID of the RDS PostgreSQL instance.
         */
        subnetId: string;
        /**
         * Tags.
         */
        tags: outputs.rds_postgresql.GetInstancesInstanceTag[];
        /**
         * The update time of the RDS PostgreSQL instance.
         */
        updateTime: string;
        /**
         * CPU size.
         */
        vCpu: number;
        /**
         * The vpc ID of the RDS PostgreSQL instance.
         */
        vpcId: string;
        /**
         * The available zone of the RDS PostgreSQL instance.
         */
        zoneId: string;
        /**
         * ID of the availability zone where each instance is located.
         */
        zoneIds: string[];
    }

    export interface GetInstancesInstanceChargeDetail {
        /**
         * Whether to automatically renew in prepaid scenarios.
         * Autorenew_Enable
         * Autorenew_Disable (default).
         */
        autoRenew: boolean;
        /**
         * Billing expiry time (yearly and monthly only).
         */
        chargeEndTime: string;
        /**
         * Billing start time (pay-as-you-go & monthly subscription).
         */
        chargeStartTime: string;
        /**
         * Pay status. Value:
         * normal - normal
         * overdue - overdue
         * .
         */
        chargeStatus: string;
        /**
         * The charge type of the RDS instance.
         */
        chargeType: string;
        /**
         * Estimated release time when arrears are closed (pay-as-you-go & monthly subscription).
         */
        overdueReclaimTime: string;
        /**
         * Shutdown time in arrears (pay-as-you-go & monthly subscription).
         */
        overdueTime: string;
        /**
         * Purchase duration in prepaid scenarios. Default: 1.
         */
        period: number;
        /**
         * The purchase cycle in the prepaid scenario.
         * Month - monthly subscription (default)
         * Year - Package year.
         */
        periodUnit: string;
        /**
         * Temporary upgrade of restoration time.
         */
        tempModifyEndTime: string;
        /**
         * Start time of temporary upgrade.
         */
        tempModifyStartTime: string;
    }

    export interface GetInstancesInstanceEndpoint {
        /**
         * Address list.
         */
        addresses: outputs.rds_postgresql.GetInstancesInstanceEndpointAddress[];
        /**
         * When the terminal type is read-write terminal or read-only terminal, it supports setting whether new nodes are automatically added.
         */
        autoAddNewNodes: string;
        /**
         * Address description.
         */
        description: string;
        /**
         * Whether global read-only is enabled, value: Enable: Enable. Disable: Disabled.
         */
        enableReadOnly: string;
        /**
         * Whether read-write separation is enabled, value: Enable: Enable. Disable: Disabled.
         */
        enableReadWriteSplitting: string;
        /**
         * Instance connection terminal ID.
         */
        endpointId: string;
        /**
         * The instance connection terminal name.
         */
        endpointName: string;
        /**
         * Terminal type:
         * Cluster: The default terminal. (created by default)
         * Primary: Primary node terminal.
         * Custom: Custom terminal.
         * Direct: Direct connection to the terminal. (Only the operation and maintenance side)
         * AllNode: All node terminals. (Only the operation and maintenance side).
         */
        endpointType: string;
        /**
         * The list of nodes configured by the connection terminal and the corresponding read-only weights.
         */
        readOnlyNodeWeights: outputs.rds_postgresql.GetInstancesInstanceEndpointReadOnlyNodeWeight[];
        /**
         * Read and write mode:
         * ReadWrite: read and write
         * ReadOnly: read only (default).
         */
        readWriteMode: string;
    }

    export interface GetInstancesInstanceEndpointAddress {
        /**
         * DNS Visibility.
         */
        dnsVisibility: boolean;
        /**
         * Connect domain name.
         */
        domain: string;
        /**
         * The ID of the EIP, only valid for Public addresses.
         */
        eipId: string;
        /**
         * The IP Address.
         */
        ipAddress: string;
        /**
         * Network address type, temporarily Private, Public, PublicService.
         */
        networkType: string;
        /**
         * The Port.
         */
        port: string;
        /**
         * The subnet ID of the RDS PostgreSQL instance.
         */
        subnetId: string;
    }

    export interface GetInstancesInstanceEndpointReadOnlyNodeWeight {
        /**
         * Node ID.
         */
        nodeId: string;
        /**
         * Node type. Value: Primary: Primary node.
         * Secondary: Standby node.
         * ReadOnly: Read-only node.
         */
        nodeType: string;
        /**
         * The weight of the node.
         */
        weight: number;
    }

    export interface GetInstancesInstanceNode {
        /**
         * Node creation local time.
         */
        createTime: string;
        /**
         * The id of the RDS PostgreSQL instance.
         */
        instanceId: string;
        /**
         * Memory size in GB.
         */
        memory: number;
        /**
         * Node ID.
         */
        nodeId: string;
        /**
         * General instance type, different from Custom instance type.
         */
        nodeSpec: string;
        /**
         * Node state, value: aligned with instance state.
         */
        nodeStatus: string;
        /**
         * Node type. Value: Primary: Primary node.
         * Secondary: Standby node.
         * ReadOnly: Read-only node.
         */
        nodeType: string;
        /**
         * The region of the RDS PostgreSQL instance.
         */
        regionId: string;
        /**
         * The update time of the RDS PostgreSQL instance.
         */
        updateTime: string;
        /**
         * CPU size.
         */
        vCpu: number;
        /**
         * The available zone of the RDS PostgreSQL instance.
         */
        zoneId: string;
    }

    export interface GetInstancesInstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetInstancesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetSchemasSchema {
        /**
         * The name of the database.
         */
        dbName: string;
        /**
         * The owner of the schema.
         */
        owner: string;
        /**
         * The name of the schema.
         */
        schemaName: string;
    }

    export interface InstanceChargeDetail {
        /**
         * Whether to automatically renew in prepaid scenarios.
         * Autorenew_Enable
         * Autorenew_Disable (default).
         */
        autoRenew: boolean;
        /**
         * Billing expiry time (yearly and monthly only).
         */
        chargeEndTime: string;
        /**
         * Billing start time (pay-as-you-go & monthly subscription).
         */
        chargeStartTime: string;
        /**
         * Pay status. Value:
         * normal - normal
         * overdue - overdue
         * .
         */
        chargeStatus: string;
        /**
         * Payment type. Value:
         * PostPaid - Pay-As-You-Go
         * PrePaid - Yearly and monthly (default).
         */
        chargeType: string;
        /**
         * Estimated release time when arrears are closed (pay-as-you-go & monthly subscription).
         */
        overdueReclaimTime: string;
        /**
         * Shutdown time in arrears (pay-as-you-go & monthly subscription).
         */
        overdueTime: string;
        /**
         * Purchase duration in prepaid scenarios. Default: 1.
         */
        period: number;
        /**
         * The purchase cycle in the prepaid scenario.
         * Month - monthly subscription (default)
         * Year - Package year.
         */
        periodUnit: string;
        /**
         * Temporary upgrade of restoration time.
         */
        tempModifyEndTime: string;
        /**
         * Start time of temporary upgrade.
         */
        tempModifyStartTime: string;
    }

    export interface InstanceChargeInfo {
        /**
         * Whether to automatically renew in prepaid scenarios.
         */
        autoRenew: boolean;
        chargeType: string;
        /**
         * Purchase duration in prepaid scenarios. Default: 1.
         */
        period: number;
        /**
         * The purchase cycle in the prepaid scenario.
         * Month - monthly subscription (default)
         * Year - Package year.
         */
        periodUnit: string;
    }

    export interface InstanceEndpoint {
        /**
         * Address list.
         */
        addresses: outputs.rds_postgresql.InstanceEndpointAddress[];
        /**
         * When the terminal type is read-write terminal or read-only terminal, it supports setting whether new nodes are automatically added.
         */
        autoAddNewNodes: string;
        /**
         * Address description.
         */
        description: string;
        /**
         * Whether global read-only is enabled, value: Enable: Enable. Disable: Disabled.
         */
        enableReadOnly: string;
        /**
         * Whether read-write separation is enabled, value: Enable: Enable. Disable: Disabled.
         */
        enableReadWriteSplitting: string;
        /**
         * Instance connection terminal ID.
         */
        endpointId: string;
        /**
         * The instance connection terminal name.
         */
        endpointName: string;
        /**
         * Terminal type:
         * Cluster: The default terminal. (created by default)
         * Primary: Primary node terminal.
         * Custom: Custom terminal.
         * Direct: Direct connection to the terminal. (Only the operation and maintenance side)
         * AllNode: All node terminals. (Only the operation and maintenance side).
         */
        endpointType: string;
        /**
         * The list of nodes configured by the connection terminal and the corresponding read-only weights.
         */
        readOnlyNodeWeights: outputs.rds_postgresql.InstanceEndpointReadOnlyNodeWeight[];
        /**
         * Read and write mode:
         * ReadWrite: read and write
         * ReadOnly: read only (default).
         */
        readWriteMode: string;
    }

    export interface InstanceEndpointAddress {
        /**
         * DNS Visibility.
         */
        dnsVisibility: boolean;
        /**
         * Connect domain name.
         */
        domain: string;
        /**
         * The ID of the EIP, only valid for Public addresses.
         */
        eipId: string;
        /**
         * The IP Address.
         */
        ipAddress: string;
        /**
         * Network address type, temporarily Private, Public, PublicService.
         */
        networkType: string;
        /**
         * The Port.
         */
        port: string;
        /**
         * Subnet ID of the RDS PostgreSQL instance.
         */
        subnetId: string;
    }

    export interface InstanceEndpointReadOnlyNodeWeight {
        /**
         * Node ID.
         */
        nodeId: string;
        /**
         * Node type. Value: Primary: Primary node.
         * Secondary: Standby node.
         * ReadOnly: Read-only node.
         */
        nodeType: string;
        /**
         * The weight of the node.
         */
        weight: number;
    }

    export interface InstanceNode {
        /**
         * Node creation local time.
         */
        createTime: string;
        /**
         * Instance ID.
         */
        instanceId: string;
        /**
         * Memory size in GB.
         */
        memory: number;
        /**
         * Node ID.
         */
        nodeId: string;
        /**
         * The specification of primary node and secondary node.
         */
        nodeSpec: string;
        /**
         * Node state, value: aligned with instance state.
         */
        nodeStatus: string;
        /**
         * Node type. Value: Primary: Primary node.
         * Secondary: Standby node.
         * ReadOnly: Read-only node.
         */
        nodeType: string;
        /**
         * The region of the RDS PostgreSQL instance.
         */
        regionId: string;
        /**
         * The update time of the RDS PostgreSQL instance.
         */
        updateTime: string;
        /**
         * CPU size.
         */
        vCpu: number;
        /**
         * The available zone of the RDS PostgreSQL instance.
         */
        zoneId: string;
    }

    export interface InstanceParameter {
        /**
         * Parameter name.
         */
        name: string;
        /**
         * Parameter value.
         */
        value: string;
    }

    export interface InstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface InstancesInstance {
        /**
         * The instance has used backup space. Unit: GB.
         */
        backupUse: number;
        /**
         * Payment methods.
         */
        chargeDetails: outputs.rds_postgresql.InstancesInstanceChargeDetail[];
        /**
         * Node creation local time.
         */
        createTime: string;
        /**
         * Data synchronization mode.
         */
        dataSyncMode: string;
        /**
         * The version of the RDS PostgreSQL instance.
         */
        dbEngineVersion: string;
        /**
         * The endpoint info of the RDS instance.
         */
        endpoints: outputs.rds_postgresql.InstancesInstanceEndpoint[];
        /**
         * The ID of the RDS PostgreSQL instance.
         */
        id: string;
        /**
         * The id of the RDS PostgreSQL instance.
         */
        instanceId: string;
        /**
         * The name of the RDS PostgreSQL instance.
         */
        instanceName: string;
        /**
         * The status of the RDS PostgreSQL instance.
         */
        instanceStatus: string;
        /**
         * The instance type of the RDS PostgreSQL instance.
         */
        instanceType: string;
        /**
         * Memory size in GB.
         */
        memory: number;
        /**
         * The number of nodes.
         */
        nodeNumber: number;
        /**
         * General instance type, different from Custom instance type.
         */
        nodeSpec: string;
        /**
         * Instance node information.
         */
        nodes: outputs.rds_postgresql.InstancesInstanceNode[];
        /**
         * The project name of the RDS PostgreSQL instance.
         */
        projectName: string;
        /**
         * The region of the RDS PostgreSQL instance.
         */
        regionId: string;
        /**
         * Total instance storage space. Unit: GB.
         */
        storageSpace: number;
        /**
         * Instance storage type.
         */
        storageType: string;
        /**
         * The subnet ID of the RDS PostgreSQL instance.
         */
        subnetId: string;
        /**
         * Tags.
         */
        tags: outputs.rds_postgresql.InstancesInstanceTag[];
        /**
         * The update time of the RDS PostgreSQL instance.
         */
        updateTime: string;
        /**
         * CPU size.
         */
        vCpu: number;
        /**
         * The vpc ID of the RDS PostgreSQL instance.
         */
        vpcId: string;
        /**
         * The available zone of the RDS PostgreSQL instance.
         */
        zoneId: string;
        /**
         * ID of the availability zone where each instance is located.
         */
        zoneIds: string[];
    }

    export interface InstancesInstanceChargeDetail {
        /**
         * Whether to automatically renew in prepaid scenarios.
         * Autorenew_Enable
         * Autorenew_Disable (default).
         */
        autoRenew: boolean;
        /**
         * Billing expiry time (yearly and monthly only).
         */
        chargeEndTime: string;
        /**
         * Billing start time (pay-as-you-go & monthly subscription).
         */
        chargeStartTime: string;
        /**
         * Pay status. Value:
         * normal - normal
         * overdue - overdue
         * .
         */
        chargeStatus: string;
        /**
         * The charge type of the RDS instance.
         */
        chargeType: string;
        /**
         * Estimated release time when arrears are closed (pay-as-you-go & monthly subscription).
         */
        overdueReclaimTime: string;
        /**
         * Shutdown time in arrears (pay-as-you-go & monthly subscription).
         */
        overdueTime: string;
        /**
         * Purchase duration in prepaid scenarios. Default: 1.
         */
        period: number;
        /**
         * The purchase cycle in the prepaid scenario.
         * Month - monthly subscription (default)
         * Year - Package year.
         */
        periodUnit: string;
        /**
         * Temporary upgrade of restoration time.
         */
        tempModifyEndTime: string;
        /**
         * Start time of temporary upgrade.
         */
        tempModifyStartTime: string;
    }

    export interface InstancesInstanceEndpoint {
        /**
         * Address list.
         */
        addresses: outputs.rds_postgresql.InstancesInstanceEndpointAddress[];
        /**
         * When the terminal type is read-write terminal or read-only terminal, it supports setting whether new nodes are automatically added.
         */
        autoAddNewNodes: string;
        /**
         * Address description.
         */
        description: string;
        /**
         * Whether global read-only is enabled, value: Enable: Enable. Disable: Disabled.
         */
        enableReadOnly: string;
        /**
         * Whether read-write separation is enabled, value: Enable: Enable. Disable: Disabled.
         */
        enableReadWriteSplitting: string;
        /**
         * Instance connection terminal ID.
         */
        endpointId: string;
        /**
         * The instance connection terminal name.
         */
        endpointName: string;
        /**
         * Terminal type:
         * Cluster: The default terminal. (created by default)
         * Primary: Primary node terminal.
         * Custom: Custom terminal.
         * Direct: Direct connection to the terminal. (Only the operation and maintenance side)
         * AllNode: All node terminals. (Only the operation and maintenance side).
         */
        endpointType: string;
        /**
         * The list of nodes configured by the connection terminal and the corresponding read-only weights.
         */
        readOnlyNodeWeights: outputs.rds_postgresql.InstancesInstanceEndpointReadOnlyNodeWeight[];
        /**
         * Read and write mode:
         * ReadWrite: read and write
         * ReadOnly: read only (default).
         */
        readWriteMode: string;
    }

    export interface InstancesInstanceEndpointAddress {
        /**
         * DNS Visibility.
         */
        dnsVisibility: boolean;
        /**
         * Connect domain name.
         */
        domain: string;
        /**
         * The ID of the EIP, only valid for Public addresses.
         */
        eipId: string;
        /**
         * The IP Address.
         */
        ipAddress: string;
        /**
         * Network address type, temporarily Private, Public, PublicService.
         */
        networkType: string;
        /**
         * The Port.
         */
        port: string;
        /**
         * The subnet ID of the RDS PostgreSQL instance.
         */
        subnetId: string;
    }

    export interface InstancesInstanceEndpointReadOnlyNodeWeight {
        /**
         * Node ID.
         */
        nodeId: string;
        /**
         * Node type. Value: Primary: Primary node.
         * Secondary: Standby node.
         * ReadOnly: Read-only node.
         */
        nodeType: string;
        /**
         * The weight of the node.
         */
        weight: number;
    }

    export interface InstancesInstanceNode {
        /**
         * Node creation local time.
         */
        createTime: string;
        /**
         * The id of the RDS PostgreSQL instance.
         */
        instanceId: string;
        /**
         * Memory size in GB.
         */
        memory: number;
        /**
         * Node ID.
         */
        nodeId: string;
        /**
         * General instance type, different from Custom instance type.
         */
        nodeSpec: string;
        /**
         * Node state, value: aligned with instance state.
         */
        nodeStatus: string;
        /**
         * Node type. Value: Primary: Primary node.
         * Secondary: Standby node.
         * ReadOnly: Read-only node.
         */
        nodeType: string;
        /**
         * The region of the RDS PostgreSQL instance.
         */
        regionId: string;
        /**
         * The update time of the RDS PostgreSQL instance.
         */
        updateTime: string;
        /**
         * CPU size.
         */
        vCpu: number;
        /**
         * The available zone of the RDS PostgreSQL instance.
         */
        zoneId: string;
    }

    export interface InstancesInstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface InstancesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface SchemasSchema {
        /**
         * The name of the database.
         */
        dbName: string;
        /**
         * The owner of the schema.
         */
        owner: string;
        /**
         * The name of the schema.
         */
        schemaName: string;
    }

}

export namespace rds_v2 {
    export interface GetRdsInstancesV2RdsInstance {
        /**
         * Payment methods.
         */
        chargeDetail: outputs.rds_v2.GetRdsInstancesV2RdsInstanceChargeDetail;
        /**
         * The connection info ot the RDS instance.
         */
        connectionInfos: outputs.rds_v2.GetRdsInstancesV2RdsInstanceConnectionInfo[];
        /**
         * Node creation local time.
         */
        createTime: string;
        /**
         * The engine of the RDS instance.
         */
        dbEngine: string;
        /**
         * The version of the RDS instance, Value:
         * MySQL Community:
         * MySQL_5.7 - MySQL 5.7
         * MySQL_8_0 - MySQL 8.0
         * PostgreSQL Community:
         * PostgreSQL_11 - PostgreSQL 11
         * PostgreSQL_12 - PostgreSQL 12
         * Microsoft SQL Server: Not available at this time
         * SQLServer_2019 - SQL Server 2019
         * veDB for MySQL:
         * MySQL_8_0 - MySQL 8.0
         * veDB for PostgreSQL:
         * PostgreSQL_13 - PostgreSQL 13.
         */
        dbEngineVersion: string;
        /**
         * The ID of the RDS instance.
         */
        id: string;
        /**
         * The id of the RDS instance.
         */
        instanceId: string;
        /**
         * The name of the RDS instance.
         */
        instanceName: string;
        /**
         * The status of the RDS instance, Value:
         * Running - running
         * Creating - Creating
         * Deleting - Deleting
         * Restarting - Restarting
         * Restoring - Restoring
         * Updating - changing
         * Upgrading - Upgrading
         * Error - the error.
         */
        instanceStatus: string;
        /**
         * The type of the RDS instance, Value:
         * Value:
         * RDS for MySQL:
         * HA - high availability version;
         * RDS for PostgreSQL:
         * HA - high availability version;
         * Microsoft SQL Server: Not available at this time
         * Enterprise - Enterprise Edition
         * Standard - Standard Edition
         * Web - Web version
         * veDB for MySQL:
         * Cluster - Cluster Edition
         * veDB for PostgreSQL:
         * Cluster - Cluster Edition
         * MySQL Sharding:
         * HA - high availability version;.
         */
        instanceType: string;
        /**
         * Instance node information.
         */
        nodeDetailInfos: outputs.rds_v2.GetRdsInstancesV2RdsInstanceNodeDetailInfo[];
        /**
         * The number of nodes.
         */
        nodeNumber: number;
        /**
         * General instance type, different from Custom instance type.
         */
        nodeSpec: string;
        /**
         * Instance intranet port.
         */
        port: string;
        /**
         * Subordinate to the project.
         */
        projectName: string;
        /**
         * The region of the RDS instance.
         */
        regionId: string;
        /**
         * The number of shards.
         */
        shardNumber: number;
        /**
         * Total instance storage space. Unit: GB.
         */
        storageSpace: number;
        /**
         * Instance storage type. When the database type is MySQL/PostgreSQL/SQL_Server/MySQL Sharding, the value is:
         * LocalSSD - local SSD disk
         * When the database type is veDB_MySQL/veDB_PostgreSQL, the value is:
         * DistributedStorage - Distributed Storage.
         */
        storageType: string;
        /**
         * The instance has used storage space. Unit: GB.
         */
        storageUse: number;
        /**
         * The subnet ID of the RDS instance.
         */
        subnetId: string;
        /**
         * Time zone.
         */
        timeZone: string;
        /**
         * The vpc ID of the RDS instance.
         */
        vpcId: string;
        /**
         * The available zone of the RDS instance.
         */
        zoneId: string;
    }

    export interface GetRdsInstancesV2RdsInstanceChargeDetail {
        /**
         * Whether to automatically renew in prepaid scenarios.
         * Autorenew_Enable
         * Autorenew_Disable (default).
         */
        autoRenew: boolean;
        /**
         * Billing expiry time (yearly and monthly only).
         */
        chargeEndTime: string;
        /**
         * Billing start time (pay-as-you-go & monthly subscription).
         */
        chargeStartTime: string;
        /**
         * Pay status. Value:
         * normal - normal
         * overdue - overdue
         * .
         */
        chargeStatus: string;
        /**
         * The charge type of the RDS instance.
         */
        chargeType: string;
        /**
         * Estimated release time when arrears are closed (pay-as-you-go & monthly subscription).
         */
        overdueReclaimTime: string;
        /**
         * Shutdown time in arrears (pay-as-you-go & monthly subscription).
         */
        overdueTime: string;
        /**
         * Purchase duration in prepaid scenarios. Default: 1.
         */
        period: number;
        /**
         * The purchase cycle in the prepaid scenario.
         * Month - monthly subscription (default)
         * Year - Package year.
         */
        periodUnit: string;
    }

    export interface GetRdsInstancesV2RdsInstanceConnectionInfo {
        /**
         * Address list.
         */
        addresses: outputs.rds_v2.GetRdsInstancesV2RdsInstanceConnectionInfoAddress[];
        /**
         * When the terminal type is read-write terminal or read-only terminal, it supports setting whether new nodes are automatically added.
         */
        autoAddNewNodes: string;
        /**
         * Address description.
         */
        description: string;
        /**
         * Whether global read-only is enabled, value: Enable: Enable. Disable: Disabled.
         */
        enableReadOnly: string;
        /**
         * Whether read-write separation is enabled, value: Enable: Enable. Disable: Disabled.
         */
        enableReadWriteSplitting: string;
        /**
         * Instance connection terminal ID.
         */
        endpointId: string;
        /**
         * The instance connection terminal name.
         */
        endpointName: string;
        /**
         * Terminal type:
         * Cluster: The default terminal. (created by default)
         * Primary: Primary node terminal.
         * Custom: Custom terminal.
         * Direct: Direct connection to the terminal. (Only the operation and maintenance side)
         * AllNode: All node terminals. (Only the operation and maintenance side).
         */
        endpointType: string;
        /**
         * The list of nodes configured by the connection terminal and the corresponding read-only weights.
         */
        readOnlyNodeWeights: outputs.rds_v2.GetRdsInstancesV2RdsInstanceConnectionInfoReadOnlyNodeWeight[];
        /**
         * Read and write mode:
         * ReadWrite: read and write
         * ReadOnly: read only (default).
         */
        readWriteMode: string;
    }

    export interface GetRdsInstancesV2RdsInstanceConnectionInfoAddress {
        /**
         * Connect domain name.
         */
        domain: string;
        /**
         * The ID of the EIP, only valid for Public addresses.
         */
        eipId: string;
        /**
         * The IP Address.
         */
        ipAddress: string;
        /**
         * Network address type, temporarily Private, Public, PublicService.
         */
        networkType: string;
        /**
         * Instance intranet port.
         */
        port: string;
        /**
         * The subnet ID of the RDS instance.
         */
        subnetId: string;
    }

    export interface GetRdsInstancesV2RdsInstanceConnectionInfoReadOnlyNodeWeight {
        /**
         * Node ID.
         */
        nodeId: string;
        /**
         * Node type. Value: Primary: Primary node.
         * Secondary: Standby node.
         * ReadOnly: Read-only node.
         */
        nodeType: string;
        /**
         * The weight of the node.
         */
        weight: number;
    }

    export interface GetRdsInstancesV2RdsInstanceNodeDetailInfo {
        /**
         * Node creation local time.
         */
        createTime: string;
        /**
         * The id of the RDS instance.
         */
        instanceId: string;
        /**
         * Memory size in GB.
         */
        memory: number;
        /**
         * Node ID.
         */
        nodeId: string;
        /**
         * General instance type, different from Custom instance type.
         */
        nodeSpec: string;
        /**
         * Node state, value: aligned with instance state.
         */
        nodeStatus: string;
        /**
         * Node type. Value: Primary: Primary node.
         * Secondary: Standby node.
         * ReadOnly: Read-only node.
         */
        nodeType: string;
        /**
         * The region of the RDS instance.
         */
        regionId: string;
        /**
         * Node updates local time.
         */
        updateTime: string;
        /**
         * CPU size. For example: 1 means 1U.
         */
        vCpu: number;
        /**
         * The available zone of the RDS instance.
         */
        zoneId: string;
    }

    export interface RdsInstanceV2ChargeInfo {
        /**
         * Whether to automatically renew in prepaid scenarios.
         */
        autoRenew: boolean;
        /**
         * Payment type. Value:
         * PostPaid - Pay-As-You-Go
         * PrePaid - Yearly and monthly (default).
         */
        chargeType: string;
        /**
         * Purchase duration in prepaid scenarios. Default: 1.
         */
        period: number;
        /**
         * The purchase cycle in the prepaid scenario.
         * Month - monthly subscription (default)
         * Year - Package year.
         */
        periodUnit: string;
    }

    export interface RdsInstanceV2ConnectionInfo {
        /**
         * Address list.
         */
        addresses: outputs.rds_v2.RdsInstanceV2ConnectionInfoAddress[];
        /**
         * When the terminal type is read-write terminal or read-only terminal, it supports setting whether new nodes are automatically added.
         */
        autoAddNewNodes: string;
        /**
         * Address description.
         */
        description: string;
        /**
         * Whether global read-only is enabled, value: Enable: Enable. Disable: Disabled.
         */
        enableReadOnly: string;
        /**
         * Whether read-write separation is enabled, value: Enable: Enable. Disable: Disabled.
         */
        enableReadWriteSplitting: string;
        /**
         * Instance connection terminal ID.
         */
        endpointId: string;
        /**
         * The instance connection terminal name.
         */
        endpointName: string;
        /**
         * Terminal type:
         * Cluster: The default terminal. (created by default)
         * Primary: Primary node terminal.
         * Custom: Custom terminal.
         * Direct: Direct connection to the terminal. (Only the operation and maintenance side)
         * AllNode: All node terminals. (Only the operation and maintenance side).
         */
        endpointType: string;
        /**
         * The list of nodes configured by the connection terminal and the corresponding read-only weights.
         */
        readOnlyNodeWeights: outputs.rds_v2.RdsInstanceV2ConnectionInfoReadOnlyNodeWeight[];
        /**
         * Read and write mode:
         * ReadWrite: read and write
         * ReadOnly: read only (default).
         */
        readWriteMode: string;
    }

    export interface RdsInstanceV2ConnectionInfoAddress {
        /**
         * Connect domain name.
         */
        domain: string;
        /**
         * The ID of the EIP, only valid for Public addresses.
         */
        eipId: string;
        /**
         * The IP Address.
         */
        ipAddress: string;
        /**
         * Network address type, temporarily Private, Public, PublicService.
         */
        networkType: string;
        /**
         * The Port.
         */
        port: string;
        /**
         * Subnet ID.
         */
        subnetId: string;
    }

    export interface RdsInstanceV2ConnectionInfoReadOnlyNodeWeight {
        /**
         * The ID of the node.
         */
        nodeId: string;
        /**
         * The type of the node.
         */
        nodeType: string;
        /**
         * The weight of the node.
         */
        weight: number;
    }

    export interface RdsInstanceV2NodeInfo {
        /**
         * The ID of the node.
         */
        nodeId: string;
        /**
         * Masternode specs. Pass
         * DescribeDBInstanceSpecs Query the instance specifications that can be sold.
         */
        nodeSpec: string;
        /**
         * Node type, the value is "Primary", "Secondary", "ReadOnly".
         */
        nodeType: string;
        /**
         * Zone ID.
         */
        zoneId: string;
    }

    export interface RdsInstancesV2RdsInstance {
        /**
         * Payment methods.
         */
        chargeDetail: outputs.rds_v2.RdsInstancesV2RdsInstanceChargeDetail;
        /**
         * The connection info ot the RDS instance.
         */
        connectionInfos: outputs.rds_v2.RdsInstancesV2RdsInstanceConnectionInfo[];
        /**
         * Node creation local time.
         */
        createTime: string;
        /**
         * The engine of the RDS instance.
         */
        dbEngine: string;
        /**
         * The version of the RDS instance, Value:
         * MySQL Community:
         * MySQL_5.7 - MySQL 5.7
         * MySQL_8_0 - MySQL 8.0
         * PostgreSQL Community:
         * PostgreSQL_11 - PostgreSQL 11
         * PostgreSQL_12 - PostgreSQL 12
         * Microsoft SQL Server: Not available at this time
         * SQLServer_2019 - SQL Server 2019
         * veDB for MySQL:
         * MySQL_8_0 - MySQL 8.0
         * veDB for PostgreSQL:
         * PostgreSQL_13 - PostgreSQL 13.
         */
        dbEngineVersion: string;
        /**
         * The ID of the RDS instance.
         */
        id: string;
        /**
         * The id of the RDS instance.
         */
        instanceId: string;
        /**
         * The name of the RDS instance.
         */
        instanceName: string;
        /**
         * The status of the RDS instance, Value:
         * Running - running
         * Creating - Creating
         * Deleting - Deleting
         * Restarting - Restarting
         * Restoring - Restoring
         * Updating - changing
         * Upgrading - Upgrading
         * Error - the error.
         */
        instanceStatus: string;
        /**
         * The type of the RDS instance, Value:
         * Value:
         * RDS for MySQL:
         * HA - high availability version;
         * RDS for PostgreSQL:
         * HA - high availability version;
         * Microsoft SQL Server: Not available at this time
         * Enterprise - Enterprise Edition
         * Standard - Standard Edition
         * Web - Web version
         * veDB for MySQL:
         * Cluster - Cluster Edition
         * veDB for PostgreSQL:
         * Cluster - Cluster Edition
         * MySQL Sharding:
         * HA - high availability version;.
         */
        instanceType: string;
        /**
         * Instance node information.
         */
        nodeDetailInfos: outputs.rds_v2.RdsInstancesV2RdsInstanceNodeDetailInfo[];
        /**
         * The number of nodes.
         */
        nodeNumber: number;
        /**
         * General instance type, different from Custom instance type.
         */
        nodeSpec: string;
        /**
         * Instance intranet port.
         */
        port: string;
        /**
         * Subordinate to the project.
         */
        projectName: string;
        /**
         * The region of the RDS instance.
         */
        regionId: string;
        /**
         * The number of shards.
         */
        shardNumber: number;
        /**
         * Total instance storage space. Unit: GB.
         */
        storageSpace: number;
        /**
         * Instance storage type. When the database type is MySQL/PostgreSQL/SQL_Server/MySQL Sharding, the value is:
         * LocalSSD - local SSD disk
         * When the database type is veDB_MySQL/veDB_PostgreSQL, the value is:
         * DistributedStorage - Distributed Storage.
         */
        storageType: string;
        /**
         * The instance has used storage space. Unit: GB.
         */
        storageUse: number;
        /**
         * The subnet ID of the RDS instance.
         */
        subnetId: string;
        /**
         * Time zone.
         */
        timeZone: string;
        /**
         * The vpc ID of the RDS instance.
         */
        vpcId: string;
        /**
         * The available zone of the RDS instance.
         */
        zoneId: string;
    }

    export interface RdsInstancesV2RdsInstanceChargeDetail {
        /**
         * Whether to automatically renew in prepaid scenarios.
         * Autorenew_Enable
         * Autorenew_Disable (default).
         */
        autoRenew: boolean;
        /**
         * Billing expiry time (yearly and monthly only).
         */
        chargeEndTime: string;
        /**
         * Billing start time (pay-as-you-go & monthly subscription).
         */
        chargeStartTime: string;
        /**
         * Pay status. Value:
         * normal - normal
         * overdue - overdue
         * .
         */
        chargeStatus: string;
        /**
         * The charge type of the RDS instance.
         */
        chargeType: string;
        /**
         * Estimated release time when arrears are closed (pay-as-you-go & monthly subscription).
         */
        overdueReclaimTime: string;
        /**
         * Shutdown time in arrears (pay-as-you-go & monthly subscription).
         */
        overdueTime: string;
        /**
         * Purchase duration in prepaid scenarios. Default: 1.
         */
        period: number;
        /**
         * The purchase cycle in the prepaid scenario.
         * Month - monthly subscription (default)
         * Year - Package year.
         */
        periodUnit: string;
    }

    export interface RdsInstancesV2RdsInstanceConnectionInfo {
        /**
         * Address list.
         */
        addresses: outputs.rds_v2.RdsInstancesV2RdsInstanceConnectionInfoAddress[];
        /**
         * When the terminal type is read-write terminal or read-only terminal, it supports setting whether new nodes are automatically added.
         */
        autoAddNewNodes: string;
        /**
         * Address description.
         */
        description: string;
        /**
         * Whether global read-only is enabled, value: Enable: Enable. Disable: Disabled.
         */
        enableReadOnly: string;
        /**
         * Whether read-write separation is enabled, value: Enable: Enable. Disable: Disabled.
         */
        enableReadWriteSplitting: string;
        /**
         * Instance connection terminal ID.
         */
        endpointId: string;
        /**
         * The instance connection terminal name.
         */
        endpointName: string;
        /**
         * Terminal type:
         * Cluster: The default terminal. (created by default)
         * Primary: Primary node terminal.
         * Custom: Custom terminal.
         * Direct: Direct connection to the terminal. (Only the operation and maintenance side)
         * AllNode: All node terminals. (Only the operation and maintenance side).
         */
        endpointType: string;
        /**
         * The list of nodes configured by the connection terminal and the corresponding read-only weights.
         */
        readOnlyNodeWeights: outputs.rds_v2.RdsInstancesV2RdsInstanceConnectionInfoReadOnlyNodeWeight[];
        /**
         * Read and write mode:
         * ReadWrite: read and write
         * ReadOnly: read only (default).
         */
        readWriteMode: string;
    }

    export interface RdsInstancesV2RdsInstanceConnectionInfoAddress {
        /**
         * Connect domain name.
         */
        domain: string;
        /**
         * The ID of the EIP, only valid for Public addresses.
         */
        eipId: string;
        /**
         * The IP Address.
         */
        ipAddress: string;
        /**
         * Network address type, temporarily Private, Public, PublicService.
         */
        networkType: string;
        /**
         * Instance intranet port.
         */
        port: string;
        /**
         * The subnet ID of the RDS instance.
         */
        subnetId: string;
    }

    export interface RdsInstancesV2RdsInstanceConnectionInfoReadOnlyNodeWeight {
        /**
         * Node ID.
         */
        nodeId: string;
        /**
         * Node type. Value: Primary: Primary node.
         * Secondary: Standby node.
         * ReadOnly: Read-only node.
         */
        nodeType: string;
        /**
         * The weight of the node.
         */
        weight: number;
    }

    export interface RdsInstancesV2RdsInstanceNodeDetailInfo {
        /**
         * Node creation local time.
         */
        createTime: string;
        /**
         * The id of the RDS instance.
         */
        instanceId: string;
        /**
         * Memory size in GB.
         */
        memory: number;
        /**
         * Node ID.
         */
        nodeId: string;
        /**
         * General instance type, different from Custom instance type.
         */
        nodeSpec: string;
        /**
         * Node state, value: aligned with instance state.
         */
        nodeStatus: string;
        /**
         * Node type. Value: Primary: Primary node.
         * Secondary: Standby node.
         * ReadOnly: Read-only node.
         */
        nodeType: string;
        /**
         * The region of the RDS instance.
         */
        regionId: string;
        /**
         * Node updates local time.
         */
        updateTime: string;
        /**
         * CPU size. For example: 1 means 1U.
         */
        vCpu: number;
        /**
         * The available zone of the RDS instance.
         */
        zoneId: string;
    }

}

export namespace redis {
    export interface AccountsAccount {
        /**
         * The name of the redis account.
         */
        accountName: string;
        /**
         * The description of the redis account.
         */
        description: string;
        /**
         * The id of the Redis instance.
         */
        instanceId: string;
        /**
         * The role info.
         */
        roleName: string;
    }

    export interface AllowListAssociatedInstance {
        /**
         * Id of instance.
         */
        instanceId: string;
        /**
         * Name of instance.
         */
        instanceName: string;
        /**
         * Id of virtual private cloud.
         */
        vpc: string;
    }

    export interface AllowListSecurityGroupBindInfo {
        /**
         * Security group association mode. The value range is as follows: IngressDirectionIp: The input direction IP, which is the IP involved in the TCP protocol and ALL protocol in the source address of the secure group input direction to access the database. If the source address is configured as a secure group, it will be ignored. AssociateEcsIp: Associate ECS IP, which allows cloud servers within the security group to access the database. Currently, only the IP information of the main network card is supported for import.
         */
        bindMode: string;
        /**
         * The list of ips in the associated security group has been linked.
         */
        ipLists: string[];
        /**
         * The associated security group ID.
         */
        securityGroupId: string;
        /**
         * The name of the associated security group.
         */
        securityGroupName: string;
    }

    export interface AllowListsAllowList {
        /**
         * The type of the whitelist.
         */
        allowListCategory: string;
        /**
         * Description of allow list.
         */
        allowListDesc: string;
        /**
         * Id of allow list.
         */
        allowListId: string;
        /**
         * The IP number of allow list.
         */
        allowListIpNum: number;
        /**
         * Name of allow list.
         */
        allowListName: string;
        /**
         * Type of allow list.
         */
        allowListType: string;
        /**
         * Ip list of allow list.
         */
        allowLists: string[];
        /**
         * The number of instance that associated to allow list.
         */
        associatedInstanceNum: number;
        /**
         * Instances associated by this allow list.
         */
        associatedInstances: outputs.redis.AllowListsAllowListAssociatedInstance[];
        /**
         * The name of the project to which the white list belongs.
         */
        projectName: string;
        /**
         * The current whitelist is the list of security group information that has been associated.
         */
        securityGroupBindInfos: outputs.redis.AllowListsAllowListSecurityGroupBindInfo[];
    }

    export interface AllowListsAllowListAssociatedInstance {
        /**
         * The Id of instance.
         */
        instanceId: string;
        /**
         * Name of instance.
         */
        instanceName: string;
        /**
         * Id of virtual private cloud.
         */
        vpc: string;
    }

    export interface AllowListsAllowListSecurityGroupBindInfo {
        /**
         * Security group association mode. The value range is as follows: IngressDirectionIp: The input direction IP, which is the IP involved in the TCP protocol and ALL protocol in the source address of the secure group input direction to access the database. If the source address is configured as a secure group, it will be ignored. AssociateEcsIp: Associate ECS IP, which allows cloud servers within the security group to access the database. Currently, only the IP information of the main network card is supported for import.
         */
        bindMode: string;
        /**
         * The list of ips in the associated security group has been linked.
         */
        ipLists: string[];
        /**
         * The associated security group ID.
         */
        securityGroupId: string;
        /**
         * The name of the associated security group.
         */
        securityGroupName: string;
    }

    export interface BackupBackupPointDownloadUrl {
        /**
         * The private network download address for RDB files.
         */
        privateDownloadUrl: string;
        /**
         * The public network download address for RDB files.
         */
        publicDownloadUrl: string;
        /**
         * RDB file size, unit: Byte.
         */
        rdbFileSize: number;
        /**
         * The shard ID where the RDB file is located.
         */
        shardId: string;
    }

    export interface BackupInstanceInfo {
        /**
         * Id of account.
         */
        accountId: number;
        /**
         * Arch type of instance(Standard/Cluster).
         */
        archType: string;
        /**
         * Charge type of instance(Postpaid/Prepaid).
         */
        chargeType: string;
        /**
         * The status of the deletion protection function of the instance.
         */
        deletionProtection: string;
        /**
         * Engine version of instance.
         */
        engineVersion: string;
        /**
         * Expired time of instance.
         */
        expiredTime: string;
        /**
         * Id of instance to create backup.
         */
        instanceId: string;
        /**
         * Name of instance.
         */
        instanceName: string;
        /**
         * The maintainable period (in UTC) of the instance.
         */
        maintenanceTime: string;
        /**
         * Network type of instance.
         */
        networkType: string;
        /**
         * Id of region.
         */
        regionId: string;
        /**
         * Count of replica in which shard.
         */
        replicas: number;
        /**
         * Capacity of shard.
         */
        shardCapacity: number;
        /**
         * The number of shards in the instance.
         */
        shardNumber: number;
        /**
         * Total capacity of instance.
         */
        totalCapacity: number;
        /**
         * The private network ID of the instance.
         */
        vpcId: string;
        /**
         * List of id of zone.
         */
        zoneIds: string[];
    }

    export interface BackupsBackup {
        /**
         * The download address information of the backup file to which the current backup point belongs.
         */
        backupPointDownloadUrls: outputs.redis.BackupsBackupBackupPointDownloadUrl[];
        /**
         * The id of backup point.
         */
        backupPointId: string;
        /**
         * Backup strategy.
         */
        backupStrategy: string;
        /**
         * Backup type.
         */
        backupType: string;
        /**
         * Query end time.
         */
        endTime: string;
        /**
         * (**Deprecated**) Replaced by instance_info. Information of instance.
         *
         * @deprecated Replaced by instance_info.
         */
        instanceDetails: outputs.redis.BackupsBackupInstanceDetail[];
        /**
         * Id of instance.
         */
        instanceId: string;
        /**
         * Information of instance.
         */
        instanceInfos: outputs.redis.BackupsBackupInstanceInfo[];
        /**
         * Back up the project to which it belongs.
         */
        projectName: string;
        /**
         * Size in MiB.
         */
        size: number;
        /**
         * Query start time.
         */
        startTime: string;
        /**
         * Status of backup (Creating/Available/Unavailable/Deleting).
         */
        status: string;
        /**
         * Backup retention days.
         */
        ttl: number;
    }

    export interface BackupsBackupBackupPointDownloadUrl {
        /**
         * The private network download address for RDB files.
         */
        privateDownloadUrl: string;
        /**
         * The public network download address for RDB files.
         */
        publicDownloadUrl: string;
        /**
         * RDB file size, unit: Byte.
         */
        rdbFileSize: number;
        /**
         * The shard ID where the RDB file is located.
         */
        shardId: string;
    }

    export interface BackupsBackupInstanceDetail {
        /**
         * Id of account.
         */
        accountId: number;
        /**
         * Arch type of instance(Standard/Cluster).
         */
        archType: string;
        /**
         * Charge type of instance(Postpaid/Prepaid).
         */
        chargeType: string;
        /**
         * Engine version of instance.
         */
        engineVersion: string;
        /**
         * Expired time of instance.
         */
        expiredTime: string;
        /**
         * Id of instance.
         */
        instanceId: string;
        /**
         * Name of instance.
         */
        instanceName: string;
        /**
         * The maintainable period (in UTC) of the instance.
         */
        maintenanceTime: string;
        /**
         * Network type of instance.
         */
        networkType: string;
        /**
         * Back up the project to which it belongs.
         */
        projectName: string;
        /**
         * Id of region.
         */
        regionId: string;
        /**
         * Count of replica in which shard.
         */
        replicas: number;
        /**
         * Count of cpu cores of instance.
         */
        serverCpu: number;
        /**
         * Capacity of shard.
         */
        shardCapacity: number;
        /**
         * Count of shard.
         */
        shardCount: number;
        /**
         * Total capacity of instance.
         */
        totalCapacity: number;
        /**
         * Capacity used of this instance.
         */
        usedCapacity: number;
        /**
         * Information of vpc.
         */
        vpcInfos: outputs.redis.BackupsBackupInstanceDetailVpcInfo[];
        /**
         * List of id of zone.
         */
        zoneIds: string[];
    }

    export interface BackupsBackupInstanceDetailVpcInfo {
        /**
         * Id of vpc.
         */
        id: string;
        /**
         * Name of vpc.
         */
        name: string;
    }

    export interface BackupsBackupInstanceInfo {
        /**
         * Id of account.
         */
        accountId: number;
        /**
         * Arch type of instance(Standard/Cluster).
         */
        archType: string;
        /**
         * Charge type of instance(Postpaid/Prepaid).
         */
        chargeType: string;
        /**
         * The status of the deletion protection function of the instance.
         */
        deletionProtection: string;
        /**
         * Engine version of instance.
         */
        engineVersion: string;
        /**
         * Expired time of instance.
         */
        expiredTime: string;
        /**
         * Id of instance.
         */
        instanceId: string;
        /**
         * Name of instance.
         */
        instanceName: string;
        /**
         * The maintainable period (in UTC) of the instance.
         */
        maintenanceTime: string;
        /**
         * Network type of instance.
         */
        networkType: string;
        /**
         * Id of region.
         */
        regionId: string;
        /**
         * Count of replica in which shard.
         */
        replicas: number;
        /**
         * Capacity of shard.
         */
        shardCapacity: number;
        /**
         * The number of shards in the instance.
         */
        shardNumber: number;
        /**
         * Total capacity of instance.
         */
        totalCapacity: number;
        /**
         * The private network ID of the instance.
         */
        vpcId: string;
        /**
         * List of id of zone.
         */
        zoneIds: string[];
    }

    export interface BigKeysBigKey {
        /**
         * The name of the database to which the big Key belongs.
         */
        dbName: string;
        /**
         * The name of the big Key.
         */
        keyInfo: string;
        /**
         * Specify the data type used to filter the query results of hot keys.
         */
        keyType: string;
        /**
         * The number of elements contained in the large Key.
         */
        valueLen: string;
        /**
         * The memory usage of large keys, unit: Byte.
         */
        valueSize: string;
    }

    export interface GetAccountsAccount {
        /**
         * The name of the redis account.
         */
        accountName: string;
        /**
         * The description of the redis account.
         */
        description: string;
        /**
         * The id of the Redis instance.
         */
        instanceId: string;
        /**
         * The role info.
         */
        roleName: string;
    }

    export interface GetAllowListsAllowList {
        /**
         * The type of the whitelist.
         */
        allowListCategory: string;
        /**
         * Description of allow list.
         */
        allowListDesc: string;
        /**
         * Id of allow list.
         */
        allowListId: string;
        /**
         * The IP number of allow list.
         */
        allowListIpNum: number;
        /**
         * Name of allow list.
         */
        allowListName: string;
        /**
         * Type of allow list.
         */
        allowListType: string;
        /**
         * Ip list of allow list.
         */
        allowLists: string[];
        /**
         * The number of instance that associated to allow list.
         */
        associatedInstanceNum: number;
        /**
         * Instances associated by this allow list.
         */
        associatedInstances: outputs.redis.GetAllowListsAllowListAssociatedInstance[];
        /**
         * The name of the project to which the white list belongs.
         */
        projectName: string;
        /**
         * The current whitelist is the list of security group information that has been associated.
         */
        securityGroupBindInfos: outputs.redis.GetAllowListsAllowListSecurityGroupBindInfo[];
    }

    export interface GetAllowListsAllowListAssociatedInstance {
        /**
         * The Id of instance.
         */
        instanceId: string;
        /**
         * Name of instance.
         */
        instanceName: string;
        /**
         * Id of virtual private cloud.
         */
        vpc: string;
    }

    export interface GetAllowListsAllowListSecurityGroupBindInfo {
        /**
         * Security group association mode. The value range is as follows: IngressDirectionIp: The input direction IP, which is the IP involved in the TCP protocol and ALL protocol in the source address of the secure group input direction to access the database. If the source address is configured as a secure group, it will be ignored. AssociateEcsIp: Associate ECS IP, which allows cloud servers within the security group to access the database. Currently, only the IP information of the main network card is supported for import.
         */
        bindMode: string;
        /**
         * The list of ips in the associated security group has been linked.
         */
        ipLists: string[];
        /**
         * The associated security group ID.
         */
        securityGroupId: string;
        /**
         * The name of the associated security group.
         */
        securityGroupName: string;
    }

    export interface GetBackupsBackup {
        /**
         * The download address information of the backup file to which the current backup point belongs.
         */
        backupPointDownloadUrls: outputs.redis.GetBackupsBackupBackupPointDownloadUrl[];
        /**
         * The id of backup point.
         */
        backupPointId: string;
        /**
         * Backup strategy.
         */
        backupStrategy: string;
        /**
         * Backup type.
         */
        backupType: string;
        /**
         * Query end time.
         */
        endTime: string;
        /**
         * (**Deprecated**) Replaced by instance_info. Information of instance.
         *
         * @deprecated Replaced by instance_info.
         */
        instanceDetails: outputs.redis.GetBackupsBackupInstanceDetail[];
        /**
         * Id of instance.
         */
        instanceId: string;
        /**
         * Information of instance.
         */
        instanceInfos: outputs.redis.GetBackupsBackupInstanceInfo[];
        /**
         * Back up the project to which it belongs.
         */
        projectName: string;
        /**
         * Size in MiB.
         */
        size: number;
        /**
         * Query start time.
         */
        startTime: string;
        /**
         * Status of backup (Creating/Available/Unavailable/Deleting).
         */
        status: string;
        /**
         * Backup retention days.
         */
        ttl: number;
    }

    export interface GetBackupsBackupBackupPointDownloadUrl {
        /**
         * The private network download address for RDB files.
         */
        privateDownloadUrl: string;
        /**
         * The public network download address for RDB files.
         */
        publicDownloadUrl: string;
        /**
         * RDB file size, unit: Byte.
         */
        rdbFileSize: number;
        /**
         * The shard ID where the RDB file is located.
         */
        shardId: string;
    }

    export interface GetBackupsBackupInstanceDetail {
        /**
         * Id of account.
         */
        accountId: number;
        /**
         * Arch type of instance(Standard/Cluster).
         */
        archType: string;
        /**
         * Charge type of instance(Postpaid/Prepaid).
         */
        chargeType: string;
        /**
         * Engine version of instance.
         */
        engineVersion: string;
        /**
         * Expired time of instance.
         */
        expiredTime: string;
        /**
         * Id of instance.
         */
        instanceId: string;
        /**
         * Name of instance.
         */
        instanceName: string;
        /**
         * The maintainable period (in UTC) of the instance.
         */
        maintenanceTime: string;
        /**
         * Network type of instance.
         */
        networkType: string;
        /**
         * Back up the project to which it belongs.
         */
        projectName: string;
        /**
         * Id of region.
         */
        regionId: string;
        /**
         * Count of replica in which shard.
         */
        replicas: number;
        /**
         * Count of cpu cores of instance.
         */
        serverCpu: number;
        /**
         * Capacity of shard.
         */
        shardCapacity: number;
        /**
         * Count of shard.
         */
        shardCount: number;
        /**
         * Total capacity of instance.
         */
        totalCapacity: number;
        /**
         * Capacity used of this instance.
         */
        usedCapacity: number;
        /**
         * Information of vpc.
         */
        vpcInfos: outputs.redis.GetBackupsBackupInstanceDetailVpcInfo[];
        /**
         * List of id of zone.
         */
        zoneIds: string[];
    }

    export interface GetBackupsBackupInstanceDetailVpcInfo {
        /**
         * Id of vpc.
         */
        id: string;
        /**
         * Name of vpc.
         */
        name: string;
    }

    export interface GetBackupsBackupInstanceInfo {
        /**
         * Id of account.
         */
        accountId: number;
        /**
         * Arch type of instance(Standard/Cluster).
         */
        archType: string;
        /**
         * Charge type of instance(Postpaid/Prepaid).
         */
        chargeType: string;
        /**
         * The status of the deletion protection function of the instance.
         */
        deletionProtection: string;
        /**
         * Engine version of instance.
         */
        engineVersion: string;
        /**
         * Expired time of instance.
         */
        expiredTime: string;
        /**
         * Id of instance.
         */
        instanceId: string;
        /**
         * Name of instance.
         */
        instanceName: string;
        /**
         * The maintainable period (in UTC) of the instance.
         */
        maintenanceTime: string;
        /**
         * Network type of instance.
         */
        networkType: string;
        /**
         * Id of region.
         */
        regionId: string;
        /**
         * Count of replica in which shard.
         */
        replicas: number;
        /**
         * Capacity of shard.
         */
        shardCapacity: number;
        /**
         * The number of shards in the instance.
         */
        shardNumber: number;
        /**
         * Total capacity of instance.
         */
        totalCapacity: number;
        /**
         * The private network ID of the instance.
         */
        vpcId: string;
        /**
         * List of id of zone.
         */
        zoneIds: string[];
    }

    export interface GetBigKeysBigKey {
        /**
         * The name of the database to which the big Key belongs.
         */
        dbName: string;
        /**
         * The name of the big Key.
         */
        keyInfo: string;
        /**
         * Specify the data type used to filter the query results of hot keys.
         */
        keyType: string;
        /**
         * The number of elements contained in the large Key.
         */
        valueLen: string;
        /**
         * The memory usage of large keys, unit: Byte.
         */
        valueSize: string;
    }

    export interface GetInstanceSpecsInstanceSpec {
        /**
         * The architecture type of the Redis instance.
         */
        archType: string;
        /**
         * The type of Redis instance.
         */
        instanceClass?: string;
        /**
         * The list of the number of nodes allowed to be used per shard. The number of nodes allowed for different instance types varies.
         */
        nodeNumbers: number[];
        /**
         * The List of capacity specifications for a single shard.
         */
        shardCapacitySpecs: outputs.redis.GetInstanceSpecsInstanceSpecShardCapacitySpec[];
        /**
         * The list of shards that the instance is allowed to use. The number of shards allowed for use varies among different instance architecture types.
         */
        shardNumbers: number[];
    }

    export interface GetInstanceSpecsInstanceSpecShardCapacitySpec {
        /**
         * The default bandwidth of the instance under the current memory capacity.
         */
        defaultBandwidthPerShard: number;
        /**
         * The upper limit of bandwidth that an instance is allowed to modify under the current memory capacity.
         */
        maxAdditionalBandwidthPerShard: number;
        /**
         * The default maximum number of connections for a single shard.
         */
        maxConnectionsPerShard: number;
        /**
         * Single-shard memory capacity.
         */
        shardCapacity: number;
    }

    export interface GetInstancesInstance {
        /**
         * The additional bandwidth of a single shard, that is, the extra bandwidth that needs to be added on top of the default bandwidth, unit: MB/s.
         */
        additionalBandwidthPerShard: number;
        /**
         * The list of backup plans.
         */
        backupPlan: outputs.redis.GetInstancesInstanceBackupPlan;
        /**
         * The memory capacity information.
         */
        capacity: outputs.redis.GetInstancesInstanceCapacity;
        /**
         * The charge type of redis instance to query. Valid values: `PostPaid`, `PrePaid`.
         */
        chargeType: string;
        /**
         * Set the list of available zones to which the node belongs.
         */
        configureNodes: outputs.redis.GetInstancesInstanceConfigureNode[];
        /**
         * The creation time of the redis instance.
         */
        createTime: string;
        /**
         * The data storage form of the instance.
         */
        dataLayout: string;
        /**
         * The default bandwidth of a single shard in the instance. Both the read bandwidth (i.e., the downlink bandwidth) and the write bandwidth (i.e., the uplink bandwidth) are of this value. Unit: MB/s.
         */
        defaultBandwidthPerShard: number;
        /**
         * whether enable deletion protection.
         */
        deletionProtection: string;
        /**
         * The engine version of redis instance to query. Valid values: `4.0`, `5.0`, `6.0`.
         */
        engineVersion: string;
        /**
         * The expire time of the redis instance, valid when charge type is `PrePaid`.
         */
        expiredTime: string;
        /**
         * The id of the redis instance.
         */
        id: string;
        /**
         * The type of the instance.
         */
        instanceClass: string;
        /**
         * The id of redis instance to query. This field supports fuzzy queries.
         */
        instanceId: string;
        /**
         * The name of redis instance to query. This field supports fuzzy queries.
         */
        instanceName: string;
        /**
         * A detailed list of all Shard shards in the instance.
         */
        instanceShards: outputs.redis.GetInstancesInstanceInstanceShard[];
        /**
         * The maintainable time of the redis instance.
         */
        maintenanceTime: string;
        /**
         * The current maximum number of connections in a single shard for the instance of the instance.
         */
        maxConnections: number;
        /**
         * Set the availability zone deployment scheme for the instance. The value range is as follows: 
         * disabled: Single availability zone deployment scheme.
         * enabled: Multi-availability zone deployment scheme.
         * Description:
         * When the newly created instance is a single-node instance (that is, when the value of NodeNumber is 1), only the single availability zone deployment scheme is allowed. At this time, the value of MultiAZ must be disabled.
         */
        multiAz: string;
        /**
         * The list of redis instance node IDs.
         */
        nodeIds: string[];
        /**
         * The number of nodes in each shard.
         */
        nodeNumber: number;
        /**
         * The list of params.
         */
        params: outputs.redis.GetInstancesInstanceParam[];
        /**
         * The project name of redis instance to query.
         */
        projectName: string;
        /**
         * The region id of the redis instance.
         */
        regionId: string;
        /**
         * A detailed list of all Server nodes in the shard.
         */
        serverNodes: outputs.redis.GetInstancesInstanceServerNode[];
        /**
         * (**Deprecated**) Replaced by shard_capacity_v2. The memory capacity of each shard. Unit: GiB.
         *
         * @deprecated Replaced by shard_capacity_v2.
         */
        shardCapacity: number;
        /**
         * The memory capacity of each shard in the instance.
         */
        shardCapacityV2: number;
        /**
         * The ID of the shard.
         */
        shardId: string;
        /**
         * The number of shards in the redis instance.
         */
        shardNumber: number;
        /**
         * Whether enable sharded cluster for redis instance. Valid values: 0, 1.
         */
        shardedCluster: number;
        /**
         * The status of redis instance to query.
         */
        status: string;
        /**
         * The subnet id of the redis instance.
         */
        subnetId: string;
        /**
         * Tags.
         */
        tags: outputs.redis.GetInstancesInstanceTag[];
        /**
         * The list of connection information.
         */
        visitAddrs: outputs.redis.GetInstancesInstanceVisitAddr[];
        /**
         * Whether to enable password-free access when connecting to an instance through a private network.
         */
        vpcAuthMode: string;
        /**
         * The vpc id of redis instance to query. This field supports fuzzy queries.
         */
        vpcId: string;
        /**
         * The list of zone ID which the redis instance belongs.
         */
        zoneIds: string[];
    }

    export interface GetInstancesInstanceBackupPlan {
        /**
         * Whether enable auto backup.
         */
        active: boolean;
        /**
         * The time period to start performing the backup. The value range is any integer between 0 and 23, where 0 means that the system will perform the backup in the period of 00:00~01:00, 1 means that the backup will be performed in the period of 01:00~02:00, and so on.
         */
        backupHour: number;
        /**
         * The backup type.
         */
        backupType: string;
        /**
         * The expected time for the next backup to be performed.
         */
        expectNextBackupTime: string;
        /**
         * The id of redis instance to query. This field supports fuzzy queries.
         */
        instanceId: string;
        /**
         * The last time the backup policy was modified.
         */
        lastUpdateTime: string;
        /**
         * The backup cycle. The value can be any integer between 1 and 7. Among them, 1 means backup every Monday, 2 means backup every Tuesday, and so on.
         */
        periods: number[];
        /**
         * The number of days to keep backups, the default is 7 days.
         */
        ttl: number;
    }

    export interface GetInstancesInstanceCapacity {
        /**
         * The total memory capacity of the redis instance. Unit: MiB.
         */
        total: number;
        /**
         * The used memory capacity of the redis instance. Unit: MiB.
         */
        used: number;
    }

    export interface GetInstancesInstanceConfigureNode {
        /**
         * Set the availability zone to which the node belongs. The number of nodes of an instance (i.e., NodeNumber) and the availability zone deployment scheme (i.e., the value of the MultiAZ parameter) will affect the filling of the current parameter. Among them:
         * When a new instance is a single-node instance (i.e., the value of NodeNumber is 1), only a single availability zone deployment scheme is allowed (i.e., the value of MultiAZ must be disabled). At this time, only one availability zone needs to be passed in AZ, and all nodes in the instance will be deployed in this availability zone. When creating a new instance as a primary-standby instance (that is, when the value of NodeNumber is greater than or equal to 2), the number of availability zones passed in must be equal to the number of nodes in a single shard (that is, the value of the NodeNumber parameter), and the value of AZ must comply with the multi-availability zone deployment scheme rules. The specific rules are as follows: If the primary-standby instance selects the multi-availability zone deployment scheme (that is, the value of MultiAZ is enabled), then at least two different availability zone IDs must be passed in in AZ, and the first availability zone is the availability zone where the primary node is located. If the primary and standby instances choose a single availability zone deployment scheme (that is, the value of MultiAZ is disabled), then the availability zones passed in for each node must be the same.
         */
        az: string;
    }

    export interface GetInstancesInstanceInstanceShard {
        /**
         * The number of nodes in each shard.
         */
        nodeNumber: number;
        /**
         * A detailed list of all Server nodes in the shard.
         */
        serverNodes: outputs.redis.GetInstancesInstanceInstanceShardServerNode[];
        /**
         * The ID of the shard.
         */
        shardId: string;
    }

    export interface GetInstancesInstanceInstanceShardServerNode {
        /**
         * The current role of the node.
         */
        currentRole: string;
        /**
         * The ID of node.
         */
        nodeId: string;
        /**
         * The status of redis instance to query.
         */
        status: string;
        /**
         * The zone id of redis instance to query. This field supports fuzzy queries.
         */
        zoneId: string;
    }

    export interface GetInstancesInstanceParam {
        /**
         * Current value of the configuration parameter.
         */
        currentValue: string;
        /**
         * Default value of the configuration parameter.
         */
        defaultValue: string;
        /**
         * The description of this option item.
         */
        description: string;
        /**
         * Whether the current redis instance supports editing this parameter.
         */
        editableForInstance: boolean;
        /**
         * Whether need to reboot the redis instance when modifying this parameter.
         */
        needReboot: boolean;
        /**
         * The list of options. Valid when the configuration parameter type is `Radio`.
         */
        options: outputs.redis.GetInstancesInstanceParamOption[];
        /**
         * The name of the configuration parameter.
         */
        paramName: string;
        /**
         * The valid value range of the numeric type configuration parameter.
         */
        range: string;
        /**
         * The type of the configuration parameter.
         */
        type: string;
        /**
         * The unit of the numeric type configuration parameter.
         */
        unit: string;
    }

    export interface GetInstancesInstanceParamOption {
        /**
         * The description of this option item.
         */
        description: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetInstancesInstanceServerNode {
        /**
         * The current role of the node.
         */
        currentRole: string;
        /**
         * The ID of node.
         */
        nodeId: string;
        /**
         * The status of redis instance to query.
         */
        status: string;
        /**
         * The zone id of redis instance to query. This field supports fuzzy queries.
         */
        zoneId: string;
    }

    export interface GetInstancesInstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetInstancesInstanceVisitAddr {
        /**
         * The connection address type.
         */
        addrType: string;
        /**
         * The connection address.
         */
        address: string;
        /**
         * The EIP ID bound to the instance's public network address.
         */
        eipId: string;
        /**
         * The connection port.
         */
        port: string;
        /**
         * The ipv4 address of the connection address.
         */
        vip: string;
        /**
         * The ipv6 address of the connection address.
         */
        vipV6: string;
    }

    export interface GetInstancesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetParameterGroupsParameterGroup {
        /**
         * The creation time of the parameter template, in the format of yyyy-MM-ddTHH:mm:ssZ (UTC).
         */
        createTime: string;
        /**
         * Whether it is the default parameter template.
         */
        default: boolean;
        /**
         * The description the Optional parameters.
         */
        description: string;
        /**
         * The Redis database version applicable to the parameter template.
         */
        engineVersion: string;
        /**
         * The name of the parameter template.
         */
        name: string;
        /**
         * The ID of the parameter template.
         */
        parameterGroupId: string;
        /**
         * The number of parameters contained in the parameter template.
         */
        parameterNum: number;
        /**
         * The list of parameter information contained in the parameter template.
         */
        parameters: outputs.redis.GetParameterGroupsParameterGroupParameter[];
        /**
         * The source of creating the parameter template.
         */
        source: string;
        /**
         * The last update time of the parameter template, in the format of yyyy-MM-ddTHH:mm:ssZ (UTC).
         */
        updateTime: string;
    }

    export interface GetParameterGroupsParameterGroupParameter {
        /**
         * The current running value of the parameter.
         */
        currentValue: string;
        /**
         * The description the Optional parameters.
         */
        description: string;
        /**
         * Whether to restart the instance to take effect after modifying this parameter.
         */
        needReboot: boolean;
        /**
         * The optional list of selector type parameters.
         */
        options: outputs.redis.GetParameterGroupsParameterGroupParameterOption[];
        /**
         * The name of parameter.
         */
        paramName: string;
        /**
         * The value range of numerical type parameters.
         */
        range: string;
        /**
         * The type of the parameter.
         */
        type: string;
        /**
         * The unit of the numerical type parameter.
         */
        unit: string;
    }

    export interface GetParameterGroupsParameterGroupParameterOption {
        /**
         * The description the Optional parameters.
         */
        description: string;
        /**
         * Optional selector type parameters.
         */
        value: string;
    }

    export interface GetPitrTimeWindowsPeriod {
        /**
         * Recoverable end time (UTC time) supported when restoring data by point in time.
         */
        endTime: string;
        /**
         * The instance id.
         */
        instanceId: string;
        /**
         * The recoverable start time (in UTC time) supported when restoring data by point in time.
         */
        startTime: string;
    }

    export interface GetPlannedEventsPlannedEvent {
        /**
         * Event operation name.
         */
        actionName: string;
        /**
         * Whether the current event is allowed to be cancelled for execution.
         */
        canCancel: boolean;
        /**
         * Whether the execution time of the current event can be changed.
         */
        canModifyTime: boolean;
        /**
         * The ID of Event.
         */
        eventId: string;
        /**
         * The ID of instance.
         */
        instanceId: string;
        /**
         * The name of instance.
         */
        instanceName: string;
        /**
         * The latest execution time at which changes are allowed for the current event.
         */
        maxEndTime: string;
        /**
         * The latest execution time of the event plan. The format is yyyy-MM-ddTHH:mm:ssZ (UTC).
         */
        planEndTime: string;
        /**
         * The earliest planned execution time of the event. The format is yyyy-MM-ddTHH:mm:ssZ (UTC).
         */
        planStartTime: string;
        /**
         * The status of event.
         */
        status: string;
        /**
         * The type of event.
         */
        type: string;
    }

    export interface GetRegionsRegion {
        /**
         * Target region info.
         */
        regionId: string;
        /**
         * The name of region.
         */
        regionName: string;
    }

    export interface GetZonesZone {
        /**
         * The id of the zone.
         */
        id: string;
        /**
         * The id of the zone.
         */
        zoneId: string;
        /**
         * The name of the zone.
         */
        zoneName: string;
        /**
         * The status of the zone.
         */
        zoneStatus: number;
    }

    export interface InstanceConfigureNode {
        /**
         * Set the availability zone to which the node belongs. The number of nodes of an instance (i.e., NodeNumber) and the availability zone deployment scheme (i.e., the value of the MultiAZ parameter) will affect the filling of the current parameter. Among them:
         * When a new instance is a single-node instance (i.e., the value of NodeNumber is 1), only a single availability zone deployment scheme is allowed (i.e., the value of MultiAZ must be disabled). At this time, only one availability zone needs to be passed in AZ, and all nodes in the instance will be deployed in this availability zone. When creating a new instance as a primary-standby instance (that is, when the value of NodeNumber is greater than or equal to 2), the number of availability zones passed in must be equal to the number of nodes in a single shard (that is, the value of the NodeNumber parameter), and the value of AZ must comply with the multi-availability zone deployment scheme rules. The specific rules are as follows: If the primary-standby instance selects the multi-availability zone deployment scheme (that is, the value of MultiAZ is enabled), then at least two different availability zone IDs must be passed in in AZ, and the first availability zone is the availability zone where the primary node is located. If the primary and standby instances choose a single availability zone deployment scheme (that is, the value of MultiAZ is disabled), then the availability zones passed in for each node must be the same.
         */
        az: string;
    }

    export interface InstanceParamValue {
        /**
         * The name of configuration parameter.
         */
        name: string;
        /**
         * The value of configuration parameter.
         */
        value: string;
    }

    export interface InstanceSpecsInstanceSpec {
        /**
         * The architecture type of the Redis instance.
         */
        archType: string;
        /**
         * The type of Redis instance.
         */
        instanceClass?: string;
        /**
         * The list of the number of nodes allowed to be used per shard. The number of nodes allowed for different instance types varies.
         */
        nodeNumbers: number[];
        /**
         * The List of capacity specifications for a single shard.
         */
        shardCapacitySpecs: outputs.redis.InstanceSpecsInstanceSpecShardCapacitySpec[];
        /**
         * The list of shards that the instance is allowed to use. The number of shards allowed for use varies among different instance architecture types.
         */
        shardNumbers: number[];
    }

    export interface InstanceSpecsInstanceSpecShardCapacitySpec {
        /**
         * The default bandwidth of the instance under the current memory capacity.
         */
        defaultBandwidthPerShard: number;
        /**
         * The upper limit of bandwidth that an instance is allowed to modify under the current memory capacity.
         */
        maxAdditionalBandwidthPerShard: number;
        /**
         * The default maximum number of connections for a single shard.
         */
        maxConnectionsPerShard: number;
        /**
         * Single-shard memory capacity.
         */
        shardCapacity: number;
    }

    export interface InstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface InstancesInstance {
        /**
         * The additional bandwidth of a single shard, that is, the extra bandwidth that needs to be added on top of the default bandwidth, unit: MB/s.
         */
        additionalBandwidthPerShard: number;
        /**
         * The list of backup plans.
         */
        backupPlan: outputs.redis.InstancesInstanceBackupPlan;
        /**
         * The memory capacity information.
         */
        capacity: outputs.redis.InstancesInstanceCapacity;
        /**
         * The charge type of redis instance to query. Valid values: `PostPaid`, `PrePaid`.
         */
        chargeType: string;
        /**
         * Set the list of available zones to which the node belongs.
         */
        configureNodes: outputs.redis.InstancesInstanceConfigureNode[];
        /**
         * The creation time of the redis instance.
         */
        createTime: string;
        /**
         * The data storage form of the instance.
         */
        dataLayout: string;
        /**
         * The default bandwidth of a single shard in the instance. Both the read bandwidth (i.e., the downlink bandwidth) and the write bandwidth (i.e., the uplink bandwidth) are of this value. Unit: MB/s.
         */
        defaultBandwidthPerShard: number;
        /**
         * whether enable deletion protection.
         */
        deletionProtection: string;
        /**
         * The engine version of redis instance to query. Valid values: `4.0`, `5.0`, `6.0`.
         */
        engineVersion: string;
        /**
         * The expire time of the redis instance, valid when charge type is `PrePaid`.
         */
        expiredTime: string;
        /**
         * The id of the redis instance.
         */
        id: string;
        /**
         * The type of the instance.
         */
        instanceClass: string;
        /**
         * The id of redis instance to query. This field supports fuzzy queries.
         */
        instanceId: string;
        /**
         * The name of redis instance to query. This field supports fuzzy queries.
         */
        instanceName: string;
        /**
         * A detailed list of all Shard shards in the instance.
         */
        instanceShards: outputs.redis.InstancesInstanceInstanceShard[];
        /**
         * The maintainable time of the redis instance.
         */
        maintenanceTime: string;
        /**
         * The current maximum number of connections in a single shard for the instance of the instance.
         */
        maxConnections: number;
        /**
         * Set the availability zone deployment scheme for the instance. The value range is as follows: 
         * disabled: Single availability zone deployment scheme.
         * enabled: Multi-availability zone deployment scheme.
         * Description:
         * When the newly created instance is a single-node instance (that is, when the value of NodeNumber is 1), only the single availability zone deployment scheme is allowed. At this time, the value of MultiAZ must be disabled.
         */
        multiAz: string;
        /**
         * The list of redis instance node IDs.
         */
        nodeIds: string[];
        /**
         * The number of nodes in each shard.
         */
        nodeNumber: number;
        /**
         * The list of params.
         */
        params: outputs.redis.InstancesInstanceParam[];
        /**
         * The project name of redis instance to query.
         */
        projectName: string;
        /**
         * The region id of the redis instance.
         */
        regionId: string;
        /**
         * A detailed list of all Server nodes in the shard.
         */
        serverNodes: outputs.redis.InstancesInstanceServerNode[];
        /**
         * (**Deprecated**) Replaced by shard_capacity_v2. The memory capacity of each shard. Unit: GiB.
         *
         * @deprecated Replaced by shard_capacity_v2.
         */
        shardCapacity: number;
        /**
         * The memory capacity of each shard in the instance.
         */
        shardCapacityV2: number;
        /**
         * The ID of the shard.
         */
        shardId: string;
        /**
         * The number of shards in the redis instance.
         */
        shardNumber: number;
        /**
         * Whether enable sharded cluster for redis instance. Valid values: 0, 1.
         */
        shardedCluster: number;
        /**
         * The status of redis instance to query.
         */
        status: string;
        /**
         * The subnet id of the redis instance.
         */
        subnetId: string;
        /**
         * Tags.
         */
        tags: outputs.redis.InstancesInstanceTag[];
        /**
         * The list of connection information.
         */
        visitAddrs: outputs.redis.InstancesInstanceVisitAddr[];
        /**
         * Whether to enable password-free access when connecting to an instance through a private network.
         */
        vpcAuthMode: string;
        /**
         * The vpc id of redis instance to query. This field supports fuzzy queries.
         */
        vpcId: string;
        /**
         * The list of zone ID which the redis instance belongs.
         */
        zoneIds: string[];
    }

    export interface InstancesInstanceBackupPlan {
        /**
         * Whether enable auto backup.
         */
        active: boolean;
        /**
         * The time period to start performing the backup. The value range is any integer between 0 and 23, where 0 means that the system will perform the backup in the period of 00:00~01:00, 1 means that the backup will be performed in the period of 01:00~02:00, and so on.
         */
        backupHour: number;
        /**
         * The backup type.
         */
        backupType: string;
        /**
         * The expected time for the next backup to be performed.
         */
        expectNextBackupTime: string;
        /**
         * The id of redis instance to query. This field supports fuzzy queries.
         */
        instanceId: string;
        /**
         * The last time the backup policy was modified.
         */
        lastUpdateTime: string;
        /**
         * The backup cycle. The value can be any integer between 1 and 7. Among them, 1 means backup every Monday, 2 means backup every Tuesday, and so on.
         */
        periods: number[];
        /**
         * The number of days to keep backups, the default is 7 days.
         */
        ttl: number;
    }

    export interface InstancesInstanceCapacity {
        /**
         * The total memory capacity of the redis instance. Unit: MiB.
         */
        total: number;
        /**
         * The used memory capacity of the redis instance. Unit: MiB.
         */
        used: number;
    }

    export interface InstancesInstanceConfigureNode {
        /**
         * Set the availability zone to which the node belongs. The number of nodes of an instance (i.e., NodeNumber) and the availability zone deployment scheme (i.e., the value of the MultiAZ parameter) will affect the filling of the current parameter. Among them:
         * When a new instance is a single-node instance (i.e., the value of NodeNumber is 1), only a single availability zone deployment scheme is allowed (i.e., the value of MultiAZ must be disabled). At this time, only one availability zone needs to be passed in AZ, and all nodes in the instance will be deployed in this availability zone. When creating a new instance as a primary-standby instance (that is, when the value of NodeNumber is greater than or equal to 2), the number of availability zones passed in must be equal to the number of nodes in a single shard (that is, the value of the NodeNumber parameter), and the value of AZ must comply with the multi-availability zone deployment scheme rules. The specific rules are as follows: If the primary-standby instance selects the multi-availability zone deployment scheme (that is, the value of MultiAZ is enabled), then at least two different availability zone IDs must be passed in in AZ, and the first availability zone is the availability zone where the primary node is located. If the primary and standby instances choose a single availability zone deployment scheme (that is, the value of MultiAZ is disabled), then the availability zones passed in for each node must be the same.
         */
        az: string;
    }

    export interface InstancesInstanceInstanceShard {
        /**
         * The number of nodes in each shard.
         */
        nodeNumber: number;
        /**
         * A detailed list of all Server nodes in the shard.
         */
        serverNodes: outputs.redis.InstancesInstanceInstanceShardServerNode[];
        /**
         * The ID of the shard.
         */
        shardId: string;
    }

    export interface InstancesInstanceInstanceShardServerNode {
        /**
         * The current role of the node.
         */
        currentRole: string;
        /**
         * The ID of node.
         */
        nodeId: string;
        /**
         * The status of redis instance to query.
         */
        status: string;
        /**
         * The zone id of redis instance to query. This field supports fuzzy queries.
         */
        zoneId: string;
    }

    export interface InstancesInstanceParam {
        /**
         * Current value of the configuration parameter.
         */
        currentValue: string;
        /**
         * Default value of the configuration parameter.
         */
        defaultValue: string;
        /**
         * The description of this option item.
         */
        description: string;
        /**
         * Whether the current redis instance supports editing this parameter.
         */
        editableForInstance: boolean;
        /**
         * Whether need to reboot the redis instance when modifying this parameter.
         */
        needReboot: boolean;
        /**
         * The list of options. Valid when the configuration parameter type is `Radio`.
         */
        options: outputs.redis.InstancesInstanceParamOption[];
        /**
         * The name of the configuration parameter.
         */
        paramName: string;
        /**
         * The valid value range of the numeric type configuration parameter.
         */
        range: string;
        /**
         * The type of the configuration parameter.
         */
        type: string;
        /**
         * The unit of the numeric type configuration parameter.
         */
        unit: string;
    }

    export interface InstancesInstanceParamOption {
        /**
         * The description of this option item.
         */
        description: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface InstancesInstanceServerNode {
        /**
         * The current role of the node.
         */
        currentRole: string;
        /**
         * The ID of node.
         */
        nodeId: string;
        /**
         * The status of redis instance to query.
         */
        status: string;
        /**
         * The zone id of redis instance to query. This field supports fuzzy queries.
         */
        zoneId: string;
    }

    export interface InstancesInstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface InstancesInstanceVisitAddr {
        /**
         * The connection address type.
         */
        addrType: string;
        /**
         * The connection address.
         */
        address: string;
        /**
         * The EIP ID bound to the instance's public network address.
         */
        eipId: string;
        /**
         * The connection port.
         */
        port: string;
        /**
         * The ipv4 address of the connection address.
         */
        vip: string;
        /**
         * The ipv6 address of the connection address.
         */
        vipV6: string;
    }

    export interface InstancesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface ParameterGroupParamValue {
        /**
         * The parameter names that need to be included in the parameter template.
         */
        name: string;
        /**
         * The parameter values set for the corresponding parameters.
         */
        value: string;
    }

    export interface ParameterGroupsParameterGroup {
        /**
         * The creation time of the parameter template, in the format of yyyy-MM-ddTHH:mm:ssZ (UTC).
         */
        createTime: string;
        /**
         * Whether it is the default parameter template.
         */
        default: boolean;
        /**
         * The description the Optional parameters.
         */
        description: string;
        /**
         * The Redis database version applicable to the parameter template.
         */
        engineVersion: string;
        /**
         * The name of the parameter template.
         */
        name: string;
        /**
         * The ID of the parameter template.
         */
        parameterGroupId: string;
        /**
         * The number of parameters contained in the parameter template.
         */
        parameterNum: number;
        /**
         * The list of parameter information contained in the parameter template.
         */
        parameters: outputs.redis.ParameterGroupsParameterGroupParameter[];
        /**
         * The source of creating the parameter template.
         */
        source: string;
        /**
         * The last update time of the parameter template, in the format of yyyy-MM-ddTHH:mm:ssZ (UTC).
         */
        updateTime: string;
    }

    export interface ParameterGroupsParameterGroupParameter {
        /**
         * The current running value of the parameter.
         */
        currentValue: string;
        /**
         * The description the Optional parameters.
         */
        description: string;
        /**
         * Whether to restart the instance to take effect after modifying this parameter.
         */
        needReboot: boolean;
        /**
         * The optional list of selector type parameters.
         */
        options: outputs.redis.ParameterGroupsParameterGroupParameterOption[];
        /**
         * The name of parameter.
         */
        paramName: string;
        /**
         * The value range of numerical type parameters.
         */
        range: string;
        /**
         * The type of the parameter.
         */
        type: string;
        /**
         * The unit of the numerical type parameter.
         */
        unit: string;
    }

    export interface ParameterGroupsParameterGroupParameterOption {
        /**
         * The description the Optional parameters.
         */
        description: string;
        /**
         * Optional selector type parameters.
         */
        value: string;
    }

    export interface PitrTimeWindowsPeriod {
        /**
         * Recoverable end time (UTC time) supported when restoring data by point in time.
         */
        endTime: string;
        /**
         * The instance id.
         */
        instanceId: string;
        /**
         * The recoverable start time (in UTC time) supported when restoring data by point in time.
         */
        startTime: string;
    }

    export interface PlannedEventsPlannedEvent {
        /**
         * Event operation name.
         */
        actionName: string;
        /**
         * Whether the current event is allowed to be cancelled for execution.
         */
        canCancel: boolean;
        /**
         * Whether the execution time of the current event can be changed.
         */
        canModifyTime: boolean;
        /**
         * The ID of Event.
         */
        eventId: string;
        /**
         * The ID of instance.
         */
        instanceId: string;
        /**
         * The name of instance.
         */
        instanceName: string;
        /**
         * The latest execution time at which changes are allowed for the current event.
         */
        maxEndTime: string;
        /**
         * The latest execution time of the event plan. The format is yyyy-MM-ddTHH:mm:ssZ (UTC).
         */
        planEndTime: string;
        /**
         * The earliest planned execution time of the event. The format is yyyy-MM-ddTHH:mm:ssZ (UTC).
         */
        planStartTime: string;
        /**
         * The status of event.
         */
        status: string;
        /**
         * The type of event.
         */
        type: string;
    }

    export interface RegionsRegion {
        /**
         * Target region info.
         */
        regionId: string;
        /**
         * The name of region.
         */
        regionName: string;
    }

    export interface ZonesZone {
        /**
         * The id of the zone.
         */
        id: string;
        /**
         * The id of the zone.
         */
        zoneId: string;
        /**
         * The name of the zone.
         */
        zoneName: string;
        /**
         * The status of the zone.
         */
        zoneStatus: number;
    }

}

export namespace rocketmq {
    export interface AccessKeysAccessKey {
        /**
         * The access key id of the rocketmq key.
         */
        accessKey: string;
        /**
         * The acl config of the rocketmq key.
         */
        aclConfigJson: string;
        /**
         * The active status of the rocketmq key.
         */
        actived: boolean;
        /**
         * The default authority of the rocketmq key.
         */
        allAuthority: string;
        /**
         * The create time of the rocketmq key.
         */
        createTime: string;
        /**
         * The description of the rocketmq key.
         */
        description: string;
        /**
         * The id of rocketmq instance.
         */
        instanceId: string;
        /**
         * The secret key of the rocketmq key.
         */
        secretKey: string;
        /**
         * The custom authority of the rocketmq key.
         */
        topicPermissions: outputs.rocketmq.AccessKeysAccessKeyTopicPermission[];
    }

    export interface AccessKeysAccessKeyTopicPermission {
        /**
         * The custom authority for the topic.
         */
        permission: string;
        /**
         * The name of the rocketmq topic.
         */
        topicName: string;
    }

    export interface AllowListsRocketmqAllowList {
        /**
         * The description of the rocketmq allow list.
         */
        allowListDesc: string;
        /**
         * The id of the rocketmq allow list.
         */
        allowListId: string;
        /**
         * The number of ip address in the rocketmq allow list.
         */
        allowListIpNum: number;
        /**
         * The name of the rocketmq allow list.
         */
        allowListName: string;
        /**
         * The type of the rocketmq allow list.
         */
        allowListType: string;
        /**
         * The IP address or a range of IP addresses in CIDR format of the allow list.
         */
        allowLists: string[];
        /**
         * The number of the rocketmq instances associated with the allow list.
         */
        associatedInstanceNum: number;
        /**
         * The associated instance information of the allow list.
         */
        associatedInstances: outputs.rocketmq.AllowListsRocketmqAllowListAssociatedInstance[];
        /**
         * The id of the rocketmq allow list.
         */
        id: string;
    }

    export interface AllowListsRocketmqAllowListAssociatedInstance {
        /**
         * The id of the rocketmq instance.
         */
        instanceId: string;
        /**
         * The name of the rocketmq instance.
         */
        instanceName: string;
        /**
         * The vpc id of the rocketmq instance.
         */
        vpc: string;
    }

    export interface GetAccessKeysAccessKey {
        /**
         * The access key id of the rocketmq key.
         */
        accessKey: string;
        /**
         * The acl config of the rocketmq key.
         */
        aclConfigJson: string;
        /**
         * The active status of the rocketmq key.
         */
        actived: boolean;
        /**
         * The default authority of the rocketmq key.
         */
        allAuthority: string;
        /**
         * The create time of the rocketmq key.
         */
        createTime: string;
        /**
         * The description of the rocketmq key.
         */
        description: string;
        /**
         * The id of rocketmq instance.
         */
        instanceId: string;
        /**
         * The secret key of the rocketmq key.
         */
        secretKey: string;
        /**
         * The custom authority of the rocketmq key.
         */
        topicPermissions: outputs.rocketmq.GetAccessKeysAccessKeyTopicPermission[];
    }

    export interface GetAccessKeysAccessKeyTopicPermission {
        /**
         * The custom authority for the topic.
         */
        permission: string;
        /**
         * The name of the rocketmq topic.
         */
        topicName: string;
    }

    export interface GetAllowListsRocketmqAllowList {
        /**
         * The description of the rocketmq allow list.
         */
        allowListDesc: string;
        /**
         * The id of the rocketmq allow list.
         */
        allowListId: string;
        /**
         * The number of ip address in the rocketmq allow list.
         */
        allowListIpNum: number;
        /**
         * The name of the rocketmq allow list.
         */
        allowListName: string;
        /**
         * The type of the rocketmq allow list.
         */
        allowListType: string;
        /**
         * The IP address or a range of IP addresses in CIDR format of the allow list.
         */
        allowLists: string[];
        /**
         * The number of the rocketmq instances associated with the allow list.
         */
        associatedInstanceNum: number;
        /**
         * The associated instance information of the allow list.
         */
        associatedInstances: outputs.rocketmq.GetAllowListsRocketmqAllowListAssociatedInstance[];
        /**
         * The id of the rocketmq allow list.
         */
        id: string;
    }

    export interface GetAllowListsRocketmqAllowListAssociatedInstance {
        /**
         * The id of the rocketmq instance.
         */
        instanceId: string;
        /**
         * The name of the rocketmq instance.
         */
        instanceName: string;
        /**
         * The vpc id of the rocketmq instance.
         */
        vpc: string;
    }

    export interface GetGroupsRocketmqGroup {
        /**
         * The consumed topic information of the rocketmq group.
         */
        consumedClients: outputs.rocketmq.GetGroupsRocketmqGroupConsumedClient[];
        /**
         * The consumed topic information of the rocketmq group.
         */
        consumedTopics: outputs.rocketmq.GetGroupsRocketmqGroupConsumedTopic[];
        /**
         * The create time of the rocketmq group.
         */
        createTime: string;
        /**
         * The description of the rocketmq group.
         */
        description: string;
        /**
         * The id of rocketmq group. This field support fuzzy query.
         */
        groupId: string;
        /**
         * The type of rocketmq group. Valid values: `TCP`.
         */
        groupType: string;
        /**
         * Whether the subscription relationship of consumer instance groups within the group is consistent.
         */
        isSubSame: boolean;
        /**
         * The message delay time of the rocketmq group. The unit is milliseconds.
         */
        messageDelayTime: string;
        /**
         * The message model of the rocketmq group.
         */
        messageModel: string;
        /**
         * The status of the rocketmq group.
         */
        status: string;
        /**
         * The total consume rate of the rocketmq group. The unit is per second.
         */
        totalConsumeRate: string;
        /**
         * The total amount of unconsumed messages.
         */
        totalDiff: number;
    }

    export interface GetGroupsRocketmqGroupConsumedClient {
        /**
         * The address of the consumed client.
         */
        clientAddress: string;
        /**
         * The id of the consumed client.
         */
        clientId: string;
        /**
         * The amount of message.
         */
        diff: number;
        /**
         * The language of the consumed client.
         */
        language: string;
        /**
         * The version of the consumed client.
         */
        version: string;
    }

    export interface GetGroupsRocketmqGroupConsumedTopic {
        /**
         * The queue number of the rocketmq topic.
         */
        queueNum: number;
        /**
         * The sub string of the rocketmq topic.
         */
        subString: string;
        /**
         * The name of the rocketmq topic.
         */
        topicName: string;
    }

    export interface GetInstancesRocketmqInstance {
        /**
         * The account id of the rocketmq instance.
         */
        accountId: string;
        /**
         * Whether the private dns to public function is enabled for the rocketmq instance.
         */
        applyPrivateDnsToPublic: boolean;
        /**
         * The available queue number of the rocketmq instance.
         */
        availableQueueNumber: number;
        /**
         * The charge detail information of the rocketmq instance.
         */
        chargeDetails: outputs.rocketmq.GetInstancesRocketmqInstanceChargeDetail[];
        /**
         * The compute spec of the rocketmq instance.
         */
        computeSpec: string;
        /**
         * The connection information of the rocketmq.
         */
        connectionInfos: outputs.rocketmq.GetInstancesRocketmqInstanceConnectionInfo[];
        /**
         * The create time of the rocketmq instance.
         */
        createTime: string;
        /**
         * The eip id of the rocketmq instance.
         */
        eipId: string;
        /**
         * Whether the ssl authentication is enabled for the rocketmq instance.
         */
        enableSsl: boolean;
        /**
         * The reserved time of messages on the RocketMQ server of the message queue. Messages that exceed the reserved time will be cleared after expiration. The unit is in hours.
         */
        fileReservedTime: number;
        /**
         * The id of the rocketmq instance.
         */
        id: string;
        /**
         * The description of the rocketmq instance.
         */
        instanceDescription: string;
        /**
         * The id of rocketmq instance.
         */
        instanceId: string;
        /**
         * The name of rocketmq instance. This field support fuzzy query.
         */
        instanceName: string;
        /**
         * The status of rocketmq instance.
         */
        instanceStatus: string;
        /**
         * The project name of rocketmq instance.
         */
        projectName: string;
        /**
         * The region id of the rocketmq instance.
         */
        regionId: string;
        /**
         * The ssl mode of the rocketmq instance.
         */
        sslMode: string;
        /**
         * The total storage space of the rocketmq instance.
         */
        storageSpace: number;
        /**
         * The subnet id of the rocketmq instance.
         */
        subnetId: string;
        /**
         * Tags.
         */
        tags: outputs.rocketmq.GetInstancesRocketmqInstanceTag[];
        /**
         * The used group number of the rocketmq instance.
         */
        usedGroupNumber: number;
        /**
         * The used queue number of the rocketmq instance.
         */
        usedQueueNumber: number;
        /**
         * The used storage space of the rocketmq instance.
         */
        usedStorageSpace: number;
        /**
         * The used topic number of the rocketmq instance.
         */
        usedTopicNumber: number;
        /**
         * The version of rocketmq instance. Valid values: `4.8`.
         */
        version: string;
        /**
         * The vpc id of rocketmq instance.
         */
        vpcId: string;
        /**
         * The zone id of rocketmq instance.
         */
        zoneId: string;
    }

    export interface GetInstancesRocketmqInstanceChargeDetail {
        /**
         * Whether to enable automatic renewal.
         */
        autoRenew: boolean;
        /**
         * The charge expire time of the rocketmq instance.
         */
        chargeExpireTime: string;
        /**
         * The charge start time of the rocketmq instance.
         */
        chargeStartTime: string;
        /**
         * The charge status of the rocketmq instance.
         */
        chargeStatus: string;
        /**
         * The charge type of rocketmq instance. Valid values: `PostPaid`, `PrePaid`.
         */
        chargeType: string;
        /**
         * The overdue reclaim time of the rocketmq instance.
         */
        overdueReclaimTime: string;
        /**
         * The overdue time of the rocketmq instance.
         */
        overdueTime: string;
        /**
         * The period unit of the rocketmq instance.
         */
        periodUnit: string;
    }

    export interface GetInstancesRocketmqInstanceConnectionInfo {
        /**
         * The endpoint address ip of the rocketmq.
         */
        endpointAddressIp: string;
        /**
         * The endpoint type of the rocketmq.
         */
        endpointType: string;
        /**
         * The internal endpoint of the rocketmq.
         */
        internalEndpoint: string;
        /**
         * The network type of the rocketmq.
         */
        networkType: string;
        /**
         * The public endpoint of the rocketmq.
         */
        publicEndpoint: string;
    }

    export interface GetInstancesRocketmqInstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetInstancesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetTopicsRocketmqTopic {
        /**
         * The access policies of the rocketmq topic.
         */
        accessPolicies: outputs.rocketmq.GetTopicsRocketmqTopicAccessPolicy[];
        /**
         * The create time of the rocketmq topic.
         */
        createTime: string;
        /**
         * The description of the rocketmq topic.
         */
        description: string;
        /**
         * The groups information of the rocketmq topic.
         */
        groups: outputs.rocketmq.GetTopicsRocketmqTopicGroup[];
        /**
         * The id of rocketmq instance.
         */
        instanceId: string;
        /**
         * The type of the rocketmq message. Setting this parameter means filtering the Topic list based on the specified message type. The value explanation is as follows:
         * 0: Regular message
         * 1: Transaction message
         * 2: Partition order message
         * 3: Global sequential message
         * 4: Delay message.
         */
        messageType: number;
        /**
         * The number of the rocketmq topic queue.
         */
        queueNumber: number;
        /**
         * The queues information of the rocketmq topic.
         */
        queues: outputs.rocketmq.GetTopicsRocketmqTopicQueue[];
        /**
         * The name of the rocketmq topic. This field support fuzzy query.
         */
        topicName: string;
    }

    export interface GetTopicsRocketmqTopicAccessPolicy {
        /**
         * The access key of the rocketmq key.
         */
        accessKey: string;
        /**
         * The authority of the rocketmq key for the current topic.
         */
        authority: string;
    }

    export interface GetTopicsRocketmqTopicGroup {
        /**
         * The id of the rocketmq group.
         */
        groupId: string;
        /**
         * The message model of the rocketmq group.
         */
        messageModel: string;
        /**
         * The sub string of the rocketmq group.
         */
        subString: string;
    }

    export interface GetTopicsRocketmqTopicQueue {
        /**
         * The end offset of the rocketmq queue.
         */
        endOffset: number;
        /**
         * The last update timestamp of the rocketmq queue.
         */
        lastUpdateTimestamp: number;
        /**
         * The message count of the rocketmq queue.
         */
        messageCount: number;
        /**
         * The id of the rocketmq queue.
         */
        queueId: string;
        /**
         * The start offset of the rocketmq queue.
         */
        startOffset: number;
    }

    export interface GroupsRocketmqGroup {
        /**
         * The consumed topic information of the rocketmq group.
         */
        consumedClients: outputs.rocketmq.GroupsRocketmqGroupConsumedClient[];
        /**
         * The consumed topic information of the rocketmq group.
         */
        consumedTopics: outputs.rocketmq.GroupsRocketmqGroupConsumedTopic[];
        /**
         * The create time of the rocketmq group.
         */
        createTime: string;
        /**
         * The description of the rocketmq group.
         */
        description: string;
        /**
         * The id of rocketmq group. This field support fuzzy query.
         */
        groupId: string;
        /**
         * The type of rocketmq group. Valid values: `TCP`.
         */
        groupType: string;
        /**
         * Whether the subscription relationship of consumer instance groups within the group is consistent.
         */
        isSubSame: boolean;
        /**
         * The message delay time of the rocketmq group. The unit is milliseconds.
         */
        messageDelayTime: string;
        /**
         * The message model of the rocketmq group.
         */
        messageModel: string;
        /**
         * The status of the rocketmq group.
         */
        status: string;
        /**
         * The total consume rate of the rocketmq group. The unit is per second.
         */
        totalConsumeRate: string;
        /**
         * The total amount of unconsumed messages.
         */
        totalDiff: number;
    }

    export interface GroupsRocketmqGroupConsumedClient {
        /**
         * The address of the consumed client.
         */
        clientAddress: string;
        /**
         * The id of the consumed client.
         */
        clientId: string;
        /**
         * The amount of message.
         */
        diff: number;
        /**
         * The language of the consumed client.
         */
        language: string;
        /**
         * The version of the consumed client.
         */
        version: string;
    }

    export interface GroupsRocketmqGroupConsumedTopic {
        /**
         * The queue number of the rocketmq topic.
         */
        queueNum: number;
        /**
         * The sub string of the rocketmq topic.
         */
        subString: string;
        /**
         * The name of the rocketmq topic.
         */
        topicName: string;
    }

    export interface InstancesRocketmqInstance {
        /**
         * The account id of the rocketmq instance.
         */
        accountId: string;
        /**
         * Whether the private dns to public function is enabled for the rocketmq instance.
         */
        applyPrivateDnsToPublic: boolean;
        /**
         * The available queue number of the rocketmq instance.
         */
        availableQueueNumber: number;
        /**
         * The charge detail information of the rocketmq instance.
         */
        chargeDetails: outputs.rocketmq.InstancesRocketmqInstanceChargeDetail[];
        /**
         * The compute spec of the rocketmq instance.
         */
        computeSpec: string;
        /**
         * The connection information of the rocketmq.
         */
        connectionInfos: outputs.rocketmq.InstancesRocketmqInstanceConnectionInfo[];
        /**
         * The create time of the rocketmq instance.
         */
        createTime: string;
        /**
         * The eip id of the rocketmq instance.
         */
        eipId: string;
        /**
         * Whether the ssl authentication is enabled for the rocketmq instance.
         */
        enableSsl: boolean;
        /**
         * The reserved time of messages on the RocketMQ server of the message queue. Messages that exceed the reserved time will be cleared after expiration. The unit is in hours.
         */
        fileReservedTime: number;
        /**
         * The id of the rocketmq instance.
         */
        id: string;
        /**
         * The description of the rocketmq instance.
         */
        instanceDescription: string;
        /**
         * The id of rocketmq instance.
         */
        instanceId: string;
        /**
         * The name of rocketmq instance. This field support fuzzy query.
         */
        instanceName: string;
        /**
         * The status of rocketmq instance.
         */
        instanceStatus: string;
        /**
         * The project name of rocketmq instance.
         */
        projectName: string;
        /**
         * The region id of the rocketmq instance.
         */
        regionId: string;
        /**
         * The ssl mode of the rocketmq instance.
         */
        sslMode: string;
        /**
         * The total storage space of the rocketmq instance.
         */
        storageSpace: number;
        /**
         * The subnet id of the rocketmq instance.
         */
        subnetId: string;
        /**
         * Tags.
         */
        tags: outputs.rocketmq.InstancesRocketmqInstanceTag[];
        /**
         * The used group number of the rocketmq instance.
         */
        usedGroupNumber: number;
        /**
         * The used queue number of the rocketmq instance.
         */
        usedQueueNumber: number;
        /**
         * The used storage space of the rocketmq instance.
         */
        usedStorageSpace: number;
        /**
         * The used topic number of the rocketmq instance.
         */
        usedTopicNumber: number;
        /**
         * The version of rocketmq instance. Valid values: `4.8`.
         */
        version: string;
        /**
         * The vpc id of rocketmq instance.
         */
        vpcId: string;
        /**
         * The zone id of rocketmq instance.
         */
        zoneId: string;
    }

    export interface InstancesRocketmqInstanceChargeDetail {
        /**
         * Whether to enable automatic renewal.
         */
        autoRenew: boolean;
        /**
         * The charge expire time of the rocketmq instance.
         */
        chargeExpireTime: string;
        /**
         * The charge start time of the rocketmq instance.
         */
        chargeStartTime: string;
        /**
         * The charge status of the rocketmq instance.
         */
        chargeStatus: string;
        /**
         * The charge type of rocketmq instance. Valid values: `PostPaid`, `PrePaid`.
         */
        chargeType: string;
        /**
         * The overdue reclaim time of the rocketmq instance.
         */
        overdueReclaimTime: string;
        /**
         * The overdue time of the rocketmq instance.
         */
        overdueTime: string;
        /**
         * The period unit of the rocketmq instance.
         */
        periodUnit: string;
    }

    export interface InstancesRocketmqInstanceConnectionInfo {
        /**
         * The endpoint address ip of the rocketmq.
         */
        endpointAddressIp: string;
        /**
         * The endpoint type of the rocketmq.
         */
        endpointType: string;
        /**
         * The internal endpoint of the rocketmq.
         */
        internalEndpoint: string;
        /**
         * The network type of the rocketmq.
         */
        networkType: string;
        /**
         * The public endpoint of the rocketmq.
         */
        publicEndpoint: string;
    }

    export interface InstancesRocketmqInstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface InstancesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface RocketMQAccessKeyTopicPermission {
        /**
         * The custom authority for the topic.
         */
        permission: string;
        /**
         * The name of the rocketmq topic.
         */
        topicName: string;
    }

    export interface RocketMQAllowListAssociatedInstance {
        /**
         * The id of the rocketmq instance.
         */
        instanceId: string;
        /**
         * The name of the rocketmq instance.
         */
        instanceName: string;
        /**
         * The vpc id of the rocketmq instance.
         */
        vpc: string;
    }

    export interface RocketMQInstanceChargeInfo {
        /**
         * Whether to automatically renew in prepaid scenarios. Default is false.
         */
        autoRenew?: boolean;
        /**
         * The charge type of the rocketmq instance. Valid values: `PostPaid`, `PrePaid`.
         */
        chargeType: string;
        /**
         * Purchase duration in prepaid scenarios. When PeriodUnit is specified as `Monthly`, the value range is 1-9. When PeriodUnit is specified as `Yearly`, the value range is 1-3. Default is 1.
         */
        period?: number;
        /**
         * The purchase cycle in the prepaid scenario. Valid values: `Monthly`, `Yearly`. Default is `Monthly`.
         */
        periodUnit?: string;
    }

    export interface RocketMQInstanceConnectionInfo {
        /**
         * The endpoint address ip of the rocketmq.
         */
        endpointAddressIp: string;
        /**
         * The endpoint type of the rocketmq.
         */
        endpointType: string;
        /**
         * The internal endpoint of the rocketmq.
         */
        internalEndpoint: string;
        /**
         * The network type of the rocketmq.
         */
        networkType: string;
        /**
         * The public endpoint of the rocketmq.
         */
        publicEndpoint: string;
    }

    export interface RocketMQInstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface RocketMQTopicAccessPolicy {
        /**
         * The access key of the rocketmq key.
         */
        accessKey: string;
        /**
         * The authority of the rocketmq key for the current topic. Valid values: `ALL`, `PUB`, `SUB`, `DENY`. Default is `DENY`.
         */
        authority: string;
    }

    export interface RocketMQTopicGroup {
        /**
         * The id of the rocketmq group.
         */
        groupId: string;
        /**
         * The message model of the rocketmq group.
         */
        messageModel: string;
        /**
         * The sub string of the rocketmq group.
         */
        subString: string;
    }

    export interface RocketMQTopicQueue {
        /**
         * The end offset of the rocketmq queue.
         */
        endOffset: number;
        /**
         * The last update timestamp of the rocketmq queue.
         */
        lastUpdateTimestamp: number;
        /**
         * The message count of the rocketmq queue.
         */
        messageCount: number;
        /**
         * The id of the rocketmq queue.
         */
        queueId: string;
        /**
         * The start offset of the rocketmq queue.
         */
        startOffset: number;
    }

    export interface TopicsRocketmqTopic {
        /**
         * The access policies of the rocketmq topic.
         */
        accessPolicies: outputs.rocketmq.TopicsRocketmqTopicAccessPolicy[];
        /**
         * The create time of the rocketmq topic.
         */
        createTime: string;
        /**
         * The description of the rocketmq topic.
         */
        description: string;
        /**
         * The groups information of the rocketmq topic.
         */
        groups: outputs.rocketmq.TopicsRocketmqTopicGroup[];
        /**
         * The id of rocketmq instance.
         */
        instanceId: string;
        /**
         * The type of the rocketmq message. Setting this parameter means filtering the Topic list based on the specified message type. The value explanation is as follows:
         * 0: Regular message
         * 1: Transaction message
         * 2: Partition order message
         * 3: Global sequential message
         * 4: Delay message.
         */
        messageType: number;
        /**
         * The number of the rocketmq topic queue.
         */
        queueNumber: number;
        /**
         * The queues information of the rocketmq topic.
         */
        queues: outputs.rocketmq.TopicsRocketmqTopicQueue[];
        /**
         * The name of the rocketmq topic. This field support fuzzy query.
         */
        topicName: string;
    }

    export interface TopicsRocketmqTopicAccessPolicy {
        /**
         * The access key of the rocketmq key.
         */
        accessKey: string;
        /**
         * The authority of the rocketmq key for the current topic.
         */
        authority: string;
    }

    export interface TopicsRocketmqTopicGroup {
        /**
         * The id of the rocketmq group.
         */
        groupId: string;
        /**
         * The message model of the rocketmq group.
         */
        messageModel: string;
        /**
         * The sub string of the rocketmq group.
         */
        subString: string;
    }

    export interface TopicsRocketmqTopicQueue {
        /**
         * The end offset of the rocketmq queue.
         */
        endOffset: number;
        /**
         * The last update timestamp of the rocketmq queue.
         */
        lastUpdateTimestamp: number;
        /**
         * The message count of the rocketmq queue.
         */
        messageCount: number;
        /**
         * The id of the rocketmq queue.
         */
        queueId: string;
        /**
         * The start offset of the rocketmq queue.
         */
        startOffset: number;
    }

}

export namespace tls {
    export interface AlarmAlarmPeriodDetail {
        /**
         * Email alarm period, the unit is minutes, and the value range is 1~1440.
         */
        email: number;
        /**
         * Customize the webhook alarm period, the unit is minutes, and the value range is 1~1440.
         */
        generalWebhook: number;
        /**
         * Telephone alarm cycle, the unit is minutes, and the value range is 10~1440.
         */
        phone: number;
        /**
         * SMS alarm cycle, the unit is minutes, and the value range is 10~1440.
         */
        sms: number;
    }

    export interface AlarmNotifyGroupReceiver {
        /**
         * The end time.
         */
        endTime: string;
        /**
         * The list of the receiver channels. Currently supported channels: Email, Sms, Phone.
         */
        receiverChannels: string[];
        /**
         * List of the receiver names.
         */
        receiverNames: string[];
        /**
         * The receiver type, Can be set as: `User`(The id of user).
         */
        receiverType: string;
        /**
         * The start time.
         */
        startTime: string;
    }

    export interface AlarmNotifyGroupsGroup {
        /**
         * The id of the alarm notify group.
         */
        alarmNotifyGroupId: string;
        /**
         * The name of the alarm notify group.
         */
        alarmNotifyGroupName: string;
        /**
         * The create time the notification.
         */
        createTime: string;
        /**
         * The name of the iam project.
         */
        iamProjectName: string;
        /**
         * The modification time the notification.
         */
        modifyTime: string;
        /**
         * The notify group type.
         */
        notifyTypes: string[];
        /**
         * List of IAM users to receive alerts.
         */
        receivers: outputs.tls.AlarmNotifyGroupsGroupReceiver[];
    }

    export interface AlarmNotifyGroupsGroupReceiver {
        /**
         * The end time.
         */
        endTime: string;
        /**
         * The list of the receiver channels.
         */
        receiverChannels: string[];
        /**
         * List of the receiver names.
         */
        receiverNames: string[];
        /**
         * The receiver type.
         */
        receiverType: string;
        /**
         * The start time.
         */
        startTime: string;
    }

    export interface AlarmQueryRequest {
        /**
         * The end time of the query range is relative to the current historical time. The unit is minutes. The value is not positive and must be greater than StartTimeOffset. The maximum value is 0 and the minimum value is -1440.
         */
        endTimeOffset: number;
        /**
         * Alarm object sequence number; increments from 1.
         */
        number: number;
        /**
         * Query statement, the maximum supported length is 1024.
         */
        query: string;
        /**
         * The start time of the query range is relative to the current historical time, in minutes. The value is non-positive, the maximum value is 0, and the minimum value is -1440.
         */
        startTimeOffset: number;
        /**
         * The id of the topic.
         */
        topicId: string;
    }

    export interface AlarmRequestCycle {
        /**
         * The cycle of alarm task execution, or the time point of periodic execution. The unit is minutes, and the value range is 1~1440.
         */
        time: number;
        /**
         * Execution cycle type.
         * Period: Periodic execution, which means executing once every certain period of time.
         * Fixed: Regular execution, which means executing at a fixed time point every day.
         */
        type: string;
    }

    export interface AlarmsAlarm {
        /**
         * The alarm id.
         */
        alarmId: string;
        /**
         * The alarm name.
         */
        alarmName: string;
        /**
         * List of notification groups corresponding to the alarm.
         */
        alarmNotifyGroups: outputs.tls.AlarmsAlarmAlarmNotifyGroup[];
        /**
         * Period for sending alarm notifications. When the number of continuous alarm triggers reaches the specified limit (TriggerPeriod), Log Service will send alarm notifications according to the specified period.
         */
        alarmPeriod: number;
        /**
         * Period for sending alarm notifications. When the number of continuous alarm triggers reaches the specified limit (TriggerPeriod), Log Service will send alarm notifications according to the specified period.
         */
        alarmPeriodDetails: outputs.tls.AlarmsAlarmAlarmPeriodDetail[];
        /**
         * Alarm trigger condition.
         */
        condition: string;
        /**
         * The create time.
         */
        createTime: string;
        /**
         * The modify time.
         */
        modifyTime: string;
        /**
         * The project id.
         */
        projectId: string;
        /**
         * Search and analyze sentences, 1~3 can be configured.
         */
        queryRequests: outputs.tls.AlarmsAlarmQueryRequest[];
        /**
         * The execution period of the alarm task.
         */
        requestCycles: outputs.tls.AlarmsAlarmRequestCycle[];
        /**
         * The status.
         */
        status: boolean;
        /**
         * Continuous cycle. The alarm will be issued after the trigger condition is continuously met for TriggerPeriod periods; the minimum value is 1, the maximum value is 10, and the default value is 1.
         */
        triggerPeriod: number;
        /**
         * Customize the alarm notification content.
         */
        userDefineMsg: string;
    }

    export interface AlarmsAlarmAlarmNotifyGroup {
        /**
         * The id of the notify group.
         */
        alarmNotifyGroupId: string;
        /**
         * Name of the notification group.
         */
        alarmNotifyGroupName: string;
        /**
         * The create time.
         */
        createTime: string;
        /**
         * The iam project name.
         */
        iamProjectName: string;
        /**
         * The modify time.
         */
        modifyTime: string;
        /**
         * The notify group type.
         */
        notifyTypes: string[];
        /**
         * List of IAM users to receive alerts.
         */
        receivers: outputs.tls.AlarmsAlarmAlarmNotifyGroupReceiver[];
    }

    export interface AlarmsAlarmAlarmNotifyGroupReceiver {
        /**
         * The end time.
         */
        endTime: string;
        /**
         * The list of the receiver channels.
         */
        receiverChannels: string[];
        /**
         * List of the receiver names.
         */
        receiverNames: string[];
        /**
         * The receiver type.
         */
        receiverType: string;
        /**
         * The start time.
         */
        startTime: string;
    }

    export interface AlarmsAlarmAlarmPeriodDetail {
        /**
         * Email alarm period, the unit is minutes, and the value range is 1~1440.
         */
        email: number;
        /**
         * Customize the webhook alarm period, the unit is minutes, and the value range is 1~1440.
         */
        generalWebhook: number;
        /**
         * Telephone alarm cycle, the unit is minutes, and the value range is 10~1440.
         */
        phone: number;
        /**
         * SMS alarm cycle, the unit is minutes, and the value range is 10~1440.
         */
        sms: number;
    }

    export interface AlarmsAlarmQueryRequest {
        /**
         * The end time of the query range is relative to the current historical time. The unit is minutes. The value is not positive and must be greater than StartTimeOffset. The maximum value is 0 and the minimum value is -1440.
         */
        endTimeOffset: number;
        /**
         * Alarm object sequence number; increments from 1.
         */
        number: number;
        /**
         * Query statement, the maximum supported length is 1024.
         */
        query: string;
        /**
         * The start time of the query range is relative to the current historical time, in minutes. The value is non-positive, the maximum value is 0, and the minimum value is -1440.
         */
        startTimeOffset: number;
        /**
         * The topic id.
         */
        topicId: string;
        /**
         * The topic name.
         */
        topicName: string;
    }

    export interface AlarmsAlarmRequestCycle {
        /**
         * The cycle of alarm task execution, or the time point of periodic execution. The unit is minutes, and the value range is 1~1440.
         */
        time: number;
        /**
         * Execution cycle type.
         */
        type: string;
    }

    export interface ConsumerGroupsConsumerGroup {
        /**
         * The name of the consumer group.
         */
        consumerGroupName: string;
        /**
         * The time of heart rate expiration, measured in seconds, has a value range of 1 to 300.
         */
        heartbeatTtl: number;
        /**
         * Whether to consume in sequence.
         */
        orderedConsume: boolean;
        /**
         * The log project ID to which the consumption group belongs.
         */
        projectId: string;
        /**
         * The name of the log item to which the consumption group belongs.
         */
        projectName: string;
        /**
         * The log topic ID to which the consumer belongs.
         */
        topicIds: string[];
    }

    export interface EtlTaskTargetResource {
        /**
         * Customize the name of the output target, which needs to be used to refer to the output target in the data processing rules.
         */
        alias: string;
        /**
         * Cross-account authorized character names.
         */
        roleTrn?: string;
        /**
         * Log topics used for storing processed logs.
         */
        topicId: string;
    }

    export interface EtlTasksTask {
        /**
         * Processing task creation time.
         */
        createTime: string;
        /**
         * A simple description of the processing task.
         */
        description: string;
        /**
         * DSL type, fixed as NORMAL.
         */
        dslType: string;
        /**
         * The running status of the processing task.
         */
        enable: boolean;
        /**
         * Task scheduling status.
         */
        etlStatus: string;
        /**
         * The start time of the data to be processed.
         */
        fromTime: number;
        /**
         * Recent startup time.
         */
        lastEnableTime: string;
        /**
         * The most recent modification time of the processing task.
         */
        modifyTime: string;
        /**
         * The name of the processing task.
         */
        name: string;
        /**
         * Specify the log item ID for querying the data processing tasks under the specified log item.
         */
        projectId: string;
        /**
         * Specify the name of the log item for querying the data processing tasks under the specified log item. Support fuzzy query.
         */
        projectName: string;
        /**
         * Processing rules.
         */
        script: string;
        /**
         * Specify the log topic ID for querying the data processing tasks related to this log topic.
         */
        sourceTopicId: string;
        /**
         * Specify the name of the log topic for querying the data processing tasks related to this log topic. Support fuzzy matching.
         */
        sourceTopicName: string;
        /**
         * Output the relevant information of the target.
         */
        targetResources: outputs.tls.EtlTasksTaskTargetResource[];
        /**
         * The ID of the processing task.
         */
        taskId: string;
        /**
         * The task type is fixed as Resident.
         */
        taskType: string;
        /**
         * The end time of the data to be processed.
         */
        toTime: number;
    }

    export interface EtlTasksTaskTargetResource {
        /**
         * Customize the name of the output target, which needs to be used to refer to the output target in the data processing rules.
         */
        alias: string;
        /**
         * Specify the log item ID for querying the data processing tasks under the specified log item.
         */
        projectId: string;
        /**
         * Specify the name of the log item for querying the data processing tasks under the specified log item. Support fuzzy query.
         */
        projectName: string;
        /**
         * Log topics used for storing processed logs.
         */
        topicId: string;
        /**
         * The name of the log topic used for storing the processed logs.
         */
        topicName: string;
    }

    export interface GetAlarmNotifyGroupsGroup {
        /**
         * The id of the alarm notify group.
         */
        alarmNotifyGroupId: string;
        /**
         * The name of the alarm notify group.
         */
        alarmNotifyGroupName: string;
        /**
         * The create time the notification.
         */
        createTime: string;
        /**
         * The name of the iam project.
         */
        iamProjectName: string;
        /**
         * The modification time the notification.
         */
        modifyTime: string;
        /**
         * The notify group type.
         */
        notifyTypes: string[];
        /**
         * List of IAM users to receive alerts.
         */
        receivers: outputs.tls.GetAlarmNotifyGroupsGroupReceiver[];
    }

    export interface GetAlarmNotifyGroupsGroupReceiver {
        /**
         * The end time.
         */
        endTime: string;
        /**
         * The list of the receiver channels.
         */
        receiverChannels: string[];
        /**
         * List of the receiver names.
         */
        receiverNames: string[];
        /**
         * The receiver type.
         */
        receiverType: string;
        /**
         * The start time.
         */
        startTime: string;
    }

    export interface GetAlarmsAlarm {
        /**
         * The alarm id.
         */
        alarmId: string;
        /**
         * The alarm name.
         */
        alarmName: string;
        /**
         * List of notification groups corresponding to the alarm.
         */
        alarmNotifyGroups: outputs.tls.GetAlarmsAlarmAlarmNotifyGroup[];
        /**
         * Period for sending alarm notifications. When the number of continuous alarm triggers reaches the specified limit (TriggerPeriod), Log Service will send alarm notifications according to the specified period.
         */
        alarmPeriod: number;
        /**
         * Period for sending alarm notifications. When the number of continuous alarm triggers reaches the specified limit (TriggerPeriod), Log Service will send alarm notifications according to the specified period.
         */
        alarmPeriodDetails: outputs.tls.GetAlarmsAlarmAlarmPeriodDetail[];
        /**
         * Alarm trigger condition.
         */
        condition: string;
        /**
         * The create time.
         */
        createTime: string;
        /**
         * The modify time.
         */
        modifyTime: string;
        /**
         * The project id.
         */
        projectId: string;
        /**
         * Search and analyze sentences, 1~3 can be configured.
         */
        queryRequests: outputs.tls.GetAlarmsAlarmQueryRequest[];
        /**
         * The execution period of the alarm task.
         */
        requestCycles: outputs.tls.GetAlarmsAlarmRequestCycle[];
        /**
         * The status.
         */
        status: boolean;
        /**
         * Continuous cycle. The alarm will be issued after the trigger condition is continuously met for TriggerPeriod periods; the minimum value is 1, the maximum value is 10, and the default value is 1.
         */
        triggerPeriod: number;
        /**
         * Customize the alarm notification content.
         */
        userDefineMsg: string;
    }

    export interface GetAlarmsAlarmAlarmNotifyGroup {
        /**
         * The id of the notify group.
         */
        alarmNotifyGroupId: string;
        /**
         * Name of the notification group.
         */
        alarmNotifyGroupName: string;
        /**
         * The create time.
         */
        createTime: string;
        /**
         * The iam project name.
         */
        iamProjectName: string;
        /**
         * The modify time.
         */
        modifyTime: string;
        /**
         * The notify group type.
         */
        notifyTypes: string[];
        /**
         * List of IAM users to receive alerts.
         */
        receivers: outputs.tls.GetAlarmsAlarmAlarmNotifyGroupReceiver[];
    }

    export interface GetAlarmsAlarmAlarmNotifyGroupReceiver {
        /**
         * The end time.
         */
        endTime: string;
        /**
         * The list of the receiver channels.
         */
        receiverChannels: string[];
        /**
         * List of the receiver names.
         */
        receiverNames: string[];
        /**
         * The receiver type.
         */
        receiverType: string;
        /**
         * The start time.
         */
        startTime: string;
    }

    export interface GetAlarmsAlarmAlarmPeriodDetail {
        /**
         * Email alarm period, the unit is minutes, and the value range is 1~1440.
         */
        email: number;
        /**
         * Customize the webhook alarm period, the unit is minutes, and the value range is 1~1440.
         */
        generalWebhook: number;
        /**
         * Telephone alarm cycle, the unit is minutes, and the value range is 10~1440.
         */
        phone: number;
        /**
         * SMS alarm cycle, the unit is minutes, and the value range is 10~1440.
         */
        sms: number;
    }

    export interface GetAlarmsAlarmQueryRequest {
        /**
         * The end time of the query range is relative to the current historical time. The unit is minutes. The value is not positive and must be greater than StartTimeOffset. The maximum value is 0 and the minimum value is -1440.
         */
        endTimeOffset: number;
        /**
         * Alarm object sequence number; increments from 1.
         */
        number: number;
        /**
         * Query statement, the maximum supported length is 1024.
         */
        query: string;
        /**
         * The start time of the query range is relative to the current historical time, in minutes. The value is non-positive, the maximum value is 0, and the minimum value is -1440.
         */
        startTimeOffset: number;
        /**
         * The topic id.
         */
        topicId: string;
        /**
         * The topic name.
         */
        topicName: string;
    }

    export interface GetAlarmsAlarmRequestCycle {
        /**
         * The cycle of alarm task execution, or the time point of periodic execution. The unit is minutes, and the value range is 1~1440.
         */
        time: number;
        /**
         * Execution cycle type.
         */
        type: string;
    }

    export interface GetConsumerGroupsConsumerGroup {
        /**
         * The name of the consumer group.
         */
        consumerGroupName: string;
        /**
         * The time of heart rate expiration, measured in seconds, has a value range of 1 to 300.
         */
        heartbeatTtl: number;
        /**
         * Whether to consume in sequence.
         */
        orderedConsume: boolean;
        /**
         * The log project ID to which the consumption group belongs.
         */
        projectId: string;
        /**
         * The name of the log item to which the consumption group belongs.
         */
        projectName: string;
        /**
         * The log topic ID to which the consumer belongs.
         */
        topicIds: string[];
    }

    export interface GetEtlTasksTask {
        /**
         * Processing task creation time.
         */
        createTime: string;
        /**
         * A simple description of the processing task.
         */
        description: string;
        /**
         * DSL type, fixed as NORMAL.
         */
        dslType: string;
        /**
         * The running status of the processing task.
         */
        enable: boolean;
        /**
         * Task scheduling status.
         */
        etlStatus: string;
        /**
         * The start time of the data to be processed.
         */
        fromTime: number;
        /**
         * Recent startup time.
         */
        lastEnableTime: string;
        /**
         * The most recent modification time of the processing task.
         */
        modifyTime: string;
        /**
         * The name of the processing task.
         */
        name: string;
        /**
         * Specify the log item ID for querying the data processing tasks under the specified log item.
         */
        projectId: string;
        /**
         * Specify the name of the log item for querying the data processing tasks under the specified log item. Support fuzzy query.
         */
        projectName: string;
        /**
         * Processing rules.
         */
        script: string;
        /**
         * Specify the log topic ID for querying the data processing tasks related to this log topic.
         */
        sourceTopicId: string;
        /**
         * Specify the name of the log topic for querying the data processing tasks related to this log topic. Support fuzzy matching.
         */
        sourceTopicName: string;
        /**
         * Output the relevant information of the target.
         */
        targetResources: outputs.tls.GetEtlTasksTaskTargetResource[];
        /**
         * The ID of the processing task.
         */
        taskId: string;
        /**
         * The task type is fixed as Resident.
         */
        taskType: string;
        /**
         * The end time of the data to be processed.
         */
        toTime: number;
    }

    export interface GetEtlTasksTaskTargetResource {
        /**
         * Customize the name of the output target, which needs to be used to refer to the output target in the data processing rules.
         */
        alias: string;
        /**
         * Specify the log item ID for querying the data processing tasks under the specified log item.
         */
        projectId: string;
        /**
         * Specify the name of the log item for querying the data processing tasks under the specified log item. Support fuzzy query.
         */
        projectName: string;
        /**
         * Log topics used for storing processed logs.
         */
        topicId: string;
        /**
         * The name of the log topic used for storing the processed logs.
         */
        topicName: string;
    }

    export interface GetHostGroupsInfo {
        /**
         * The abnormal heartbeat status count of host.
         */
        abnormalHeartbeatStatusCount: number;
        /**
         * The latest version of log collector.
         */
        agentLatestVersion: string;
        /**
         * Whether enable auto update.
         */
        autoUpdate: boolean;
        /**
         * The create time of host group.
         */
        createTime: string;
        /**
         * The count of host.
         */
        hostCount: number;
        /**
         * The id of host group.
         */
        hostGroupId: string;
        /**
         * The name of host group.
         */
        hostGroupName: string;
        /**
         * The type of host group.
         */
        hostGroupType: string;
        /**
         * The identifier of host.
         */
        hostIdentifier: string;
        /**
         * The ip list of host group.
         */
        hostIpLists: string[];
        /**
         * The project name of iam.
         */
        iamProjectName: string;
        /**
         * The modify time of host group.
         */
        modifyTime: string;
        /**
         * The normal heartbeat status count of host.
         */
        normalHeartbeatStatusCount: number;
        /**
         * The rule count of host.
         */
        ruleCount: number;
        /**
         * Whether enable service logging.
         */
        serviceLogging: boolean;
        /**
         * The update end time of log collector.
         */
        updateEndTime: string;
        /**
         * The update start time of log collector.
         */
        updateStartTime: string;
    }

    export interface GetHostsHostInfo {
        /**
         * The the heartbeat status.
         */
        heartbeatStatus: number;
        /**
         * The id of host group.
         */
        hostGroupId: string;
        /**
         * The ip address.
         */
        ip: string;
        /**
         * The version of log collector.
         */
        logCollectorVersion: string;
    }

    export interface GetImportTasksTaskInfo {
        /**
         * The creation time of the data import task.
         */
        createTime: string;
        /**
         * Data import task description.
         */
        description: string;
        /**
         * The source information of the data import task.
         */
        importSourceInfo: outputs.tls.GetImportTasksTaskInfoImportSourceInfo;
        /**
         * Specify the log item ID for querying the data import tasks under the specified log item.
         */
        projectId: string;
        /**
         * Specify the name of the log item for querying the data import tasks under the specified log item. Support fuzzy query..
         */
        projectName: string;
        /**
         * Specify the import type for querying the data import tasks related to this import type.
         */
        sourceType: string;
        /**
         * Specify the status of the import task.
         */
        status?: number;
        /**
         * The output information of the data import task.
         */
        targetInfo: outputs.tls.GetImportTasksTaskInfoTargetInfo;
        /**
         * Import the task ID of the data to be queried.
         */
        taskId: string;
        /**
         * Import the task name of the data to be queried.
         */
        taskName: string;
        /**
         * The progress of the data import task.
         */
        taskStatistics: outputs.tls.GetImportTasksTaskInfoTaskStatistics;
        /**
         * Specify the log topic ID for querying the data import tasks related to this log topic.
         */
        topicId: string;
        /**
         * Specify the name of the log topic for querying the data import tasks related to this log topic. Support fuzzy query.
         */
        topicName: string;
    }

    export interface GetImportTasksTaskInfoImportSourceInfo {
        /**
         * TOS imports source information.
         */
        kafkaSourceInfo: outputs.tls.GetImportTasksTaskInfoImportSourceInfoKafkaSourceInfo;
        /**
         * TOS imports source information.
         */
        tosSourceInfo: outputs.tls.GetImportTasksTaskInfoImportSourceInfoTosSourceInfo;
    }

    export interface GetImportTasksTaskInfoImportSourceInfoKafkaSourceInfo {
        /**
         * The encoding format of the data.
         */
        encode: string;
        /**
         * Kafka consumer group.
         */
        group: string;
        /**
         * The service addresses corresponding to different types of Kafka clusters are different.
         */
        host: string;
        /**
         * The starting position of data import.
         */
        initialOffset: number;
        /**
         * When you are using the Volcano Engine Message Queue Kafka version, it should be set to the Kafka instance ID.
         */
        instanceId: string;
        /**
         * Whether to enable authentication.
         */
        isNeedAuth: boolean;
        /**
         * Password authentication mechanism.
         */
        mechanism: string;
        /**
         * The Kafka SASL user password used for identity authentication.
         */
        password: string;
        /**
         * Secure Transport protocol.
         */
        protocol: string;
        /**
         * Specify the log time.
         */
        timeSourceDefault: number;
        /**
         * Kafka Topic name.
         */
        topic: string;
        /**
         * The Kafka SASL username used for identity authentication.
         */
        username: string;
    }

    export interface GetImportTasksTaskInfoImportSourceInfoTosSourceInfo {
        /**
         * The TOS bucket where the log file is located.
         */
        bucket: string;
        /**
         * The compression mode of data in the TOS bucket.
         */
        compressType: string;
        /**
         * The path of the file to be imported in the TOS bucket.
         */
        prefix: string;
        /**
         * Regional ID.
         */
        region: string;
    }

    export interface GetImportTasksTaskInfoTargetInfo {
        /**
         * Log extraction rules.
         */
        extractRule: outputs.tls.GetImportTasksTaskInfoTargetInfoExtractRule;
        /**
         * Log sample.
         */
        logSample: string;
        /**
         * Specify the log parsing type when importing.
         */
        logType: string;
        /**
         * Regional ID.
         */
        region: string;
    }

    export interface GetImportTasksTaskInfoTargetInfoExtractRule {
        /**
         * The regular expression used to identify the first line in each log, and its matching part will serve as the beginning of the log.
         */
        beginRegex: string;
        /**
         * Log delimiter.
         */
        delimiter: string;
        /**
         * List of log field names (Keys).
         */
        keys: string[];
        /**
         * Reference symbol. The content wrapped by the reference will not be separated but will be parsed into a complete field. It is valid if and only if the LogType is delimiter_log.
         */
        quote: string;
        /**
         * The number of log lines skipped.
         */
        skipLineCount: number;
        /**
         * A regular expression for extracting time, used to extract the time value in the TimeKey field and parse it into the corresponding collection time.
         */
        timeExtractRegex: string;
        /**
         * The parsing format of the time field.
         */
        timeFormat: string;
        /**
         * The field name of the log time field.
         */
        timeKey: string;
        /**
         * Time zone, supporting both machine time zone (default) and custom time zone. Among them, the custom time zone supports GMT and UTC.
         */
        timeZone: string;
        /**
         * When uploading a log that failed to parse, the key name of the parse failed log.
         */
        unMatchLogKey: string;
        /**
         * Whether to upload the logs of failed parsing.
         */
        unMatchUpLoadSwitch: boolean;
    }

    export interface GetImportTasksTaskInfoTaskStatistics {
        /**
         * The total number of resource bytes that have been listed.
         */
        bytesTotal: number;
        /**
         * The number of imported bytes.
         */
        bytesTransferred: number;
        /**
         * The number of resources that failed to import.
         */
        failed: number;
        /**
         * The number of non-existent resources.
         */
        notExist: number;
        /**
         * Skip the number of imported resources.
         */
        skipped: number;
        /**
         * Import the status of the task.
         */
        taskStatus: string;
        /**
         * The total number of resources that have been listed.
         */
        total: number;
        /**
         * The number of imported resources.
         */
        transferred: number;
    }

    export interface GetIndexesTlsIndex {
        /**
         * The create time of the tls index.
         */
        createTime: string;
        /**
         * The FullText index of the tls topic.
         */
        fullText: outputs.tls.GetIndexesTlsIndexFullText;
        /**
         * The topic id of the tls index.
         */
        id: string;
        /**
         * The KeyValue index of the tls topic.
         */
        keyValues: outputs.tls.GetIndexesTlsIndexKeyValue[];
        /**
         * The modify time of the tls index.
         */
        modifyTime: string;
        /**
         * The topic id of the tls index.
         */
        topicId: string;
        /**
         * The reserved field index configuration of the tls topic.
         */
        userInnerKeyValues: outputs.tls.GetIndexesTlsIndexUserInnerKeyValue[];
    }

    export interface GetIndexesTlsIndexFullText {
        /**
         * Whether the value is case sensitive.
         */
        caseSensitive: boolean;
        /**
         * The delimiter of the value.
         */
        delimiter: string;
        /**
         * Whether the value include chinese.
         */
        includeChinese: boolean;
    }

    export interface GetIndexesTlsIndexKeyValue {
        /**
         * Whether the value is case sensitive.
         */
        caseSensitive: boolean;
        /**
         * The delimiter of the value.
         */
        delimiter: string;
        /**
         * Whether the value include chinese.
         */
        includeChinese: boolean;
        /**
         * Whether to create indexes for all fields in JSON fields with text values.
         */
        indexAll: boolean;
        /**
         * The JSON subfield key value index.
         */
        jsonKeys: outputs.tls.GetIndexesTlsIndexKeyValueJsonKey[];
        /**
         * The key of the KeyValue index.
         */
        key: string;
        /**
         * Whether the filed is enabled for analysis.
         */
        sqlFlag: boolean;
        /**
         * The type of value.
         */
        valueType: string;
    }

    export interface GetIndexesTlsIndexKeyValueJsonKey {
        /**
         * Whether the value is case sensitive.
         */
        caseSensitive: boolean;
        /**
         * The delimiter of the value.
         */
        delimiter: string;
        /**
         * Whether the value include chinese.
         */
        includeChinese: boolean;
        /**
         * The key of the KeyValue index.
         */
        key: string;
        /**
         * Whether the filed is enabled for analysis.
         */
        sqlFlag: boolean;
        /**
         * The type of value.
         */
        valueType: string;
    }

    export interface GetIndexesTlsIndexUserInnerKeyValue {
        /**
         * Whether the value is case sensitive.
         */
        caseSensitive: boolean;
        /**
         * The delimiter of the value.
         */
        delimiter: string;
        /**
         * Whether the value include chinese.
         */
        includeChinese: boolean;
        /**
         * The JSON subfield key value index.
         */
        jsonKeys: outputs.tls.GetIndexesTlsIndexUserInnerKeyValueJsonKey[];
        /**
         * The key of the KeyValue index.
         */
        key: string;
        /**
         * Whether the filed is enabled for analysis.
         */
        sqlFlag: boolean;
        /**
         * The type of value.
         */
        valueType: string;
    }

    export interface GetIndexesTlsIndexUserInnerKeyValueJsonKey {
        /**
         * Whether the value is case sensitive.
         */
        caseSensitive: boolean;
        /**
         * The delimiter of the value.
         */
        delimiter: string;
        /**
         * Whether the value include chinese.
         */
        includeChinese: boolean;
        /**
         * The key of the KeyValue index.
         */
        key: string;
        /**
         * Whether the filed is enabled for analysis.
         */
        sqlFlag: boolean;
        /**
         * The type of value.
         */
        valueType: string;
    }

    export interface GetKafkaConsumersData {
        /**
         * Whether allow consume.
         */
        allowConsume: boolean;
        /**
         * The topic of consume.
         */
        consumeTopic: string;
        /**
         * The ID of Topic.
         */
        topicId: string;
    }

    export interface GetProjectsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetProjectsTlsProject {
        /**
         * The create time of the tls project.
         */
        createTime: string;
        /**
         * The description of the tls project.
         */
        description: string;
        /**
         * The IAM project name of the tls project.
         */
        iamProjectName: string;
        /**
         * The ID of the tls project.
         */
        id: string;
        /**
         * The inner net domain of the tls project.
         */
        innerNetDomain: string;
        /**
         * The id of tls project. This field supports fuzzy queries. It is not supported to specify both ProjectName and ProjectId at the same time.
         */
        projectId: string;
        /**
         * The name of tls project. This field supports fuzzy queries. It is not supported to specify both ProjectName and ProjectId at the same time.
         */
        projectName: string;
        /**
         * Tags.
         */
        tags: outputs.tls.GetProjectsTlsProjectTag[];
        /**
         * The count of topics in the tls project.
         */
        topicCount: number;
    }

    export interface GetProjectsTlsProjectTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetRuleAppliersRule {
        /**
         * Container collection rules.
         */
        containerRules: outputs.tls.GetRuleAppliersRuleContainerRule[];
        /**
         * The creation time.
         */
        createTime: string;
        /**
         * Collect the blacklist list.
         */
        excludePaths: outputs.tls.GetRuleAppliersRuleExcludePath[];
        /**
         * The extract rule.
         */
        extractRules: outputs.tls.GetRuleAppliersRuleExtractRule[];
        /**
         * The collection type.
         */
        inputType: number;
        /**
         * Log sample.
         */
        logSample: string;
        /**
         * The log type.
         */
        logType: string;
        /**
         * The modification time.
         */
        modifyTime: string;
        /**
         * Collection path list.
         */
        paths: string[];
        /**
         * The rule id.
         */
        ruleId: string;
        /**
         * The rule name.
         */
        ruleName: string;
        /**
         * The topic id.
         */
        topicId: string;
        /**
         * The topic name.
         */
        topicName: string;
        /**
         * User-defined collection rules.
         */
        userDefineRules: outputs.tls.GetRuleAppliersRuleUserDefineRule[];
    }

    export interface GetRuleAppliersRuleContainerRule {
        /**
         * The name of the container to be collected.
         */
        containerNameRegex: string;
        /**
         * Whether to add environment variables as log tags to raw log data.
         */
        envTag: {[key: string]: any};
        /**
         * The container environment variable blacklist is used to specify the range of containers not to be collected.
         */
        excludeContainerEnvRegex: {[key: string]: any};
        /**
         * The container Label blacklist is used to specify the range of containers not to be collected.
         */
        excludeContainerLabelRegex: {[key: string]: any};
        /**
         * The container environment variable whitelist specifies the container to be collected through the container environment variable. If the whitelist is not enabled, it means that all containers are specified to be collected.
         */
        includeContainerEnvRegex: {[key: string]: any};
        /**
         * The container label whitelist specifies the containers to be collected through the container label. If the whitelist is not enabled, all containers are specified to be collected.
         */
        includeContainerLabelRegex: {[key: string]: any};
        /**
         * Collection rules for Kubernetes containers.
         */
        kubernetesRules: outputs.tls.GetRuleAppliersRuleContainerRuleKubernetesRule[];
        /**
         * The collection mode.
         */
        stream: string;
    }

    export interface GetRuleAppliersRuleContainerRuleKubernetesRule {
        /**
         * Whether to add Kubernetes Annotation as a log tag to the raw log data.
         */
        annotationTag: {[key: string]: any};
        /**
         * Specify the containers not to be collected through the Pod Label blacklist, and not enable means to collect all containers.
         */
        excludePodLabelRegex: {[key: string]: any};
        /**
         * The Pod Label whitelist is used to specify containers to be collected. When the Pod Label whitelist is not enabled, it means that all containers are collected.
         */
        includePodLabelRegex: {[key: string]: any};
        /**
         * Whether to add Kubernetes Label as a log label to the original log data.
         */
        labelTag: {[key: string]: any};
        /**
         * The name of the Kubernetes Namespace to be collected. If no Namespace name is specified, all containers will be collected. Namespace names support regular matching.
         */
        namespaceNameRegex: string;
        /**
         * The Pod name is used to specify the container to be collected. When no Pod name is specified, it means to collect all containers.
         */
        podNameRegex: string;
        /**
         * Specify the container to be collected by the name of the workload. When no workload name is specified, all containers are collected. The workload name supports regular matching.
         */
        workloadNameRegex: string;
        /**
         * Specify the container to be collected by the type of workload. Only one type can be selected. When no type is specified, it means to collect all types of containers.
         */
        workloadType: string;
    }

    export interface GetRuleAppliersRuleExcludePath {
        /**
         * The type of the log template.
         */
        type: string;
        /**
         * Collection path.
         */
        value: string;
    }

    export interface GetRuleAppliersRuleExtractRule {
        /**
         * The first log line needs to match the regular expression.
         */
        beginRegex: string;
        /**
         * The delimiter of the log.
         */
        delimiter: string;
        /**
         * The filter key list.
         */
        filterKeyRegexes: outputs.tls.GetRuleAppliersRuleExtractRuleFilterKeyRegex[];
        /**
         * A list of field names. Log Service will parse the path sample (PathSample) into multiple fields according to the regular expression (Regex), and Keys is used to specify the field name of each field.
         */
        keys: string[];
        /**
         * The entire log needs to match the regular expression.
         */
        logRegex: string;
        /**
         * Automatically extract log fields according to the specified log template.
         */
        logTemplates: outputs.tls.GetRuleAppliersRuleExtractRuleLogTemplate[];
        /**
         * Parsing format of the time field.
         */
        timeFormat: string;
        /**
         * The field name of the log time field.
         */
        timeKey: string;
        /**
         * When uploading the failed log, the key name of the failed log.
         */
        unMatchLogKey: string;
        /**
         * Whether to upload the log of parsing failure.
         */
        unMatchUpLoadSwitch: boolean;
    }

    export interface GetRuleAppliersRuleExtractRuleFilterKeyRegex {
        /**
         * The name of the filter key.
         */
        key: string;
        /**
         * Regular expression for extracting path fields. It must match the collection path sample, otherwise it cannot be extracted successfully.
         */
        regex: string;
    }

    export interface GetRuleAppliersRuleExtractRuleLogTemplate {
        /**
         * Log template content.
         */
        format: string;
        /**
         * The type of the log template.
         */
        type: string;
    }

    export interface GetRuleAppliersRuleUserDefineRule {
        /**
         * LogCollector extension configuration.
         */
        advanceds: outputs.tls.GetRuleAppliersRuleUserDefineRuleAdvanced[];
        /**
         * Whether to upload raw logs.
         */
        enableRawLog: boolean;
        /**
         * Add constant fields to logs.
         */
        fields: {[key: string]: any};
        /**
         * Rules for parsing collection paths. After the rules are set, the fields in the collection path will be extracted through the regular expressions specified in the rules, and added to the log data as metadata.
         */
        parsePathRules: outputs.tls.GetRuleAppliersRuleUserDefineRuleParsePathRule[];
        /**
         * Plugin configuration. After the plugin configuration is enabled, one or more LogCollector processor plugins can be added to parse logs with complex or variable structures.
         */
        plugins: outputs.tls.GetRuleAppliersRuleUserDefineRulePlugin[];
        /**
         * Rules for routing log partitions. Setting this parameter indicates that the HashKey routing shard mode is used when collecting logs, and Log Service will write the data to the shard containing the specified Key value.
         */
        shardHashKeys: outputs.tls.GetRuleAppliersRuleUserDefineRuleShardHashKey[];
        /**
         * LogCollector collection strategy, which specifies whether LogCollector collects incremental logs or full logs. The default is false, which means to collect all logs.
         */
        tailFiles: boolean;
    }

    export interface GetRuleAppliersRuleUserDefineRuleAdvanced {
        /**
         * Whether to release the log file handle after reading to the end of the log file. The default is false.
         */
        closeEof: boolean;
        /**
         * The wait time to release the log file handle. When the log file has not written a new log for more than the specified time, release the handle of the log file.
         */
        closeInactive: number;
        /**
         * After the log file is removed, whether to release the handle of the log file. The default is false.
         */
        closeRemoved: boolean;
        /**
         * After the log file is renamed, whether to release the handle of the log file. The default is false.
         */
        closeRenamed: boolean;
        /**
         * The maximum length of time that LogCollector monitors log files. The unit is seconds, and the default is 0 seconds, which means that there is no limit to the length of time LogCollector monitors log files.
         */
        closeTimeout: number;
    }

    export interface GetRuleAppliersRuleUserDefineRuleParsePathRule {
        /**
         * A list of field names. Log Service will parse the path sample (PathSample) into multiple fields according to the regular expression (Regex), and Keys is used to specify the field name of each field.
         */
        keys: string[];
        /**
         * Sample capture path for a real scene.
         */
        pathSample: string;
        /**
         * Regular expression for extracting path fields. It must match the collection path sample, otherwise it cannot be extracted successfully.
         */
        regex: string;
    }

    export interface GetRuleAppliersRuleUserDefineRulePlugin {
        /**
         * LogCollector plugin.
         */
        processors: string;
    }

    export interface GetRuleAppliersRuleUserDefineRuleShardHashKey {
        /**
         * The HashKey of the log group is used to specify the partition (shard) to be written to by the current log group.
         */
        hashKey: string;
    }

    export interface GetRulesRule {
        /**
         * Container collection rules.
         */
        containerRules: outputs.tls.GetRulesRuleContainerRule[];
        /**
         * The creation time.
         */
        createTime: string;
        /**
         * Collect the blacklist list.
         */
        excludePaths: outputs.tls.GetRulesRuleExcludePath[];
        /**
         * The extract rule.
         */
        extractRules: outputs.tls.GetRulesRuleExtractRule[];
        /**
         * The collection type.
         */
        inputType: number;
        /**
         * Log sample.
         */
        logSample: string;
        /**
         * The log type.
         */
        logType: string;
        /**
         * The modification time.
         */
        modifyTime: string;
        /**
         * Collection path list.
         */
        paths: string[];
        /**
         * The rule id.
         */
        ruleId: string;
        /**
         * The rule name.
         */
        ruleName: string;
        /**
         * The topic id.
         */
        topicId: string;
        /**
         * The topic name.
         */
        topicName: string;
        /**
         * User-defined collection rules.
         */
        userDefineRules: outputs.tls.GetRulesRuleUserDefineRule[];
    }

    export interface GetRulesRuleContainerRule {
        /**
         * The name of the container to be collected.
         */
        containerNameRegex: string;
        /**
         * Whether to add environment variables as log tags to raw log data.
         */
        envTag: {[key: string]: any};
        /**
         * The container environment variable blacklist is used to specify the range of containers not to be collected.
         */
        excludeContainerEnvRegex: {[key: string]: any};
        /**
         * The container Label blacklist is used to specify the range of containers not to be collected.
         */
        excludeContainerLabelRegex: {[key: string]: any};
        /**
         * The container environment variable whitelist specifies the container to be collected through the container environment variable. If the whitelist is not enabled, it means that all containers are specified to be collected.
         */
        includeContainerEnvRegex: {[key: string]: any};
        /**
         * The container label whitelist specifies the containers to be collected through the container label. If the whitelist is not enabled, all containers are specified to be collected.
         */
        includeContainerLabelRegex: {[key: string]: any};
        /**
         * Collection rules for Kubernetes containers.
         */
        kubernetesRules: outputs.tls.GetRulesRuleContainerRuleKubernetesRule[];
        /**
         * The collection mode.
         */
        stream: string;
    }

    export interface GetRulesRuleContainerRuleKubernetesRule {
        /**
         * Whether to add Kubernetes Annotation as a log tag to the raw log data.
         */
        annotationTag: {[key: string]: any};
        /**
         * Specify the containers not to be collected through the Pod Label blacklist, and not enable means to collect all containers.
         */
        excludePodLabelRegex: {[key: string]: any};
        /**
         * The Pod Label whitelist is used to specify containers to be collected. When the Pod Label whitelist is not enabled, it means that all containers are collected.
         */
        includePodLabelRegex: {[key: string]: any};
        /**
         * Whether to add Kubernetes Label as a log label to the original log data.
         */
        labelTag: {[key: string]: any};
        /**
         * The name of the Kubernetes Namespace to be collected. If no Namespace name is specified, all containers will be collected. Namespace names support regular matching.
         */
        namespaceNameRegex: string;
        /**
         * The Pod name is used to specify the container to be collected. When no Pod name is specified, it means to collect all containers.
         */
        podNameRegex: string;
        /**
         * Specify the container to be collected by the name of the workload. When no workload name is specified, all containers are collected. The workload name supports regular matching.
         */
        workloadNameRegex: string;
        /**
         * Specify the container to be collected by the type of workload. Only one type can be selected. When no type is specified, it means to collect all types of containers.
         */
        workloadType: string;
    }

    export interface GetRulesRuleExcludePath {
        /**
         * The type of the log template.
         */
        type: string;
        /**
         * Collection path.
         */
        value: string;
    }

    export interface GetRulesRuleExtractRule {
        /**
         * The first log line needs to match the regular expression.
         */
        beginRegex: string;
        /**
         * The delimiter of the log.
         */
        delimiter: string;
        /**
         * The filter key list.
         */
        filterKeyRegexes: outputs.tls.GetRulesRuleExtractRuleFilterKeyRegex[];
        /**
         * A list of field names. Log Service will parse the path sample (PathSample) into multiple fields according to the regular expression (Regex), and Keys is used to specify the field name of each field.
         */
        keys: string[];
        /**
         * The entire log needs to match the regular expression.
         */
        logRegex: string;
        /**
         * Automatically extract log fields according to the specified log template.
         */
        logTemplates: outputs.tls.GetRulesRuleExtractRuleLogTemplate[];
        /**
         * Parsing format of the time field.
         */
        timeFormat: string;
        /**
         * The field name of the log time field.
         */
        timeKey: string;
        /**
         * When uploading the failed log, the key name of the failed log.
         */
        unMatchLogKey: string;
        /**
         * Whether to upload the log of parsing failure.
         */
        unMatchUpLoadSwitch: boolean;
    }

    export interface GetRulesRuleExtractRuleFilterKeyRegex {
        /**
         * The name of the filter key.
         */
        key: string;
        /**
         * Regular expression for extracting path fields. It must match the collection path sample, otherwise it cannot be extracted successfully.
         */
        regex: string;
    }

    export interface GetRulesRuleExtractRuleLogTemplate {
        /**
         * Log template content.
         */
        format: string;
        /**
         * The type of the log template.
         */
        type: string;
    }

    export interface GetRulesRuleUserDefineRule {
        /**
         * LogCollector extension configuration.
         */
        advanceds: outputs.tls.GetRulesRuleUserDefineRuleAdvanced[];
        /**
         * Whether to upload raw logs.
         */
        enableRawLog: boolean;
        /**
         * Add constant fields to logs.
         */
        fields: {[key: string]: any};
        /**
         * Rules for parsing collection paths. After the rules are set, the fields in the collection path will be extracted through the regular expressions specified in the rules, and added to the log data as metadata.
         */
        parsePathRules: outputs.tls.GetRulesRuleUserDefineRuleParsePathRule[];
        /**
         * Plugin configuration. After the plugin configuration is enabled, one or more LogCollector processor plugins can be added to parse logs with complex or variable structures.
         */
        plugins: outputs.tls.GetRulesRuleUserDefineRulePlugin[];
        /**
         * Rules for routing log partitions. Setting this parameter indicates that the HashKey routing shard mode is used when collecting logs, and Log Service will write the data to the shard containing the specified Key value.
         */
        shardHashKeys: outputs.tls.GetRulesRuleUserDefineRuleShardHashKey[];
        /**
         * LogCollector collection strategy, which specifies whether LogCollector collects incremental logs or full logs. The default is false, which means to collect all logs.
         */
        tailFiles: boolean;
    }

    export interface GetRulesRuleUserDefineRuleAdvanced {
        /**
         * Whether to release the log file handle after reading to the end of the log file. The default is false.
         */
        closeEof: boolean;
        /**
         * The wait time to release the log file handle. When the log file has not written a new log for more than the specified time, release the handle of the log file.
         */
        closeInactive: number;
        /**
         * After the log file is removed, whether to release the handle of the log file. The default is false.
         */
        closeRemoved: boolean;
        /**
         * After the log file is renamed, whether to release the handle of the log file. The default is false.
         */
        closeRenamed: boolean;
        /**
         * The maximum length of time that LogCollector monitors log files. The unit is seconds, and the default is 0 seconds, which means that there is no limit to the length of time LogCollector monitors log files.
         */
        closeTimeout: number;
    }

    export interface GetRulesRuleUserDefineRuleParsePathRule {
        /**
         * A list of field names. Log Service will parse the path sample (PathSample) into multiple fields according to the regular expression (Regex), and Keys is used to specify the field name of each field.
         */
        keys: string[];
        /**
         * Sample capture path for a real scene.
         */
        pathSample: string;
        /**
         * Regular expression for extracting path fields. It must match the collection path sample, otherwise it cannot be extracted successfully.
         */
        regex: string;
    }

    export interface GetRulesRuleUserDefineRulePlugin {
        /**
         * LogCollector plugin.
         */
        processors: string[];
    }

    export interface GetRulesRuleUserDefineRuleShardHashKey {
        /**
         * The HashKey of the log group is used to specify the partition (shard) to be written to by the current log group.
         */
        hashKey: string;
    }

    export interface GetScheduleSqlTasksTask {
        /**
         * Set the creation time of timed SQL analysis tasks.
         */
        createTimeStamp: number;
        /**
         * A simple description of the timed SQL analysis task.
         */
        description: string;
        /**
         * The log project ID to which the target log topic belongs.
         */
        destProjectId: string;
        /**
         * The region to which the target log project belongs.
         */
        destRegion: string;
        /**
         * The target log topic ID used for storing the result data of timed SQL analysis.
         */
        destTopicId: string;
        /**
         * The name of the target log topic used for storing the data of the timed SQL analysis results.
         */
        destTopicName: string;
        /**
         * The most recent modification time of the scheduled SQL analysis task.
         */
        modifyTimeStamp: number;
        /**
         * Schedule the end time of the timed SQL analysis task in the format of a second-level timestamp.
         */
        processEndTime: number;
        /**
         * The delay time of each scheduling. The value range is from 0 to 120, and the unit is seconds.
         */
        processSqlDelay: number;
        /**
         * The start time of the scheduled SQL task, that is, the start time when the first instance is scheduled. The format is a timestamp at the second level.
         */
        processStartTime: number;
        /**
         * SQL time window, which refers to the time range for log retrieval and analysis when a timed SQL analysis task is running, is in a left-closed and right-open format.
         */
        processTimeWindow: string;
        /**
         * Timed SQL analysis tasks are retrieval and analysis statements that are executed regularly.
         */
        query: string;
        /**
         * The scheduling cycle of timed SQL analysis tasks.
         */
        requestCycle: outputs.tls.GetScheduleSqlTasksTaskRequestCycle;
        /**
         * The log project ID to which the source log topic belongs.
         */
        sourceProjectId: string;
        /**
         * The name of the log item to which the source log topic belongs.
         */
        sourceProjectName: string;
        /**
         * The source log topic ID where the original log for timed SQL analysis is located.
         */
        sourceTopicId: string;
        /**
         * Source log topic name.
         */
        sourceTopicName: string;
        /**
         * Timed SQL analysis task status.
         */
        status: number;
        /**
         * Timed SQL analysis task ID.
         */
        taskId: string;
        /**
         * Timed SQL analysis task name.
         */
        taskName: string;
    }

    export interface GetScheduleSqlTasksTaskRequestCycle {
        /**
         * Cron expression. The log service specifies the timed execution of alarm tasks through the Cron expression. The minimum granularity of Cron expressions is minutes, 24 hours. For example, 0 18 * * * indicates that an alarm task is executed exactly at 18:00 every day.
         */
        cronTab: string;
        /**
         * When setting the Type to Cron, the time zone also needs to be set.
         */
        cronTimeZone: string;
        /**
         * The scheduling cycle or the time point of regular execution (the number of minutes away from 00:00), with a value range of 1 to 1440, and the unit is minutes.
         */
        time: number;
        /**
         * The type of Scheduling cycle.
         */
        type: string;
    }

    export interface GetShardsShard {
        /**
         * The end key info.
         */
        exclusiveEndKey: string;
        /**
         * The begin key info.
         */
        inclusiveBeginKey: string;
        /**
         * The modify time.
         */
        modifyTime: string;
        /**
         * The id of shard.
         */
        shardId: number;
        /**
         * The status of shard.
         */
        status: string;
        /**
         * The stop write time.
         */
        stopWriteTime: string;
        /**
         * The id of topic.
         */
        topicId: string;
    }

    export interface GetShippersShipper {
        /**
         * The content format configuration of the delivery log.
         */
        contentInfo: outputs.tls.GetShippersShipperContentInfo;
        /**
         * Processing task creation time.
         */
        createTime: string;
        /**
         * The default built-in dashboard ID for delivery.
         */
        dashboardId: string;
        /**
         * JSON format log content configuration.
         */
        kafkaShipperInfo: outputs.tls.GetShippersShipperKafkaShipperInfo;
        /**
         * The most recent modification time of the processing task.
         */
        modifyTime: string;
        /**
         * Specify the log item ID for querying the data delivery configuration under the specified log item.
         */
        projectId: string;
        /**
         * Specify the name of the log item for querying the data delivery configuration under the specified log item. Support fuzzy matching.
         */
        projectName: string;
        /**
         * Delivery end time, millisecond timestamp. If not configured, it will keep delivering.
         */
        shipperEndTime: number;
        /**
         * Delivery configuration ID.
         */
        shipperId: string;
        /**
         * Delivery configuration name.
         */
        shipperName: string;
        /**
         * Delivery start time, millisecond timestamp. If not configured, it defaults to the current time.
         */
        shipperStartTime: number;
        /**
         * Specify the delivery type for querying the delivery configuration related to that delivery type.
         */
        shipperType: string;
        /**
         * Whether to enable the delivery configuration.
         */
        status: boolean;
        /**
         * Specify the log topic ID for querying the data delivery configuration related to this log topic.
         */
        topicId: string;
        /**
         * Specify the name of the log topic for querying the data delivery configuration related to this log topic. Support fuzzy matching.
         */
        topicName: string;
        /**
         * Deliver the relevant configuration to the object storage (TOS).
         */
        tosShipperInfo: outputs.tls.GetShippersShipperTosShipperInfo;
    }

    export interface GetShippersShipperContentInfo {
        /**
         * CSV format log content configuration.
         */
        csvInfo: outputs.tls.GetShippersShipperContentInfoCsvInfo;
        /**
         * Log content parsing format.
         */
        format: string;
        /**
         * JSON format log content configuration.
         */
        jsonInfo: outputs.tls.GetShippersShipperContentInfoJsonInfo;
    }

    export interface GetShippersShipperContentInfoCsvInfo {
        /**
         * Delimiters are supported, including commas, tabs, vertical bars, semicolons, and Spaces.
         */
        delimiter: string;
        /**
         * When the field content contains a delimiter, use an escape character to wrap the field. Currently, only single quotes, double quotes, and null characters are supported.
         */
        escapeChar: string;
        /**
         * When delivering in JSON format, if this parameter is not configured, it indicates that all fields have been delivered. Including __content__ (choice), __source__, __path__, __time__, __image_name__, __container_name__, __pod_name__, __pod_uid__, namespace, __tag____client_ip__, __tag____receive_time__.
         */
        keys: string[];
        /**
         * Invalid field filling content, with a length ranging from 0 to 128.
         */
        nonFieldContent: string;
        /**
         * Whether to print the Key on the first line.
         */
        printHeader: boolean;
    }

    export interface GetShippersShipperContentInfoJsonInfo {
        /**
         * Enable the flag.
         */
        enable: boolean;
        /**
         * Whether to escape or not. It must be configured as true.
         */
        escape: boolean;
        /**
         * When delivering in JSON format, if this parameter is not configured, it indicates that all fields have been delivered. Including __content__ (choice), __source__, __path__, __time__, __image_name__, __container_name__, __pod_name__, __pod_uid__, namespace, __tag____client_ip__, __tag____receive_time__.
         */
        keys: string[];
    }

    export interface GetShippersShipperKafkaShipperInfo {
        /**
         * Compression formats currently supported include snappy, gzip, lz4, and none.
         */
        compress: string;
        /**
         * Delivery end time, millisecond timestamp. If not configured, it will keep delivering.
         */
        endTime: number;
        /**
         * Kafka instance.
         */
        instance: string;
        /**
         * The name of the Kafka Topic.
         */
        kafkaTopic: string;
        /**
         * Delivery start time, millisecond timestamp. If not configured, the default is the current time.
         */
        startTime: number;
    }

    export interface GetShippersShipperTosShipperInfo {
        /**
         * When choosing a TOS bucket, it must be located in the same region as the source log topic.
         */
        bucket: string;
        /**
         * Compression formats currently supported include snappy, gzip, lz4, and none.
         */
        compress: string;
        /**
         * The delivery time interval, measured in seconds, ranges from 300 to 900.
         */
        interval: number;
        /**
         * The maximum size of the original file that can be delivered to each partition (Shard), that is, the size of the uncompressed log file. The unit is MiB, and the value range is 5 to 256.
         */
        maxSize: number;
        /**
         * Partition rules for delivering logs.
         */
        partitionFormat: string;
        /**
         * The top-level directory name of the storage bucket. All log data delivered through this delivery configuration will be delivered to this directory.
         */
        prefix: string;
    }

    export interface GetTopicsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetTopicsTlsTopic {
        /**
         * Whether to enable automatic partition splitting function of the tls topic.
         */
        autoSplit: boolean;
        /**
         * The create time of the tls topic.
         */
        createTime: string;
        /**
         * The description of the tls topic.
         */
        description: string;
        /**
         * Whether to enable WebTracking function of the tls topic.
         */
        enableTracking: boolean;
        /**
         * The ID of the tls topic.
         */
        id: string;
        /**
         * The max count of shards in the tls topic.
         */
        maxSplitShard: number;
        /**
         * The modify time of the tls topic.
         */
        modifyTime: string;
        /**
         * The project id of tls topic.
         */
        projectId: string;
        /**
         * The count of shards in the tls topic.
         */
        shardCount: number;
        /**
         * Tags.
         */
        tags: outputs.tls.GetTopicsTlsTopicTag[];
        /**
         * The format of the time field.
         */
        timeFormat: string;
        /**
         * The name of the time field.
         */
        timeKey: string;
        /**
         * The id of tls topic. This field supports fuzzy queries. It is not supported to specify both TopicName and TopicId at the same time.
         */
        topicId: string;
        /**
         * The name of tls topic. This field supports fuzzy queries. It is not supported to specify both TopicName and TopicId at the same time.
         */
        topicName: string;
        /**
         * The data storage time of the tls topic. Unit: Day.
         */
        ttl: number;
    }

    export interface GetTopicsTlsTopicTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface HostGroupsInfo {
        /**
         * The abnormal heartbeat status count of host.
         */
        abnormalHeartbeatStatusCount: number;
        /**
         * The latest version of log collector.
         */
        agentLatestVersion: string;
        /**
         * Whether enable auto update.
         */
        autoUpdate: boolean;
        /**
         * The create time of host group.
         */
        createTime: string;
        /**
         * The count of host.
         */
        hostCount: number;
        /**
         * The id of host group.
         */
        hostGroupId: string;
        /**
         * The name of host group.
         */
        hostGroupName: string;
        /**
         * The type of host group.
         */
        hostGroupType: string;
        /**
         * The identifier of host.
         */
        hostIdentifier: string;
        /**
         * The ip list of host group.
         */
        hostIpLists: string[];
        /**
         * The project name of iam.
         */
        iamProjectName: string;
        /**
         * The modify time of host group.
         */
        modifyTime: string;
        /**
         * The normal heartbeat status count of host.
         */
        normalHeartbeatStatusCount: number;
        /**
         * The rule count of host.
         */
        ruleCount: number;
        /**
         * Whether enable service logging.
         */
        serviceLogging: boolean;
        /**
         * The update end time of log collector.
         */
        updateEndTime: string;
        /**
         * The update start time of log collector.
         */
        updateStartTime: string;
    }

    export interface HostsHostInfo {
        /**
         * The the heartbeat status.
         */
        heartbeatStatus: number;
        /**
         * The id of host group.
         */
        hostGroupId: string;
        /**
         * The ip address.
         */
        ip: string;
        /**
         * The version of log collector.
         */
        logCollectorVersion: string;
    }

    export interface ImportTaskImportSourceInfo {
        /**
         * TOS imports source information.
         */
        kafkaSourceInfo: outputs.tls.ImportTaskImportSourceInfoKafkaSourceInfo;
        /**
         * TOS imports source information.
         */
        tosSourceInfo: outputs.tls.ImportTaskImportSourceInfoTosSourceInfo;
    }

    export interface ImportTaskImportSourceInfoKafkaSourceInfo {
        /**
         * The encoding format of the data.
         */
        encode: string;
        /**
         * Kafka consumer group.
         */
        group: string;
        /**
         * The service addresses corresponding to different types of Kafka clusters are different.
         */
        host: string;
        /**
         * The starting position of data import.
         */
        initialOffset: number;
        /**
         * When you are using the Volcano Engine Message Queue Kafka version, it should be set to the Kafka instance ID.
         */
        instanceId: string;
        /**
         * Whether to enable authentication.
         */
        isNeedAuth: boolean;
        /**
         * Password authentication mechanism.
         */
        mechanism: string;
        /**
         * The Kafka SASL user password used for identity authentication.
         */
        password: string;
        /**
         * Secure Transport protocol.
         */
        protocol: string;
        /**
         * Specify the log time.
         */
        timeSourceDefault: number;
        /**
         * Kafka Topic name.
         */
        topic: string;
        /**
         * The Kafka SASL username used for identity authentication.
         */
        username: string;
    }

    export interface ImportTaskImportSourceInfoTosSourceInfo {
        /**
         * The TOS bucket where the log file is located.
         */
        bucket: string;
        /**
         * The compression mode of data in the TOS bucket.
         */
        compressType: string;
        /**
         * The path of the file to be imported in the TOS bucket.
         */
        prefix: string;
        /**
         * The region where the TOS bucket is located. Support cross-regional data import.
         */
        region: string;
    }

    export interface ImportTaskTargetInfo {
        /**
         * Log extraction rules.
         */
        extractRule: outputs.tls.ImportTaskTargetInfoExtractRule;
        /**
         * Log sample.
         */
        logSample: string;
        /**
         * Specify the log parsing type when importing.
         */
        logType: string;
        /**
         * Regional ID.
         */
        region: string;
    }

    export interface ImportTaskTargetInfoExtractRule {
        /**
         * The regular expression used to identify the first line in each log, and its matching part will serve as the beginning of the log.
         */
        beginRegex: string;
        /**
         * Log delimiter.
         */
        delimiter: string;
        /**
         * List of log field names (Keys).
         */
        keys: string[];
        /**
         * Reference symbol. The content wrapped by the reference will not be separated but will be parsed into a complete field. It is valid if and only if the LogType is delimiter_log.
         */
        quote: string;
        /**
         * The number of log lines skipped.
         */
        skipLineCount: number;
        /**
         * A regular expression for extracting time, used to extract the time value in the TimeKey field and parse it into the corresponding collection time.
         */
        timeExtractRegex: string;
        /**
         * The parsing format of the time field.
         */
        timeFormat: string;
        /**
         * The field name of the log time field.
         */
        timeKey: string;
        /**
         * Time zone, supporting both machine time zone (default) and custom time zone. Among them, the custom time zone supports GMT and UTC.
         */
        timeZone: string;
        /**
         * When uploading a log that failed to parse, the key name of the parse failed log.
         */
        unMatchLogKey: string;
        /**
         * Whether to upload the logs of failed parsing.
         */
        unMatchUpLoadSwitch: boolean;
    }

    export interface ImportTasksTaskInfo {
        /**
         * The creation time of the data import task.
         */
        createTime: string;
        /**
         * Data import task description.
         */
        description: string;
        /**
         * The source information of the data import task.
         */
        importSourceInfo: outputs.tls.ImportTasksTaskInfoImportSourceInfo;
        /**
         * Specify the log item ID for querying the data import tasks under the specified log item.
         */
        projectId: string;
        /**
         * Specify the name of the log item for querying the data import tasks under the specified log item. Support fuzzy query..
         */
        projectName: string;
        /**
         * Specify the import type for querying the data import tasks related to this import type.
         */
        sourceType: string;
        /**
         * Specify the status of the import task.
         */
        status?: number;
        /**
         * The output information of the data import task.
         */
        targetInfo: outputs.tls.ImportTasksTaskInfoTargetInfo;
        /**
         * Import the task ID of the data to be queried.
         */
        taskId: string;
        /**
         * Import the task name of the data to be queried.
         */
        taskName: string;
        /**
         * The progress of the data import task.
         */
        taskStatistics: outputs.tls.ImportTasksTaskInfoTaskStatistics;
        /**
         * Specify the log topic ID for querying the data import tasks related to this log topic.
         */
        topicId: string;
        /**
         * Specify the name of the log topic for querying the data import tasks related to this log topic. Support fuzzy query.
         */
        topicName: string;
    }

    export interface ImportTasksTaskInfoImportSourceInfo {
        /**
         * TOS imports source information.
         */
        kafkaSourceInfo: outputs.tls.ImportTasksTaskInfoImportSourceInfoKafkaSourceInfo;
        /**
         * TOS imports source information.
         */
        tosSourceInfo: outputs.tls.ImportTasksTaskInfoImportSourceInfoTosSourceInfo;
    }

    export interface ImportTasksTaskInfoImportSourceInfoKafkaSourceInfo {
        /**
         * The encoding format of the data.
         */
        encode: string;
        /**
         * Kafka consumer group.
         */
        group: string;
        /**
         * The service addresses corresponding to different types of Kafka clusters are different.
         */
        host: string;
        /**
         * The starting position of data import.
         */
        initialOffset: number;
        /**
         * When you are using the Volcano Engine Message Queue Kafka version, it should be set to the Kafka instance ID.
         */
        instanceId: string;
        /**
         * Whether to enable authentication.
         */
        isNeedAuth: boolean;
        /**
         * Password authentication mechanism.
         */
        mechanism: string;
        /**
         * The Kafka SASL user password used for identity authentication.
         */
        password: string;
        /**
         * Secure Transport protocol.
         */
        protocol: string;
        /**
         * Specify the log time.
         */
        timeSourceDefault: number;
        /**
         * Kafka Topic name.
         */
        topic: string;
        /**
         * The Kafka SASL username used for identity authentication.
         */
        username: string;
    }

    export interface ImportTasksTaskInfoImportSourceInfoTosSourceInfo {
        /**
         * The TOS bucket where the log file is located.
         */
        bucket: string;
        /**
         * The compression mode of data in the TOS bucket.
         */
        compressType: string;
        /**
         * The path of the file to be imported in the TOS bucket.
         */
        prefix: string;
        /**
         * Regional ID.
         */
        region: string;
    }

    export interface ImportTasksTaskInfoTargetInfo {
        /**
         * Log extraction rules.
         */
        extractRule: outputs.tls.ImportTasksTaskInfoTargetInfoExtractRule;
        /**
         * Log sample.
         */
        logSample: string;
        /**
         * Specify the log parsing type when importing.
         */
        logType: string;
        /**
         * Regional ID.
         */
        region: string;
    }

    export interface ImportTasksTaskInfoTargetInfoExtractRule {
        /**
         * The regular expression used to identify the first line in each log, and its matching part will serve as the beginning of the log.
         */
        beginRegex: string;
        /**
         * Log delimiter.
         */
        delimiter: string;
        /**
         * List of log field names (Keys).
         */
        keys: string[];
        /**
         * Reference symbol. The content wrapped by the reference will not be separated but will be parsed into a complete field. It is valid if and only if the LogType is delimiter_log.
         */
        quote: string;
        /**
         * The number of log lines skipped.
         */
        skipLineCount: number;
        /**
         * A regular expression for extracting time, used to extract the time value in the TimeKey field and parse it into the corresponding collection time.
         */
        timeExtractRegex: string;
        /**
         * The parsing format of the time field.
         */
        timeFormat: string;
        /**
         * The field name of the log time field.
         */
        timeKey: string;
        /**
         * Time zone, supporting both machine time zone (default) and custom time zone. Among them, the custom time zone supports GMT and UTC.
         */
        timeZone: string;
        /**
         * When uploading a log that failed to parse, the key name of the parse failed log.
         */
        unMatchLogKey: string;
        /**
         * Whether to upload the logs of failed parsing.
         */
        unMatchUpLoadSwitch: boolean;
    }

    export interface ImportTasksTaskInfoTaskStatistics {
        /**
         * The total number of resource bytes that have been listed.
         */
        bytesTotal: number;
        /**
         * The number of imported bytes.
         */
        bytesTransferred: number;
        /**
         * The number of resources that failed to import.
         */
        failed: number;
        /**
         * The number of non-existent resources.
         */
        notExist: number;
        /**
         * Skip the number of imported resources.
         */
        skipped: number;
        /**
         * Import the status of the task.
         */
        taskStatus: string;
        /**
         * The total number of resources that have been listed.
         */
        total: number;
        /**
         * The number of imported resources.
         */
        transferred: number;
    }

    export interface IndexFullText {
        /**
         * Whether the FullTextInfo is case sensitive.
         */
        caseSensitive: boolean;
        /**
         * The delimiter of the FullTextInfo.
         */
        delimiter?: string;
        /**
         * Whether the FullTextInfo include chinese.
         */
        includeChinese?: boolean;
    }

    export interface IndexKeyValue {
        /**
         * Whether the value is case sensitive.
         */
        caseSensitive?: boolean;
        /**
         * The delimiter of the value.
         */
        delimiter?: string;
        /**
         * Whether the value include chinese.
         */
        includeChinese?: boolean;
        /**
         * Whether to create indexes for all fields in JSON fields with text values. This field is valid when the `valueType` is `json`.
         */
        indexAll?: boolean;
        /**
         * The JSON subfield key value index.
         */
        jsonKeys?: outputs.tls.IndexKeyValueJsonKey[];
        /**
         * The key of the KeyValueInfo.
         */
        key: string;
        /**
         * Whether the filed is enabled for analysis.
         */
        sqlFlag?: boolean;
        /**
         * The type of value. Valid values: `long`, `double`, `text`, `json`.
         */
        valueType: string;
    }

    export interface IndexKeyValueJsonKey {
        /**
         * The key of the subfield key value index.
         */
        key: string;
        /**
         * The type of value. Valid values: `long`, `double`, `text`.
         */
        valueType: string;
    }

    export interface IndexUserInnerKeyValue {
        /**
         * Whether the value is case sensitive.
         */
        caseSensitive?: boolean;
        /**
         * The delimiter of the value.
         */
        delimiter?: string;
        /**
         * Whether the value include chinese.
         */
        includeChinese?: boolean;
        /**
         * The JSON subfield key value index.
         */
        jsonKeys?: outputs.tls.IndexUserInnerKeyValueJsonKey[];
        /**
         * The key of the KeyValueInfo.
         */
        key: string;
        /**
         * Whether the filed is enabled for analysis.
         */
        sqlFlag?: boolean;
        /**
         * The type of value. Valid values: `long`, `double`, `text`, `json`.
         */
        valueType: string;
    }

    export interface IndexUserInnerKeyValueJsonKey {
        /**
         * The key of the subfield key value index.
         */
        key: string;
        /**
         * The type of value. Valid values: `long`, `double`, `text`.
         */
        valueType: string;
    }

    export interface IndexesTlsIndex {
        /**
         * The create time of the tls index.
         */
        createTime: string;
        /**
         * The FullText index of the tls topic.
         */
        fullText: outputs.tls.IndexesTlsIndexFullText;
        /**
         * The topic id of the tls index.
         */
        id: string;
        /**
         * The KeyValue index of the tls topic.
         */
        keyValues: outputs.tls.IndexesTlsIndexKeyValue[];
        /**
         * The modify time of the tls index.
         */
        modifyTime: string;
        /**
         * The topic id of the tls index.
         */
        topicId: string;
        /**
         * The reserved field index configuration of the tls topic.
         */
        userInnerKeyValues: outputs.tls.IndexesTlsIndexUserInnerKeyValue[];
    }

    export interface IndexesTlsIndexFullText {
        /**
         * Whether the value is case sensitive.
         */
        caseSensitive: boolean;
        /**
         * The delimiter of the value.
         */
        delimiter: string;
        /**
         * Whether the value include chinese.
         */
        includeChinese: boolean;
    }

    export interface IndexesTlsIndexKeyValue {
        /**
         * Whether the value is case sensitive.
         */
        caseSensitive: boolean;
        /**
         * The delimiter of the value.
         */
        delimiter: string;
        /**
         * Whether the value include chinese.
         */
        includeChinese: boolean;
        /**
         * Whether to create indexes for all fields in JSON fields with text values.
         */
        indexAll: boolean;
        /**
         * The JSON subfield key value index.
         */
        jsonKeys: outputs.tls.IndexesTlsIndexKeyValueJsonKey[];
        /**
         * The key of the KeyValue index.
         */
        key: string;
        /**
         * Whether the filed is enabled for analysis.
         */
        sqlFlag: boolean;
        /**
         * The type of value.
         */
        valueType: string;
    }

    export interface IndexesTlsIndexKeyValueJsonKey {
        /**
         * Whether the value is case sensitive.
         */
        caseSensitive: boolean;
        /**
         * The delimiter of the value.
         */
        delimiter: string;
        /**
         * Whether the value include chinese.
         */
        includeChinese: boolean;
        /**
         * The key of the KeyValue index.
         */
        key: string;
        /**
         * Whether the filed is enabled for analysis.
         */
        sqlFlag: boolean;
        /**
         * The type of value.
         */
        valueType: string;
    }

    export interface IndexesTlsIndexUserInnerKeyValue {
        /**
         * Whether the value is case sensitive.
         */
        caseSensitive: boolean;
        /**
         * The delimiter of the value.
         */
        delimiter: string;
        /**
         * Whether the value include chinese.
         */
        includeChinese: boolean;
        /**
         * The JSON subfield key value index.
         */
        jsonKeys: outputs.tls.IndexesTlsIndexUserInnerKeyValueJsonKey[];
        /**
         * The key of the KeyValue index.
         */
        key: string;
        /**
         * Whether the filed is enabled for analysis.
         */
        sqlFlag: boolean;
        /**
         * The type of value.
         */
        valueType: string;
    }

    export interface IndexesTlsIndexUserInnerKeyValueJsonKey {
        /**
         * Whether the value is case sensitive.
         */
        caseSensitive: boolean;
        /**
         * The delimiter of the value.
         */
        delimiter: string;
        /**
         * Whether the value include chinese.
         */
        includeChinese: boolean;
        /**
         * The key of the KeyValue index.
         */
        key: string;
        /**
         * Whether the filed is enabled for analysis.
         */
        sqlFlag: boolean;
        /**
         * The type of value.
         */
        valueType: string;
    }

    export interface KafkaConsumersData {
        /**
         * Whether allow consume.
         */
        allowConsume: boolean;
        /**
         * The topic of consume.
         */
        consumeTopic: string;
        /**
         * The ID of Topic.
         */
        topicId: string;
    }

    export interface ProjectTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface ProjectsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface ProjectsTlsProject {
        /**
         * The create time of the tls project.
         */
        createTime: string;
        /**
         * The description of the tls project.
         */
        description: string;
        /**
         * The IAM project name of the tls project.
         */
        iamProjectName: string;
        /**
         * The ID of the tls project.
         */
        id: string;
        /**
         * The inner net domain of the tls project.
         */
        innerNetDomain: string;
        /**
         * The id of tls project. This field supports fuzzy queries. It is not supported to specify both ProjectName and ProjectId at the same time.
         */
        projectId: string;
        /**
         * The name of tls project. This field supports fuzzy queries. It is not supported to specify both ProjectName and ProjectId at the same time.
         */
        projectName: string;
        /**
         * Tags.
         */
        tags: outputs.tls.ProjectsTlsProjectTag[];
        /**
         * The count of topics in the tls project.
         */
        topicCount: number;
    }

    export interface ProjectsTlsProjectTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface RuleAppliersRule {
        /**
         * Container collection rules.
         */
        containerRules: outputs.tls.RuleAppliersRuleContainerRule[];
        /**
         * The creation time.
         */
        createTime: string;
        /**
         * Collect the blacklist list.
         */
        excludePaths: outputs.tls.RuleAppliersRuleExcludePath[];
        /**
         * The extract rule.
         */
        extractRules: outputs.tls.RuleAppliersRuleExtractRule[];
        /**
         * The collection type.
         */
        inputType: number;
        /**
         * Log sample.
         */
        logSample: string;
        /**
         * The log type.
         */
        logType: string;
        /**
         * The modification time.
         */
        modifyTime: string;
        /**
         * Collection path list.
         */
        paths: string[];
        /**
         * The rule id.
         */
        ruleId: string;
        /**
         * The rule name.
         */
        ruleName: string;
        /**
         * The topic id.
         */
        topicId: string;
        /**
         * The topic name.
         */
        topicName: string;
        /**
         * User-defined collection rules.
         */
        userDefineRules: outputs.tls.RuleAppliersRuleUserDefineRule[];
    }

    export interface RuleAppliersRuleContainerRule {
        /**
         * The name of the container to be collected.
         */
        containerNameRegex: string;
        /**
         * Whether to add environment variables as log tags to raw log data.
         */
        envTag: {[key: string]: any};
        /**
         * The container environment variable blacklist is used to specify the range of containers not to be collected.
         */
        excludeContainerEnvRegex: {[key: string]: any};
        /**
         * The container Label blacklist is used to specify the range of containers not to be collected.
         */
        excludeContainerLabelRegex: {[key: string]: any};
        /**
         * The container environment variable whitelist specifies the container to be collected through the container environment variable. If the whitelist is not enabled, it means that all containers are specified to be collected.
         */
        includeContainerEnvRegex: {[key: string]: any};
        /**
         * The container label whitelist specifies the containers to be collected through the container label. If the whitelist is not enabled, all containers are specified to be collected.
         */
        includeContainerLabelRegex: {[key: string]: any};
        /**
         * Collection rules for Kubernetes containers.
         */
        kubernetesRules: outputs.tls.RuleAppliersRuleContainerRuleKubernetesRule[];
        /**
         * The collection mode.
         */
        stream: string;
    }

    export interface RuleAppliersRuleContainerRuleKubernetesRule {
        /**
         * Whether to add Kubernetes Annotation as a log tag to the raw log data.
         */
        annotationTag: {[key: string]: any};
        /**
         * Specify the containers not to be collected through the Pod Label blacklist, and not enable means to collect all containers.
         */
        excludePodLabelRegex: {[key: string]: any};
        /**
         * The Pod Label whitelist is used to specify containers to be collected. When the Pod Label whitelist is not enabled, it means that all containers are collected.
         */
        includePodLabelRegex: {[key: string]: any};
        /**
         * Whether to add Kubernetes Label as a log label to the original log data.
         */
        labelTag: {[key: string]: any};
        /**
         * The name of the Kubernetes Namespace to be collected. If no Namespace name is specified, all containers will be collected. Namespace names support regular matching.
         */
        namespaceNameRegex: string;
        /**
         * The Pod name is used to specify the container to be collected. When no Pod name is specified, it means to collect all containers.
         */
        podNameRegex: string;
        /**
         * Specify the container to be collected by the name of the workload. When no workload name is specified, all containers are collected. The workload name supports regular matching.
         */
        workloadNameRegex: string;
        /**
         * Specify the container to be collected by the type of workload. Only one type can be selected. When no type is specified, it means to collect all types of containers.
         */
        workloadType: string;
    }

    export interface RuleAppliersRuleExcludePath {
        /**
         * The type of the log template.
         */
        type: string;
        /**
         * Collection path.
         */
        value: string;
    }

    export interface RuleAppliersRuleExtractRule {
        /**
         * The first log line needs to match the regular expression.
         */
        beginRegex: string;
        /**
         * The delimiter of the log.
         */
        delimiter: string;
        /**
         * The filter key list.
         */
        filterKeyRegexes: outputs.tls.RuleAppliersRuleExtractRuleFilterKeyRegex[];
        /**
         * A list of field names. Log Service will parse the path sample (PathSample) into multiple fields according to the regular expression (Regex), and Keys is used to specify the field name of each field.
         */
        keys: string[];
        /**
         * The entire log needs to match the regular expression.
         */
        logRegex: string;
        /**
         * Automatically extract log fields according to the specified log template.
         */
        logTemplates: outputs.tls.RuleAppliersRuleExtractRuleLogTemplate[];
        /**
         * Parsing format of the time field.
         */
        timeFormat: string;
        /**
         * The field name of the log time field.
         */
        timeKey: string;
        /**
         * When uploading the failed log, the key name of the failed log.
         */
        unMatchLogKey: string;
        /**
         * Whether to upload the log of parsing failure.
         */
        unMatchUpLoadSwitch: boolean;
    }

    export interface RuleAppliersRuleExtractRuleFilterKeyRegex {
        /**
         * The name of the filter key.
         */
        key: string;
        /**
         * Regular expression for extracting path fields. It must match the collection path sample, otherwise it cannot be extracted successfully.
         */
        regex: string;
    }

    export interface RuleAppliersRuleExtractRuleLogTemplate {
        /**
         * Log template content.
         */
        format: string;
        /**
         * The type of the log template.
         */
        type: string;
    }

    export interface RuleAppliersRuleUserDefineRule {
        /**
         * LogCollector extension configuration.
         */
        advanceds: outputs.tls.RuleAppliersRuleUserDefineRuleAdvanced[];
        /**
         * Whether to upload raw logs.
         */
        enableRawLog: boolean;
        /**
         * Add constant fields to logs.
         */
        fields: {[key: string]: any};
        /**
         * Rules for parsing collection paths. After the rules are set, the fields in the collection path will be extracted through the regular expressions specified in the rules, and added to the log data as metadata.
         */
        parsePathRules: outputs.tls.RuleAppliersRuleUserDefineRuleParsePathRule[];
        /**
         * Plugin configuration. After the plugin configuration is enabled, one or more LogCollector processor plugins can be added to parse logs with complex or variable structures.
         */
        plugins: outputs.tls.RuleAppliersRuleUserDefineRulePlugin[];
        /**
         * Rules for routing log partitions. Setting this parameter indicates that the HashKey routing shard mode is used when collecting logs, and Log Service will write the data to the shard containing the specified Key value.
         */
        shardHashKeys: outputs.tls.RuleAppliersRuleUserDefineRuleShardHashKey[];
        /**
         * LogCollector collection strategy, which specifies whether LogCollector collects incremental logs or full logs. The default is false, which means to collect all logs.
         */
        tailFiles: boolean;
    }

    export interface RuleAppliersRuleUserDefineRuleAdvanced {
        /**
         * Whether to release the log file handle after reading to the end of the log file. The default is false.
         */
        closeEof: boolean;
        /**
         * The wait time to release the log file handle. When the log file has not written a new log for more than the specified time, release the handle of the log file.
         */
        closeInactive: number;
        /**
         * After the log file is removed, whether to release the handle of the log file. The default is false.
         */
        closeRemoved: boolean;
        /**
         * After the log file is renamed, whether to release the handle of the log file. The default is false.
         */
        closeRenamed: boolean;
        /**
         * The maximum length of time that LogCollector monitors log files. The unit is seconds, and the default is 0 seconds, which means that there is no limit to the length of time LogCollector monitors log files.
         */
        closeTimeout: number;
    }

    export interface RuleAppliersRuleUserDefineRuleParsePathRule {
        /**
         * A list of field names. Log Service will parse the path sample (PathSample) into multiple fields according to the regular expression (Regex), and Keys is used to specify the field name of each field.
         */
        keys: string[];
        /**
         * Sample capture path for a real scene.
         */
        pathSample: string;
        /**
         * Regular expression for extracting path fields. It must match the collection path sample, otherwise it cannot be extracted successfully.
         */
        regex: string;
    }

    export interface RuleAppliersRuleUserDefineRulePlugin {
        /**
         * LogCollector plugin.
         */
        processors: string;
    }

    export interface RuleAppliersRuleUserDefineRuleShardHashKey {
        /**
         * The HashKey of the log group is used to specify the partition (shard) to be written to by the current log group.
         */
        hashKey: string;
    }

    export interface RuleContainerRule {
        /**
         * The name of the container to be collected.
         */
        containerNameRegex?: string;
        /**
         * Whether to add environment variables as log tags to raw log data.
         */
        envTag?: {[key: string]: string};
        /**
         * The container environment variable blacklist is used to specify the range of containers not to be collected.
         */
        excludeContainerEnvRegex?: {[key: string]: string};
        /**
         * The container Label blacklist is used to specify the range of containers not to be collected.
         */
        excludeContainerLabelRegex?: {[key: string]: string};
        /**
         * The container environment variable whitelist specifies the container to be collected through the container environment variable. If the whitelist is not enabled, it means that all containers are specified to be collected.
         */
        includeContainerEnvRegex?: {[key: string]: string};
        /**
         * The container label whitelist specifies the containers to be collected through the container label. If the whitelist is not enabled, all containers are specified to be collected.
         */
        includeContainerLabelRegex?: {[key: string]: string};
        /**
         * Collection rules for Kubernetes containers.
         */
        kubernetesRule?: outputs.tls.RuleContainerRuleKubernetesRule;
        /**
         * The collection mode.
         */
        stream: string;
    }

    export interface RuleContainerRuleKubernetesRule {
        /**
         * Whether to add Kubernetes Annotation as a log tag to the raw log data.
         */
        annotationTag?: {[key: string]: string};
        /**
         * Specify the containers not to be collected through the Pod Label blacklist, and not enable means to collect all containers.
         */
        excludePodLabelRegex?: {[key: string]: string};
        /**
         * The Pod Label whitelist is used to specify containers to be collected. When the Pod Label whitelist is not enabled, it means that all containers are collected.
         */
        includePodLabelRegex?: {[key: string]: string};
        /**
         * Whether to add Kubernetes Label as a log label to the original log data.
         */
        labelTag?: {[key: string]: string};
        /**
         * The name of the Kubernetes Namespace to be collected. If no Namespace name is specified, all containers will be collected. Namespace names support regular matching.
         */
        namespaceNameRegex?: string;
        /**
         * The Pod name is used to specify the container to be collected. When no Pod name is specified, it means to collect all containers.
         */
        podNameRegex?: string;
        /**
         * Specify the container to be collected by the name of the workload. When no workload name is specified, all containers are collected. The workload name supports regular matching.
         */
        workloadNameRegex?: string;
        /**
         * Specify the containers to be collected by the type of workload, only one type can be selected. When no type is specified, it means all types of containers are collected. The supported types of workloads are:
         * Deployment: stateless workload.
         * StatefulSet: stateful workload.
         * DaemonSet: daemon process.
         * Job: task.
         * CronJob: scheduled task.
         */
        workloadType?: string;
    }

    export interface RuleExcludePath {
        /**
         * Collection path type. The path type can be `File` or `Path`.
         */
        type: string;
        /**
         * Collection path.
         */
        value: string;
    }

    export interface RuleExtractRule {
        /**
         * The first log line needs to match the regular expression.
         */
        beginRegex?: string;
        /**
         * The delimiter of the log.
         */
        delimiter?: string;
        /**
         * The filter key list.
         */
        filterKeyRegexes?: outputs.tls.RuleExtractRuleFilterKeyRegex[];
        /**
         * A list of log field names (Key).
         */
        keys: string[];
        /**
         * The entire log needs to match the regular expression.
         */
        logRegex?: string;
        /**
         * Automatically extract log fields according to the specified log template.
         */
        logTemplate?: outputs.tls.RuleExtractRuleLogTemplate;
        /**
         * Parsing format of the time field.
         */
        timeFormat?: string;
        /**
         * The field name of the log time field.
         */
        timeKey?: string;
        /**
         * When uploading the failed log, the key name of the failed log.
         */
        unMatchLogKey?: string;
        /**
         * Whether to upload the log of parsing failure.
         */
        unMatchUpLoadSwitch: boolean;
    }

    export interface RuleExtractRuleFilterKeyRegex {
        /**
         * The name of the filter key.
         */
        key: string;
        /**
         * The log content of the filter field needs to match the regular expression.
         */
        regex: string;
    }

    export interface RuleExtractRuleLogTemplate {
        /**
         * Log template content.
         */
        format: string;
        /**
         * The type of the log template.
         */
        type: string;
    }

    export interface RuleUserDefineRule {
        /**
         * LogCollector extension configuration.
         */
        advanced?: outputs.tls.RuleUserDefineRuleAdvanced;
        /**
         * Whether to upload raw logs.
         */
        enableRawLog?: boolean;
        /**
         * Add constant fields to logs.
         */
        fields?: {[key: string]: string};
        /**
         * Rules for parsing collection paths. After the rules are set, the fields in the collection path will be extracted through the regular expressions specified in the rules, and added to the log data as metadata.
         */
        parsePathRule?: outputs.tls.RuleUserDefineRuleParsePathRule;
        /**
         * Plugin configuration. After the plugin configuration is enabled, one or more LogCollector processor plugins can be added to parse logs with complex or variable structures.
         */
        plugin?: outputs.tls.RuleUserDefineRulePlugin;
        /**
         * Rules for routing log partitions. Setting this parameter indicates that the HashKey routing shard mode is used when collecting logs, and Log Service will write the data to the shard containing the specified Key value.
         */
        shardHashKey?: outputs.tls.RuleUserDefineRuleShardHashKey;
        /**
         * LogCollector collection strategy, which specifies whether LogCollector collects incremental logs or full logs. The default is false, which means to collect all logs.
         */
        tailFiles?: boolean;
    }

    export interface RuleUserDefineRuleAdvanced {
        /**
         * Whether to release the log file handle after reading to the end of the log file. The default is false.
         */
        closeEof?: boolean;
        /**
         * The wait time to release the log file handle. When the log file has not written a new log for more than the specified time, release the handle of the log file.
         */
        closeInactive?: number;
        /**
         * After the log file is removed, whether to release the handle of the log file. The default is false.
         */
        closeRemoved?: boolean;
        /**
         * After the log file is renamed, whether to release the handle of the log file. The default is false.
         */
        closeRenamed?: boolean;
        /**
         * The maximum length of time that LogCollector monitors log files. The unit is seconds, and the default is 0 seconds, which means that there is no limit to the length of time LogCollector monitors log files.
         */
        closeTimeout?: number;
    }

    export interface RuleUserDefineRuleParsePathRule {
        /**
         * A list of field names. Log Service will parse the path sample (PathSample) into multiple fields according to the regular expression (Regex), and Keys is used to specify the field name of each field.
         */
        keys?: string[];
        /**
         * Sample capture path for a real scene.
         */
        pathSample?: string;
        /**
         * Regular expression for extracting path fields. It must match the collection path sample, otherwise it cannot be extracted successfully.
         */
        regex?: string;
    }

    export interface RuleUserDefineRulePlugin {
        /**
         * LogCollector plugin.
         */
        processors: string[];
    }

    export interface RuleUserDefineRuleShardHashKey {
        /**
         * The HashKey of the log group is used to specify the partition (shard) to be written to by the current log group.
         */
        hashKey: string;
    }

    export interface RulesRule {
        /**
         * Container collection rules.
         */
        containerRules: outputs.tls.RulesRuleContainerRule[];
        /**
         * The creation time.
         */
        createTime: string;
        /**
         * Collect the blacklist list.
         */
        excludePaths: outputs.tls.RulesRuleExcludePath[];
        /**
         * The extract rule.
         */
        extractRules: outputs.tls.RulesRuleExtractRule[];
        /**
         * The collection type.
         */
        inputType: number;
        /**
         * Log sample.
         */
        logSample: string;
        /**
         * The log type.
         */
        logType: string;
        /**
         * The modification time.
         */
        modifyTime: string;
        /**
         * Collection path list.
         */
        paths: string[];
        /**
         * The rule id.
         */
        ruleId: string;
        /**
         * The rule name.
         */
        ruleName: string;
        /**
         * The topic id.
         */
        topicId: string;
        /**
         * The topic name.
         */
        topicName: string;
        /**
         * User-defined collection rules.
         */
        userDefineRules: outputs.tls.RulesRuleUserDefineRule[];
    }

    export interface RulesRuleContainerRule {
        /**
         * The name of the container to be collected.
         */
        containerNameRegex: string;
        /**
         * Whether to add environment variables as log tags to raw log data.
         */
        envTag: {[key: string]: any};
        /**
         * The container environment variable blacklist is used to specify the range of containers not to be collected.
         */
        excludeContainerEnvRegex: {[key: string]: any};
        /**
         * The container Label blacklist is used to specify the range of containers not to be collected.
         */
        excludeContainerLabelRegex: {[key: string]: any};
        /**
         * The container environment variable whitelist specifies the container to be collected through the container environment variable. If the whitelist is not enabled, it means that all containers are specified to be collected.
         */
        includeContainerEnvRegex: {[key: string]: any};
        /**
         * The container label whitelist specifies the containers to be collected through the container label. If the whitelist is not enabled, all containers are specified to be collected.
         */
        includeContainerLabelRegex: {[key: string]: any};
        /**
         * Collection rules for Kubernetes containers.
         */
        kubernetesRules: outputs.tls.RulesRuleContainerRuleKubernetesRule[];
        /**
         * The collection mode.
         */
        stream: string;
    }

    export interface RulesRuleContainerRuleKubernetesRule {
        /**
         * Whether to add Kubernetes Annotation as a log tag to the raw log data.
         */
        annotationTag: {[key: string]: any};
        /**
         * Specify the containers not to be collected through the Pod Label blacklist, and not enable means to collect all containers.
         */
        excludePodLabelRegex: {[key: string]: any};
        /**
         * The Pod Label whitelist is used to specify containers to be collected. When the Pod Label whitelist is not enabled, it means that all containers are collected.
         */
        includePodLabelRegex: {[key: string]: any};
        /**
         * Whether to add Kubernetes Label as a log label to the original log data.
         */
        labelTag: {[key: string]: any};
        /**
         * The name of the Kubernetes Namespace to be collected. If no Namespace name is specified, all containers will be collected. Namespace names support regular matching.
         */
        namespaceNameRegex: string;
        /**
         * The Pod name is used to specify the container to be collected. When no Pod name is specified, it means to collect all containers.
         */
        podNameRegex: string;
        /**
         * Specify the container to be collected by the name of the workload. When no workload name is specified, all containers are collected. The workload name supports regular matching.
         */
        workloadNameRegex: string;
        /**
         * Specify the container to be collected by the type of workload. Only one type can be selected. When no type is specified, it means to collect all types of containers.
         */
        workloadType: string;
    }

    export interface RulesRuleExcludePath {
        /**
         * The type of the log template.
         */
        type: string;
        /**
         * Collection path.
         */
        value: string;
    }

    export interface RulesRuleExtractRule {
        /**
         * The first log line needs to match the regular expression.
         */
        beginRegex: string;
        /**
         * The delimiter of the log.
         */
        delimiter: string;
        /**
         * The filter key list.
         */
        filterKeyRegexes: outputs.tls.RulesRuleExtractRuleFilterKeyRegex[];
        /**
         * A list of field names. Log Service will parse the path sample (PathSample) into multiple fields according to the regular expression (Regex), and Keys is used to specify the field name of each field.
         */
        keys: string[];
        /**
         * The entire log needs to match the regular expression.
         */
        logRegex: string;
        /**
         * Automatically extract log fields according to the specified log template.
         */
        logTemplates: outputs.tls.RulesRuleExtractRuleLogTemplate[];
        /**
         * Parsing format of the time field.
         */
        timeFormat: string;
        /**
         * The field name of the log time field.
         */
        timeKey: string;
        /**
         * When uploading the failed log, the key name of the failed log.
         */
        unMatchLogKey: string;
        /**
         * Whether to upload the log of parsing failure.
         */
        unMatchUpLoadSwitch: boolean;
    }

    export interface RulesRuleExtractRuleFilterKeyRegex {
        /**
         * The name of the filter key.
         */
        key: string;
        /**
         * Regular expression for extracting path fields. It must match the collection path sample, otherwise it cannot be extracted successfully.
         */
        regex: string;
    }

    export interface RulesRuleExtractRuleLogTemplate {
        /**
         * Log template content.
         */
        format: string;
        /**
         * The type of the log template.
         */
        type: string;
    }

    export interface RulesRuleUserDefineRule {
        /**
         * LogCollector extension configuration.
         */
        advanceds: outputs.tls.RulesRuleUserDefineRuleAdvanced[];
        /**
         * Whether to upload raw logs.
         */
        enableRawLog: boolean;
        /**
         * Add constant fields to logs.
         */
        fields: {[key: string]: any};
        /**
         * Rules for parsing collection paths. After the rules are set, the fields in the collection path will be extracted through the regular expressions specified in the rules, and added to the log data as metadata.
         */
        parsePathRules: outputs.tls.RulesRuleUserDefineRuleParsePathRule[];
        /**
         * Plugin configuration. After the plugin configuration is enabled, one or more LogCollector processor plugins can be added to parse logs with complex or variable structures.
         */
        plugins: outputs.tls.RulesRuleUserDefineRulePlugin[];
        /**
         * Rules for routing log partitions. Setting this parameter indicates that the HashKey routing shard mode is used when collecting logs, and Log Service will write the data to the shard containing the specified Key value.
         */
        shardHashKeys: outputs.tls.RulesRuleUserDefineRuleShardHashKey[];
        /**
         * LogCollector collection strategy, which specifies whether LogCollector collects incremental logs or full logs. The default is false, which means to collect all logs.
         */
        tailFiles: boolean;
    }

    export interface RulesRuleUserDefineRuleAdvanced {
        /**
         * Whether to release the log file handle after reading to the end of the log file. The default is false.
         */
        closeEof: boolean;
        /**
         * The wait time to release the log file handle. When the log file has not written a new log for more than the specified time, release the handle of the log file.
         */
        closeInactive: number;
        /**
         * After the log file is removed, whether to release the handle of the log file. The default is false.
         */
        closeRemoved: boolean;
        /**
         * After the log file is renamed, whether to release the handle of the log file. The default is false.
         */
        closeRenamed: boolean;
        /**
         * The maximum length of time that LogCollector monitors log files. The unit is seconds, and the default is 0 seconds, which means that there is no limit to the length of time LogCollector monitors log files.
         */
        closeTimeout: number;
    }

    export interface RulesRuleUserDefineRuleParsePathRule {
        /**
         * A list of field names. Log Service will parse the path sample (PathSample) into multiple fields according to the regular expression (Regex), and Keys is used to specify the field name of each field.
         */
        keys: string[];
        /**
         * Sample capture path for a real scene.
         */
        pathSample: string;
        /**
         * Regular expression for extracting path fields. It must match the collection path sample, otherwise it cannot be extracted successfully.
         */
        regex: string;
    }

    export interface RulesRuleUserDefineRulePlugin {
        /**
         * LogCollector plugin.
         */
        processors: string[];
    }

    export interface RulesRuleUserDefineRuleShardHashKey {
        /**
         * The HashKey of the log group is used to specify the partition (shard) to be written to by the current log group.
         */
        hashKey: string;
    }

    export interface ScheduleSqlTaskRequestCycle {
        /**
         * Cron expression. The log service specifies the timed execution of alarm tasks through the Cron expression. The minimum granularity of Cron expressions is minutes, 24 hours. For example, 0 18 * * * indicates that an alarm task is executed exactly at 18:00 every day.
         */
        cronTab?: string;
        /**
         * When setting the Type to Cron, the time zone also needs to be set.
         */
        cronTimeZone?: string;
        /**
         * The scheduling cycle or the time point of regular execution (the number of minutes away from 00:00), with a value range of 1 to 1440, and the unit is minutes.
         */
        time: number;
        /**
         * The type of Scheduling cycle.
         */
        type: string;
    }

    export interface ScheduleSqlTasksTask {
        /**
         * Set the creation time of timed SQL analysis tasks.
         */
        createTimeStamp: number;
        /**
         * A simple description of the timed SQL analysis task.
         */
        description: string;
        /**
         * The log project ID to which the target log topic belongs.
         */
        destProjectId: string;
        /**
         * The region to which the target log project belongs.
         */
        destRegion: string;
        /**
         * The target log topic ID used for storing the result data of timed SQL analysis.
         */
        destTopicId: string;
        /**
         * The name of the target log topic used for storing the data of the timed SQL analysis results.
         */
        destTopicName: string;
        /**
         * The most recent modification time of the scheduled SQL analysis task.
         */
        modifyTimeStamp: number;
        /**
         * Schedule the end time of the timed SQL analysis task in the format of a second-level timestamp.
         */
        processEndTime: number;
        /**
         * The delay time of each scheduling. The value range is from 0 to 120, and the unit is seconds.
         */
        processSqlDelay: number;
        /**
         * The start time of the scheduled SQL task, that is, the start time when the first instance is scheduled. The format is a timestamp at the second level.
         */
        processStartTime: number;
        /**
         * SQL time window, which refers to the time range for log retrieval and analysis when a timed SQL analysis task is running, is in a left-closed and right-open format.
         */
        processTimeWindow: string;
        /**
         * Timed SQL analysis tasks are retrieval and analysis statements that are executed regularly.
         */
        query: string;
        /**
         * The scheduling cycle of timed SQL analysis tasks.
         */
        requestCycle: outputs.tls.ScheduleSqlTasksTaskRequestCycle;
        /**
         * The log project ID to which the source log topic belongs.
         */
        sourceProjectId: string;
        /**
         * The name of the log item to which the source log topic belongs.
         */
        sourceProjectName: string;
        /**
         * The source log topic ID where the original log for timed SQL analysis is located.
         */
        sourceTopicId: string;
        /**
         * Source log topic name.
         */
        sourceTopicName: string;
        /**
         * Timed SQL analysis task status.
         */
        status: number;
        /**
         * Timed SQL analysis task ID.
         */
        taskId: string;
        /**
         * Timed SQL analysis task name.
         */
        taskName: string;
    }

    export interface ScheduleSqlTasksTaskRequestCycle {
        /**
         * Cron expression. The log service specifies the timed execution of alarm tasks through the Cron expression. The minimum granularity of Cron expressions is minutes, 24 hours. For example, 0 18 * * * indicates that an alarm task is executed exactly at 18:00 every day.
         */
        cronTab: string;
        /**
         * When setting the Type to Cron, the time zone also needs to be set.
         */
        cronTimeZone: string;
        /**
         * The scheduling cycle or the time point of regular execution (the number of minutes away from 00:00), with a value range of 1 to 1440, and the unit is minutes.
         */
        time: number;
        /**
         * The type of Scheduling cycle.
         */
        type: string;
    }

    export interface ShardsShard {
        /**
         * The end key info.
         */
        exclusiveEndKey: string;
        /**
         * The begin key info.
         */
        inclusiveBeginKey: string;
        /**
         * The modify time.
         */
        modifyTime: string;
        /**
         * The id of shard.
         */
        shardId: number;
        /**
         * The status of shard.
         */
        status: string;
        /**
         * The stop write time.
         */
        stopWriteTime: string;
        /**
         * The id of topic.
         */
        topicId: string;
    }

    export interface ShipperContentInfo {
        /**
         * CSV format log content configuration.
         */
        csvInfo: outputs.tls.ShipperContentInfoCsvInfo;
        /**
         * Log content parsing format.
         */
        format: string;
        /**
         * JSON format log content configuration.
         */
        jsonInfo: outputs.tls.ShipperContentInfoJsonInfo;
    }

    export interface ShipperContentInfoCsvInfo {
        /**
         * Delimiters are supported, including commas, tabs, vertical bars, semicolons, and Spaces.
         */
        delimiter: string;
        /**
         * When the field content contains a delimiter, use an escape character to wrap the field. Currently, only single quotes, double quotes, and null characters are supported.
         */
        escapeChar: string;
        /**
         * Configure the fields that need to be delivered.
         */
        keys: string[];
        /**
         * Invalid field filling content, with a length ranging from 0 to 128.
         */
        nonFieldContent: string;
        /**
         * Whether to print the Key on the first line.
         */
        printHeader: boolean;
    }

    export interface ShipperContentInfoJsonInfo {
        /**
         * Enable the flag.
         */
        enable: boolean;
        /**
         * Whether to escape or not. It must be configured as true.
         */
        escape: boolean;
        /**
         * When delivering in JSON format, if this parameter is not configured, it indicates that all fields have been delivered. Including __content__ (choice), __source__, __path__, __time__, __image_name__, __container_name__, __pod_name__, __pod_uid__, namespace, __tag____client_ip__, __tag____receive_time__.
         */
        keys: string[];
    }

    export interface ShipperKafkaShipperInfo {
        /**
         * Compression formats currently supported include snappy, gzip, lz4, and none.
         */
        compress: string;
        /**
         * Delivery end time, millisecond timestamp. If not configured, it will keep delivering.
         */
        endTime: number;
        /**
         * Kafka instance.
         */
        instance: string;
        /**
         * The name of the Kafka Topic.
         */
        kafkaTopic: string;
        /**
         * Delivery start time, millisecond timestamp. If not configured, the default is the current time.
         */
        startTime: number;
    }

    export interface ShipperTosShipperInfo {
        /**
         * When choosing a TOS bucket, it must be located in the same region as the source log topic.
         */
        bucket: string;
        /**
         * Compression formats currently supported include snappy, gzip, lz4, and none.
         */
        compress: string;
        /**
         * The delivery time interval, measured in seconds, ranges from 300 to 900.
         */
        interval: number;
        /**
         * The maximum size of the original file that can be delivered to each partition (Shard), that is, the size of the uncompressed log file. The unit is MiB, and the value range is 5 to 256.
         */
        maxSize: number;
        /**
         * Partition rules for delivering logs.
         */
        partitionFormat: string;
        /**
         * The top-level directory name of the storage bucket. All log data delivered through this delivery configuration will be delivered to this directory.
         */
        prefix: string;
    }

    export interface ShippersShipper {
        /**
         * The content format configuration of the delivery log.
         */
        contentInfo: outputs.tls.ShippersShipperContentInfo;
        /**
         * Processing task creation time.
         */
        createTime: string;
        /**
         * The default built-in dashboard ID for delivery.
         */
        dashboardId: string;
        /**
         * JSON format log content configuration.
         */
        kafkaShipperInfo: outputs.tls.ShippersShipperKafkaShipperInfo;
        /**
         * The most recent modification time of the processing task.
         */
        modifyTime: string;
        /**
         * Specify the log item ID for querying the data delivery configuration under the specified log item.
         */
        projectId: string;
        /**
         * Specify the name of the log item for querying the data delivery configuration under the specified log item. Support fuzzy matching.
         */
        projectName: string;
        /**
         * Delivery end time, millisecond timestamp. If not configured, it will keep delivering.
         */
        shipperEndTime: number;
        /**
         * Delivery configuration ID.
         */
        shipperId: string;
        /**
         * Delivery configuration name.
         */
        shipperName: string;
        /**
         * Delivery start time, millisecond timestamp. If not configured, it defaults to the current time.
         */
        shipperStartTime: number;
        /**
         * Specify the delivery type for querying the delivery configuration related to that delivery type.
         */
        shipperType: string;
        /**
         * Whether to enable the delivery configuration.
         */
        status: boolean;
        /**
         * Specify the log topic ID for querying the data delivery configuration related to this log topic.
         */
        topicId: string;
        /**
         * Specify the name of the log topic for querying the data delivery configuration related to this log topic. Support fuzzy matching.
         */
        topicName: string;
        /**
         * Deliver the relevant configuration to the object storage (TOS).
         */
        tosShipperInfo: outputs.tls.ShippersShipperTosShipperInfo;
    }

    export interface ShippersShipperContentInfo {
        /**
         * CSV format log content configuration.
         */
        csvInfo: outputs.tls.ShippersShipperContentInfoCsvInfo;
        /**
         * Log content parsing format.
         */
        format: string;
        /**
         * JSON format log content configuration.
         */
        jsonInfo: outputs.tls.ShippersShipperContentInfoJsonInfo;
    }

    export interface ShippersShipperContentInfoCsvInfo {
        /**
         * Delimiters are supported, including commas, tabs, vertical bars, semicolons, and Spaces.
         */
        delimiter: string;
        /**
         * When the field content contains a delimiter, use an escape character to wrap the field. Currently, only single quotes, double quotes, and null characters are supported.
         */
        escapeChar: string;
        /**
         * When delivering in JSON format, if this parameter is not configured, it indicates that all fields have been delivered. Including __content__ (choice), __source__, __path__, __time__, __image_name__, __container_name__, __pod_name__, __pod_uid__, namespace, __tag____client_ip__, __tag____receive_time__.
         */
        keys: string[];
        /**
         * Invalid field filling content, with a length ranging from 0 to 128.
         */
        nonFieldContent: string;
        /**
         * Whether to print the Key on the first line.
         */
        printHeader: boolean;
    }

    export interface ShippersShipperContentInfoJsonInfo {
        /**
         * Enable the flag.
         */
        enable: boolean;
        /**
         * Whether to escape or not. It must be configured as true.
         */
        escape: boolean;
        /**
         * When delivering in JSON format, if this parameter is not configured, it indicates that all fields have been delivered. Including __content__ (choice), __source__, __path__, __time__, __image_name__, __container_name__, __pod_name__, __pod_uid__, namespace, __tag____client_ip__, __tag____receive_time__.
         */
        keys: string[];
    }

    export interface ShippersShipperKafkaShipperInfo {
        /**
         * Compression formats currently supported include snappy, gzip, lz4, and none.
         */
        compress: string;
        /**
         * Delivery end time, millisecond timestamp. If not configured, it will keep delivering.
         */
        endTime: number;
        /**
         * Kafka instance.
         */
        instance: string;
        /**
         * The name of the Kafka Topic.
         */
        kafkaTopic: string;
        /**
         * Delivery start time, millisecond timestamp. If not configured, the default is the current time.
         */
        startTime: number;
    }

    export interface ShippersShipperTosShipperInfo {
        /**
         * When choosing a TOS bucket, it must be located in the same region as the source log topic.
         */
        bucket: string;
        /**
         * Compression formats currently supported include snappy, gzip, lz4, and none.
         */
        compress: string;
        /**
         * The delivery time interval, measured in seconds, ranges from 300 to 900.
         */
        interval: number;
        /**
         * The maximum size of the original file that can be delivered to each partition (Shard), that is, the size of the uncompressed log file. The unit is MiB, and the value range is 5 to 256.
         */
        maxSize: number;
        /**
         * Partition rules for delivering logs.
         */
        partitionFormat: string;
        /**
         * The top-level directory name of the storage bucket. All log data delivered through this delivery configuration will be delivered to this directory.
         */
        prefix: string;
    }

    export interface TopicTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface TopicsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface TopicsTlsTopic {
        /**
         * Whether to enable automatic partition splitting function of the tls topic.
         */
        autoSplit: boolean;
        /**
         * The create time of the tls topic.
         */
        createTime: string;
        /**
         * The description of the tls topic.
         */
        description: string;
        /**
         * Whether to enable WebTracking function of the tls topic.
         */
        enableTracking: boolean;
        /**
         * The ID of the tls topic.
         */
        id: string;
        /**
         * The max count of shards in the tls topic.
         */
        maxSplitShard: number;
        /**
         * The modify time of the tls topic.
         */
        modifyTime: string;
        /**
         * The project id of tls topic.
         */
        projectId: string;
        /**
         * The count of shards in the tls topic.
         */
        shardCount: number;
        /**
         * Tags.
         */
        tags: outputs.tls.TopicsTlsTopicTag[];
        /**
         * The format of the time field.
         */
        timeFormat: string;
        /**
         * The name of the time field.
         */
        timeKey: string;
        /**
         * The id of tls topic. This field supports fuzzy queries. It is not supported to specify both TopicName and TopicId at the same time.
         */
        topicId: string;
        /**
         * The name of tls topic. This field supports fuzzy queries. It is not supported to specify both TopicName and TopicId at the same time.
         */
        topicName: string;
        /**
         * The data storage time of the tls topic. Unit: Day.
         */
        ttl: number;
    }

    export interface TopicsTlsTopicTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

}

export namespace tos {
    export interface BucketAccountAcl {
        /**
         * The accountId to control.
         */
        accountId: string;
        /**
         * The acl type to control.Valid value is CanonicalUser.
         */
        aclType?: string;
        /**
         * The permission to control.Valid value is FULL_CONTROL|READ|READ_ACP|WRITE|WRITE_ACP.
         */
        permission: string;
    }

    export interface BucketCorsCorsRule {
        /**
         * The list of headers that are allowed in a preflight request.
         */
        allowedHeaders?: string[];
        /**
         * The list of HTTP methods that are allowed in a preflight request. Valid values: `PUT`, `POST`, `DELETE`, `GET`, `HEAD`.
         */
        allowedMethods: string[];
        /**
         * The list of origins that are allowed to make requests to the bucket.
         */
        allowedOrigins: string[];
        /**
         * The list of headers that are exposed in the response to a preflight request. It is recommended to add two expose headers, X-Tos-Request-Id and ETag.
         */
        exposeHeaders?: string[];
        /**
         * The maximum amount of time that a preflight request can be cached. Unit: second. Default value: 3600.
         */
        maxAgeSeconds: number;
        /**
         * Indicates whether the bucket returns the 'Vary: Origin' header in the response to preflight requests. Default value: false.
         */
        responseVary: boolean;
    }

    export interface BucketEncryptionRule {
        /**
         * The server side encryption configuration.
         */
        applyServerSideEncryptionByDefault: outputs.tos.BucketEncryptionRuleApplyServerSideEncryptionByDefault;
    }

    export interface BucketEncryptionRuleApplyServerSideEncryptionByDefault {
        /**
         * The kms data encryption. Valid values: `AES256`, `SM4`. Default is `AES256`.
         */
        kmsDataEncryption: string;
        /**
         * The kms master key id. This field is required when `sseAlgorithm` is `kms`. The format is `trn:kms:<region>:<accountID>:keyrings/<keyring>/keys/<key>`.
         */
        kmsMasterKeyId: string;
        /**
         * The server side encryption algorithm. Valid values: `kms`, `AES256`, `SM4`.
         */
        sseAlgorithm: string;
    }

    export interface BucketInventoriesInventoryConfiguration {
        /**
         * The name the TOS bucket.
         */
        bucketName: string;
        /**
         * The destination information of the bucket inventory.
         */
        destinations: outputs.tos.BucketInventoriesInventoryConfigurationDestination[];
        /**
         * The filter of the bucket inventory.
         */
        filters: outputs.tos.BucketInventoriesInventoryConfigurationFilter[];
        /**
         * The name of the bucket inventory.
         */
        id: string;
        /**
         * The export version of object. Valid values: `All`, `Current`.
         */
        includedObjectVersions: string;
        /**
         * Whether to enable the bucket inventory.
         */
        isEnabled: boolean;
        /**
         * The information exported from the bucket inventory.
         */
        optionalFields: outputs.tos.BucketInventoriesInventoryConfigurationOptionalField[];
        /**
         * The export schedule of the bucket inventory.
         */
        schedules: outputs.tos.BucketInventoriesInventoryConfigurationSchedule[];
    }

    export interface BucketInventoriesInventoryConfigurationDestination {
        /**
         * The destination tos bucket information of the bucket inventory.
         */
        tosBucketDestinations: outputs.tos.BucketInventoriesInventoryConfigurationDestinationTosBucketDestination[];
    }

    export interface BucketInventoriesInventoryConfigurationDestinationTosBucketDestination {
        /**
         * The account id of the destination tos bucket.
         */
        accountId: string;
        /**
         * The name of the destination tos bucket.
         */
        bucket: string;
        /**
         * The format of the bucket inventory. Valid values: `CSV`.
         */
        format: string;
        /**
         * The prefix matching information of the exported object. If not set, a list of all objects in the bucket will be generated by default.
         */
        prefix: string;
        /**
         * The role name used to grant object storage access to read all files from the source bucket and write files to the destination bucket.
         */
        role: string;
    }

    export interface BucketInventoriesInventoryConfigurationFilter {
        /**
         * The prefix matching information of the exported object. If not set, a list of all objects in the bucket will be generated by default.
         */
        prefix: string;
    }

    export interface BucketInventoriesInventoryConfigurationOptionalField {
        /**
         * The information exported from the bucket inventory. Valid values: `Size`, `LastModifiedDate`, `ETag`, `StorageClass`, `IsMultipartUploaded`, `EncryptionStatus`, `CRC64`, `ReplicationStatus`.
         */
        fields: string[];
    }

    export interface BucketInventoriesInventoryConfigurationSchedule {
        /**
         * The export schedule of the bucket inventory. Valid values: `Daily`, `Weekly`.
         */
        frequency: string;
    }

    export interface BucketInventoryDestination {
        /**
         * The destination tos bucket information of the bucket inventory.
         */
        tosBucketDestination: outputs.tos.BucketInventoryDestinationTosBucketDestination;
    }

    export interface BucketInventoryDestinationTosBucketDestination {
        /**
         * The account id of the destination tos bucket.
         */
        accountId: string;
        /**
         * The name of the destination tos bucket.
         */
        bucket: string;
        /**
         * The format of the bucket inventory. Valid values: `CSV`.
         */
        format: string;
        /**
         * The storage path prefix of the bucket inventory in destination tos bucket.
         */
        prefix: string;
        /**
         * The role name used to grant TOS access to read all files from the source bucket and write files to the destination bucket. You can use the default TOS role `TosArchiveTOSInventory`.
         */
        role: string;
    }

    export interface BucketInventoryFilter {
        /**
         * The prefix matching information of the exported object. If not set, a list of all objects in the bucket will be generated by default.
         */
        prefix?: string;
    }

    export interface BucketInventoryOptionalFields {
        /**
         * The information exported from the bucket inventory. Valid values: `Size`, `LastModifiedDate`, `ETag`, `StorageClass`, `IsMultipartUploaded`, `EncryptionStatus`, `CRC64`, `ReplicationStatus`.
         */
        fields?: string[];
    }

    export interface BucketInventorySchedule {
        /**
         * The export schedule of the bucket inventory. Valid values: `Daily`, `Weekly`.
         */
        frequency: string;
    }

    export interface BucketNotificationRules {
        /**
         * The destination info of the notification.
         */
        destination: outputs.tos.BucketNotificationRulesDestination;
        /**
         * The event type of the notification.
         */
        events: string[];
        /**
         * The filter of the notification.
         */
        filter?: outputs.tos.BucketNotificationRulesFilter;
        /**
         * The rule name of the notification.
         */
        ruleId: string;
    }

    export interface BucketNotificationRulesDestination {
        /**
         * The VeFaas info of the destination.
         */
        veFaas?: outputs.tos.BucketNotificationRulesDestinationVeFaa[];
    }

    export interface BucketNotificationRulesDestinationVeFaa {
        /**
         * The function id of the destination.
         */
        functionId: string;
    }

    export interface BucketNotificationRulesFilter {
        /**
         * The tos filter of the notification.
         */
        tosKey?: outputs.tos.BucketNotificationRulesFilterTosKey;
    }

    export interface BucketNotificationRulesFilterTosKey {
        /**
         * The filter rules of the notification.
         */
        filterRules?: outputs.tos.BucketNotificationRulesFilterTosKeyFilterRule[];
    }

    export interface BucketNotificationRulesFilterTosKeyFilterRule {
        /**
         * The name of the filter rule. Valid values: `prefix`, `suffix`.
         */
        name?: string;
        /**
         * The value of the filter rule.
         */
        value?: string;
    }

    export interface BucketObjectAccountAcl {
        /**
         * The accountId to control.
         */
        accountId: string;
        /**
         * The acl type to control.Valid value is CanonicalUser.
         */
        aclType?: string;
        /**
         * The permission to control.Valid value is FULL_CONTROL|READ|READ_ACP|WRITE|WRITE_ACP.
         */
        permission: string;
    }

    export interface BucketObjectTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface BucketObjectsObject {
        /**
         * The content the TOS Object when content type is json or text and xml.
         */
        content: string;
        /**
         * The name the TOS Object.
         */
        name: string;
        /**
         * The name the TOS Object size.
         */
        size: number;
        /**
         * The name the TOS Object storage class.
         */
        storageClass: string;
    }

    export interface BucketRealtimeLogAccessLogConfiguration {
        /**
         * The ID of the tls dashboard.
         */
        tlsDashboardId: string;
        /**
         * The ID of the tls project.
         */
        tlsProjectId: string;
        /**
         * The ID of the tls topic.
         */
        tlsTopicId: string;
        /**
         * The TLS log retention duration. Unit in days. Valid values range is 1~3650. default is 7.
         */
        ttl?: number;
    }

    export interface BucketTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface BucketsBucket {
        /**
         * The create date of the TOS bucket.
         */
        creationDate: string;
        /**
         * The extranet endpoint of the TOS bucket.
         */
        extranetEndpoint: string;
        /**
         * The intranet endpoint the TOS bucket.
         */
        intranetEndpoint: string;
        /**
         * (**Deprecated**) The Field is Deprecated. The truncated the TOS bucket.
         *
         * @deprecated The Field is Deprecated.
         */
        isTruncated: boolean;
        /**
         * The location of the TOS bucket.
         */
        location: string;
        /**
         * (**Deprecated**) The Field is Deprecated. The marker the TOS bucket.
         *
         * @deprecated The Field is Deprecated.
         */
        marker: string;
        /**
         * (**Deprecated**) The Field is Deprecated. The max keys the TOS bucket.
         *
         * @deprecated The Field is Deprecated.
         */
        maxKeys: number;
        /**
         * The name the TOS bucket.
         */
        name: string;
        /**
         * (**Deprecated**) The Field is Deprecated. The prefix the TOS bucket.
         *
         * @deprecated The Field is Deprecated.
         */
        prefix: string;
    }

    export interface GetBucketInventoriesInventoryConfiguration {
        /**
         * The name the TOS bucket.
         */
        bucketName: string;
        /**
         * The destination information of the bucket inventory.
         */
        destinations: outputs.tos.GetBucketInventoriesInventoryConfigurationDestination[];
        /**
         * The filter of the bucket inventory.
         */
        filters: outputs.tos.GetBucketInventoriesInventoryConfigurationFilter[];
        /**
         * The name of the bucket inventory.
         */
        id: string;
        /**
         * The export version of object. Valid values: `All`, `Current`.
         */
        includedObjectVersions: string;
        /**
         * Whether to enable the bucket inventory.
         */
        isEnabled: boolean;
        /**
         * The information exported from the bucket inventory.
         */
        optionalFields: outputs.tos.GetBucketInventoriesInventoryConfigurationOptionalField[];
        /**
         * The export schedule of the bucket inventory.
         */
        schedules: outputs.tos.GetBucketInventoriesInventoryConfigurationSchedule[];
    }

    export interface GetBucketInventoriesInventoryConfigurationDestination {
        /**
         * The destination tos bucket information of the bucket inventory.
         */
        tosBucketDestinations: outputs.tos.GetBucketInventoriesInventoryConfigurationDestinationTosBucketDestination[];
    }

    export interface GetBucketInventoriesInventoryConfigurationDestinationTosBucketDestination {
        /**
         * The account id of the destination tos bucket.
         */
        accountId: string;
        /**
         * The name of the destination tos bucket.
         */
        bucket: string;
        /**
         * The format of the bucket inventory. Valid values: `CSV`.
         */
        format: string;
        /**
         * The prefix matching information of the exported object. If not set, a list of all objects in the bucket will be generated by default.
         */
        prefix: string;
        /**
         * The role name used to grant object storage access to read all files from the source bucket and write files to the destination bucket.
         */
        role: string;
    }

    export interface GetBucketInventoriesInventoryConfigurationFilter {
        /**
         * The prefix matching information of the exported object. If not set, a list of all objects in the bucket will be generated by default.
         */
        prefix: string;
    }

    export interface GetBucketInventoriesInventoryConfigurationOptionalField {
        /**
         * The information exported from the bucket inventory. Valid values: `Size`, `LastModifiedDate`, `ETag`, `StorageClass`, `IsMultipartUploaded`, `EncryptionStatus`, `CRC64`, `ReplicationStatus`.
         */
        fields: string[];
    }

    export interface GetBucketInventoriesInventoryConfigurationSchedule {
        /**
         * The export schedule of the bucket inventory. Valid values: `Daily`, `Weekly`.
         */
        frequency: string;
    }

    export interface GetBucketObjectsObject {
        /**
         * The content the TOS Object when content type is json or text and xml.
         */
        content: string;
        /**
         * The name the TOS Object.
         */
        name: string;
        /**
         * The name the TOS Object size.
         */
        size: number;
        /**
         * The name the TOS Object storage class.
         */
        storageClass: string;
    }

    export interface GetBucketsBucket {
        /**
         * The create date of the TOS bucket.
         */
        creationDate: string;
        /**
         * The extranet endpoint of the TOS bucket.
         */
        extranetEndpoint: string;
        /**
         * The intranet endpoint the TOS bucket.
         */
        intranetEndpoint: string;
        /**
         * (**Deprecated**) The Field is Deprecated. The truncated the TOS bucket.
         *
         * @deprecated The Field is Deprecated.
         */
        isTruncated: boolean;
        /**
         * The location of the TOS bucket.
         */
        location: string;
        /**
         * (**Deprecated**) The Field is Deprecated. The marker the TOS bucket.
         *
         * @deprecated The Field is Deprecated.
         */
        marker: string;
        /**
         * (**Deprecated**) The Field is Deprecated. The max keys the TOS bucket.
         *
         * @deprecated The Field is Deprecated.
         */
        maxKeys: number;
        /**
         * The name the TOS bucket.
         */
        name: string;
        /**
         * (**Deprecated**) The Field is Deprecated. The prefix the TOS bucket.
         *
         * @deprecated The Field is Deprecated.
         */
        prefix: string;
    }

}

export namespace transit_router {
    export interface BandwidthPackageAllocation {
        /**
         * The delete time of the transit router bandwidth package.
         */
        allocateTime: string;
        /**
         * The delete time of the transit router bandwidth package.
         */
        deleteTime: string;
        /**
         * The local region id of the transit router.
         */
        localRegionId: string;
        /**
         * The ID of the peer attachment.
         */
        transitRouterPeerAttachmentId: string;
    }

    export interface BandwidthPackageTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface BandwidthPackagesBandwidthPackage {
        /**
         * The account id.
         */
        accountId: string;
        /**
         * The detailed information on cross regional connections associated with bandwidth packets.
         */
        allocations: outputs.transit_router.BandwidthPackagesBandwidthPackageAllocation[];
        /**
         * The bandwidth peak of the transit router bandwidth package. Unit: Mbps.
         */
        bandwidth: number;
        /**
         * The billing type of the transit router bandwidth package.
         */
        billingType: string;
        /**
         * The business status of the transit router bandwidth package.
         */
        businessStatus: string;
        /**
         * The create time of the transit router bandwidth package.
         */
        creationTime: string;
        /**
         * The delete time of the transit router bandwidth package.
         */
        deleteTime: string;
        /**
         * The description of the transit router bandwidth package.
         */
        description: string;
        /**
         * The expired time of the transit router bandwidth package.
         */
        expiredTime: string;
        /**
         * The id of the transit router bandwidth package.
         */
        id: string;
        /**
         * The local geographic region set ID.
         */
        localGeographicRegionSetId: string;
        /**
         * The peer geographic region set ID.
         */
        peerGeographicRegionSetId: string;
        /**
         * The ProjectName of the TransitRouter bandwidth package.
         */
        projectName: string;
        /**
         * The remaining bandwidth of the transit router bandwidth package. Unit: Mbps.
         */
        remainingBandwidth: number;
        /**
         * The status of the transit router bandwidth package.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.transit_router.BandwidthPackagesBandwidthPackageTag[];
        /**
         * The id of the transit router attachment.
         */
        transitRouterBandwidthPackageId: string;
        /**
         * The name of the TransitRouter bandwidth package.
         */
        transitRouterBandwidthPackageName: string;
        /**
         * The update time of the transit router bandwidth package.
         */
        updateTime: string;
    }

    export interface BandwidthPackagesBandwidthPackageAllocation {
        /**
         * The delete time of the transit router bandwidth package.
         */
        allocateTime: string;
        /**
         * The delete time of the transit router bandwidth package.
         */
        deleteTime: string;
        /**
         * The local region id of the transit router.
         */
        localRegionId: string;
        /**
         * The ID of the peer attachment.
         */
        transitRouterPeerAttachmentId: string;
    }

    export interface BandwidthPackagesBandwidthPackageTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface BandwidthPackagesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface DirectConnectGatewayAttachmentTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface DirectConnectGatewayAttachmentsAttachment {
        /**
         * The account id.
         */
        accountId: string;
        /**
         * The create time.
         */
        creationTime: string;
        /**
         * The description info.
         */
        description: string;
        /**
         * ID of the direct connection gateway.
         */
        directConnectGatewayId: string;
        /**
         * The status of the network instance connection.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.transit_router.DirectConnectGatewayAttachmentsAttachmentTag[];
        /**
         * The id of the transit router attachment.
         */
        transitRouterAttachmentId: string;
        /**
         * The name of the transit router attachment.
         */
        transitRouterAttachmentName: string;
        /**
         * The id of the transit router.
         */
        transitRouterId: string;
        /**
         * The update time.
         */
        updateTime: string;
    }

    export interface DirectConnectGatewayAttachmentsAttachmentTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface DirectConnectGatewayAttachmentsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetBandwidthPackagesBandwidthPackage {
        /**
         * The account id.
         */
        accountId: string;
        /**
         * The detailed information on cross regional connections associated with bandwidth packets.
         */
        allocations: outputs.transit_router.GetBandwidthPackagesBandwidthPackageAllocation[];
        /**
         * The bandwidth peak of the transit router bandwidth package. Unit: Mbps.
         */
        bandwidth: number;
        /**
         * The billing type of the transit router bandwidth package.
         */
        billingType: string;
        /**
         * The business status of the transit router bandwidth package.
         */
        businessStatus: string;
        /**
         * The create time of the transit router bandwidth package.
         */
        creationTime: string;
        /**
         * The delete time of the transit router bandwidth package.
         */
        deleteTime: string;
        /**
         * The description of the transit router bandwidth package.
         */
        description: string;
        /**
         * The expired time of the transit router bandwidth package.
         */
        expiredTime: string;
        /**
         * The id of the transit router bandwidth package.
         */
        id: string;
        /**
         * The local geographic region set ID.
         */
        localGeographicRegionSetId: string;
        /**
         * The peer geographic region set ID.
         */
        peerGeographicRegionSetId: string;
        /**
         * The ProjectName of the TransitRouter bandwidth package.
         */
        projectName: string;
        /**
         * The remaining bandwidth of the transit router bandwidth package. Unit: Mbps.
         */
        remainingBandwidth: number;
        /**
         * The status of the transit router bandwidth package.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.transit_router.GetBandwidthPackagesBandwidthPackageTag[];
        /**
         * The id of the transit router attachment.
         */
        transitRouterBandwidthPackageId: string;
        /**
         * The name of the TransitRouter bandwidth package.
         */
        transitRouterBandwidthPackageName: string;
        /**
         * The update time of the transit router bandwidth package.
         */
        updateTime: string;
    }

    export interface GetBandwidthPackagesBandwidthPackageAllocation {
        /**
         * The delete time of the transit router bandwidth package.
         */
        allocateTime: string;
        /**
         * The delete time of the transit router bandwidth package.
         */
        deleteTime: string;
        /**
         * The local region id of the transit router.
         */
        localRegionId: string;
        /**
         * The ID of the peer attachment.
         */
        transitRouterPeerAttachmentId: string;
    }

    export interface GetBandwidthPackagesBandwidthPackageTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetBandwidthPackagesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetDirectConnectGatewayAttachmentsAttachment {
        /**
         * The account id.
         */
        accountId: string;
        /**
         * The create time.
         */
        creationTime: string;
        /**
         * The description info.
         */
        description: string;
        /**
         * ID of the direct connection gateway.
         */
        directConnectGatewayId: string;
        /**
         * The status of the network instance connection.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.transit_router.GetDirectConnectGatewayAttachmentsAttachmentTag[];
        /**
         * The id of the transit router attachment.
         */
        transitRouterAttachmentId: string;
        /**
         * The name of the transit router attachment.
         */
        transitRouterAttachmentName: string;
        /**
         * The id of the transit router.
         */
        transitRouterId: string;
        /**
         * The update time.
         */
        updateTime: string;
    }

    export interface GetDirectConnectGatewayAttachmentsAttachmentTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetDirectConnectGatewayAttachmentsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetGrantRulesRule {
        /**
         * The creation time of the rule.
         */
        creationTime: string;
        /**
         * The description of the rule.
         */
        description: string;
        /**
         * The id of the grant account.
         */
        grantAccountId: string;
        /**
         * The status of the rule.
         */
        status: string;
        /**
         * The id of the transit router.
         */
        transitRouterId: string;
        /**
         * The update time of the rule.
         */
        updateTime: string;
    }

    export interface GetPeerAttachmentsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetPeerAttachmentsTransitRouterAttachment {
        /**
         * The bandwidth of the transit router peer attachment.
         */
        bandwidth: number;
        /**
         * The creation time of the transit router peer attachment.
         */
        creationTime: string;
        /**
         * The description of the transit router peer attachment.
         */
        description: string;
        /**
         * The id of the transit router peer attachment.
         */
        id: string;
        /**
         * The id of peer transit router.
         */
        peerTransitRouterId: string;
        /**
         * The region id of peer transit router.
         */
        peerTransitRouterRegionId: string;
        /**
         * The status of the transit router peer attachment.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.transit_router.GetPeerAttachmentsTransitRouterAttachmentTag[];
        /**
         * The id of the transit router peer attachment.
         */
        transitRouterAttachmentId: string;
        /**
         * The name of transit router peer attachment.
         */
        transitRouterAttachmentName: string;
        /**
         * The bandwidth package id of the transit router peer attachment.
         */
        transitRouterBandwidthPackageId: string;
        /**
         * The id of local transit router.
         */
        transitRouterId: string;
        /**
         * The route table id of the transit router peer attachment.
         */
        transitRouterRouteTableId: string;
        /**
         * The update time of the transit router peer attachment.
         */
        updateTime: string;
    }

    export interface GetPeerAttachmentsTransitRouterAttachmentTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetRouteEntriesEntry {
        /**
         * The as path of the route entry.
         */
        asPath: string;
        /**
         * The creation time of the route entry.
         */
        creationTime: string;
        /**
         * Description of the transit router route entry.
         */
        description: string;
        /**
         * The target network segment of the route entry.
         */
        destinationCidrBlock: string;
        /**
         * The status of the route entry.
         */
        status: string;
        /**
         * The id of the route entry.
         */
        transitRouterRouteEntryId: string;
        /**
         * The name of the route entry.
         */
        transitRouterRouteEntryName: string;
        /**
         * The next hot id of the routing entry.
         */
        transitRouterRouteEntryNextHopId: string;
        /**
         * The next hop type of the routing entry. The value can be Attachment or BlackHole.
         */
        transitRouterRouteEntryNextHopType: string;
        /**
         * The type of the route entry.
         */
        transitRouterRouteEntryType: string;
        /**
         * The update time of the route entry.
         */
        updateTime: string;
    }

    export interface GetRouteTableAssociationsAssociation {
        /**
         * The status of the route table.
         */
        status: string;
        /**
         * The ID of the network instance connection.
         */
        transitRouterAttachmentId: string;
        /**
         * The ID of the routing table associated with the transit router instance.
         */
        transitRouterRouteTableId: string;
    }

    export interface GetRouteTablePropagationsPropagation {
        /**
         * The creation time of the route table propagation.
         */
        creationTime: string;
        /**
         * The status of the route table.
         */
        status: string;
        /**
         * The ID of the network instance connection.
         */
        transitRouterAttachmentId: string;
        /**
         * The ID of the routing table associated with the transit router instance.
         */
        transitRouterRouteTableId: string;
    }

    export interface GetRouteTablesRouteTable {
        /**
         * The creation time of the route table.
         */
        creationTime: string;
        /**
         * The description.
         */
        description: string;
        /**
         * The status of the route table.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.transit_router.GetRouteTablesRouteTableTag[];
        /**
         * The id of the route table.
         */
        transitRouterRouteTableId: string;
        /**
         * The name of the route table.
         */
        transitRouterRouteTableName: string;
        /**
         * The type of the route table. The value can be System or Custom.
         */
        transitRouterRouteTableType: string;
        /**
         * The update time of the route table.
         */
        updateTime: string;
    }

    export interface GetRouteTablesRouteTableTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetRouteTablesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetTransitRoutersTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetTransitRoutersTransitRouter {
        /**
         * The ID of account.
         */
        accountId: string;
        /**
         * The asn of the transit router.
         */
        asn: number;
        /**
         * The business status of the transit router.
         */
        businessStatus: string;
        /**
         * The create time.
         */
        creationTime: string;
        /**
         * The description info.
         */
        description: string;
        /**
         * The grant status of the transit router.
         */
        grantStatus: string;
        /**
         * The ID of the transit router.
         */
        id: string;
        /**
         * The overdue time.
         */
        overdueTime: string;
        /**
         * The ProjectName of the transit router.
         */
        projectName: string;
        /**
         * The status of the transit router.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.transit_router.GetTransitRoutersTransitRouterTag[];
        /**
         * The attachments of transit router.
         */
        transitRouterAttachments: outputs.transit_router.GetTransitRoutersTransitRouterTransitRouterAttachment[];
        /**
         * The ID of the transit router.
         */
        transitRouterId: string;
        /**
         * The name info.
         */
        transitRouterName: string;
        /**
         * The update time.
         */
        updateTime: string;
    }

    export interface GetTransitRoutersTransitRouterTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetTransitRoutersTransitRouterTransitRouterAttachment {
        /**
         * The create time.
         */
        creationTime: string;
        /**
         * The id of resource.
         */
        resourceId: string;
        /**
         * The type of resource.
         */
        resourceType: string;
        /**
         * The status of the transit router.
         */
        status: string;
        /**
         * The id of transit router attachment.
         */
        transitRouterAttachmentId: string;
        /**
         * The name of transit router attachment.
         */
        transitRouterAttachmentName: string;
        /**
         * The id of transit router route table.
         */
        transitRouterRouteTableId: string;
        /**
         * The update time.
         */
        updateTime: string;
    }

    export interface GetVpcAttachmentsAttachment {
        /**
         * The collection of attach points.
         */
        attachPoints: outputs.transit_router.GetVpcAttachmentsAttachmentAttachPoint[];
        /**
         * Whether to auto publish route of the transit router to vpc instance.
         */
        autoPublishRouteEnabled: boolean;
        /**
         * The create time.
         */
        creationTime: string;
        /**
         * The description info.
         */
        description: string;
        /**
         * The status of the transit router.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.transit_router.GetVpcAttachmentsAttachmentTag[];
        /**
         * The id of the transit router attachment.
         */
        transitRouterAttachmentId: string;
        /**
         * The name of the transit router attachment.
         */
        transitRouterAttachmentName: string;
        /**
         * The id of transit router.
         */
        transitRouterId: string;
        /**
         * The update time.
         */
        updateTime: string;
        /**
         * The id of vpc.
         */
        vpcId: string;
    }

    export interface GetVpcAttachmentsAttachmentAttachPoint {
        /**
         * The ID of network interface.
         */
        networkInterfaceId: string;
        /**
         * The ID of subnet.
         */
        subnetId: string;
        /**
         * The ID of zone.
         */
        zoneId: string;
    }

    export interface GetVpcAttachmentsAttachmentTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetVpcAttachmentsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetVpnAttachmentsAttachment {
        /**
         * The create time.
         */
        creationTime: string;
        /**
         * The description info.
         */
        description: string;
        /**
         * The status of the transit router.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.transit_router.GetVpnAttachmentsAttachmentTag[];
        /**
         * The id of the transit router attachment.
         */
        transitRouterAttachmentId: string;
        /**
         * The name of the transit router attachment.
         */
        transitRouterAttachmentName: string;
        /**
         * The id of the transit router.
         */
        transitRouterId: string;
        /**
         * The update time.
         */
        updateTime: string;
        /**
         * The ID of the IPSec connection.
         */
        vpnConnectionId: string;
        /**
         * The ID of the availability zone.
         */
        zoneId: string;
    }

    export interface GetVpnAttachmentsAttachmentTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetVpnAttachmentsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GrantRulesRule {
        /**
         * The creation time of the rule.
         */
        creationTime: string;
        /**
         * The description of the rule.
         */
        description: string;
        /**
         * The id of the grant account.
         */
        grantAccountId: string;
        /**
         * The status of the rule.
         */
        status: string;
        /**
         * The id of the transit router.
         */
        transitRouterId: string;
        /**
         * The update time of the rule.
         */
        updateTime: string;
    }

    export interface PeerAttachmentTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface PeerAttachmentsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface PeerAttachmentsTransitRouterAttachment {
        /**
         * The bandwidth of the transit router peer attachment.
         */
        bandwidth: number;
        /**
         * The creation time of the transit router peer attachment.
         */
        creationTime: string;
        /**
         * The description of the transit router peer attachment.
         */
        description: string;
        /**
         * The id of the transit router peer attachment.
         */
        id: string;
        /**
         * The id of peer transit router.
         */
        peerTransitRouterId: string;
        /**
         * The region id of peer transit router.
         */
        peerTransitRouterRegionId: string;
        /**
         * The status of the transit router peer attachment.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.transit_router.PeerAttachmentsTransitRouterAttachmentTag[];
        /**
         * The id of the transit router peer attachment.
         */
        transitRouterAttachmentId: string;
        /**
         * The name of transit router peer attachment.
         */
        transitRouterAttachmentName: string;
        /**
         * The bandwidth package id of the transit router peer attachment.
         */
        transitRouterBandwidthPackageId: string;
        /**
         * The id of local transit router.
         */
        transitRouterId: string;
        /**
         * The route table id of the transit router peer attachment.
         */
        transitRouterRouteTableId: string;
        /**
         * The update time of the transit router peer attachment.
         */
        updateTime: string;
    }

    export interface PeerAttachmentsTransitRouterAttachmentTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface RouteEntriesEntry {
        /**
         * The as path of the route entry.
         */
        asPath: string;
        /**
         * The creation time of the route entry.
         */
        creationTime: string;
        /**
         * Description of the transit router route entry.
         */
        description: string;
        /**
         * The target network segment of the route entry.
         */
        destinationCidrBlock: string;
        /**
         * The status of the route entry.
         */
        status: string;
        /**
         * The id of the route entry.
         */
        transitRouterRouteEntryId: string;
        /**
         * The name of the route entry.
         */
        transitRouterRouteEntryName: string;
        /**
         * The next hot id of the routing entry.
         */
        transitRouterRouteEntryNextHopId: string;
        /**
         * The next hop type of the routing entry. The value can be Attachment or BlackHole.
         */
        transitRouterRouteEntryNextHopType: string;
        /**
         * The type of the route entry.
         */
        transitRouterRouteEntryType: string;
        /**
         * The update time of the route entry.
         */
        updateTime: string;
    }

    export interface RouteTableAssociationsAssociation {
        /**
         * The status of the route table.
         */
        status: string;
        /**
         * The ID of the network instance connection.
         */
        transitRouterAttachmentId: string;
        /**
         * The ID of the routing table associated with the transit router instance.
         */
        transitRouterRouteTableId: string;
    }

    export interface RouteTablePropagationsPropagation {
        /**
         * The creation time of the route table propagation.
         */
        creationTime: string;
        /**
         * The status of the route table.
         */
        status: string;
        /**
         * The ID of the network instance connection.
         */
        transitRouterAttachmentId: string;
        /**
         * The ID of the routing table associated with the transit router instance.
         */
        transitRouterRouteTableId: string;
    }

    export interface RouteTableTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface RouteTablesRouteTable {
        /**
         * The creation time of the route table.
         */
        creationTime: string;
        /**
         * The description.
         */
        description: string;
        /**
         * The status of the route table.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.transit_router.RouteTablesRouteTableTag[];
        /**
         * The id of the route table.
         */
        transitRouterRouteTableId: string;
        /**
         * The name of the route table.
         */
        transitRouterRouteTableName: string;
        /**
         * The type of the route table. The value can be System or Custom.
         */
        transitRouterRouteTableType: string;
        /**
         * The update time of the route table.
         */
        updateTime: string;
    }

    export interface RouteTablesRouteTableTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface RouteTablesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface TransitRouterTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface TransitRouterTransitRouterAttachment {
        /**
         * The create time.
         */
        creationTime: string;
        /**
         * The id of resource.
         */
        resourceId: string;
        /**
         * The type of resource.
         */
        resourceType: string;
        /**
         * The status of the transit router.
         */
        status: string;
        /**
         * The id of transit router attachment.
         */
        transitRouterAttachmentId: string;
        /**
         * The name of transit router attachment.
         */
        transitRouterAttachmentName: string;
        /**
         * The id of transit router route table.
         */
        transitRouterRouteTableId: string;
        /**
         * The update time.
         */
        updateTime: string;
    }

    export interface TransitRoutersTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface TransitRoutersTransitRouter {
        /**
         * The ID of account.
         */
        accountId: string;
        /**
         * The asn of the transit router.
         */
        asn: number;
        /**
         * The business status of the transit router.
         */
        businessStatus: string;
        /**
         * The create time.
         */
        creationTime: string;
        /**
         * The description info.
         */
        description: string;
        /**
         * The grant status of the transit router.
         */
        grantStatus: string;
        /**
         * The ID of the transit router.
         */
        id: string;
        /**
         * The overdue time.
         */
        overdueTime: string;
        /**
         * The ProjectName of the transit router.
         */
        projectName: string;
        /**
         * The status of the transit router.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.transit_router.TransitRoutersTransitRouterTag[];
        /**
         * The attachments of transit router.
         */
        transitRouterAttachments: outputs.transit_router.TransitRoutersTransitRouterTransitRouterAttachment[];
        /**
         * The ID of the transit router.
         */
        transitRouterId: string;
        /**
         * The name info.
         */
        transitRouterName: string;
        /**
         * The update time.
         */
        updateTime: string;
    }

    export interface TransitRoutersTransitRouterTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface TransitRoutersTransitRouterTransitRouterAttachment {
        /**
         * The create time.
         */
        creationTime: string;
        /**
         * The id of resource.
         */
        resourceId: string;
        /**
         * The type of resource.
         */
        resourceType: string;
        /**
         * The status of the transit router.
         */
        status: string;
        /**
         * The id of transit router attachment.
         */
        transitRouterAttachmentId: string;
        /**
         * The name of transit router attachment.
         */
        transitRouterAttachmentName: string;
        /**
         * The id of transit router route table.
         */
        transitRouterRouteTableId: string;
        /**
         * The update time.
         */
        updateTime: string;
    }

    export interface VpcAttachmentAttachPoint {
        /**
         * The id of subnet.
         */
        subnetId: string;
        /**
         * The id of zone.
         */
        zoneId: string;
    }

    export interface VpcAttachmentTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface VpcAttachmentsAttachment {
        /**
         * The collection of attach points.
         */
        attachPoints: outputs.transit_router.VpcAttachmentsAttachmentAttachPoint[];
        /**
         * Whether to auto publish route of the transit router to vpc instance.
         */
        autoPublishRouteEnabled: boolean;
        /**
         * The create time.
         */
        creationTime: string;
        /**
         * The description info.
         */
        description: string;
        /**
         * The status of the transit router.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.transit_router.VpcAttachmentsAttachmentTag[];
        /**
         * The id of the transit router attachment.
         */
        transitRouterAttachmentId: string;
        /**
         * The name of the transit router attachment.
         */
        transitRouterAttachmentName: string;
        /**
         * The id of transit router.
         */
        transitRouterId: string;
        /**
         * The update time.
         */
        updateTime: string;
        /**
         * The id of vpc.
         */
        vpcId: string;
    }

    export interface VpcAttachmentsAttachmentAttachPoint {
        /**
         * The ID of network interface.
         */
        networkInterfaceId: string;
        /**
         * The ID of subnet.
         */
        subnetId: string;
        /**
         * The ID of zone.
         */
        zoneId: string;
    }

    export interface VpcAttachmentsAttachmentTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface VpcAttachmentsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface VpnAttachmentTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface VpnAttachmentsAttachment {
        /**
         * The create time.
         */
        creationTime: string;
        /**
         * The description info.
         */
        description: string;
        /**
         * The status of the transit router.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.transit_router.VpnAttachmentsAttachmentTag[];
        /**
         * The id of the transit router attachment.
         */
        transitRouterAttachmentId: string;
        /**
         * The name of the transit router attachment.
         */
        transitRouterAttachmentName: string;
        /**
         * The id of the transit router.
         */
        transitRouterId: string;
        /**
         * The update time.
         */
        updateTime: string;
        /**
         * The ID of the IPSec connection.
         */
        vpnConnectionId: string;
        /**
         * The ID of the availability zone.
         */
        zoneId: string;
    }

    export interface VpnAttachmentsAttachmentTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface VpnAttachmentsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

}

export namespace vedb_mysql {
    export interface AccountAccountPrivilege {
        /**
         * Authorization database privilege types: 
         * ReadWrite: Read and write privilege.
         * ReadOnly: Read-only privilege.
         * DDLOnly: Only DDL privilege.
         * DMLOnly: Only DML privilege.
         * Custom: Custom privilege.
         */
        accountPrivilege: string;
        /**
         * The specific SQL operation permissions contained in the permission type are separated by English commas (,) between multiple strings.
         * When used as a request parameter in the CreateDatabase interface, when the AccountPrivilege value is Custom, this parameter is required. Value range (multiple selections allowed): SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, REFERENCES, INDEX, ALTER, CREATE TEMPORARY TABLES, LOCK TABLES, EXECUTE, CREATE VIEW, SHOW VIEW, CREATE ROUTINE, ALTER ROUTINE, EVENT, TRIGGER. When used as a return parameter in the DescribeDatabases interface, regardless of the value of AccountPrivilege, the details of the SQL operation permissions contained in this permission type are returned. For the specific SQL operation permissions contained in each permission type, please refer to the account permission list.
         */
        accountPrivilegeDetail: string;
        /**
         * Database name requiring authorization.
         */
        dbName: string;
    }

    export interface AccountsAccount {
        /**
         * The name of the database account. This field supports fuzzy query.
         */
        accountName: string;
        /**
         * The privilege detail list of RDS mysql instance account.
         */
        accountPrivileges: outputs.vedb_mysql.AccountsAccountAccountPrivilege[];
        /**
         * The type of the database account.
         */
        accountType: string;
    }

    export interface AccountsAccountAccountPrivilege {
        /**
         * The privilege type of the account.
         */
        accountPrivilege: string;
        /**
         * The privilege detail of the account.
         */
        accountPrivilegeDetail: string;
        /**
         * The name of database.
         */
        dbName: string;
    }

    export interface AllowlistsAllowList {
        /**
         * The description of the allow list.
         */
        allowListDesc: string;
        /**
         * The id of the allow list.
         */
        allowListId: string;
        /**
         * The total number of IP addresses (or address ranges) in the whitelist.
         */
        allowListIpNum: number;
        /**
         * The name of the allow list.
         */
        allowListName: string;
        /**
         * The type of the allow list.
         */
        allowListType: string;
        /**
         * The IP address or a range of IP addresses in CIDR format.
         */
        allowLists: string[];
        /**
         * The total number of instances bound under the whitelist.
         */
        associatedInstanceNum: number;
        /**
         * The list of instances.
         */
        associatedInstances: outputs.vedb_mysql.AllowlistsAllowListAssociatedInstance[];
    }

    export interface AllowlistsAllowListAssociatedInstance {
        /**
         * Instance ID. When an InstanceId is specified, the DescribeAllowLists interface will return the whitelist bound to the specified instance.
         */
        instanceId: string;
        /**
         * The name of the instance.
         */
        instanceName: string;
        /**
         * The id of the vpc.
         */
        vpc: string;
    }

    export interface BackupBackupPolicy {
        /**
         * Data backup retention period, value: 7 to 30 days.
         */
        backupRetentionPeriod: number;
        /**
         * The time for executing the backup task has an interval window of 2 hours and must be an even-hour time. Format: HH:mmZ-HH:mmZ (UTC time).
         */
        backupTime: string;
        /**
         * Full backup period. It is recommended to select at least 2 days per week for full backup. Multiple values are separated by English commas (,). Values: Monday: Monday. Tuesday: Tuesday. Wednesday: Wednesday. Thursday: Thursday. Friday: Friday. Saturday: Saturday. Sunday: Sunday.
         */
        fullBackupPeriod: string;
    }

    export interface BackupsBackup {
        /**
         * The end time of the backup.
         */
        backupEndTime: string;
        /**
         * The size of the backup file.
         */
        backupFileSize: number;
        /**
         * The id of the backup.
         */
        backupId: string;
        /**
         * Backup method. Currently, only physical backup is supported. The value is Physical.
         */
        backupMethod: string;
        /**
         * Data backup strategy for instances.
         */
        backupPolicies: outputs.vedb_mysql.BackupsBackupBackupPolicy[];
        /**
         * The start time of the backup.
         */
        backupStartTime: string;
        /**
         * The status of the backup.
         */
        backupStatus: string;
        /**
         * The type of the backup.
         */
        backupType: string;
        /**
         * The time point of consistent backup, in the format: yyyy-MM-ddTHH:mm:ssZ (UTC time).
         */
        consistentTime: string;
        /**
         * The type of the backup create.
         */
        createType: string;
        /**
         * The id of the backup.
         */
        id: string;
    }

    export interface BackupsBackupBackupPolicy {
        /**
         * Data backup retention period, value: 7 to 30 days.
         */
        backupRetentionPeriod: number;
        /**
         * The time for executing the backup task. The interval window is two hours. Format: HH:mmZ-HH:mmZ (UTC time).
         */
        backupTime: string;
        /**
         * Whether to enable continuous backup. The value is fixed as true.
         */
        continueBackup: boolean;
        /**
         * Full backup period. Multiple values are separated by English commas (,). Values:
         * Monday: Monday.
         * Tuesday: Tuesday.
         * Wednesday: Wednesday.
         * Thursday: Thursday.
         * Friday: Friday.
         * Saturday: Saturday.
         * Sunday: Sunday.
         */
        fullBackupPeriod: string;
        /**
         * The id of the instance.
         */
        instanceId: string;
    }

    export interface DatabasesDatabase {
        /**
         * Database character set: utf8mb4 (default), utf8, latin1, ascii.
         */
        characterSetName: string;
        databasesPrivileges: outputs.vedb_mysql.DatabasesDatabaseDatabasesPrivilege[];
        /**
         * Database name.
         */
        dbName: string;
    }

    export interface DatabasesDatabaseDatabasesPrivilege {
        /**
         * Account name that requires authorization.
         */
        accountName: string;
        /**
         * Authorization database privilege types: 
         * ReadWrite: Read and write privilege.
         *  ReadOnly: Read-only privilege.
         *  DDLOnly: Only DDL privilege.
         *  DMLOnly: Only DML privilege.
         *  Custom: Custom privilege.
         */
        accountPrivilege: string;
        /**
         * The specific SQL operation permissions contained in the permission type are separated by English commas (,) between multiple strings.
         *  When used as a request parameter in the CreateDatabase interface, when the AccountPrivilege value is Custom, this parameter is required. Value range (multiple selections allowed): SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, REFERENCES, INDEX, ALTER, CREATE TEMPORARY TABLES, LOCK TABLES, EXECUTE, CREATE VIEW, SHOW VIEW, CREATE ROUTINE, ALTER ROUTINE, EVENT, TRIGGER. When used as a return parameter in the DescribeDatabases interface, regardless of the value of AccountPrivilege, the details of the SQL operation permissions contained in this permission type are returned. For the specific SQL operation permissions contained in each permission type, please refer to the account permission list.
         */
        accountPrivilegeDetail: string;
    }

    export interface EndpointsEndpoint {
        /**
         * The address information.
         */
        addresses: outputs.vedb_mysql.EndpointsEndpointAddress[];
        /**
         * Set whether newly created read-only nodes will automatically join this connection endpoint. Values:
         * true: Automatically join.
         * false: Do not automatically join (default).
         */
        autoAddNewNodes: boolean;
        /**
         * Consistency level. For detailed introduction of consistency level, please refer to consistency level. Value range:
         * Eventual: eventual consistency.
         * Session: session consistency.
         * Global: global consistency.
         * Description
         * When the value of ReadWriteMode is ReadWrite, the selectable consistency levels are Eventual, Session (default), and Global.
         * When the value of ReadWriteMode is ReadOnly, the consistency level is Eventual by default and cannot be changed.
         */
        consistLevel: string;
        /**
         * When there is a large delay, the timeout period for read-only nodes to synchronize the latest data, in us. The value range is from 1us to 100000000us, and the default value is 10000us.
         * Explanation
         * This parameter takes effect only when the value of ConsistLevel is Global or Session.
         */
        consistTimeout: number;
        /**
         * Timeout policy after data synchronization timeout of read-only nodes supports the following two policies:
         * ReturnError: Return SQL error (wait replication complete timeout, please retry).
         * ReadMaster: Send a request to the master node (default).
         * Description
         * This parameter takes effect only when the value of ConsistLevel is Global or Session.
         */
        consistTimeoutAction: string;
        /**
         * Description information for connecting endpoint. The length cannot exceed 200 characters.
         */
        description: string;
        /**
         * Set whether to enable transaction splitting. For detailed introduction to transaction splitting, please refer to transaction splitting. Value range:
         * true: Enabled (default).
         * false: Disabled.
         * Description
         * Only when the value of ReadWriteMode is ReadWrite, is enabling transaction splitting supported.
         */
        distributedTransaction: boolean;
        /**
         * The id of the endpoint.
         */
        endpointId: string;
        /**
         * Connect the endpoint name. The setting rules are as follows:
         * It cannot start with a number or a hyphen (-).
         * It can only contain Chinese characters, letters, numbers, underscores (_), and hyphens (-).
         * The length is 1 to 64 characters.
         */
        endpointName: string;
        /**
         * Connect terminal type. The value is fixed as Custom, indicating a custom terminal.
         */
        endpointType: string;
        /**
         * The id of the endpoint.
         */
        id: string;
        /**
         * The master node accepts read requests. Value range:
         * true: (default) After enabling the master node to accept read functions, non-transactional read requests will be sent to the master node or read-only nodes in a load-balanced mode according to the number of active requests.
         * false: After disabling the master node from accepting read requests, at this time, the master node only accepts transactional read requests, and non-transactional read requests will not be sent to the master node.
         * Description
         * Only when the value of ReadWriteMode is ReadWrite, enabling the master node to accept reads is supported.
         */
        masterAcceptReadRequests: boolean;
        /**
         * Connect the node IDs associated with the endpoint.The filling rules are as follows:
         * When the value of ReadWriteMode is ReadWrite, at least two nodes must be passed in, and the master node must be passed in.
         * When the value of ReadWriteMode is ReadOnly, one or more read-only nodes can be passed in.
         */
        nodeIds: string[];
        /**
         * Endpoint read-write mode. Values:
         * ReadWrite: Read and write terminal.
         * ReadOnly: Read-only terminal (default).
         */
        readWriteMode: string;
    }

    export interface EndpointsEndpointAddress {
        /**
         * Parsing method. Currently, the return value can only be false (Volcengine private network parsing).
         */
        dnsVisibility: boolean;
        /**
         * Instance intranet access domain name.
         */
        domain: string;
        /**
         * The EIP id.
         */
        eipId: string;
        /**
         * IP address.
         */
        ipAddress: string;
        /**
         * Network type:
         * Private: Private network VPC.
         * Public: Public network access.
         */
        networkType: string;
        /**
         * Instance intranet access port.
         */
        port: string;
        /**
         * Subnet ID. The subnet must belong to the selected availability zone.
         * Description
         * A subnet is an IP address block within a private network. All cloud resources in a private network must be deployed within a subnet. The subnet assigns private IP addresses to cloud resources.
         */
        subnetId: string;
    }

    export interface GetAccountsAccount {
        /**
         * The name of the database account. This field supports fuzzy query.
         */
        accountName: string;
        /**
         * The privilege detail list of RDS mysql instance account.
         */
        accountPrivileges: outputs.vedb_mysql.GetAccountsAccountAccountPrivilege[];
        /**
         * The type of the database account.
         */
        accountType: string;
    }

    export interface GetAccountsAccountAccountPrivilege {
        /**
         * The privilege type of the account.
         */
        accountPrivilege: string;
        /**
         * The privilege detail of the account.
         */
        accountPrivilegeDetail: string;
        /**
         * The name of database.
         */
        dbName: string;
    }

    export interface GetAllowlistsAllowList {
        /**
         * The description of the allow list.
         */
        allowListDesc: string;
        /**
         * The id of the allow list.
         */
        allowListId: string;
        /**
         * The total number of IP addresses (or address ranges) in the whitelist.
         */
        allowListIpNum: number;
        /**
         * The name of the allow list.
         */
        allowListName: string;
        /**
         * The type of the allow list.
         */
        allowListType: string;
        /**
         * The IP address or a range of IP addresses in CIDR format.
         */
        allowLists: string[];
        /**
         * The total number of instances bound under the whitelist.
         */
        associatedInstanceNum: number;
        /**
         * The list of instances.
         */
        associatedInstances: outputs.vedb_mysql.GetAllowlistsAllowListAssociatedInstance[];
    }

    export interface GetAllowlistsAllowListAssociatedInstance {
        /**
         * Instance ID. When an InstanceId is specified, the DescribeAllowLists interface will return the whitelist bound to the specified instance.
         */
        instanceId: string;
        /**
         * The name of the instance.
         */
        instanceName: string;
        /**
         * The id of the vpc.
         */
        vpc: string;
    }

    export interface GetBackupsBackup {
        /**
         * The end time of the backup.
         */
        backupEndTime: string;
        /**
         * The size of the backup file.
         */
        backupFileSize: number;
        /**
         * The id of the backup.
         */
        backupId: string;
        /**
         * Backup method. Currently, only physical backup is supported. The value is Physical.
         */
        backupMethod: string;
        /**
         * Data backup strategy for instances.
         */
        backupPolicies: outputs.vedb_mysql.GetBackupsBackupBackupPolicy[];
        /**
         * The start time of the backup.
         */
        backupStartTime: string;
        /**
         * The status of the backup.
         */
        backupStatus: string;
        /**
         * The type of the backup.
         */
        backupType: string;
        /**
         * The time point of consistent backup, in the format: yyyy-MM-ddTHH:mm:ssZ (UTC time).
         */
        consistentTime: string;
        /**
         * The type of the backup create.
         */
        createType: string;
        /**
         * The id of the backup.
         */
        id: string;
    }

    export interface GetBackupsBackupBackupPolicy {
        /**
         * Data backup retention period, value: 7 to 30 days.
         */
        backupRetentionPeriod: number;
        /**
         * The time for executing the backup task. The interval window is two hours. Format: HH:mmZ-HH:mmZ (UTC time).
         */
        backupTime: string;
        /**
         * Whether to enable continuous backup. The value is fixed as true.
         */
        continueBackup: boolean;
        /**
         * Full backup period. Multiple values are separated by English commas (,). Values:
         * Monday: Monday.
         * Tuesday: Tuesday.
         * Wednesday: Wednesday.
         * Thursday: Thursday.
         * Friday: Friday.
         * Saturday: Saturday.
         * Sunday: Sunday.
         */
        fullBackupPeriod: string;
        /**
         * The id of the instance.
         */
        instanceId: string;
    }

    export interface GetDatabasesDatabase {
        /**
         * Database character set: utf8mb4 (default), utf8, latin1, ascii.
         */
        characterSetName: string;
        databasesPrivileges: outputs.vedb_mysql.GetDatabasesDatabaseDatabasesPrivilege[];
        /**
         * Database name.
         */
        dbName: string;
    }

    export interface GetDatabasesDatabaseDatabasesPrivilege {
        /**
         * Account name that requires authorization.
         */
        accountName: string;
        /**
         * Authorization database privilege types: 
         * ReadWrite: Read and write privilege.
         *  ReadOnly: Read-only privilege.
         *  DDLOnly: Only DDL privilege.
         *  DMLOnly: Only DML privilege.
         *  Custom: Custom privilege.
         */
        accountPrivilege: string;
        /**
         * The specific SQL operation permissions contained in the permission type are separated by English commas (,) between multiple strings.
         *  When used as a request parameter in the CreateDatabase interface, when the AccountPrivilege value is Custom, this parameter is required. Value range (multiple selections allowed): SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, REFERENCES, INDEX, ALTER, CREATE TEMPORARY TABLES, LOCK TABLES, EXECUTE, CREATE VIEW, SHOW VIEW, CREATE ROUTINE, ALTER ROUTINE, EVENT, TRIGGER. When used as a return parameter in the DescribeDatabases interface, regardless of the value of AccountPrivilege, the details of the SQL operation permissions contained in this permission type are returned. For the specific SQL operation permissions contained in each permission type, please refer to the account permission list.
         */
        accountPrivilegeDetail: string;
    }

    export interface GetEndpointsEndpoint {
        /**
         * The address information.
         */
        addresses: outputs.vedb_mysql.GetEndpointsEndpointAddress[];
        /**
         * Set whether newly created read-only nodes will automatically join this connection endpoint. Values:
         * true: Automatically join.
         * false: Do not automatically join (default).
         */
        autoAddNewNodes: boolean;
        /**
         * Consistency level. For detailed introduction of consistency level, please refer to consistency level. Value range:
         * Eventual: eventual consistency.
         * Session: session consistency.
         * Global: global consistency.
         * Description
         * When the value of ReadWriteMode is ReadWrite, the selectable consistency levels are Eventual, Session (default), and Global.
         * When the value of ReadWriteMode is ReadOnly, the consistency level is Eventual by default and cannot be changed.
         */
        consistLevel: string;
        /**
         * When there is a large delay, the timeout period for read-only nodes to synchronize the latest data, in us. The value range is from 1us to 100000000us, and the default value is 10000us.
         * Explanation
         * This parameter takes effect only when the value of ConsistLevel is Global or Session.
         */
        consistTimeout: number;
        /**
         * Timeout policy after data synchronization timeout of read-only nodes supports the following two policies:
         * ReturnError: Return SQL error (wait replication complete timeout, please retry).
         * ReadMaster: Send a request to the master node (default).
         * Description
         * This parameter takes effect only when the value of ConsistLevel is Global or Session.
         */
        consistTimeoutAction: string;
        /**
         * Description information for connecting endpoint. The length cannot exceed 200 characters.
         */
        description: string;
        /**
         * Set whether to enable transaction splitting. For detailed introduction to transaction splitting, please refer to transaction splitting. Value range:
         * true: Enabled (default).
         * false: Disabled.
         * Description
         * Only when the value of ReadWriteMode is ReadWrite, is enabling transaction splitting supported.
         */
        distributedTransaction: boolean;
        /**
         * The id of the endpoint.
         */
        endpointId: string;
        /**
         * Connect the endpoint name. The setting rules are as follows:
         * It cannot start with a number or a hyphen (-).
         * It can only contain Chinese characters, letters, numbers, underscores (_), and hyphens (-).
         * The length is 1 to 64 characters.
         */
        endpointName: string;
        /**
         * Connect terminal type. The value is fixed as Custom, indicating a custom terminal.
         */
        endpointType: string;
        /**
         * The id of the endpoint.
         */
        id: string;
        /**
         * The master node accepts read requests. Value range:
         * true: (default) After enabling the master node to accept read functions, non-transactional read requests will be sent to the master node or read-only nodes in a load-balanced mode according to the number of active requests.
         * false: After disabling the master node from accepting read requests, at this time, the master node only accepts transactional read requests, and non-transactional read requests will not be sent to the master node.
         * Description
         * Only when the value of ReadWriteMode is ReadWrite, enabling the master node to accept reads is supported.
         */
        masterAcceptReadRequests: boolean;
        /**
         * Connect the node IDs associated with the endpoint.The filling rules are as follows:
         * When the value of ReadWriteMode is ReadWrite, at least two nodes must be passed in, and the master node must be passed in.
         * When the value of ReadWriteMode is ReadOnly, one or more read-only nodes can be passed in.
         */
        nodeIds: string[];
        /**
         * Endpoint read-write mode. Values:
         * ReadWrite: Read and write terminal.
         * ReadOnly: Read-only terminal (default).
         */
        readWriteMode: string;
    }

    export interface GetEndpointsEndpointAddress {
        /**
         * Parsing method. Currently, the return value can only be false (Volcengine private network parsing).
         */
        dnsVisibility: boolean;
        /**
         * Instance intranet access domain name.
         */
        domain: string;
        /**
         * The EIP id.
         */
        eipId: string;
        /**
         * IP address.
         */
        ipAddress: string;
        /**
         * Network type:
         * Private: Private network VPC.
         * Public: Public network access.
         */
        networkType: string;
        /**
         * Instance intranet access port.
         */
        port: string;
        /**
         * Subnet ID. The subnet must belong to the selected availability zone.
         * Description
         * A subnet is an IP address block within a private network. All cloud resources in a private network must be deployed within a subnet. The subnet assigns private IP addresses to cloud resources.
         */
        subnetId: string;
    }

    export interface GetInstancesInstance {
        /**
         * Whether auto-renewal is enabled in the prepaid scenario. Values:
         * true: Auto-renewal is enabled.
         * false: Auto-renewal is not enabled.
         */
        autoRenew: boolean;
        /**
         * The billing expiration time in the prepaid scenario, in the format: yyyy-MM-ddTHH:mm:ssZ (UTC time).
         */
        chargeEndTime: string;
        /**
         * The time when billing starts. Format: yyyy-MM-ddTHH:mm:ssZ (UTC time).
         */
        chargeStartTime: string;
        /**
         * Payment status:
         * Normal: Normal.
         * Overdue: In arrears.
         * Shutdown: Shut down.
         */
        chargeStatus: string;
        /**
         * The charge type of the veDB Mysql instance.
         */
        chargeType: string;
        /**
         * The create time of the veDB Mysql instance.
         */
        createTime: string;
        /**
         * The version of the veDB Mysql instance.
         */
        dbEngineVersion: string;
        /**
         * The ID of the veDB Mysql instance.
         */
        id: string;
        /**
         * The id of the veDB Mysql instance.
         */
        instanceId: string;
        /**
         * The name of the veDB Mysql instance.
         */
        instanceName: string;
        /**
         * The status of the veDB Mysql instance.
         */
        instanceStatus: string;
        /**
         * Whether the table name is case sensitive, the default value is 1.
         * Ranges:
         * 0: Table names are stored as fixed and table names are case-sensitive.
         * 1: Table names will be stored in lowercase and table names are not case sensitive.
         */
        lowerCaseTableNames: string;
        /**
         * Detailed information of instance nodes.
         */
        nodes: outputs.vedb_mysql.GetInstancesInstanceNode[];
        /**
         * Expected release time when shut down due to arrears. Format: yyyy-MM-ddTHH:mm:ssZ (UTC time).
         */
        overdueReclaimTime: string;
        /**
         * Overdue shutdown time. Format: yyyy-MM-ddTHH:mm:ssZ (UTC time).
         */
        overdueTime: string;
        /**
         * Total storage capacity in GiB for prepaid services.
         */
        prePaidStorageInGb: number;
        /**
         * The project name of the veDB Mysql instance.
         */
        projectName: string;
        /**
         * The region id.
         */
        regionId: string;
        /**
         * Storage billing type. Values:
         * PostPaid: Pay-as-you-go (postpaid).
         * PrePaid: Monthly/yearly subscription (prepaid).
         */
        storageChargeType: string;
        /**
         * Used storage size, unit: GiB.
         */
        storageUsedGib: number;
        /**
         * The subnet ID of the veDB Mysql instance.
         */
        subnetId: string;
        /**
         * Tags.
         */
        tags: outputs.vedb_mysql.GetInstancesInstanceTag[];
        /**
         * Time zone.
         */
        timeZone: string;
        /**
         * The vpc ID of the veDB Mysql instance.
         */
        vpcId: string;
        /**
         * The available zone of the veDB Mysql instance.
         */
        zoneIds: string;
    }

    export interface GetInstancesInstanceNode {
        /**
         * Memory size, in GiB.
         */
        memory: number;
        /**
         * The id of the node.
         */
        nodeId: string;
        /**
         * Node specification of an instance.
         */
        nodeSpec: string;
        /**
         * Node type. Values:
         * Primary: Primary node.
         * ReadOnly: Read-only node.
         */
        nodeType: string;
        /**
         * CPU size. For example, when the value is 1, it means the CPU size is 1U.
         */
        vCpu: number;
        /**
         * The available zone of the veDB Mysql instance.
         */
        zoneId: string;
    }

    export interface GetInstancesInstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetInstancesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface InstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface InstancesInstance {
        /**
         * Whether auto-renewal is enabled in the prepaid scenario. Values:
         * true: Auto-renewal is enabled.
         * false: Auto-renewal is not enabled.
         */
        autoRenew: boolean;
        /**
         * The billing expiration time in the prepaid scenario, in the format: yyyy-MM-ddTHH:mm:ssZ (UTC time).
         */
        chargeEndTime: string;
        /**
         * The time when billing starts. Format: yyyy-MM-ddTHH:mm:ssZ (UTC time).
         */
        chargeStartTime: string;
        /**
         * Payment status:
         * Normal: Normal.
         * Overdue: In arrears.
         * Shutdown: Shut down.
         */
        chargeStatus: string;
        /**
         * The charge type of the veDB Mysql instance.
         */
        chargeType: string;
        /**
         * The create time of the veDB Mysql instance.
         */
        createTime: string;
        /**
         * The version of the veDB Mysql instance.
         */
        dbEngineVersion: string;
        /**
         * The ID of the veDB Mysql instance.
         */
        id: string;
        /**
         * The id of the veDB Mysql instance.
         */
        instanceId: string;
        /**
         * The name of the veDB Mysql instance.
         */
        instanceName: string;
        /**
         * The status of the veDB Mysql instance.
         */
        instanceStatus: string;
        /**
         * Whether the table name is case sensitive, the default value is 1.
         * Ranges:
         * 0: Table names are stored as fixed and table names are case-sensitive.
         * 1: Table names will be stored in lowercase and table names are not case sensitive.
         */
        lowerCaseTableNames: string;
        /**
         * Detailed information of instance nodes.
         */
        nodes: outputs.vedb_mysql.InstancesInstanceNode[];
        /**
         * Expected release time when shut down due to arrears. Format: yyyy-MM-ddTHH:mm:ssZ (UTC time).
         */
        overdueReclaimTime: string;
        /**
         * Overdue shutdown time. Format: yyyy-MM-ddTHH:mm:ssZ (UTC time).
         */
        overdueTime: string;
        /**
         * Total storage capacity in GiB for prepaid services.
         */
        prePaidStorageInGb: number;
        /**
         * The project name of the veDB Mysql instance.
         */
        projectName: string;
        /**
         * The region id.
         */
        regionId: string;
        /**
         * Storage billing type. Values:
         * PostPaid: Pay-as-you-go (postpaid).
         * PrePaid: Monthly/yearly subscription (prepaid).
         */
        storageChargeType: string;
        /**
         * Used storage size, unit: GiB.
         */
        storageUsedGib: number;
        /**
         * The subnet ID of the veDB Mysql instance.
         */
        subnetId: string;
        /**
         * Tags.
         */
        tags: outputs.vedb_mysql.InstancesInstanceTag[];
        /**
         * Time zone.
         */
        timeZone: string;
        /**
         * The vpc ID of the veDB Mysql instance.
         */
        vpcId: string;
        /**
         * The available zone of the veDB Mysql instance.
         */
        zoneIds: string;
    }

    export interface InstancesInstanceNode {
        /**
         * Memory size, in GiB.
         */
        memory: number;
        /**
         * The id of the node.
         */
        nodeId: string;
        /**
         * Node specification of an instance.
         */
        nodeSpec: string;
        /**
         * Node type. Values:
         * Primary: Primary node.
         * ReadOnly: Read-only node.
         */
        nodeType: string;
        /**
         * CPU size. For example, when the value is 1, it means the CPU size is 1U.
         */
        vCpu: number;
        /**
         * The available zone of the veDB Mysql instance.
         */
        zoneId: string;
    }

    export interface InstancesInstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface InstancesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

}

export namespace veecp {
    export interface AddonsAddon {
        /**
         * The categories of addons, the value is `Storage` or `Network` or `Monitor` or `Scheduler` or `Dns` or `Security` or `Gpu` or `Image`.
         */
        categories?: string[];
        /**
         * The deploy model.
         */
        deployMode: string;
        /**
         * The deploy node types, the value is `Node` or `VirtualNode`. Only effected when deployMode is `Unmanaged`.
         */
        deployNodeTypes: string[];
        /**
         * The name of the addon.
         */
        name: string;
        /**
         * The necessary of addon.
         */
        necessary?: string;
        /**
         * The container network model, the value is `Flannel` or `VpcCniShared`. Flannel: Flannel network model, an independent Underlay container network solution, combined with the global routing capability of VPC, to achieve a high-performance network experience for the cluster. VpcCniShared: VPC-CNI network model, an Underlay container network solution based on the ENI of the private network elastic network card, with high network communication performance.
         */
        podNetworkModes: string[];
        /**
         * The version info of addon.
         */
        versions: outputs.veecp.AddonsAddonVersion[];
    }

    export interface AddonsAddonVersion {
        /**
         * The compatible version list.
         */
        compatibilities: outputs.veecp.AddonsAddonVersionCompatibility[];
        /**
         * The compatible version list.
         */
        compatibleVersions: string[];
        /**
         * The basic version info.
         */
        version: string;
    }

    export interface AddonsAddonVersionCompatibility {
        /**
         * The Kubernetes Version of addon.
         */
        kubernetesVersion: string;
    }

    export interface BatchEdgeMachinesMachine {
        /**
         * The bootstrap script.
         */
        bootstrapScript: string;
        /**
         * The ClusterId of NodePool.
         */
        clusterId: string;
        /**
         * The Condition of Status.
         */
        conditionTypes: string[];
        /**
         * The ClientToken when successfully created.
         */
        createClientToken: string;
        /**
         * The CreateTime of NodePool.
         */
        createTime: string;
        /**
         * Edge node type.
         */
        edgeNodeType: string;
        /**
         * The Id of NodePool.
         */
        id: string;
        /**
         * The Name of NodePool.
         */
        name: string;
        /**
         * The Phase of Status.
         */
        phase: string;
        /**
         * Edge: Edge node pool. If the return value is empty, it is the central node pool.
         */
        profile: string;
        /**
         * The TTL time.
         */
        ttlTime: number;
        /**
         * The UpdateTime time of NodePool.
         */
        updateTime: string;
    }

    export interface BatchEdgeMachinesStatus {
        /**
         * Indicates the status condition of the node pool in the active state. The value can be `Progressing` or `Ok` or `VersionPartlyUpgraded` or `StockOut` or `LimitedByQuota` or `Balance` or `Degraded` or `ClusterVersionUpgrading` or `Cluster` or `ResourceCleanupFailed` or `Unknown` or `ClusterNotRunning` or `SetByProvider`.
         */
        edgeNodeStatusConditionType?: string;
        /**
         * The Phase of Status. The value can be `Creating` or `Running` or `Updating` or `Deleting` or `Failed` or `Scaling`.
         */
        phase?: string;
    }

    export interface ClusterClusterConfig {
        /**
         * Cluster API Server public network access configuration information. It takes effect only when ApiServerPublicAccessEnabled=true.
         */
        apiServerPublicAccessConfig?: outputs.veecp.ClusterClusterConfigApiServerPublicAccessConfig;
        /**
         * Cluster API Server public network access configuration, values:
         * false: (default value). closed
         * true: opened.
         */
        apiServerPublicAccessEnabled?: boolean;
        /**
         * Node public network access configuration, values:
         * false: (default value). Do not enable public network access. Existing NAT gateways and rules are not affected. true: Enable public network access. After enabling, a NAT gateway is automatically created for the cluster's private network and corresponding rules are configured. Note: This parameter cannot be modified after the cluster is created. Please configure it reasonably.
         */
        resourcePublicAccessDefaultEnabled?: boolean;
        /**
         * The subnet ID for communication within the private network (VPC) of the cluster control plane. You can call the private network API to obtain the subnet ID. Note: When creating a cluster, please ensure that all specified SubnetIds (including but not limited to this parameter) belong to the same private network. It is recommended that you choose subnets in different availability zones as much as possible to improve the high availability of the cluster control plane. Please note that this parameter is not supported to be modified after the cluster is created. Please configure it reasonably.
         */
        subnetIds: string[];
    }

    export interface ClusterClusterConfigApiServerPublicAccessConfig {
        /**
         * Public network access network configuration.
         */
        publicAccessNetworkConfig?: outputs.veecp.ClusterClusterConfigApiServerPublicAccessConfigPublicAccessNetworkConfig;
    }

    export interface ClusterClusterConfigApiServerPublicAccessConfigPublicAccessNetworkConfig {
        /**
         * The peak bandwidth of the public IP, unit: Mbps.
         */
        bandwidth?: number;
        /**
         * Billing type of public IP, the value is `PostPaidByBandwidth` or `PostPaidByTraffic`.
         */
        billingType?: string;
    }

    export interface ClusterLoggingConfig {
        /**
         * The TLS log item ID of the collection target.
         */
        logProjectId: string;
        /**
         * Cluster logging options. This structure can only be modified and added, and cannot be deleted. When encountering a `cannot be deleted` error, please query the log setups of the current cluster and fill in the current `tf` file.
         */
        logSetups?: outputs.veecp.ClusterLoggingConfigLogSetup[];
    }

    export interface ClusterLoggingConfigLogSetup {
        /**
         * Whether to enable the log option, true means enable, false means not enable, the default is false. When Enabled is changed from false to true, a new Topic will be created.
         */
        enabled?: boolean;
        /**
         * The storage time of logs in Log Service. After the specified log storage time is exceeded, the expired logs in this log topic will be automatically cleared. The unit is days, and the default is 30 days. The value range is 1 to 3650, specifying 3650 days means permanent storage.
         */
        logTtl?: number;
        /**
         * The current types of logs that can be enabled are:
         * Audit: Cluster audit logs.
         * KubeApiServer: kube-apiserver component logs.
         * KubeScheduler: kube-scheduler component logs.
         * KubeControllerManager: kube-controller-manager component logs.
         */
        logType: string;
    }

    export interface ClusterPodsConfig {
        /**
         * Flannel network configuration. It can be configured only when PodNetworkMode=Flannel, but it is not mandatory.
         */
        flannelConfig?: outputs.veecp.ClusterPodsConfigFlannelConfig;
        /**
         * Container network model, values: Flannel: Flannel network model, an independent Underlay container network solution. Combined with the global routing capability of a private network (VPC), it realizes a high-performance network experience for the cluster. VpcCniShared: VPC-CNI network model, an Underlay container network solution implemented based on the elastic network interface (ENI) of a private network, with high network communication performance. Description: After the cluster is created, this parameter is not supported to be modified temporarily. Please configure it reasonably.
         */
        podNetworkMode: string;
        /**
         * VPC-CNI network configuration. PodNetworkMode=VpcCniShared, but it is not mandatory.
         */
        vpcCniConfig?: outputs.veecp.ClusterPodsConfigVpcCniConfig;
    }

    export interface ClusterPodsConfigFlannelConfig {
        /**
         * Upper limit of the number of single-node Pod instances in the Flannel model container network. Values: 64(default value), 16, 32, 128, 256.
         */
        maxPodsPerNode?: number;
        /**
         * Pod CIDR of Flannel model container network. Only configurable when PodNetworkMode=Flannel, but not mandatory. Note: The number of Pods in the cluster is limited by the number of IPs in this CIDR. This parameter cannot be modified after cluster creation. Please plan the Pod CIDR reasonably. Cannot conflict with the following network segments: private network network segments corresponding to ClusterConfig.SubnetIds. All clusters within the same private network's FlannelConfig.PodCidrs. All clusters within the same private network's ServiceConfig.ServiceCidrsv4. Different clusters within the same private network's FlannelConfig.PodCidrs cannot conflict.
         */
        podCidrs: string[];
    }

    export interface ClusterPodsConfigVpcCniConfig {
        /**
         * A list of Pod subnet IDs for the VPC-CNI container network.
         */
        subnetIds: string[];
    }

    export interface ClusterServicesConfig {
        /**
         * CIDR used by services within the cluster. It cannot conflict with the following network segments: FlannelConfig.PodCidrs. SubnetIds of all clusters within the same private network or FlannelConfig.VpcConfig.SubnetIds. ServiceConfig.ServiceCidrsv4 of all clusters within the same private network (this parameter).It is stated that currently only one array element is supported. When multiple values are specified, only the first value takes effect.
         */
        serviceCidrsv4s: string[];
    }

    export interface ClustersCluster {
        /**
         * The config of the cluster.
         */
        clusterConfig: outputs.veecp.ClustersClusterClusterConfig;
        /**
         * ClientToken when the cluster is created successfully. ClientToken is a string that guarantees the idempotency of the request. This string is passed in by the caller.
         */
        createClientToken: string;
        /**
         * Cluster creation time. UTC+0 time in standard RFC3339 format.
         */
        createTime: string;
        /**
         * Cluster deletion protection. Values: true: Enable deletion protection. false: Disable deletion protection.
         */
        deleteProtectionEnabled: boolean;
        /**
         * Cluster description information.
         */
        description: string;
        /**
         * The ID of the cluster.
         */
        id: string;
        /**
         * Kubernetes version information corresponding to the cluster, specific to the patch version.
         */
        kubernetesVersion: string;
        /**
         * Cluster log configuration information.
         */
        loggingConfigs: outputs.veecp.ClustersClusterLoggingConfig[];
        /**
         * Cluster name.
         */
        name: string;
        /**
         * Statistics on the number of nodes corresponding to each master state in the cluster.
         */
        nodeStatistics: outputs.veecp.ClustersClusterNodeStatistics;
        /**
         * The config of the pods.
         */
        podsConfig: outputs.veecp.ClustersClusterPodsConfig;
        /**
         * The config of the services.
         */
        servicesConfig: outputs.veecp.ClustersClusterServicesConfig;
        /**
         * Cluster status. For detailed instructions, please refer to ClusterStatusResponse.
         */
        statuses: outputs.veecp.ClustersClusterStatus[];
        /**
         * The ClientToken when the last cluster update succeeded. ClientToken is a string that guarantees the idempotency of the request. This string is passed in by the caller.
         */
        updateClientToken: string;
        /**
         * The time when the cluster last accepted a request and executed or completed execution. UTC+0 time in standard RFC3339 format.
         */
        updateTime: string;
    }

    export interface ClustersClusterClusterConfig {
        /**
         * Endpoint information accessed by the cluster API Server.
         */
        apiServerEndpoints: outputs.veecp.ClustersClusterClusterConfigApiServerEndpoints;
        /**
         * Cluster API Server public network access configuration.
         */
        apiServerPublicAccessConfig: outputs.veecp.ClustersClusterClusterConfigApiServerPublicAccessConfig;
        /**
         * Cluster API Server public network access configuration, the value is `true` or `false`.
         */
        apiServerPublicAccessEnabled: boolean;
        /**
         * Node public network access configuration, the value is `true` or `false`.
         */
        resourcePublicAccessDefaultEnabled: boolean;
        /**
         * The security group used by the cluster control plane and nodes.
         */
        securityGroupIds: string[];
        /**
         * A list of Pod subnet IDs for the VPC-CNI container network.
         */
        subnetIds: string[];
        /**
         * The private network where the cluster control plane network resides.
         */
        vpcId: string;
    }

    export interface ClustersClusterClusterConfigApiServerEndpoints {
        /**
         * Endpoint address of the cluster API Server private network.
         */
        privateIp: outputs.veecp.ClustersClusterClusterConfigApiServerEndpointsPrivateIp;
        /**
         * Endpoint address of the cluster API Server public network.
         */
        publicIp: outputs.veecp.ClustersClusterClusterConfigApiServerEndpointsPublicIp;
    }

    export interface ClustersClusterClusterConfigApiServerEndpointsPrivateIp {
        /**
         * Ipv4 address.
         */
        ipv4: string;
    }

    export interface ClustersClusterClusterConfigApiServerEndpointsPublicIp {
        /**
         * Ipv4 address.
         */
        ipv4: string;
    }

    export interface ClustersClusterClusterConfigApiServerPublicAccessConfig {
        /**
         * IPv4 public network access whitelist. A null value means all network segments (0.0.0.0/0) are allowed to pass.
         */
        accessSourceIpsv4s: string[];
        /**
         * [SkipDoc]The IpFamily configuration,the value is `Ipv4` or `DualStack`.
         */
        ipFamily: string;
        /**
         * Public network access network configuration.
         */
        publicAccessNetworkConfig: outputs.veecp.ClustersClusterClusterConfigApiServerPublicAccessConfigPublicAccessNetworkConfig;
    }

    export interface ClustersClusterClusterConfigApiServerPublicAccessConfigPublicAccessNetworkConfig {
        /**
         * The peak bandwidth of the public IP, unit: Mbps.
         */
        bandwidth: number;
        /**
         * Billing type of public IP, the value is `PostPaidByBandwidth` or `PostPaidByTraffic`.
         */
        billingType: string;
        /**
         * The ISP of public IP.
         */
        isp: string;
    }

    export interface ClustersClusterLoggingConfig {
        /**
         * The TLS log item ID of the collection target.
         */
        logProjectId: string;
        /**
         * Cluster logging options.
         */
        logSetups: outputs.veecp.ClustersClusterLoggingConfigLogSetup[];
    }

    export interface ClustersClusterLoggingConfigLogSetup {
        /**
         * Whether to enable the log option, true means enable, false means not enable, the default is false. When Enabled is changed from false to true, a new Topic will be created.
         */
        enabled: boolean;
        /**
         * The storage time of logs in Log Service. After the specified log storage time is exceeded, the expired logs in this log topic will be automatically cleared. The unit is days, and the default is 30 days. The value range is 1 to 3650, specifying 3650 days means permanent storage.
         */
        logTtl: number;
        /**
         * The currently enabled log type.
         */
        logType: string;
    }

    export interface ClustersClusterNodeStatistics {
        /**
         * Phase=Creating total number of nodes.
         */
        creatingCount: number;
        /**
         * Phase=Deleting total number of nodes.
         */
        deletingCount: number;
        /**
         * Phase=Failed total number of nodes.
         */
        failedCount: number;
        /**
         * Phase=Running total number of nodes.
         */
        runningCount: number;
        /**
         * Phase=Starting total number of nodes.
         */
        startingCount: number;
        /**
         * (**Deprecated**) This field has been deprecated and is not recommended for use. Phase=Stopped total number of nodes.
         *
         * @deprecated This field has been deprecated and is not recommended for use.
         */
        stoppedCount: number;
        /**
         * Phase=Stopping total number of nodes.
         */
        stoppingCount: number;
        /**
         * The total count of query.
         */
        totalCount: number;
        /**
         * Phase=Updating total number of nodes.
         */
        updatingCount: number;
    }

    export interface ClustersClusterPodsConfig {
        /**
         * Flannel network configuration.
         */
        flannelConfig: outputs.veecp.ClustersClusterPodsConfigFlannelConfig;
        /**
         * Container Pod Network Type (CNI), the value is `Flannel` or `VpcCniShared`.
         */
        podNetworkMode: string;
        /**
         * VPC-CNI network configuration.
         */
        vpcCniConfig: outputs.veecp.ClustersClusterPodsConfigVpcCniConfig;
    }

    export interface ClustersClusterPodsConfigFlannelConfig {
        /**
         * The maximum number of single-node Pod instances for a Flannel container network.
         */
        maxPodsPerNode: number;
        /**
         * Pod CIDR for the Flannel container network.
         */
        podCidrs: string[];
    }

    export interface ClustersClusterPodsConfigVpcCniConfig {
        /**
         * A list of Pod subnet IDs for the VPC-CNI container network.
         */
        subnetIds: string[];
        /**
         * The private network where the cluster control plane network resides.
         */
        vpcId: string;
    }

    export interface ClustersClusterServicesConfig {
        /**
         * The IPv4 private network address exposed by the service.
         */
        serviceCidrsv4s: string[];
    }

    export interface ClustersClusterStatus {
        /**
         * The state condition in the current primary state of the cluster, that is, the reason for entering the primary state.
         */
        conditions: outputs.veecp.ClustersClusterStatusCondition[];
        /**
         * Cluster status. The value contains `Creating`, `Running`, `Updating`, `Deleting`, `Failed`.
         */
        phase: string;
    }

    export interface ClustersClusterStatusCondition {
        /**
         * The state condition in the current main state of the cluster, that is, the reason for entering the main state, there can be multiple reasons, the value contains `Progressing`, `Ok`, `Balance`, `CreateError`, `ResourceCleanupFailed`, `Unknown`.
         */
        type: string;
    }

    export interface ClustersStatus {
        /**
         * The state condition in the current main state of the cluster, that is, the reason for entering the main state, there can be multiple reasons, the value contains `Progressing`, `Ok`, `Degraded`, `SetByProvider`, `Balance`, `Security`, `CreateError`, `ResourceCleanupFailed`, `LimitedByQuota`, `StockOut`,`Unknown`.
         */
        conditionsType?: string;
        /**
         * The status of cluster. the value contains `Creating`, `Running`, `Updating`, `Deleting`, `Stopped`, `Failed`.
         */
        phase?: string;
    }

    export interface EdgeNodeAutoCompleteConfig {
        /**
         * The address of the machine to be managed.
         */
        address?: string;
        /**
         * Directly managed through the edge computing instance ID. When it is true, there is no need to provide Address. Only DirectAddInstances needs to be provided.
         */
        directAdd?: boolean;
        /**
         * Edge computing instance ID on Volcano Engine.
         */
        directAddInstances?: outputs.veecp.EdgeNodeAutoCompleteConfigDirectAddInstance[];
        /**
         * Enable/Disable automatic management.
         */
        enable: boolean;
        /**
         * Login credentials.
         */
        machineAuth?: outputs.veecp.EdgeNodeAutoCompleteConfigMachineAuth;
    }

    export interface EdgeNodeAutoCompleteConfigDirectAddInstance {
        /**
         * Edge service ID.
         */
        cloudServerIdentity: string;
        /**
         * Edge computing instance ID.
         */
        instanceIdentity: string;
    }

    export interface EdgeNodeAutoCompleteConfigMachineAuth {
        /**
         * Authentication method. Currently only Password is open.
         */
        authType: string;
        /**
         * SSH port, default 22.
         */
        sshPort: number;
        /**
         * Login username.
         */
        user: string;
    }

    export interface EdgeNodePoolBillingConfigs {
        /**
         * Whether to automatically renew the node pool.
         */
        autoRenew?: boolean;
        /**
         * The pre-paid period of the node pool, in months. The value range is 1-9. This parameter takes effect only when the billingType is PrePaid.
         */
        prePaidPeriod: number;
        /**
         * Prepaid period number.
         */
        prePaidPeriodNumber: number;
    }

    export interface EdgeNodePoolElasticConfig {
        /**
         * The node pool elastic scaling configuration information.
         */
        autoScaleConfig: outputs.veecp.EdgeNodePoolElasticConfigAutoScaleConfig;
        /**
         * The ID of the edge service corresponding to the elastic node. On the edge computing node's edge service page, obtain the edge service ID.
         */
        cloudServerIdentity: string;
        instanceArea: outputs.veecp.EdgeNodePoolElasticConfigInstanceArea;
    }

    export interface EdgeNodePoolElasticConfigAutoScaleConfig {
        /**
         * The DesiredReplicas of AutoScaling, default 0, range in minReplicas to max_replicas.
         */
        desiredReplicas: number;
        /**
         * Whether to enable the auto scaling function of the node pool. When a node needs to be manually added to the node pool, the value of this field must be `false`.
         */
        enabled: boolean;
        /**
         * The MaxReplicas of AutoScaling, default 10, range in 1~2000. This field is valid when the value of `enabled` is `true`.
         */
        maxReplicas: number;
        /**
         * The MinReplicas of AutoScaling, default 0. This field is valid when the value of `enabled` is `true`.
         */
        minReplicas: number;
        /**
         * The Priority of AutoScaling, default 10, rang in 0~100. This field is valid when the value of `enabled` is `true` and the value of `subnetPolicy` is `Priority`.
         */
        priority: number;
    }

    export interface EdgeNodePoolElasticConfigInstanceArea {
        /**
         * Region name. You can obtain the regions and operators supported by instance specifications through the ListAvailableResourceInfo interface.
         */
        areaName: string;
        /**
         * The cluster name.
         */
        clusterName: string;
        /**
         * Default operator. When using three-line nodes, this parameter can be configured. After configuration, this operator will be used as the default export.
         */
        defaultIsp: string;
        /**
         * Public network configuration of three-line nodes. If it is a single-line node, this parameter will be ignored. Value range: single_interface_multi_ip: Single network card with multiple IPs. single_interface_cmcc_ip: Single network card with China Mobile IP. Relevant permissions need to be opened by submitting a work order. single_interface_cucc_ip: Single network card with China Unicom IP. Relevant permissions need to be opened by submitting a work order. single_interface_ctcc_ip: Single network card with China Telecom IP. Relevant permissions need to be opened by submitting a work order. multi_interface_multi_ip: Multiple network cards with multiple IPs. Relevant permissions need to be opened by submitting a work order. no_interface: No public network network card. Relevant permissions need to be opened by submitting a work order. If this parameter is not configured: When there is a public network network card, singleInterfaceMultiIp is used by default. When there is no public network network card, noInterface is used by default.
         */
        externalNetworkMode: string;
        /**
         * Operator. You can obtain the regions and operators supported by instance specifications through the ListAvailableResourceInfo interface.
         */
        isp: string;
        /**
         * The subnet id.
         */
        subnetId?: string;
        /**
         * The vpc id.
         */
        vpcIdentity: string;
    }

    export interface EdgeNodePoolKubernetesConfig {
        /**
         * The Labels of KubernetesConfig.
         */
        labels?: outputs.veecp.EdgeNodePoolKubernetesConfigLabel[];
        /**
         * The Taints of KubernetesConfig.
         */
        taints?: outputs.veecp.EdgeNodePoolKubernetesConfigTaint[];
    }

    export interface EdgeNodePoolKubernetesConfigLabel {
        /**
         * The Key of Labels.
         */
        key?: string;
        /**
         * The Value of Labels.
         */
        value?: string;
    }

    export interface EdgeNodePoolKubernetesConfigTaint {
        /**
         * The Effect of Taints, the value can be `NoSchedule` or `NoExecute` or `PreferNoSchedule`.
         */
        effect?: string;
        /**
         * The Key of Taints.
         */
        key?: string;
        /**
         * The Value of Taints.
         */
        value?: string;
    }

    export interface EdgeNodePoolsNodePool {
        /**
         * The billing configuration.
         */
        billingConfigs: outputs.veecp.EdgeNodePoolsNodePoolBillingConfig[];
        /**
         * The ClusterId of NodePool.
         */
        clusterId: string;
        /**
         * The Condition of Status.
         */
        conditionTypes: string[];
        /**
         * The ClientToken when successfully created.
         */
        createClientToken: string;
        /**
         * The CreateTime of NodePool.
         */
        createTime: string;
        /**
         * Elastic scaling configuration of node pool.
         */
        elasticConfigs: outputs.veecp.EdgeNodePoolsNodePoolElasticConfig[];
        /**
         * The Id of NodePool.
         */
        id: string;
        /**
         * The LabelContent of KubernetesConfig.
         */
        labelContents: outputs.veecp.EdgeNodePoolsNodePoolLabelContent[];
        /**
         * The Name of NodePool.
         */
        name: string;
        /**
         * The method of adding nodes to the node pool.
         */
        nodeAddMethods: string[];
        /**
         * The NodeStatistics of NodeConfig.
         */
        nodeStatistics: outputs.veecp.EdgeNodePoolsNodePoolNodeStatistic[];
        /**
         * The Phase of Status.
         */
        phase: string;
        /**
         * Edge: Edge node pool. If the return value is empty, it is the central node pool.
         */
        profile: string;
        /**
         * The TaintContent of NodeConfig.
         */
        taintContents: outputs.veecp.EdgeNodePoolsNodePoolTaintContent[];
        /**
         * Node pool type, machine-set: central node pool. edge-machine-set: edge node pool. edge-machine-pool: edge elastic node pool.
         */
        type: string;
        /**
         * The ClientToken when last update was successful.
         */
        updateClientToken: string;
        /**
         * The UpdateTime time of NodePool.
         */
        updateTime: string;
        /**
         * The static node pool specifies the node pool to associate with the VPC.
         */
        vpcId: string;
    }

    export interface EdgeNodePoolsNodePoolBillingConfig {
        /**
         * Whether to automatically renew the node pool.
         */
        autoRenew: boolean;
        /**
         * The pre-paid period of the node pool, in months. The value range is 1-9. This parameter takes effect only when the billingType is PrePaid.
         */
        prePaidPeriod: number;
        /**
         * Prepaid period number.
         */
        prePaidPeriodNumber: number;
    }

    export interface EdgeNodePoolsNodePoolElasticConfig {
        /**
         * The auto scaling configuration.
         */
        autoScaleConfigs: outputs.veecp.EdgeNodePoolsNodePoolElasticConfigAutoScaleConfig[];
        /**
         * Cloud server identity.
         */
        cloudServerIdentity: string;
        /**
         * The information of instance area.
         */
        instanceAreas: outputs.veecp.EdgeNodePoolsNodePoolElasticConfigInstanceArea[];
    }

    export interface EdgeNodePoolsNodePoolElasticConfigAutoScaleConfig {
        /**
         * The DesiredReplicas of AutoScaling.
         */
        desiredReplicas: number;
        /**
         * Whether to enable auto scaling.
         */
        enabled: boolean;
        /**
         * The maximum number of nodes.
         */
        maxReplicas: number;
        /**
         * The minimum number of nodes.
         */
        minReplicas: number;
        /**
         * The Priority of AutoScaling.
         */
        priority: number;
    }

    export interface EdgeNodePoolsNodePoolElasticConfigInstanceArea {
        /**
         * Region name. You can obtain the regions and operators supported by instance specifications through the ListAvailableResourceInfo interface.
         */
        areaName: string;
        /**
         * Cluster name.
         */
        clusterName: string;
        /**
         * Default operator. When using three-line nodes, this parameter can be configured. After configuration, this operator will be used as the default export.
         */
        defaultIsp: string;
        /**
         * Public network configuration of three-line nodes. If it is a single-line node, this parameter will be ignored. Value range: single_interface_multi_ip: Single network card with multiple IPs. single_interface_cmcc_ip: Single network card with China Mobile IP. Relevant permissions need to be opened by submitting a work order. single_interface_cucc_ip: Single network card with China Unicom IP. Relevant permissions need to be opened by submitting a work order. single_interface_ctcc_ip: Single network card with China Telecom IP. Relevant permissions need to be opened by submitting a work order. multi_interface_multi_ip: Multiple network cards with multiple IPs. Relevant permissions need to be opened by submitting a work order. no_interface: No public network network card. Relevant permissions need to be opened by submitting a work order. If this parameter is not configured: When there is a public network network card, singleInterfaceMultiIp is used by default. When there is no public network network card, noInterface is used by default.
         */
        externalNetworkMode: string;
        /**
         * Operator. You can obtain the regions and operators supported by the instance specification through the ListAvailableResourceInfo interface.
         */
        isp: string;
        /**
         * Subnet ID.
         */
        subnetIdentity: string;
        /**
         * VPC ID.
         */
        vpcIdentity: string;
    }

    export interface EdgeNodePoolsNodePoolLabelContent {
        /**
         * The Key of Taint.
         */
        key: string;
        /**
         * The Value of Taint.
         */
        value: string;
    }

    export interface EdgeNodePoolsNodePoolNodeStatistic {
        /**
         * The CreatingCount of Node.
         */
        creatingCount: number;
        /**
         * The DeletingCount of Node.
         */
        deletingCount: number;
        /**
         * The FailedCount of Node.
         */
        failedCount: number;
        /**
         * The RunningCount of Node.
         */
        runningCount: number;
        /**
         * (**Deprecated**) This field has been deprecated and is not recommended for use. The StartingCount of Node.
         *
         * @deprecated This field has been deprecated and is not recommended for use.
         */
        startingCount: number;
        /**
         * (**Deprecated**) This field has been deprecated and is not recommended for use. The StoppedCount of Node.
         *
         * @deprecated This field has been deprecated and is not recommended for use.
         */
        stoppedCount: number;
        /**
         * (**Deprecated**) This field has been deprecated and is not recommended for use. The StoppingCount of Node.
         *
         * @deprecated This field has been deprecated and is not recommended for use.
         */
        stoppingCount: number;
        /**
         * The total count of query.
         */
        totalCount: number;
        /**
         * The UpdatingCount of Node.
         */
        updatingCount: number;
    }

    export interface EdgeNodePoolsNodePoolTaintContent {
        /**
         * The Effect of Taint.
         */
        effect: string;
        /**
         * The Key of Taint.
         */
        key: string;
        /**
         * The Value of Taint.
         */
        value: string;
    }

    export interface EdgeNodePoolsStatus {
        /**
         * Indicates the status condition of the node pool in the active state. The value can be `Progressing` or `Ok` or `VersionPartlyUpgraded` or `StockOut` or `LimitedByQuota` or `Balance` or `Degraded` or `ClusterVersionUpgrading` or `Cluster` or `ResourceCleanupFailed` or `Unknown` or `ClusterNotRunning` or `SetByProvider`.
         */
        conditionsType?: string;
        /**
         * The Phase of Status. The value can be `Creating` or `Running` or `Updating` or `Deleting` or `Failed` or `Scaling`.
         */
        phase?: string;
    }

    export interface EdgeNodesNode {
        /**
         * The bootstrap script of node.
         */
        bootstrapScript: string;
        /**
         * The cluster id of node.
         */
        clusterId: string;
        /**
         * The Condition of Node.
         */
        conditionTypes: string[];
        /**
         * The Create Client Token.
         */
        createClientToken: string;
        /**
         * The create time of Node.
         */
        createTime: string;
        /**
         * The edge node type of node.
         */
        edgeNodeType: string;
        /**
         * The ID of Node.
         */
        id: string;
        /**
         * The instance id of node.
         */
        instanceId: string;
        /**
         * The Name of Node.
         */
        name: string;
        /**
         * The node pool id.
         */
        nodePoolId: string;
        /**
         * The Phase of Node.
         */
        phase: string;
        /**
         * The profile of node. Distinguish between edge and central nodes.
         */
        profile: string;
        /**
         * The provider id of node.
         */
        providerId: string;
        /**
         * The update time of Node.
         */
        updateTime: string;
    }

    export interface EdgeNodesStatus {
        /**
         * The Type of Node Condition, the value is `Progressing` or `Ok` or `Unschedulable` or `InitilizeFailed` or `Unknown` or `NotReady` or `Security` or `Balance` or `ResourceCleanupFailed`.
         */
        edgeNodeStatusConditionType?: string;
        /**
         * The Phase of Node, the value is `Creating` or `Running` or `Updating` or `Deleting` or `Failed` or `Starting` or `Stopping` or `Stopped`.
         */
        phase?: string;
    }

    export interface GetAddonsAddon {
        /**
         * The categories of addons, the value is `Storage` or `Network` or `Monitor` or `Scheduler` or `Dns` or `Security` or `Gpu` or `Image`.
         */
        categories?: string[];
        /**
         * The deploy model.
         */
        deployMode: string;
        /**
         * The deploy node types, the value is `Node` or `VirtualNode`. Only effected when deployMode is `Unmanaged`.
         */
        deployNodeTypes: string[];
        /**
         * The name of the addon.
         */
        name: string;
        /**
         * The necessary of addon.
         */
        necessary?: string;
        /**
         * The container network model, the value is `Flannel` or `VpcCniShared`. Flannel: Flannel network model, an independent Underlay container network solution, combined with the global routing capability of VPC, to achieve a high-performance network experience for the cluster. VpcCniShared: VPC-CNI network model, an Underlay container network solution based on the ENI of the private network elastic network card, with high network communication performance.
         */
        podNetworkModes: string[];
        /**
         * The version info of addon.
         */
        versions: outputs.veecp.GetAddonsAddonVersion[];
    }

    export interface GetAddonsAddonVersion {
        /**
         * The compatible version list.
         */
        compatibilities: outputs.veecp.GetAddonsAddonVersionCompatibility[];
        /**
         * The compatible version list.
         */
        compatibleVersions: string[];
        /**
         * The basic version info.
         */
        version: string;
    }

    export interface GetAddonsAddonVersionCompatibility {
        /**
         * The Kubernetes Version of addon.
         */
        kubernetesVersion: string;
    }

    export interface GetBatchEdgeMachinesMachine {
        /**
         * The bootstrap script.
         */
        bootstrapScript: string;
        /**
         * The ClusterId of NodePool.
         */
        clusterId: string;
        /**
         * The Condition of Status.
         */
        conditionTypes: string[];
        /**
         * The ClientToken when successfully created.
         */
        createClientToken: string;
        /**
         * The CreateTime of NodePool.
         */
        createTime: string;
        /**
         * Edge node type.
         */
        edgeNodeType: string;
        /**
         * The Id of NodePool.
         */
        id: string;
        /**
         * The Name of NodePool.
         */
        name: string;
        /**
         * The Phase of Status.
         */
        phase: string;
        /**
         * Edge: Edge node pool. If the return value is empty, it is the central node pool.
         */
        profile: string;
        /**
         * The TTL time.
         */
        ttlTime: number;
        /**
         * The UpdateTime time of NodePool.
         */
        updateTime: string;
    }

    export interface GetBatchEdgeMachinesStatus {
        /**
         * Indicates the status condition of the node pool in the active state. The value can be `Progressing` or `Ok` or `VersionPartlyUpgraded` or `StockOut` or `LimitedByQuota` or `Balance` or `Degraded` or `ClusterVersionUpgrading` or `Cluster` or `ResourceCleanupFailed` or `Unknown` or `ClusterNotRunning` or `SetByProvider`.
         */
        edgeNodeStatusConditionType?: string;
        /**
         * The Phase of Status. The value can be `Creating` or `Running` or `Updating` or `Deleting` or `Failed` or `Scaling`.
         */
        phase?: string;
    }

    export interface GetClustersCluster {
        /**
         * The config of the cluster.
         */
        clusterConfig: outputs.veecp.GetClustersClusterClusterConfig;
        /**
         * ClientToken when the cluster is created successfully. ClientToken is a string that guarantees the idempotency of the request. This string is passed in by the caller.
         */
        createClientToken: string;
        /**
         * Cluster creation time. UTC+0 time in standard RFC3339 format.
         */
        createTime: string;
        /**
         * Cluster deletion protection. Values: true: Enable deletion protection. false: Disable deletion protection.
         */
        deleteProtectionEnabled: boolean;
        /**
         * Cluster description information.
         */
        description: string;
        /**
         * The ID of the cluster.
         */
        id: string;
        /**
         * Kubernetes version information corresponding to the cluster, specific to the patch version.
         */
        kubernetesVersion: string;
        /**
         * Cluster log configuration information.
         */
        loggingConfigs: outputs.veecp.GetClustersClusterLoggingConfig[];
        /**
         * Cluster name.
         */
        name: string;
        /**
         * Statistics on the number of nodes corresponding to each master state in the cluster.
         */
        nodeStatistics: outputs.veecp.GetClustersClusterNodeStatistics;
        /**
         * The config of the pods.
         */
        podsConfig: outputs.veecp.GetClustersClusterPodsConfig;
        /**
         * The config of the services.
         */
        servicesConfig: outputs.veecp.GetClustersClusterServicesConfig;
        /**
         * Cluster status. For detailed instructions, please refer to ClusterStatusResponse.
         */
        statuses: outputs.veecp.GetClustersClusterStatus[];
        /**
         * The ClientToken when the last cluster update succeeded. ClientToken is a string that guarantees the idempotency of the request. This string is passed in by the caller.
         */
        updateClientToken: string;
        /**
         * The time when the cluster last accepted a request and executed or completed execution. UTC+0 time in standard RFC3339 format.
         */
        updateTime: string;
    }

    export interface GetClustersClusterClusterConfig {
        /**
         * Endpoint information accessed by the cluster API Server.
         */
        apiServerEndpoints: outputs.veecp.GetClustersClusterClusterConfigApiServerEndpoints;
        /**
         * Cluster API Server public network access configuration.
         */
        apiServerPublicAccessConfig: outputs.veecp.GetClustersClusterClusterConfigApiServerPublicAccessConfig;
        /**
         * Cluster API Server public network access configuration, the value is `true` or `false`.
         */
        apiServerPublicAccessEnabled: boolean;
        /**
         * Node public network access configuration, the value is `true` or `false`.
         */
        resourcePublicAccessDefaultEnabled: boolean;
        /**
         * The security group used by the cluster control plane and nodes.
         */
        securityGroupIds: string[];
        /**
         * A list of Pod subnet IDs for the VPC-CNI container network.
         */
        subnetIds: string[];
        /**
         * The private network where the cluster control plane network resides.
         */
        vpcId: string;
    }

    export interface GetClustersClusterClusterConfigApiServerEndpoints {
        /**
         * Endpoint address of the cluster API Server private network.
         */
        privateIp: outputs.veecp.GetClustersClusterClusterConfigApiServerEndpointsPrivateIp;
        /**
         * Endpoint address of the cluster API Server public network.
         */
        publicIp: outputs.veecp.GetClustersClusterClusterConfigApiServerEndpointsPublicIp;
    }

    export interface GetClustersClusterClusterConfigApiServerEndpointsPrivateIp {
        /**
         * Ipv4 address.
         */
        ipv4: string;
    }

    export interface GetClustersClusterClusterConfigApiServerEndpointsPublicIp {
        /**
         * Ipv4 address.
         */
        ipv4: string;
    }

    export interface GetClustersClusterClusterConfigApiServerPublicAccessConfig {
        /**
         * IPv4 public network access whitelist. A null value means all network segments (0.0.0.0/0) are allowed to pass.
         */
        accessSourceIpsv4s: string[];
        /**
         * [SkipDoc]The IpFamily configuration,the value is `Ipv4` or `DualStack`.
         */
        ipFamily: string;
        /**
         * Public network access network configuration.
         */
        publicAccessNetworkConfig: outputs.veecp.GetClustersClusterClusterConfigApiServerPublicAccessConfigPublicAccessNetworkConfig;
    }

    export interface GetClustersClusterClusterConfigApiServerPublicAccessConfigPublicAccessNetworkConfig {
        /**
         * The peak bandwidth of the public IP, unit: Mbps.
         */
        bandwidth: number;
        /**
         * Billing type of public IP, the value is `PostPaidByBandwidth` or `PostPaidByTraffic`.
         */
        billingType: string;
        /**
         * The ISP of public IP.
         */
        isp: string;
    }

    export interface GetClustersClusterLoggingConfig {
        /**
         * The TLS log item ID of the collection target.
         */
        logProjectId: string;
        /**
         * Cluster logging options.
         */
        logSetups: outputs.veecp.GetClustersClusterLoggingConfigLogSetup[];
    }

    export interface GetClustersClusterLoggingConfigLogSetup {
        /**
         * Whether to enable the log option, true means enable, false means not enable, the default is false. When Enabled is changed from false to true, a new Topic will be created.
         */
        enabled: boolean;
        /**
         * The storage time of logs in Log Service. After the specified log storage time is exceeded, the expired logs in this log topic will be automatically cleared. The unit is days, and the default is 30 days. The value range is 1 to 3650, specifying 3650 days means permanent storage.
         */
        logTtl: number;
        /**
         * The currently enabled log type.
         */
        logType: string;
    }

    export interface GetClustersClusterNodeStatistics {
        /**
         * Phase=Creating total number of nodes.
         */
        creatingCount: number;
        /**
         * Phase=Deleting total number of nodes.
         */
        deletingCount: number;
        /**
         * Phase=Failed total number of nodes.
         */
        failedCount: number;
        /**
         * Phase=Running total number of nodes.
         */
        runningCount: number;
        /**
         * Phase=Starting total number of nodes.
         */
        startingCount: number;
        /**
         * (**Deprecated**) This field has been deprecated and is not recommended for use. Phase=Stopped total number of nodes.
         *
         * @deprecated This field has been deprecated and is not recommended for use.
         */
        stoppedCount: number;
        /**
         * Phase=Stopping total number of nodes.
         */
        stoppingCount: number;
        /**
         * The total count of query.
         */
        totalCount: number;
        /**
         * Phase=Updating total number of nodes.
         */
        updatingCount: number;
    }

    export interface GetClustersClusterPodsConfig {
        /**
         * Flannel network configuration.
         */
        flannelConfig: outputs.veecp.GetClustersClusterPodsConfigFlannelConfig;
        /**
         * Container Pod Network Type (CNI), the value is `Flannel` or `VpcCniShared`.
         */
        podNetworkMode: string;
        /**
         * VPC-CNI network configuration.
         */
        vpcCniConfig: outputs.veecp.GetClustersClusterPodsConfigVpcCniConfig;
    }

    export interface GetClustersClusterPodsConfigFlannelConfig {
        /**
         * The maximum number of single-node Pod instances for a Flannel container network.
         */
        maxPodsPerNode: number;
        /**
         * Pod CIDR for the Flannel container network.
         */
        podCidrs: string[];
    }

    export interface GetClustersClusterPodsConfigVpcCniConfig {
        /**
         * A list of Pod subnet IDs for the VPC-CNI container network.
         */
        subnetIds: string[];
        /**
         * The private network where the cluster control plane network resides.
         */
        vpcId: string;
    }

    export interface GetClustersClusterServicesConfig {
        /**
         * The IPv4 private network address exposed by the service.
         */
        serviceCidrsv4s: string[];
    }

    export interface GetClustersClusterStatus {
        /**
         * The state condition in the current primary state of the cluster, that is, the reason for entering the primary state.
         */
        conditions: outputs.veecp.GetClustersClusterStatusCondition[];
        /**
         * Cluster status. The value contains `Creating`, `Running`, `Updating`, `Deleting`, `Failed`.
         */
        phase: string;
    }

    export interface GetClustersClusterStatusCondition {
        /**
         * The state condition in the current main state of the cluster, that is, the reason for entering the main state, there can be multiple reasons, the value contains `Progressing`, `Ok`, `Balance`, `CreateError`, `ResourceCleanupFailed`, `Unknown`.
         */
        type: string;
    }

    export interface GetClustersStatus {
        /**
         * The state condition in the current main state of the cluster, that is, the reason for entering the main state, there can be multiple reasons, the value contains `Progressing`, `Ok`, `Degraded`, `SetByProvider`, `Balance`, `Security`, `CreateError`, `ResourceCleanupFailed`, `LimitedByQuota`, `StockOut`,`Unknown`.
         */
        conditionsType?: string;
        /**
         * The status of cluster. the value contains `Creating`, `Running`, `Updating`, `Deleting`, `Stopped`, `Failed`.
         */
        phase?: string;
    }

    export interface GetEdgeNodePoolsNodePool {
        /**
         * The billing configuration.
         */
        billingConfigs: outputs.veecp.GetEdgeNodePoolsNodePoolBillingConfig[];
        /**
         * The ClusterId of NodePool.
         */
        clusterId: string;
        /**
         * The Condition of Status.
         */
        conditionTypes: string[];
        /**
         * The ClientToken when successfully created.
         */
        createClientToken: string;
        /**
         * The CreateTime of NodePool.
         */
        createTime: string;
        /**
         * Elastic scaling configuration of node pool.
         */
        elasticConfigs: outputs.veecp.GetEdgeNodePoolsNodePoolElasticConfig[];
        /**
         * The Id of NodePool.
         */
        id: string;
        /**
         * The LabelContent of KubernetesConfig.
         */
        labelContents: outputs.veecp.GetEdgeNodePoolsNodePoolLabelContent[];
        /**
         * The Name of NodePool.
         */
        name: string;
        /**
         * The method of adding nodes to the node pool.
         */
        nodeAddMethods: string[];
        /**
         * The NodeStatistics of NodeConfig.
         */
        nodeStatistics: outputs.veecp.GetEdgeNodePoolsNodePoolNodeStatistic[];
        /**
         * The Phase of Status.
         */
        phase: string;
        /**
         * Edge: Edge node pool. If the return value is empty, it is the central node pool.
         */
        profile: string;
        /**
         * The TaintContent of NodeConfig.
         */
        taintContents: outputs.veecp.GetEdgeNodePoolsNodePoolTaintContent[];
        /**
         * Node pool type, machine-set: central node pool. edge-machine-set: edge node pool. edge-machine-pool: edge elastic node pool.
         */
        type: string;
        /**
         * The ClientToken when last update was successful.
         */
        updateClientToken: string;
        /**
         * The UpdateTime time of NodePool.
         */
        updateTime: string;
        /**
         * The static node pool specifies the node pool to associate with the VPC.
         */
        vpcId: string;
    }

    export interface GetEdgeNodePoolsNodePoolBillingConfig {
        /**
         * Whether to automatically renew the node pool.
         */
        autoRenew: boolean;
        /**
         * The pre-paid period of the node pool, in months. The value range is 1-9. This parameter takes effect only when the billingType is PrePaid.
         */
        prePaidPeriod: number;
        /**
         * Prepaid period number.
         */
        prePaidPeriodNumber: number;
    }

    export interface GetEdgeNodePoolsNodePoolElasticConfig {
        /**
         * The auto scaling configuration.
         */
        autoScaleConfigs: outputs.veecp.GetEdgeNodePoolsNodePoolElasticConfigAutoScaleConfig[];
        /**
         * Cloud server identity.
         */
        cloudServerIdentity: string;
        /**
         * The information of instance area.
         */
        instanceAreas: outputs.veecp.GetEdgeNodePoolsNodePoolElasticConfigInstanceArea[];
    }

    export interface GetEdgeNodePoolsNodePoolElasticConfigAutoScaleConfig {
        /**
         * The DesiredReplicas of AutoScaling.
         */
        desiredReplicas: number;
        /**
         * Whether to enable auto scaling.
         */
        enabled: boolean;
        /**
         * The maximum number of nodes.
         */
        maxReplicas: number;
        /**
         * The minimum number of nodes.
         */
        minReplicas: number;
        /**
         * The Priority of AutoScaling.
         */
        priority: number;
    }

    export interface GetEdgeNodePoolsNodePoolElasticConfigInstanceArea {
        /**
         * Region name. You can obtain the regions and operators supported by instance specifications through the ListAvailableResourceInfo interface.
         */
        areaName: string;
        /**
         * Cluster name.
         */
        clusterName: string;
        /**
         * Default operator. When using three-line nodes, this parameter can be configured. After configuration, this operator will be used as the default export.
         */
        defaultIsp: string;
        /**
         * Public network configuration of three-line nodes. If it is a single-line node, this parameter will be ignored. Value range: single_interface_multi_ip: Single network card with multiple IPs. single_interface_cmcc_ip: Single network card with China Mobile IP. Relevant permissions need to be opened by submitting a work order. single_interface_cucc_ip: Single network card with China Unicom IP. Relevant permissions need to be opened by submitting a work order. single_interface_ctcc_ip: Single network card with China Telecom IP. Relevant permissions need to be opened by submitting a work order. multi_interface_multi_ip: Multiple network cards with multiple IPs. Relevant permissions need to be opened by submitting a work order. no_interface: No public network network card. Relevant permissions need to be opened by submitting a work order. If this parameter is not configured: When there is a public network network card, singleInterfaceMultiIp is used by default. When there is no public network network card, noInterface is used by default.
         */
        externalNetworkMode: string;
        /**
         * Operator. You can obtain the regions and operators supported by the instance specification through the ListAvailableResourceInfo interface.
         */
        isp: string;
        /**
         * Subnet ID.
         */
        subnetIdentity: string;
        /**
         * VPC ID.
         */
        vpcIdentity: string;
    }

    export interface GetEdgeNodePoolsNodePoolLabelContent {
        /**
         * The Key of Taint.
         */
        key: string;
        /**
         * The Value of Taint.
         */
        value: string;
    }

    export interface GetEdgeNodePoolsNodePoolNodeStatistic {
        /**
         * The CreatingCount of Node.
         */
        creatingCount: number;
        /**
         * The DeletingCount of Node.
         */
        deletingCount: number;
        /**
         * The FailedCount of Node.
         */
        failedCount: number;
        /**
         * The RunningCount of Node.
         */
        runningCount: number;
        /**
         * (**Deprecated**) This field has been deprecated and is not recommended for use. The StartingCount of Node.
         *
         * @deprecated This field has been deprecated and is not recommended for use.
         */
        startingCount: number;
        /**
         * (**Deprecated**) This field has been deprecated and is not recommended for use. The StoppedCount of Node.
         *
         * @deprecated This field has been deprecated and is not recommended for use.
         */
        stoppedCount: number;
        /**
         * (**Deprecated**) This field has been deprecated and is not recommended for use. The StoppingCount of Node.
         *
         * @deprecated This field has been deprecated and is not recommended for use.
         */
        stoppingCount: number;
        /**
         * The total count of query.
         */
        totalCount: number;
        /**
         * The UpdatingCount of Node.
         */
        updatingCount: number;
    }

    export interface GetEdgeNodePoolsNodePoolTaintContent {
        /**
         * The Effect of Taint.
         */
        effect: string;
        /**
         * The Key of Taint.
         */
        key: string;
        /**
         * The Value of Taint.
         */
        value: string;
    }

    export interface GetEdgeNodePoolsStatus {
        /**
         * Indicates the status condition of the node pool in the active state. The value can be `Progressing` or `Ok` or `VersionPartlyUpgraded` or `StockOut` or `LimitedByQuota` or `Balance` or `Degraded` or `ClusterVersionUpgrading` or `Cluster` or `ResourceCleanupFailed` or `Unknown` or `ClusterNotRunning` or `SetByProvider`.
         */
        conditionsType?: string;
        /**
         * The Phase of Status. The value can be `Creating` or `Running` or `Updating` or `Deleting` or `Failed` or `Scaling`.
         */
        phase?: string;
    }

    export interface GetEdgeNodesNode {
        /**
         * The bootstrap script of node.
         */
        bootstrapScript: string;
        /**
         * The cluster id of node.
         */
        clusterId: string;
        /**
         * The Condition of Node.
         */
        conditionTypes: string[];
        /**
         * The Create Client Token.
         */
        createClientToken: string;
        /**
         * The create time of Node.
         */
        createTime: string;
        /**
         * The edge node type of node.
         */
        edgeNodeType: string;
        /**
         * The ID of Node.
         */
        id: string;
        /**
         * The instance id of node.
         */
        instanceId: string;
        /**
         * The Name of Node.
         */
        name: string;
        /**
         * The node pool id.
         */
        nodePoolId: string;
        /**
         * The Phase of Node.
         */
        phase: string;
        /**
         * The profile of node. Distinguish between edge and central nodes.
         */
        profile: string;
        /**
         * The provider id of node.
         */
        providerId: string;
        /**
         * The update time of Node.
         */
        updateTime: string;
    }

    export interface GetEdgeNodesStatus {
        /**
         * The Type of Node Condition, the value is `Progressing` or `Ok` or `Unschedulable` or `InitilizeFailed` or `Unknown` or `NotReady` or `Security` or `Balance` or `ResourceCleanupFailed`.
         */
        edgeNodeStatusConditionType?: string;
        /**
         * The Phase of Node, the value is `Creating` or `Running` or `Updating` or `Deleting` or `Failed` or `Starting` or `Stopping` or `Stopped`.
         */
        phase?: string;
    }

    export interface GetNodePoolsNodePool {
        /**
         * Is AdditionalContainerStorageEnabled of NodeConfig.
         */
        additionalContainerStorageEnabled: boolean;
        /**
         * Is auto renew of the PrePaid instance of NodeConfig.
         */
        autoRenew: boolean;
        /**
         * The AutoRenewPeriod of the PrePaid instance of NodeConfig.
         */
        autoRenewPeriod: number;
        /**
         * The ClusterId of NodePool.
         */
        clusterId: string;
        /**
         * The Condition of Status.
         */
        conditionTypes: string[];
        /**
         * The Cordon of KubernetesConfig.
         */
        cordon: boolean;
        /**
         * The ClientToken when successfully created.
         */
        createClientToken: string;
        /**
         * The CreateTime of NodePool.
         */
        createTime: string;
        /**
         * The DataVolume of NodeConfig.
         */
        dataVolumes: outputs.veecp.GetNodePoolsNodePoolDataVolume[];
        /**
         * The DesiredReplicas of AutoScaling.
         */
        desiredReplicas: number;
        /**
         * Tags for Ecs.
         */
        ecsTags: outputs.veecp.GetNodePoolsNodePoolEcsTag[];
        /**
         * Is Enabled of AutoScaling.
         */
        enabled: boolean;
        /**
         * The IDs of HpcCluster.
         */
        hpcClusterIds: string[];
        /**
         * The Id of NodePool.
         */
        id: string;
        /**
         * The ImageId of NodeConfig.
         */
        imageId: string;
        /**
         * The InitializeScript of NodeConfig.
         */
        initializeScript: string;
        /**
         * The InstanceChargeType of NodeConfig.
         */
        instanceChargeType: string;
        /**
         * The InstanceTypeIds of NodeConfig.
         */
        instanceTypeIds: string[];
        /**
         * The NamePrefix of node metadata.
         */
        kubeConfigNamePrefix: string;
        /**
         * The LabelContent of KubernetesConfig.
         */
        labelContents: outputs.veecp.GetNodePoolsNodePoolLabelContent[];
        /**
         * The login SshKeyPairName of NodeConfig.
         */
        loginKeyPairName: string;
        /**
         * The login type of NodeConfig.
         */
        loginType: string;
        /**
         * The MaxReplicas of AutoScaling.
         */
        maxReplicas: number;
        /**
         * The MinReplicas of AutoScaling.
         */
        minReplicas: number;
        /**
         * The Name of NodePool.
         */
        name: string;
        /**
         * The NamePrefix of NodeConfig.
         */
        namePrefix: string;
        /**
         * The NodeStatistics of NodeConfig.
         */
        nodeStatistics: outputs.veecp.GetNodePoolsNodePoolNodeStatistic[];
        /**
         * The period of the PrePaid instance of NodeConfig.
         */
        period: number;
        /**
         * The Phase of Status.
         */
        phase: string;
        /**
         * The Priority of AutoScaling.
         */
        priority: number;
        /**
         * The SecurityGroupIds of NodeConfig.
         */
        securityGroupIds: string[];
        /**
         * The SecurityStrategies of NodeConfig.
         */
        securityStrategies: string[];
        /**
         * The SecurityStrategyEnabled of NodeConfig.
         */
        securityStrategyEnabled: boolean;
        /**
         * The SubnetId of NodeConfig.
         */
        subnetIds: string[];
        /**
         * Multi-subnet scheduling strategy for nodes. The value can be `ZoneBalance` or `Priority`.
         */
        subnetPolicy: string;
        /**
         * The SystemVolume of NodeConfig.
         */
        systemVolumes: outputs.veecp.GetNodePoolsNodePoolSystemVolume[];
        /**
         * Tags of the NodePool.
         */
        tags: outputs.veecp.GetNodePoolsNodePoolTag[];
        /**
         * The TaintContent of NodeConfig.
         */
        taintContents: outputs.veecp.GetNodePoolsNodePoolTaintContent[];
        /**
         * The ClientToken when last update was successful.
         */
        updateClientToken: string;
        /**
         * The UpdateTime time of NodePool.
         */
        updateTime: string;
    }

    export interface GetNodePoolsNodePoolDataVolume {
        /**
         * The target mount directory of the disk.
         */
        mountPoint: string;
        /**
         * The Size of SystemVolume.
         */
        size: string;
        /**
         * The Type of Tags.
         */
        type: string;
    }

    export interface GetNodePoolsNodePoolEcsTag {
        /**
         * The Key of Taint.
         */
        key: string;
        /**
         * The Value of Taint.
         */
        value: string;
    }

    export interface GetNodePoolsNodePoolLabelContent {
        /**
         * The Key of Taint.
         */
        key: string;
        /**
         * The Value of Taint.
         */
        value: string;
    }

    export interface GetNodePoolsNodePoolNodeStatistic {
        /**
         * The CreatingCount of Node.
         */
        creatingCount: number;
        /**
         * The DeletingCount of Node.
         */
        deletingCount: number;
        /**
         * The FailedCount of Node.
         */
        failedCount: number;
        /**
         * The RunningCount of Node.
         */
        runningCount: number;
        /**
         * (**Deprecated**) This field has been deprecated and is not recommended for use. The StartingCount of Node.
         *
         * @deprecated This field has been deprecated and is not recommended for use.
         */
        startingCount: number;
        /**
         * (**Deprecated**) This field has been deprecated and is not recommended for use. The StoppedCount of Node.
         *
         * @deprecated This field has been deprecated and is not recommended for use.
         */
        stoppedCount: number;
        /**
         * (**Deprecated**) This field has been deprecated and is not recommended for use. The StoppingCount of Node.
         *
         * @deprecated This field has been deprecated and is not recommended for use.
         */
        stoppingCount: number;
        /**
         * The total count of query.
         */
        totalCount: number;
        /**
         * The UpdatingCount of Node.
         */
        updatingCount: number;
    }

    export interface GetNodePoolsNodePoolSystemVolume {
        /**
         * The Size of SystemVolume.
         */
        size: string;
        /**
         * The Type of Tags.
         */
        type: string;
    }

    export interface GetNodePoolsNodePoolTag {
        /**
         * The Key of Taint.
         */
        key: string;
        /**
         * The Type of Tags.
         */
        type: string;
        /**
         * The Value of Taint.
         */
        value: string;
    }

    export interface GetNodePoolsNodePoolTaintContent {
        /**
         * The Effect of Taint.
         */
        effect: string;
        /**
         * The Key of Taint.
         */
        key: string;
        /**
         * The Value of Taint.
         */
        value: string;
    }

    export interface GetNodePoolsStatus {
        /**
         * Indicates the status condition of the node pool in the active state. The value can be `Progressing` or `Ok` or `VersionPartlyUpgraded` or `StockOut` or `LimitedByQuota` or `Balance` or `Degraded` or `ClusterVersionUpgrading` or `Cluster` or `ResourceCleanupFailed` or `Unknown` or `ClusterNotRunning` or `SetByProvider`.
         */
        conditionsType?: string;
        /**
         * The Phase of Status. The value can be `Creating` or `Running` or `Updating` or `Deleting` or `Failed` or `Scaling`.
         */
        phase?: string;
    }

    export interface GetSupportAddonsAddon {
        /**
         * The categories of addons, the value is `Storage` or `Network` or `Monitor` or `Scheduler` or `Dns` or `Security` or `Gpu` or `Image`.
         */
        categories?: string[];
        /**
         * The deploy model, the value is `Managed` or `Unmanaged`.
         */
        deployModes: string[];
        /**
         * The deploy node types, the value is `Node` or `VirtualNode`. Only effected when deployMode is `Unmanaged`.
         */
        deployNodeTypes: string[];
        /**
         * The name of the addon.
         */
        name: string;
        /**
         * The necessary of addon.
         */
        necessary?: string;
        /**
         * The container network model, the value is `Flannel` or `VpcCniShared`. Flannel: Flannel network model, an independent Underlay container network solution, combined with the global routing capability of VPC, to achieve a high-performance network experience for the cluster. VpcCniShared: VPC-CNI network model, an Underlay container network solution based on the ENI of the private network elastic network card, with high network communication performance.
         */
        podNetworkModes: string[];
        /**
         * The version info of addon.
         */
        versions: outputs.veecp.GetSupportAddonsAddonVersion[];
    }

    export interface GetSupportAddonsAddonVersion {
        /**
         * The compatible version list.
         */
        compatibilities: outputs.veecp.GetSupportAddonsAddonVersionCompatibility[];
        /**
         * The compatible version list.
         */
        compatibleVersions: string[];
        /**
         * The basic version info.
         */
        version: string;
    }

    export interface GetSupportAddonsAddonVersionCompatibility {
        /**
         * The Kubernetes Version of addon.
         */
        kubernetesVersion: string;
    }

    export interface GetSupportResourceTypesResource {
        /**
         * The scope of resource.
         */
        resourceScope: string;
        /**
         * The resource specifications info.
         */
        resourceSpecifications: string[];
        /**
         * The type of resource.
         */
        resourceType: string;
        /**
         * The id of zone.
         */
        zoneId: string;
    }

    export interface NodePoolAutoScaling {
        /**
         * The DesiredReplicas of AutoScaling, default 0, range in minReplicas to max_replicas.
         */
        desiredReplicas: number;
        /**
         * Whether to enable the auto scaling function of the node pool. When a node needs to be manually added to the node pool, the value of this field must be `false`.
         */
        enabled: boolean;
        /**
         * The MaxReplicas of AutoScaling, default 10, range in 1~2000. This field is valid when the value of `enabled` is `true`.
         */
        maxReplicas?: number;
        /**
         * The MinReplicas of AutoScaling, default 0. This field is valid when the value of `enabled` is `true`.
         */
        minReplicas: number;
        /**
         * The Priority of AutoScaling, default 10, rang in 0~100. This field is valid when the value of `enabled` is `true` and the value of `subnetPolicy` is `Priority`.
         */
        priority: number;
        /**
         * Multi-subnet scheduling strategy for nodes. The value can be `ZoneBalance` or `Priority`.
         */
        subnetPolicy: string;
    }

    export interface NodePoolKubernetesConfig {
        /**
         * Whether to disable the function of automatically synchronizing labels and taints to existing nodes. Default is false.
         */
        autoSyncDisabled: boolean;
        /**
         * The Cordon of KubernetesConfig.
         */
        cordon: boolean;
        /**
         * The Labels of KubernetesConfig.
         */
        labels?: outputs.veecp.NodePoolKubernetesConfigLabel[];
        /**
         * The NamePrefix of node metadata.
         */
        namePrefix?: string;
        /**
         * The Taints of KubernetesConfig.
         */
        taints?: outputs.veecp.NodePoolKubernetesConfigTaint[];
    }

    export interface NodePoolKubernetesConfigLabel {
        /**
         * The Key of Labels.
         */
        key?: string;
        /**
         * The Value of Labels.
         */
        value?: string;
    }

    export interface NodePoolKubernetesConfigTaint {
        /**
         * The Effect of Taints, the value can be `NoSchedule` or `NoExecute` or `PreferNoSchedule`.
         */
        effect?: string;
        /**
         * The Key of Taints.
         */
        key?: string;
        /**
         * The Value of Taints.
         */
        value?: string;
    }

    export interface NodePoolNodeConfig {
        /**
         * The AdditionalContainerStorageEnabled of NodeConfig.
         */
        additionalContainerStorageEnabled?: boolean;
        /**
         * Is AutoRenew of PrePaid instance of NodeConfig. Valid values: true, false. when InstanceChargeType is PrePaid, default value is true.
         */
        autoRenew: boolean;
        /**
         * The AutoRenewPeriod of PrePaid instance of NodeConfig. Valid values: 1, 2, 3, 6, 12. Unit: month. when InstanceChargeType is PrePaid and AutoRenew enable, default value is 1.
         */
        autoRenewPeriod: number;
        /**
         * The DataVolumes of NodeConfig.
         */
        dataVolumes?: outputs.veecp.NodePoolNodeConfigDataVolume[];
        /**
         * Tags for Ecs.
         */
        ecsTags?: outputs.veecp.NodePoolNodeConfigEcsTag[];
        /**
         * The IDs of HpcCluster, only one ID is supported currently.
         */
        hpcClusterIds?: string[];
        /**
         * The ImageId of NodeConfig.
         */
        imageId: string;
        /**
         * The initializeScript of NodeConfig.
         */
        initializeScript?: string;
        /**
         * The InstanceChargeType of PrePaid instance of NodeConfig. Valid values: PostPaid, PrePaid. Default value: PostPaid.
         */
        instanceChargeType?: string;
        /**
         * The InstanceTypeIds of NodeConfig. The value can get from volcengine.veecp.getSupportResourceTypes datasource.
         */
        instanceTypeIds: string[];
        /**
         * The NamePrefix of NodeConfig.
         */
        namePrefix?: string;
        /**
         * The Period of PrePaid instance of NodeConfig. Valid values: 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 24, 36. Unit: month. when InstanceChargeType is PrePaid, default value is 12.
         */
        period: number;
        /**
         * The Security of NodeConfig.
         */
        security: outputs.veecp.NodePoolNodeConfigSecurity;
        /**
         * The SubnetIds of NodeConfig.
         */
        subnetIds: string[];
        /**
         * The SystemVolume of NodeConfig.
         */
        systemVolume: outputs.veecp.NodePoolNodeConfigSystemVolume;
    }

    export interface NodePoolNodeConfigDataVolume {
        /**
         * The target mount directory of the disk. Must start with `/`.
         */
        mountPoint?: string;
        /**
         * The Size of DataVolumes, the value range in 20~32768. Default value is `20`.
         */
        size?: number;
        /**
         * The Type of DataVolumes, the value can be `PTSSD` or `ESSD_PL0` or `ESSD_FlexPL`. Default value is `ESSD_PL0`.
         */
        type?: string;
    }

    export interface NodePoolNodeConfigEcsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface NodePoolNodeConfigSecurity {
        /**
         * The Login of Security.
         */
        login?: outputs.veecp.NodePoolNodeConfigSecurityLogin;
        /**
         * The SecurityGroupIds of Security.
         */
        securityGroupIds: string[];
        /**
         * The SecurityStrategies of Security, the value can be empty or `Hids`.
         */
        securityStrategies?: string[];
    }

    export interface NodePoolNodeConfigSecurityLogin {
        /**
         * The Password of Security, this field must be encoded with base64.
         */
        password?: string;
        /**
         * The SshKeyPairName of Security.
         */
        sshKeyPairName?: string;
    }

    export interface NodePoolNodeConfigSystemVolume {
        /**
         * The Size of SystemVolume, the value range in 20~2048.
         */
        size: number;
        /**
         * The Type of SystemVolume, the value can be `PTSSD` or `ESSD_PL0` or `ESSD_FlexPL`.
         */
        type: string;
    }

    export interface NodePoolNodeStatistic {
        /**
         * The CreatingCount of Node.
         */
        creatingCount: number;
        /**
         * The DeletingCount of Node.
         */
        deletingCount: number;
        /**
         * The FailedCount of Node.
         */
        failedCount: number;
        /**
         * The RunningCount of Node.
         */
        runningCount: number;
        /**
         * (**Deprecated**) This field has been deprecated and is not recommended for use. The StartingCount of Node.
         *
         * @deprecated This field has been deprecated and is not recommended for use.
         */
        startingCount: number;
        /**
         * (**Deprecated**) This field has been deprecated and is not recommended for use. The StoppedCount of Node.
         *
         * @deprecated This field has been deprecated and is not recommended for use.
         */
        stoppedCount: number;
        /**
         * (**Deprecated**) This field has been deprecated and is not recommended for use. The StoppingCount of Node.
         *
         * @deprecated This field has been deprecated and is not recommended for use.
         */
        stoppingCount: number;
        /**
         * The TotalCount of Node.
         */
        totalCount: number;
        /**
         * The UpdatingCount of Node.
         */
        updatingCount: number;
    }

    export interface NodePoolsNodePool {
        /**
         * Is AdditionalContainerStorageEnabled of NodeConfig.
         */
        additionalContainerStorageEnabled: boolean;
        /**
         * Is auto renew of the PrePaid instance of NodeConfig.
         */
        autoRenew: boolean;
        /**
         * The AutoRenewPeriod of the PrePaid instance of NodeConfig.
         */
        autoRenewPeriod: number;
        /**
         * The ClusterId of NodePool.
         */
        clusterId: string;
        /**
         * The Condition of Status.
         */
        conditionTypes: string[];
        /**
         * The Cordon of KubernetesConfig.
         */
        cordon: boolean;
        /**
         * The ClientToken when successfully created.
         */
        createClientToken: string;
        /**
         * The CreateTime of NodePool.
         */
        createTime: string;
        /**
         * The DataVolume of NodeConfig.
         */
        dataVolumes: outputs.veecp.NodePoolsNodePoolDataVolume[];
        /**
         * The DesiredReplicas of AutoScaling.
         */
        desiredReplicas: number;
        /**
         * Tags for Ecs.
         */
        ecsTags: outputs.veecp.NodePoolsNodePoolEcsTag[];
        /**
         * Is Enabled of AutoScaling.
         */
        enabled: boolean;
        /**
         * The IDs of HpcCluster.
         */
        hpcClusterIds: string[];
        /**
         * The Id of NodePool.
         */
        id: string;
        /**
         * The ImageId of NodeConfig.
         */
        imageId: string;
        /**
         * The InitializeScript of NodeConfig.
         */
        initializeScript: string;
        /**
         * The InstanceChargeType of NodeConfig.
         */
        instanceChargeType: string;
        /**
         * The InstanceTypeIds of NodeConfig.
         */
        instanceTypeIds: string[];
        /**
         * The NamePrefix of node metadata.
         */
        kubeConfigNamePrefix: string;
        /**
         * The LabelContent of KubernetesConfig.
         */
        labelContents: outputs.veecp.NodePoolsNodePoolLabelContent[];
        /**
         * The login SshKeyPairName of NodeConfig.
         */
        loginKeyPairName: string;
        /**
         * The login type of NodeConfig.
         */
        loginType: string;
        /**
         * The MaxReplicas of AutoScaling.
         */
        maxReplicas: number;
        /**
         * The MinReplicas of AutoScaling.
         */
        minReplicas: number;
        /**
         * The Name of NodePool.
         */
        name: string;
        /**
         * The NamePrefix of NodeConfig.
         */
        namePrefix: string;
        /**
         * The NodeStatistics of NodeConfig.
         */
        nodeStatistics: outputs.veecp.NodePoolsNodePoolNodeStatistic[];
        /**
         * The period of the PrePaid instance of NodeConfig.
         */
        period: number;
        /**
         * The Phase of Status.
         */
        phase: string;
        /**
         * The Priority of AutoScaling.
         */
        priority: number;
        /**
         * The SecurityGroupIds of NodeConfig.
         */
        securityGroupIds: string[];
        /**
         * The SecurityStrategies of NodeConfig.
         */
        securityStrategies: string[];
        /**
         * The SecurityStrategyEnabled of NodeConfig.
         */
        securityStrategyEnabled: boolean;
        /**
         * The SubnetId of NodeConfig.
         */
        subnetIds: string[];
        /**
         * Multi-subnet scheduling strategy for nodes. The value can be `ZoneBalance` or `Priority`.
         */
        subnetPolicy: string;
        /**
         * The SystemVolume of NodeConfig.
         */
        systemVolumes: outputs.veecp.NodePoolsNodePoolSystemVolume[];
        /**
         * Tags of the NodePool.
         */
        tags: outputs.veecp.NodePoolsNodePoolTag[];
        /**
         * The TaintContent of NodeConfig.
         */
        taintContents: outputs.veecp.NodePoolsNodePoolTaintContent[];
        /**
         * The ClientToken when last update was successful.
         */
        updateClientToken: string;
        /**
         * The UpdateTime time of NodePool.
         */
        updateTime: string;
    }

    export interface NodePoolsNodePoolDataVolume {
        /**
         * The target mount directory of the disk.
         */
        mountPoint: string;
        /**
         * The Size of SystemVolume.
         */
        size: string;
        /**
         * The Type of Tags.
         */
        type: string;
    }

    export interface NodePoolsNodePoolEcsTag {
        /**
         * The Key of Taint.
         */
        key: string;
        /**
         * The Value of Taint.
         */
        value: string;
    }

    export interface NodePoolsNodePoolLabelContent {
        /**
         * The Key of Taint.
         */
        key: string;
        /**
         * The Value of Taint.
         */
        value: string;
    }

    export interface NodePoolsNodePoolNodeStatistic {
        /**
         * The CreatingCount of Node.
         */
        creatingCount: number;
        /**
         * The DeletingCount of Node.
         */
        deletingCount: number;
        /**
         * The FailedCount of Node.
         */
        failedCount: number;
        /**
         * The RunningCount of Node.
         */
        runningCount: number;
        /**
         * (**Deprecated**) This field has been deprecated and is not recommended for use. The StartingCount of Node.
         *
         * @deprecated This field has been deprecated and is not recommended for use.
         */
        startingCount: number;
        /**
         * (**Deprecated**) This field has been deprecated and is not recommended for use. The StoppedCount of Node.
         *
         * @deprecated This field has been deprecated and is not recommended for use.
         */
        stoppedCount: number;
        /**
         * (**Deprecated**) This field has been deprecated and is not recommended for use. The StoppingCount of Node.
         *
         * @deprecated This field has been deprecated and is not recommended for use.
         */
        stoppingCount: number;
        /**
         * The total count of query.
         */
        totalCount: number;
        /**
         * The UpdatingCount of Node.
         */
        updatingCount: number;
    }

    export interface NodePoolsNodePoolSystemVolume {
        /**
         * The Size of SystemVolume.
         */
        size: string;
        /**
         * The Type of Tags.
         */
        type: string;
    }

    export interface NodePoolsNodePoolTag {
        /**
         * The Key of Taint.
         */
        key: string;
        /**
         * The Type of Tags.
         */
        type: string;
        /**
         * The Value of Taint.
         */
        value: string;
    }

    export interface NodePoolsNodePoolTaintContent {
        /**
         * The Effect of Taint.
         */
        effect: string;
        /**
         * The Key of Taint.
         */
        key: string;
        /**
         * The Value of Taint.
         */
        value: string;
    }

    export interface NodePoolsStatus {
        /**
         * Indicates the status condition of the node pool in the active state. The value can be `Progressing` or `Ok` or `VersionPartlyUpgraded` or `StockOut` or `LimitedByQuota` or `Balance` or `Degraded` or `ClusterVersionUpgrading` or `Cluster` or `ResourceCleanupFailed` or `Unknown` or `ClusterNotRunning` or `SetByProvider`.
         */
        conditionsType?: string;
        /**
         * The Phase of Status. The value can be `Creating` or `Running` or `Updating` or `Deleting` or `Failed` or `Scaling`.
         */
        phase?: string;
    }

    export interface SupportAddonsAddon {
        /**
         * The categories of addons, the value is `Storage` or `Network` or `Monitor` or `Scheduler` or `Dns` or `Security` or `Gpu` or `Image`.
         */
        categories?: string[];
        /**
         * The deploy model, the value is `Managed` or `Unmanaged`.
         */
        deployModes: string[];
        /**
         * The deploy node types, the value is `Node` or `VirtualNode`. Only effected when deployMode is `Unmanaged`.
         */
        deployNodeTypes: string[];
        /**
         * The name of the addon.
         */
        name: string;
        /**
         * The necessary of addon.
         */
        necessary?: string;
        /**
         * The container network model, the value is `Flannel` or `VpcCniShared`. Flannel: Flannel network model, an independent Underlay container network solution, combined with the global routing capability of VPC, to achieve a high-performance network experience for the cluster. VpcCniShared: VPC-CNI network model, an Underlay container network solution based on the ENI of the private network elastic network card, with high network communication performance.
         */
        podNetworkModes: string[];
        /**
         * The version info of addon.
         */
        versions: outputs.veecp.SupportAddonsAddonVersion[];
    }

    export interface SupportAddonsAddonVersion {
        /**
         * The compatible version list.
         */
        compatibilities: outputs.veecp.SupportAddonsAddonVersionCompatibility[];
        /**
         * The compatible version list.
         */
        compatibleVersions: string[];
        /**
         * The basic version info.
         */
        version: string;
    }

    export interface SupportAddonsAddonVersionCompatibility {
        /**
         * The Kubernetes Version of addon.
         */
        kubernetesVersion: string;
    }

    export interface SupportResourceTypesResource {
        /**
         * The scope of resource.
         */
        resourceScope: string;
        /**
         * The resource specifications info.
         */
        resourceSpecifications: string[];
        /**
         * The type of resource.
         */
        resourceType: string;
        /**
         * The id of zone.
         */
        zoneId: string;
    }

}

export namespace veenedge {
    export interface AvailableResourcesRegion {
        /**
         * The config of area.
         */
        area: outputs.veenedge.AvailableResourcesRegionArea;
        /**
         * The config of city.
         */
        city: outputs.veenedge.AvailableResourcesRegionCity;
        /**
         * The config of cluster.
         */
        cluster: outputs.veenedge.AvailableResourcesRegionCluster;
        /**
         * The config of country.
         */
        country: outputs.veenedge.AvailableResourcesRegionCountry;
        /**
         * The config of isp.
         */
        isp: outputs.veenedge.AvailableResourcesRegionIsp;
    }

    export interface AvailableResourcesRegionArea {
        /**
         * The english name of region.
         */
        enName: string;
        /**
         * The id of region.
         */
        id: string;
        /**
         * The name of region.
         */
        name: string;
    }

    export interface AvailableResourcesRegionCity {
        /**
         * The english name of region.
         */
        enName: string;
        /**
         * The id of region.
         */
        id: string;
        /**
         * The name of region.
         */
        name: string;
    }

    export interface AvailableResourcesRegionCluster {
        /**
         * The english name of region.
         */
        enName: string;
        /**
         * The id of region.
         */
        id: string;
        /**
         * The name of region.
         */
        name: string;
    }

    export interface AvailableResourcesRegionCountry {
        /**
         * The english name of region.
         */
        enName: string;
        /**
         * The id of region.
         */
        id: string;
        /**
         * The name of region.
         */
        name: string;
    }

    export interface AvailableResourcesRegionIsp {
        /**
         * The english name of region.
         */
        enName: string;
        /**
         * The id of region.
         */
        id: string;
        /**
         * The name of region.
         */
        name: string;
    }

    export interface CloudServerBillingConfig {
        /**
         * The method of bandwidth billing. The value can be `MonthlyP95` or `DailyPeak`.
         */
        bandwidthBillingMethod: string;
        /**
         * The method of computing billing. The value can be `MonthlyPeak` or `DailyPeak`.
         */
        computingBillingMethod: string;
    }

    export interface CloudServerCustomData {
        /**
         * The custom data info.
         */
        data: string;
    }

    export interface CloudServerNetworkConfig {
        /**
         * The peak of bandwidth.
         */
        bandwidthPeak: string;
        /**
         * The name of custom external interface.
         */
        customExternalInterfaceName?: string;
        /**
         * The name of custom internal interface.
         */
        customInternalInterfaceName?: string;
        /**
         * Whether enable ipv6.
         */
        enableIpv6: boolean;
        /**
         * The internal peak of bandwidth.
         */
        internalBandwidthPeak: string;
    }

    export interface CloudServerScheduleStrategy {
        /**
         * The network strategy.
         */
        networkStrategy: string;
        /**
         * The price strategy. The value can be `highPriority` or `lowPriority`.
         */
        priceStrategy: string;
        /**
         * The type of schedule strategy. The value can be `dispersion` or `concentration`.
         */
        scheduleStrategy: string;
    }

    export interface CloudServerStorageConfig {
        /**
         * The disk list info of data.
         */
        dataDiskLists?: outputs.veenedge.CloudServerStorageConfigDataDiskList[];
        /**
         * The disk info of system.
         */
        systemDisk: outputs.veenedge.CloudServerStorageConfigSystemDisk;
    }

    export interface CloudServerStorageConfigDataDiskList {
        /**
         * The capacity of storage.
         */
        capacity: string;
        /**
         * The type of storage. The value can be `CloudBlockHDD` or `CloudBlockSSD`.
         */
        storageType: string;
    }

    export interface CloudServerStorageConfigSystemDisk {
        /**
         * The capacity of storage.
         */
        capacity: string;
        /**
         * The type of storage. The value can be `CloudBlockHDD` or `CloudBlockSSD`.
         */
        storageType: string;
    }

    export interface CloudServersCloudServer {
        /**
         * The config of billing.
         */
        billingConfig: outputs.veenedge.CloudServersCloudServerBillingConfig;
        /**
         * The Id of cloud server.
         */
        cloudServerIdentity: string;
        /**
         * The cpu info of cloud server.
         */
        cpu: string;
        /**
         * The create time info.
         */
        createTime: number;
        /**
         * The config of custom data.
         */
        customData: outputs.veenedge.CloudServersCloudServerCustomData;
        /**
         * The config of gpu.
         */
        gpu: outputs.veenedge.CloudServersCloudServerGpu;
        /**
         * The Id of cloud server.
         */
        id: string;
        /**
         * The config of image.
         */
        image: outputs.veenedge.CloudServersCloudServerImage;
        /**
         * The count of instance.
         */
        instanceCount: number;
        /**
         * The status of instances.
         */
        instanceStatuses: outputs.veenedge.CloudServersCloudServerInstanceStatus[];
        /**
         * The memory info of cloud server.
         */
        mem: string;
        /**
         * The name of cloud server.
         */
        name: string;
        /**
         * The config of network.
         */
        network: outputs.veenedge.CloudServersCloudServerNetwork;
        /**
         * The config of schedule strategy.
         */
        scheduleStrategyConfigs: outputs.veenedge.CloudServersCloudServerScheduleStrategyConfigs;
        /**
         * The config of secret.
         */
        secretConfig: outputs.veenedge.CloudServersCloudServerSecretConfig;
        /**
         * The server area count number.
         */
        serverAreaCount: number;
        /**
         * The area level of cloud server.
         */
        serverAreaLevel: string;
        /**
         * The server areas info.
         */
        serverAreas: outputs.veenedge.CloudServersCloudServerServerArea[];
        /**
         * The spec info of cloud server.
         */
        spec: string;
        /**
         * The Chinese spec info of cloud server.
         */
        specDisplay: string;
        /**
         * The spec summary of cloud server.
         */
        specSum: {[key: string]: any};
        /**
         * The config of storage.
         */
        storage: outputs.veenedge.CloudServersCloudServerStorage;
        /**
         * The update time info.
         */
        updateTime: number;
    }

    export interface CloudServersCloudServerBillingConfig {
        /**
         * The bandwidth billing method.
         */
        bandwidthBillingMethod: string;
        /**
         * The computing billing method.
         */
        computingBillingMethod: string;
    }

    export interface CloudServersCloudServerCustomData {
        /**
         * The data info.
         */
        data: string;
    }

    export interface CloudServersCloudServerGpu {
        /**
         * The list gpu info.
         */
        gpuses: outputs.veenedge.CloudServersCloudServerGpuGpus[];
    }

    export interface CloudServersCloudServerGpuGpus {
        /**
         * The spec of gpu.
         */
        gpuSpec: outputs.veenedge.CloudServersCloudServerGpuGpusGpuSpec;
        /**
         * The number of gpu.
         */
        num: number;
    }

    export interface CloudServersCloudServerGpuGpusGpuSpec {
        /**
         * The type of gpu.
         */
        gpuType: string;
    }

    export interface CloudServersCloudServerImage {
        /**
         * The id of image.
         */
        imageIdentity: string;
        /**
         * The name of image.
         */
        imageName: string;
        /**
         * The property of system.
         */
        property: string;
        /**
         * The arch of system.
         */
        systemArch: string;
        /**
         * The bit of system.
         */
        systemBit: string;
        /**
         * The type of system.
         */
        systemType: string;
        /**
         * The version of system.
         */
        systemVersion: string;
    }

    export interface CloudServersCloudServerInstanceStatus {
        /**
         * The count of instance.
         */
        instanceCount: number;
        /**
         * The status info.
         */
        status: string;
    }

    export interface CloudServersCloudServerNetwork {
        /**
         * The peak of bandwidth.
         */
        bandwidthPeak: string;
        /**
         * Whether enable ipv6.
         */
        enableIpv6: boolean;
        /**
         * The internal peak of bandwidth.
         */
        internalBandwidthPeak: string;
    }

    export interface CloudServersCloudServerScheduleStrategyConfigs {
        /**
         * The price strategy.
         */
        priceStrategy: string;
        /**
         * The schedule strategy.
         */
        scheduleStrategy: string;
    }

    export interface CloudServersCloudServerSecretConfig {
        /**
         * The data of secret.
         */
        secretData: string;
        /**
         * The type of secret.
         */
        secretType: number;
    }

    export interface CloudServersCloudServerServerArea {
        /**
         * The area info.
         */
        area: string;
        /**
         * The number of instance.
         */
        instanceNum: number;
        /**
         * The isp info.
         */
        isp: string;
    }

    export interface CloudServersCloudServerStorage {
        /**
         * The disk info of data.
         */
        dataDisk: outputs.veenedge.CloudServersCloudServerStorageDataDisk;
        /**
         * The disk list info of data.
         */
        dataDiskLists: outputs.veenedge.CloudServersCloudServerStorageDataDiskList[];
        /**
         * The disk info of system.
         */
        systemDisk: outputs.veenedge.CloudServersCloudServerStorageSystemDisk;
    }

    export interface CloudServersCloudServerStorageDataDisk {
        /**
         * The capacity of storage.
         */
        capacity: string;
        /**
         * The type of storage.
         */
        storageType: string;
    }

    export interface CloudServersCloudServerStorageDataDiskList {
        /**
         * The capacity of storage.
         */
        capacity: string;
        /**
         * The type of storage.
         */
        storageType: string;
    }

    export interface CloudServersCloudServerStorageSystemDisk {
        /**
         * The capacity of storage.
         */
        capacity: string;
        /**
         * The type of storage.
         */
        storageType: string;
    }

    export interface GetAvailableResourcesRegion {
        /**
         * The config of area.
         */
        area: outputs.veenedge.GetAvailableResourcesRegionArea;
        /**
         * The config of city.
         */
        city: outputs.veenedge.GetAvailableResourcesRegionCity;
        /**
         * The config of cluster.
         */
        cluster: outputs.veenedge.GetAvailableResourcesRegionCluster;
        /**
         * The config of country.
         */
        country: outputs.veenedge.GetAvailableResourcesRegionCountry;
        /**
         * The config of isp.
         */
        isp: outputs.veenedge.GetAvailableResourcesRegionIsp;
    }

    export interface GetAvailableResourcesRegionArea {
        /**
         * The english name of region.
         */
        enName: string;
        /**
         * The id of region.
         */
        id: string;
        /**
         * The name of region.
         */
        name: string;
    }

    export interface GetAvailableResourcesRegionCity {
        /**
         * The english name of region.
         */
        enName: string;
        /**
         * The id of region.
         */
        id: string;
        /**
         * The name of region.
         */
        name: string;
    }

    export interface GetAvailableResourcesRegionCluster {
        /**
         * The english name of region.
         */
        enName: string;
        /**
         * The id of region.
         */
        id: string;
        /**
         * The name of region.
         */
        name: string;
    }

    export interface GetAvailableResourcesRegionCountry {
        /**
         * The english name of region.
         */
        enName: string;
        /**
         * The id of region.
         */
        id: string;
        /**
         * The name of region.
         */
        name: string;
    }

    export interface GetAvailableResourcesRegionIsp {
        /**
         * The english name of region.
         */
        enName: string;
        /**
         * The id of region.
         */
        id: string;
        /**
         * The name of region.
         */
        name: string;
    }

    export interface GetCloudServersCloudServer {
        /**
         * The config of billing.
         */
        billingConfig: outputs.veenedge.GetCloudServersCloudServerBillingConfig;
        /**
         * The Id of cloud server.
         */
        cloudServerIdentity: string;
        /**
         * The cpu info of cloud server.
         */
        cpu: string;
        /**
         * The create time info.
         */
        createTime: number;
        /**
         * The config of custom data.
         */
        customData: outputs.veenedge.GetCloudServersCloudServerCustomData;
        /**
         * The config of gpu.
         */
        gpu: outputs.veenedge.GetCloudServersCloudServerGpu;
        /**
         * The Id of cloud server.
         */
        id: string;
        /**
         * The config of image.
         */
        image: outputs.veenedge.GetCloudServersCloudServerImage;
        /**
         * The count of instance.
         */
        instanceCount: number;
        /**
         * The status of instances.
         */
        instanceStatuses: outputs.veenedge.GetCloudServersCloudServerInstanceStatus[];
        /**
         * The memory info of cloud server.
         */
        mem: string;
        /**
         * The name of cloud server.
         */
        name: string;
        /**
         * The config of network.
         */
        network: outputs.veenedge.GetCloudServersCloudServerNetwork;
        /**
         * The config of schedule strategy.
         */
        scheduleStrategyConfigs: outputs.veenedge.GetCloudServersCloudServerScheduleStrategyConfigs;
        /**
         * The config of secret.
         */
        secretConfig: outputs.veenedge.GetCloudServersCloudServerSecretConfig;
        /**
         * The server area count number.
         */
        serverAreaCount: number;
        /**
         * The area level of cloud server.
         */
        serverAreaLevel: string;
        /**
         * The server areas info.
         */
        serverAreas: outputs.veenedge.GetCloudServersCloudServerServerArea[];
        /**
         * The spec info of cloud server.
         */
        spec: string;
        /**
         * The Chinese spec info of cloud server.
         */
        specDisplay: string;
        /**
         * The spec summary of cloud server.
         */
        specSum: {[key: string]: any};
        /**
         * The config of storage.
         */
        storage: outputs.veenedge.GetCloudServersCloudServerStorage;
        /**
         * The update time info.
         */
        updateTime: number;
    }

    export interface GetCloudServersCloudServerBillingConfig {
        /**
         * The bandwidth billing method.
         */
        bandwidthBillingMethod: string;
        /**
         * The computing billing method.
         */
        computingBillingMethod: string;
    }

    export interface GetCloudServersCloudServerCustomData {
        /**
         * The data info.
         */
        data: string;
    }

    export interface GetCloudServersCloudServerGpu {
        /**
         * The list gpu info.
         */
        gpuses: outputs.veenedge.GetCloudServersCloudServerGpuGpus[];
    }

    export interface GetCloudServersCloudServerGpuGpus {
        /**
         * The spec of gpu.
         */
        gpuSpec: outputs.veenedge.GetCloudServersCloudServerGpuGpusGpuSpec;
        /**
         * The number of gpu.
         */
        num: number;
    }

    export interface GetCloudServersCloudServerGpuGpusGpuSpec {
        /**
         * The type of gpu.
         */
        gpuType: string;
    }

    export interface GetCloudServersCloudServerImage {
        /**
         * The id of image.
         */
        imageIdentity: string;
        /**
         * The name of image.
         */
        imageName: string;
        /**
         * The property of system.
         */
        property: string;
        /**
         * The arch of system.
         */
        systemArch: string;
        /**
         * The bit of system.
         */
        systemBit: string;
        /**
         * The type of system.
         */
        systemType: string;
        /**
         * The version of system.
         */
        systemVersion: string;
    }

    export interface GetCloudServersCloudServerInstanceStatus {
        /**
         * The count of instance.
         */
        instanceCount: number;
        /**
         * The status info.
         */
        status: string;
    }

    export interface GetCloudServersCloudServerNetwork {
        /**
         * The peak of bandwidth.
         */
        bandwidthPeak: string;
        /**
         * Whether enable ipv6.
         */
        enableIpv6: boolean;
        /**
         * The internal peak of bandwidth.
         */
        internalBandwidthPeak: string;
    }

    export interface GetCloudServersCloudServerScheduleStrategyConfigs {
        /**
         * The price strategy.
         */
        priceStrategy: string;
        /**
         * The schedule strategy.
         */
        scheduleStrategy: string;
    }

    export interface GetCloudServersCloudServerSecretConfig {
        /**
         * The data of secret.
         */
        secretData: string;
        /**
         * The type of secret.
         */
        secretType: number;
    }

    export interface GetCloudServersCloudServerServerArea {
        /**
         * The area info.
         */
        area: string;
        /**
         * The number of instance.
         */
        instanceNum: number;
        /**
         * The isp info.
         */
        isp: string;
    }

    export interface GetCloudServersCloudServerStorage {
        /**
         * The disk info of data.
         */
        dataDisk: outputs.veenedge.GetCloudServersCloudServerStorageDataDisk;
        /**
         * The disk list info of data.
         */
        dataDiskLists: outputs.veenedge.GetCloudServersCloudServerStorageDataDiskList[];
        /**
         * The disk info of system.
         */
        systemDisk: outputs.veenedge.GetCloudServersCloudServerStorageSystemDisk;
    }

    export interface GetCloudServersCloudServerStorageDataDisk {
        /**
         * The capacity of storage.
         */
        capacity: string;
        /**
         * The type of storage.
         */
        storageType: string;
    }

    export interface GetCloudServersCloudServerStorageDataDiskList {
        /**
         * The capacity of storage.
         */
        capacity: string;
        /**
         * The type of storage.
         */
        storageType: string;
    }

    export interface GetCloudServersCloudServerStorageSystemDisk {
        /**
         * The capacity of storage.
         */
        capacity: string;
        /**
         * The type of storage.
         */
        storageType: string;
    }

    export interface GetInstanceTypesInstanceTypeConfig {
        /**
         * The cpu of instance type.
         */
        cpu: number;
        /**
         * The gpu of instance type.
         */
        gpu: number;
        /**
         * The gpu spec of instance.
         */
        gpuSpec: string;
        /**
         * The type of instance.
         */
        instanceType: string;
        /**
         * The type family of instance.
         */
        instanceTypeFamily: string;
        /**
         * The name of instance type family.
         */
        instanceTypeFamilyName: string;
        /**
         * The memory of instance type.
         */
        memory: number;
        /**
         * The config of storage.
         */
        storages: outputs.veenedge.GetInstanceTypesInstanceTypeConfigStorage[];
    }

    export interface GetInstanceTypesInstanceTypeConfigStorage {
        /**
         * The amount of local storage.
         */
        localStorageAmount: number;
        /**
         * The capacity of local storage.
         */
        localStorageCapacity: number;
        /**
         * The local storage category.
         */
        localStorageCategory: string;
        /**
         * The unit of local storage.
         */
        localStorageUnit: string;
    }

    export interface GetInstancesInstance {
        /**
         * The id of cloud server.
         */
        cloudServerIdentity: string;
        /**
         * The name of cloud server.
         */
        cloudServerName: string;
        /**
         * The cluster info.
         */
        cluster: outputs.veenedge.GetInstancesInstanceCluster;
        /**
         * The cpu of instance.
         */
        cpu: string;
        /**
         * The create time of instance.
         */
        createTime: number;
        /**
         * The creator of instance.
         */
        creator: string;
        /**
         * The delete time of instance.
         */
        deleteTime: number;
        /**
         * The end time of instance.
         */
        endTime: number;
        /**
         * The config of gpu.
         */
        gpu: outputs.veenedge.GetInstancesInstanceGpu;
        /**
         * The Id of instance.
         */
        id: string;
        /**
         * The config of image.
         */
        image: outputs.veenedge.GetInstancesInstanceImage;
        /**
         * The Id of instance.
         */
        instanceIdentity: string;
        /**
         * The name of instance.
         */
        instanceName: string;
        /**
         * The memory of instance.
         */
        mem: string;
        /**
         * The config of network.
         */
        network: outputs.veenedge.GetInstancesInstanceNetwork;
        /**
         * The spec of instance.
         */
        spec: string;
        /**
         * The spec display of instance.
         */
        specDisplay: string;
        /**
         * The start time of instance.
         */
        startTime: number;
        /**
         * The status of instance.
         */
        status: string;
        /**
         * The config of storage.
         */
        storage: outputs.veenedge.GetInstancesInstanceStorage;
        /**
         * The subnet cidr.
         */
        subnetCidr: string;
        /**
         * The update time of instance.
         */
        updateTime: number;
        /**
         * The id of vpc.
         */
        vpcIdentity: string;
    }

    export interface GetInstancesInstanceCluster {
        /**
         * The alias of cluster.
         */
        alias: string;
        /**
         * The city of cluster.
         */
        city: string;
        /**
         * The name of cluster.
         */
        clusterName: string;
        /**
         * The country of cluster.
         */
        country: string;
        /**
         * The isp info.
         */
        isp: string;
        /**
         * The level of cluster.
         */
        level: string;
        /**
         * The province of cluster.
         */
        province: string;
        /**
         * The region of cluster.
         */
        region: string;
    }

    export interface GetInstancesInstanceGpu {
        /**
         * The list gpu info.
         */
        gpuses: outputs.veenedge.GetInstancesInstanceGpuGpus[];
    }

    export interface GetInstancesInstanceGpuGpus {
        /**
         * The spec of gpu.
         */
        gpuSpec: outputs.veenedge.GetInstancesInstanceGpuGpusGpuSpec;
        /**
         * The number of gpu.
         */
        num: number;
    }

    export interface GetInstancesInstanceGpuGpusGpuSpec {
        /**
         * The type of gpu.
         */
        gpuType: string;
    }

    export interface GetInstancesInstanceImage {
        /**
         * The id of image.
         */
        imageIdentity: string;
        /**
         * The name of image.
         */
        imageName: string;
        /**
         * The property of system.
         */
        property: string;
        /**
         * The arch of system.
         */
        systemArch: string;
        /**
         * The bit of system.
         */
        systemBit: string;
        /**
         * The type of system.
         */
        systemType: string;
        /**
         * The version of system.
         */
        systemVersion: string;
    }

    export interface GetInstancesInstanceNetwork {
        /**
         * Whether enable ipv6.
         */
        enableIpv6: boolean;
        /**
         * The external interface of network.
         */
        externalInterface: outputs.veenedge.GetInstancesInstanceNetworkExternalInterface;
        /**
         * The internal interface of network.
         */
        internalInterface: outputs.veenedge.GetInstancesInstanceNetworkInternalInterface;
        /**
         * The passthrough info.
         */
        vfPassthrough: boolean;
    }

    export interface GetInstancesInstanceNetworkExternalInterface {
        /**
         * The peak of bandwidth.
         */
        bandwidthPeak: string;
        /**
         * The ipv6 address.
         */
        ip6Addr: string;
        /**
         * The ip address.
         */
        ipAddr: string;
        /**
         * The ips of network.
         */
        ips: outputs.veenedge.GetInstancesInstanceNetworkExternalInterfaceIp[];
        /**
         * The mac address.
         */
        macAddr: string;
        /**
         * The mask info.
         */
        mask: string;
        /**
         * The ipv6 mask info.
         */
        mask6: string;
    }

    export interface GetInstancesInstanceNetworkExternalInterfaceIp {
        /**
         * The ip address.
         */
        addr: string;
        /**
         * The version of ip address.
         */
        ipVersion: string;
        /**
         * The isp info.
         */
        isp: string;
        /**
         * The mask info.
         */
        mask: string;
    }

    export interface GetInstancesInstanceNetworkInternalInterface {
        /**
         * The peak of bandwidth.
         */
        bandwidthPeak: string;
        /**
         * The ipv6 address.
         */
        ip6Addr: string;
        /**
         * The ip address.
         */
        ipAddr: string;
        /**
         * The ips of network.
         */
        ips: outputs.veenedge.GetInstancesInstanceNetworkInternalInterfaceIp[];
        /**
         * The mac address.
         */
        macAddr: string;
        /**
         * The mask info.
         */
        mask: string;
        /**
         * The ipv6 mask info.
         */
        mask6: string;
    }

    export interface GetInstancesInstanceNetworkInternalInterfaceIp {
        /**
         * The ip address.
         */
        addr: string;
        /**
         * The version of ip address.
         */
        ipVersion: string;
        /**
         * The isp info.
         */
        isp: string;
        /**
         * The mask info.
         */
        mask: string;
    }

    export interface GetInstancesInstanceStorage {
        /**
         * The disk info of data.
         */
        dataDisk: outputs.veenedge.GetInstancesInstanceStorageDataDisk;
        /**
         * The disk list info of data.
         */
        dataDiskLists: outputs.veenedge.GetInstancesInstanceStorageDataDiskList[];
        /**
         * The disk info of system.
         */
        systemDisk: outputs.veenedge.GetInstancesInstanceStorageSystemDisk;
    }

    export interface GetInstancesInstanceStorageDataDisk {
        /**
         * The capacity of storage.
         */
        capacity: string;
        /**
         * The type of storage.
         */
        storageType: string;
    }

    export interface GetInstancesInstanceStorageDataDiskList {
        /**
         * The capacity of storage.
         */
        capacity: string;
        /**
         * The type of storage.
         */
        storageType: string;
    }

    export interface GetInstancesInstanceStorageSystemDisk {
        /**
         * The capacity of storage.
         */
        capacity: string;
        /**
         * The type of storage.
         */
        storageType: string;
    }

    export interface GetVpcsVpcInstance {
        /**
         * The account id.
         */
        accountIdentity: number;
        /**
         * The cluster info.
         */
        cluster: outputs.veenedge.GetVpcsVpcInstanceCluster;
        /**
         * The cluster vpc id.
         */
        clusterVpcId: number;
        /**
         * The creation time.
         */
        createTime: number;
        /**
         * The description of VPC.
         */
        desc: string;
        /**
         * The ID of VPC.
         */
        id: string;
        /**
         * Is default vpc.
         */
        isDefault: boolean;
        /**
         * The resource statistic info.
         */
        resourceStatistics: outputs.veenedge.GetVpcsVpcInstanceResourceStatistic[];
        /**
         * The status of VPC.
         */
        status: string;
        /**
         * The subnets info.
         */
        subNets: outputs.veenedge.GetVpcsVpcInstanceSubNet[];
        /**
         * The update time of VPC.
         */
        updateTime: number;
        /**
         * The id of user.
         */
        userIdentity: number;
        /**
         * The ID of VPC.
         */
        vpcIdentity: string;
        /**
         * The name of VPC.
         */
        vpcName: string;
        /**
         * The namespace of VPC.
         */
        vpcNs: string;
    }

    export interface GetVpcsVpcInstanceCluster {
        /**
         * The alias of cluster.
         */
        alias: string;
        /**
         * The city of cluster.
         */
        city: string;
        /**
         * The name of cluster.
         */
        clusterName: string;
        /**
         * The country of cluster.
         */
        country: string;
        /**
         * The isp of cluster.
         */
        isp: string;
        /**
         * The level of cluster.
         */
        level: string;
        /**
         * The province of cluster.
         */
        province: string;
        /**
         * The region of cluster.
         */
        region: string;
    }

    export interface GetVpcsVpcInstanceResourceStatistic {
        /**
         * The count of instance.
         */
        veenInstanceCount: number;
        /**
         * The count of load balancers.
         */
        veewLbInstanceCount: number;
        /**
         * The count of security groups.
         */
        veewSgInstanceCount: number;
    }

    export interface GetVpcsVpcInstanceSubNet {
        /**
         * The account id.
         */
        accountIdentity: number;
        /**
         * The ip of cidr.
         */
        cidrIp: string;
        /**
         * The mask of cidr.
         */
        cidrMask: number;
        /**
         * The creation time.
         */
        createTime: number;
        /**
         * The id of subnet.
         */
        subnetIdentity: string;
        /**
         * The update time of VPC.
         */
        updateTime: number;
        /**
         * The id of user.
         */
        userIdentity: number;
    }

    export interface InstanceTypesInstanceTypeConfig {
        /**
         * The cpu of instance type.
         */
        cpu: number;
        /**
         * The gpu of instance type.
         */
        gpu: number;
        /**
         * The gpu spec of instance.
         */
        gpuSpec: string;
        /**
         * The type of instance.
         */
        instanceType: string;
        /**
         * The type family of instance.
         */
        instanceTypeFamily: string;
        /**
         * The name of instance type family.
         */
        instanceTypeFamilyName: string;
        /**
         * The memory of instance type.
         */
        memory: number;
        /**
         * The config of storage.
         */
        storages: outputs.veenedge.InstanceTypesInstanceTypeConfigStorage[];
    }

    export interface InstanceTypesInstanceTypeConfigStorage {
        /**
         * The amount of local storage.
         */
        localStorageAmount: number;
        /**
         * The capacity of local storage.
         */
        localStorageCapacity: number;
        /**
         * The local storage category.
         */
        localStorageCategory: string;
        /**
         * The unit of local storage.
         */
        localStorageUnit: string;
    }

    export interface InstancesInstance {
        /**
         * The id of cloud server.
         */
        cloudServerIdentity: string;
        /**
         * The name of cloud server.
         */
        cloudServerName: string;
        /**
         * The cluster info.
         */
        cluster: outputs.veenedge.InstancesInstanceCluster;
        /**
         * The cpu of instance.
         */
        cpu: string;
        /**
         * The create time of instance.
         */
        createTime: number;
        /**
         * The creator of instance.
         */
        creator: string;
        /**
         * The delete time of instance.
         */
        deleteTime: number;
        /**
         * The end time of instance.
         */
        endTime: number;
        /**
         * The config of gpu.
         */
        gpu: outputs.veenedge.InstancesInstanceGpu;
        /**
         * The Id of instance.
         */
        id: string;
        /**
         * The config of image.
         */
        image: outputs.veenedge.InstancesInstanceImage;
        /**
         * The Id of instance.
         */
        instanceIdentity: string;
        /**
         * The name of instance.
         */
        instanceName: string;
        /**
         * The memory of instance.
         */
        mem: string;
        /**
         * The config of network.
         */
        network: outputs.veenedge.InstancesInstanceNetwork;
        /**
         * The spec of instance.
         */
        spec: string;
        /**
         * The spec display of instance.
         */
        specDisplay: string;
        /**
         * The start time of instance.
         */
        startTime: number;
        /**
         * The status of instance.
         */
        status: string;
        /**
         * The config of storage.
         */
        storage: outputs.veenedge.InstancesInstanceStorage;
        /**
         * The subnet cidr.
         */
        subnetCidr: string;
        /**
         * The update time of instance.
         */
        updateTime: number;
        /**
         * The id of vpc.
         */
        vpcIdentity: string;
    }

    export interface InstancesInstanceCluster {
        /**
         * The alias of cluster.
         */
        alias: string;
        /**
         * The city of cluster.
         */
        city: string;
        /**
         * The name of cluster.
         */
        clusterName: string;
        /**
         * The country of cluster.
         */
        country: string;
        /**
         * The isp info.
         */
        isp: string;
        /**
         * The level of cluster.
         */
        level: string;
        /**
         * The province of cluster.
         */
        province: string;
        /**
         * The region of cluster.
         */
        region: string;
    }

    export interface InstancesInstanceGpu {
        /**
         * The list gpu info.
         */
        gpuses: outputs.veenedge.InstancesInstanceGpuGpus[];
    }

    export interface InstancesInstanceGpuGpus {
        /**
         * The spec of gpu.
         */
        gpuSpec: outputs.veenedge.InstancesInstanceGpuGpusGpuSpec;
        /**
         * The number of gpu.
         */
        num: number;
    }

    export interface InstancesInstanceGpuGpusGpuSpec {
        /**
         * The type of gpu.
         */
        gpuType: string;
    }

    export interface InstancesInstanceImage {
        /**
         * The id of image.
         */
        imageIdentity: string;
        /**
         * The name of image.
         */
        imageName: string;
        /**
         * The property of system.
         */
        property: string;
        /**
         * The arch of system.
         */
        systemArch: string;
        /**
         * The bit of system.
         */
        systemBit: string;
        /**
         * The type of system.
         */
        systemType: string;
        /**
         * The version of system.
         */
        systemVersion: string;
    }

    export interface InstancesInstanceNetwork {
        /**
         * Whether enable ipv6.
         */
        enableIpv6: boolean;
        /**
         * The external interface of network.
         */
        externalInterface: outputs.veenedge.InstancesInstanceNetworkExternalInterface;
        /**
         * The internal interface of network.
         */
        internalInterface: outputs.veenedge.InstancesInstanceNetworkInternalInterface;
        /**
         * The passthrough info.
         */
        vfPassthrough: boolean;
    }

    export interface InstancesInstanceNetworkExternalInterface {
        /**
         * The peak of bandwidth.
         */
        bandwidthPeak: string;
        /**
         * The ipv6 address.
         */
        ip6Addr: string;
        /**
         * The ip address.
         */
        ipAddr: string;
        /**
         * The ips of network.
         */
        ips: outputs.veenedge.InstancesInstanceNetworkExternalInterfaceIp[];
        /**
         * The mac address.
         */
        macAddr: string;
        /**
         * The mask info.
         */
        mask: string;
        /**
         * The ipv6 mask info.
         */
        mask6: string;
    }

    export interface InstancesInstanceNetworkExternalInterfaceIp {
        /**
         * The ip address.
         */
        addr: string;
        /**
         * The version of ip address.
         */
        ipVersion: string;
        /**
         * The isp info.
         */
        isp: string;
        /**
         * The mask info.
         */
        mask: string;
    }

    export interface InstancesInstanceNetworkInternalInterface {
        /**
         * The peak of bandwidth.
         */
        bandwidthPeak: string;
        /**
         * The ipv6 address.
         */
        ip6Addr: string;
        /**
         * The ip address.
         */
        ipAddr: string;
        /**
         * The ips of network.
         */
        ips: outputs.veenedge.InstancesInstanceNetworkInternalInterfaceIp[];
        /**
         * The mac address.
         */
        macAddr: string;
        /**
         * The mask info.
         */
        mask: string;
        /**
         * The ipv6 mask info.
         */
        mask6: string;
    }

    export interface InstancesInstanceNetworkInternalInterfaceIp {
        /**
         * The ip address.
         */
        addr: string;
        /**
         * The version of ip address.
         */
        ipVersion: string;
        /**
         * The isp info.
         */
        isp: string;
        /**
         * The mask info.
         */
        mask: string;
    }

    export interface InstancesInstanceStorage {
        /**
         * The disk info of data.
         */
        dataDisk: outputs.veenedge.InstancesInstanceStorageDataDisk;
        /**
         * The disk list info of data.
         */
        dataDiskLists: outputs.veenedge.InstancesInstanceStorageDataDiskList[];
        /**
         * The disk info of system.
         */
        systemDisk: outputs.veenedge.InstancesInstanceStorageSystemDisk;
    }

    export interface InstancesInstanceStorageDataDisk {
        /**
         * The capacity of storage.
         */
        capacity: string;
        /**
         * The type of storage.
         */
        storageType: string;
    }

    export interface InstancesInstanceStorageDataDiskList {
        /**
         * The capacity of storage.
         */
        capacity: string;
        /**
         * The type of storage.
         */
        storageType: string;
    }

    export interface InstancesInstanceStorageSystemDisk {
        /**
         * The capacity of storage.
         */
        capacity: string;
        /**
         * The type of storage.
         */
        storageType: string;
    }

    export interface VpcsVpcInstance {
        /**
         * The account id.
         */
        accountIdentity: number;
        /**
         * The cluster info.
         */
        cluster: outputs.veenedge.VpcsVpcInstanceCluster;
        /**
         * The cluster vpc id.
         */
        clusterVpcId: number;
        /**
         * The creation time.
         */
        createTime: number;
        /**
         * The description of VPC.
         */
        desc: string;
        /**
         * The ID of VPC.
         */
        id: string;
        /**
         * Is default vpc.
         */
        isDefault: boolean;
        /**
         * The resource statistic info.
         */
        resourceStatistics: outputs.veenedge.VpcsVpcInstanceResourceStatistic[];
        /**
         * The status of VPC.
         */
        status: string;
        /**
         * The subnets info.
         */
        subNets: outputs.veenedge.VpcsVpcInstanceSubNet[];
        /**
         * The update time of VPC.
         */
        updateTime: number;
        /**
         * The id of user.
         */
        userIdentity: number;
        /**
         * The ID of VPC.
         */
        vpcIdentity: string;
        /**
         * The name of VPC.
         */
        vpcName: string;
        /**
         * The namespace of VPC.
         */
        vpcNs: string;
    }

    export interface VpcsVpcInstanceCluster {
        /**
         * The alias of cluster.
         */
        alias: string;
        /**
         * The city of cluster.
         */
        city: string;
        /**
         * The name of cluster.
         */
        clusterName: string;
        /**
         * The country of cluster.
         */
        country: string;
        /**
         * The isp of cluster.
         */
        isp: string;
        /**
         * The level of cluster.
         */
        level: string;
        /**
         * The province of cluster.
         */
        province: string;
        /**
         * The region of cluster.
         */
        region: string;
    }

    export interface VpcsVpcInstanceResourceStatistic {
        /**
         * The count of instance.
         */
        veenInstanceCount: number;
        /**
         * The count of load balancers.
         */
        veewLbInstanceCount: number;
        /**
         * The count of security groups.
         */
        veewSgInstanceCount: number;
    }

    export interface VpcsVpcInstanceSubNet {
        /**
         * The account id.
         */
        accountIdentity: number;
        /**
         * The ip of cidr.
         */
        cidrIp: string;
        /**
         * The mask of cidr.
         */
        cidrMask: number;
        /**
         * The creation time.
         */
        createTime: number;
        /**
         * The id of subnet.
         */
        subnetIdentity: string;
        /**
         * The update time of VPC.
         */
        updateTime: number;
        /**
         * The id of user.
         */
        userIdentity: number;
    }

}

export namespace vefaas {
    export interface FunctionEnv {
        /**
         * The Key of the environment variable.
         */
        key: string;
        /**
         * The Value of the environment variable.
         */
        value: string;
    }

    export interface FunctionNasStorage {
        /**
         * Whether to enable NAS storage mounting.
         */
        enableNas: boolean;
        /**
         * The configuration of NAS.
         */
        nasConfigs?: outputs.vefaas.FunctionNasStorageNasConfig[];
    }

    export interface FunctionNasStorageNasConfig {
        /**
         * The ID of NAS file system.
         */
        fileSystemId: string;
        /**
         * The directory of Function local mount.
         */
        localMountPath: string;
        /**
         * The ID of NAS mount point.
         */
        mountPointId: string;
        /**
         * Remote directory of the file system.
         */
        remotePath: string;
    }

    export interface FunctionSourceAccessConfig {
        /**
         * The image repository password.
         */
        password: boolean;
        /**
         * Mirror repository username.
         */
        username: string;
    }

    export interface FunctionTlsConfig {
        /**
         * TLS log function switch.
         */
        enableLog: boolean;
        /**
         * The project ID of TLS log topic.
         */
        tlsProjectId?: string;
        /**
         * The topic ID of TLS log topic.
         */
        tlsTopicId?: string;
    }

    export interface FunctionTosMountConfig {
        /**
         * After enabling TOS, you need to provide an AKSK with access rights to the TOS domain name. When importing resources, this attribute will not be imported. If this attribute is set, please use lifecycle and ignoreChanges ignore changes in fields.
         */
        credentials?: outputs.vefaas.FunctionTosMountConfigCredentials;
        /**
         * Whether to enable TOS storage mounting.
         */
        enableTos: boolean;
        /**
         * After enabling TOS, you need to provide a TOS storage configuration list, with a maximum of 5 items.
         */
        mountPoints?: outputs.vefaas.FunctionTosMountConfigMountPoint[];
    }

    export interface FunctionTosMountConfigCredentials {
        /**
         * The AccessKey ID (AK) of the Volcano Engine account.
         */
        accessKeyId: string;
        /**
         * The Secret Access Key (SK) of the Volcano Engine account.
         */
        secretAccessKey: string;
    }

    export interface FunctionTosMountConfigMountPoint {
        /**
         * TOS bucket.
         */
        bucketName: string;
        /**
         * The mounted TOS Bucket path.
         */
        bucketPath: string;
        /**
         * TOS Access domain name.
         */
        endpoint: string;
        /**
         * Function local mount directory.
         */
        localMountPath: string;
        /**
         * Function local directory access permissions. After mounting the TOS Bucket, whether the function local mount directory has read-only permissions.
         */
        readOnly?: boolean;
    }

    export interface FunctionVpcConfig {
        /**
         * Function access to the public network switch.
         */
        enableSharedInternetAccess?: boolean;
        /**
         * Whether the function enables private network access.
         */
        enableVpc: boolean;
        /**
         * The ID of security group.
         */
        securityGroupIds?: string[];
        /**
         * The ID of subnet.
         */
        subnetIds?: string[];
        /**
         * The ID of VPC.
         */
        vpcId?: string;
    }

    export interface FunctionsItem {
        /**
         * The size of code package.
         */
        codeSize: number;
        /**
         * Maximum code package size.
         */
        codeSizeLimit: number;
        /**
         * The custom startup command for the instance.
         */
        command: string;
        /**
         * Function CPU charging policy.
         */
        cpuStrategy: string;
        /**
         * Creation time.
         */
        creationTime: string;
        /**
         * The description of Function.
         */
        description: string;
        /**
         * Function environment variable.
         */
        envs: outputs.vefaas.FunctionsItemEnv[];
        /**
         * Exclusive mode switch.
         */
        exclusiveMode: boolean;
        /**
         * The ID of Function.
         */
        id: string;
        /**
         * Function to initialize timeout configuration.
         */
        initializerSec: number;
        /**
         * The instance type of the function instance.
         */
        instanceType: string;
        /**
         * Update time.
         */
        lastUpdateTime: string;
        /**
         * Maximum concurrency of a single instance.
         */
        maxConcurrency: number;
        /**
         * Maximum memory for a single instance.
         */
        memoryMb: number;
        /**
         * The name of Function.
         */
        name: string;
        /**
         * The configuration of file storage NAS mount.
         */
        nasStorages: outputs.vefaas.FunctionsItemNasStorage[];
        /**
         * The owner of Function.
         */
        owner: string;
        /**
         * Custom listening port for the instance.
         */
        port: number;
        /**
         * Request timeout (in seconds).
         */
        requestTimeout: number;
        /**
         * The runtime of Function.
         */
        runtime: string;
        /**
         * The source address of the code/image.
         */
        sourceLocation: string;
        /**
         * Code Source type, supports tos, zip, image (whitelist accounts support native/v1 custom images).
         */
        sourceType: string;
        /**
         * Tags.
         */
        tags: outputs.vefaas.FunctionsItemTag[];
        /**
         * Function log configuration.
         */
        tlsConfigs: outputs.vefaas.FunctionsItemTlsConfig[];
        /**
         * The configuration of Object Storage TOS mount.
         */
        tosMountConfigs: outputs.vefaas.FunctionsItemTosMountConfig[];
        /**
         * The number of triggers for this Function.
         */
        triggersCount: number;
        /**
         * The configuration of VPC.
         */
        vpcConfigs: outputs.vefaas.FunctionsItemVpcConfig[];
    }

    export interface FunctionsItemEnv {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface FunctionsItemNasStorage {
        /**
         * Whether to enable NAS storage mounting.
         */
        enableNas: boolean;
        /**
         * The configuration of NAS.
         */
        nasConfigs: outputs.vefaas.FunctionsItemNasStorageNasConfig[];
    }

    export interface FunctionsItemNasStorageNasConfig {
        /**
         * The ID of NAS file system.
         */
        fileSystemId: string;
        /**
         * User groups in the file system. Customization is not supported yet. If this parameter is provided, the parameter value is 1000 (consistent with the function run user gid).
         */
        gid: number;
        /**
         * Function local mount directory.
         */
        localMountPath: string;
        /**
         * The ID of NAS mount point.
         */
        mountPointId: string;
        /**
         * Remote directory of the file system.
         */
        remotePath: string;
        /**
         * Users in the file system do not support customization yet. If this parameter is provided, its value can only be 1000 (consistent with the function run user uid).
         */
        uid: number;
    }

    export interface FunctionsItemTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface FunctionsItemTlsConfig {
        /**
         * TLS log function switch.
         */
        enableLog: boolean;
        /**
         * The project ID of TLS log topic.
         */
        tlsProjectId: string;
        /**
         * The topic ID of TLS log topic.
         */
        tlsTopicId: string;
    }

    export interface FunctionsItemTosMountConfig {
        /**
         * After enabling TOS, you need to provide an AKSK with access rights to the TOS domain name.
         */
        credentials: outputs.vefaas.FunctionsItemTosMountConfigCredential[];
        /**
         * Whether to enable TOS storage mounting.
         */
        enableTos: boolean;
        /**
         * After enabling TOS, you need to provide a TOS storage configuration list, with a maximum of 5 items.
         */
        mountPoints: outputs.vefaas.FunctionsItemTosMountConfigMountPoint[];
    }

    export interface FunctionsItemTosMountConfigCredential {
        /**
         * The AccessKey ID (AK) of the Volcano Engine account.
         */
        accessKeyId: string;
        /**
         * The Secret Access Key (SK) of the Volcano Engine account.
         */
        secretAccessKey: string;
    }

    export interface FunctionsItemTosMountConfigMountPoint {
        /**
         * TOS bucket.
         */
        bucketName: string;
        /**
         * The mounted TOS Bucket path.
         */
        bucketPath: string;
        /**
         * TOS Access domain name.
         */
        endpoint: string;
        /**
         * Function local mount directory.
         */
        localMountPath: string;
        /**
         * Function local directory access permissions. After mounting the TOS Bucket, whether the function local mount directory has read-only permissions.
         */
        readOnly: boolean;
    }

    export interface FunctionsItemVpcConfig {
        /**
         * Function access to the public network switch.
         */
        enableSharedInternetAccess: boolean;
        /**
         * Whether the function enables private network access.
         */
        enableVpc: boolean;
        /**
         * The ID of security group.
         */
        securityGroupIds: string[];
        /**
         * The ID of subnet.
         */
        subnetIds: string[];
        /**
         * The ID of VPC.
         */
        vpcId: string;
    }

    export interface GetFunctionsItem {
        /**
         * The size of code package.
         */
        codeSize: number;
        /**
         * Maximum code package size.
         */
        codeSizeLimit: number;
        /**
         * The custom startup command for the instance.
         */
        command: string;
        /**
         * Function CPU charging policy.
         */
        cpuStrategy: string;
        /**
         * Creation time.
         */
        creationTime: string;
        /**
         * The description of Function.
         */
        description: string;
        /**
         * Function environment variable.
         */
        envs: outputs.vefaas.GetFunctionsItemEnv[];
        /**
         * Exclusive mode switch.
         */
        exclusiveMode: boolean;
        /**
         * The ID of Function.
         */
        id: string;
        /**
         * Function to initialize timeout configuration.
         */
        initializerSec: number;
        /**
         * The instance type of the function instance.
         */
        instanceType: string;
        /**
         * Update time.
         */
        lastUpdateTime: string;
        /**
         * Maximum concurrency of a single instance.
         */
        maxConcurrency: number;
        /**
         * Maximum memory for a single instance.
         */
        memoryMb: number;
        /**
         * The name of Function.
         */
        name: string;
        /**
         * The configuration of file storage NAS mount.
         */
        nasStorages: outputs.vefaas.GetFunctionsItemNasStorage[];
        /**
         * The owner of Function.
         */
        owner: string;
        /**
         * Custom listening port for the instance.
         */
        port: number;
        /**
         * Request timeout (in seconds).
         */
        requestTimeout: number;
        /**
         * The runtime of Function.
         */
        runtime: string;
        /**
         * The source address of the code/image.
         */
        sourceLocation: string;
        /**
         * Code Source type, supports tos, zip, image (whitelist accounts support native/v1 custom images).
         */
        sourceType: string;
        /**
         * Tags.
         */
        tags: outputs.vefaas.GetFunctionsItemTag[];
        /**
         * Function log configuration.
         */
        tlsConfigs: outputs.vefaas.GetFunctionsItemTlsConfig[];
        /**
         * The configuration of Object Storage TOS mount.
         */
        tosMountConfigs: outputs.vefaas.GetFunctionsItemTosMountConfig[];
        /**
         * The number of triggers for this Function.
         */
        triggersCount: number;
        /**
         * The configuration of VPC.
         */
        vpcConfigs: outputs.vefaas.GetFunctionsItemVpcConfig[];
    }

    export interface GetFunctionsItemEnv {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetFunctionsItemNasStorage {
        /**
         * Whether to enable NAS storage mounting.
         */
        enableNas: boolean;
        /**
         * The configuration of NAS.
         */
        nasConfigs: outputs.vefaas.GetFunctionsItemNasStorageNasConfig[];
    }

    export interface GetFunctionsItemNasStorageNasConfig {
        /**
         * The ID of NAS file system.
         */
        fileSystemId: string;
        /**
         * User groups in the file system. Customization is not supported yet. If this parameter is provided, the parameter value is 1000 (consistent with the function run user gid).
         */
        gid: number;
        /**
         * Function local mount directory.
         */
        localMountPath: string;
        /**
         * The ID of NAS mount point.
         */
        mountPointId: string;
        /**
         * Remote directory of the file system.
         */
        remotePath: string;
        /**
         * Users in the file system do not support customization yet. If this parameter is provided, its value can only be 1000 (consistent with the function run user uid).
         */
        uid: number;
    }

    export interface GetFunctionsItemTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetFunctionsItemTlsConfig {
        /**
         * TLS log function switch.
         */
        enableLog: boolean;
        /**
         * The project ID of TLS log topic.
         */
        tlsProjectId: string;
        /**
         * The topic ID of TLS log topic.
         */
        tlsTopicId: string;
    }

    export interface GetFunctionsItemTosMountConfig {
        /**
         * After enabling TOS, you need to provide an AKSK with access rights to the TOS domain name.
         */
        credentials: outputs.vefaas.GetFunctionsItemTosMountConfigCredential[];
        /**
         * Whether to enable TOS storage mounting.
         */
        enableTos: boolean;
        /**
         * After enabling TOS, you need to provide a TOS storage configuration list, with a maximum of 5 items.
         */
        mountPoints: outputs.vefaas.GetFunctionsItemTosMountConfigMountPoint[];
    }

    export interface GetFunctionsItemTosMountConfigCredential {
        /**
         * The AccessKey ID (AK) of the Volcano Engine account.
         */
        accessKeyId: string;
        /**
         * The Secret Access Key (SK) of the Volcano Engine account.
         */
        secretAccessKey: string;
    }

    export interface GetFunctionsItemTosMountConfigMountPoint {
        /**
         * TOS bucket.
         */
        bucketName: string;
        /**
         * The mounted TOS Bucket path.
         */
        bucketPath: string;
        /**
         * TOS Access domain name.
         */
        endpoint: string;
        /**
         * Function local mount directory.
         */
        localMountPath: string;
        /**
         * Function local directory access permissions. After mounting the TOS Bucket, whether the function local mount directory has read-only permissions.
         */
        readOnly: boolean;
    }

    export interface GetFunctionsItemVpcConfig {
        /**
         * Function access to the public network switch.
         */
        enableSharedInternetAccess: boolean;
        /**
         * Whether the function enables private network access.
         */
        enableVpc: boolean;
        /**
         * The ID of security group.
         */
        securityGroupIds: string[];
        /**
         * The ID of subnet.
         */
        subnetIds: string[];
        /**
         * The ID of VPC.
         */
        vpcId: string;
    }

    export interface GetKafkaTriggersItem {
        /**
         * The ID of account.
         */
        accountId: string;
        /**
         * The creation time of the Timer trigger.
         */
        creationTime: string;
        /**
         * The description of the Timer trigger.
         */
        description: string;
        /**
         * The details of trigger configuration.
         */
        detailedConfig: string;
        /**
         * Whether the Timer trigger is enabled.
         */
        enabled: boolean;
        /**
         * The ID of Function.
         */
        functionId: string;
        /**
         * The ID of the Timer trigger.
         */
        id: string;
        /**
         * The image version of the Timer trigger.
         */
        imageVersion: string;
        /**
         * The last update time of the Timer trigger.
         */
        lastUpdateTime: string;
        /**
         * The name of the Timer trigger.
         */
        name: string;
        /**
         * The category of the Timer trigger.
         */
        type: string;
    }

    export interface GetReleasesFilter {
        /**
         * Filter key enumeration.
         */
        name?: string;
        /**
         * The filtering value of the query.
         */
        values?: string[];
    }

    export interface GetReleasesItem {
        /**
         * The create time of the published information.
         */
        creationTime: string;
        /**
         * The description of the published information.
         */
        description: string;
        /**
         * Finish time.
         */
        finishTime: string;
        /**
         * The ID of Function.
         */
        functionId: string;
        /**
         * The ID of function release.
         */
        id: string;
        /**
         * The last update time of the published information.
         */
        lastUpdateTime: string;
        /**
         * The historical version numbers released.
         */
        sourceRevisionNumber: number;
        /**
         * The status of function release.
         */
        status: string;
        /**
         * The target version number released.
         */
        targetRevisionNumber: number;
    }

    export interface GetReleasesOrderBy {
        /**
         * Whether the sorting result is sorted in ascending order.
         */
        ascend?: boolean;
        /**
         * Key names used for sorting.
         */
        key?: string;
    }

    export interface GetTimersItem {
        /**
         * The ID of account.
         */
        accountId: string;
        /**
         * The creation time of the Timer trigger.
         */
        creationTime: string;
        /**
         * The description of the Timer trigger.
         */
        description: string;
        /**
         * The details of trigger configuration.
         */
        detailedConfig: string;
        /**
         * Whether the Timer trigger is enabled.
         */
        enabled: boolean;
        /**
         * The ID of Function.
         */
        functionId: string;
        /**
         * The ID of the Timer trigger.
         */
        id: string;
        /**
         * The image version of the Timer trigger.
         */
        imageVersion: string;
        /**
         * The last update time of the Timer trigger.
         */
        lastUpdateTime: string;
        /**
         * The name of the Timer trigger.
         */
        name: string;
        /**
         * The category of the Timer trigger.
         */
        type: string;
    }

    export interface KafkaTriggerKafkaCredentials {
        /**
         * Kafka authentication mechanism.
         */
        mechanism: string;
        /**
         * The SASL/PLAIN user password set when creating a Kafka instance.
         */
        password: string;
        /**
         * The SASL/PLAIN user name set when creating a Kafka instance.
         */
        username: string;
    }

    export interface KafkaTriggersItem {
        /**
         * The ID of account.
         */
        accountId: string;
        /**
         * The creation time of the Timer trigger.
         */
        creationTime: string;
        /**
         * The description of the Timer trigger.
         */
        description: string;
        /**
         * The details of trigger configuration.
         */
        detailedConfig: string;
        /**
         * Whether the Timer trigger is enabled.
         */
        enabled: boolean;
        /**
         * The ID of Function.
         */
        functionId: string;
        /**
         * The ID of the Timer trigger.
         */
        id: string;
        /**
         * The image version of the Timer trigger.
         */
        imageVersion: string;
        /**
         * The last update time of the Timer trigger.
         */
        lastUpdateTime: string;
        /**
         * The name of the Timer trigger.
         */
        name: string;
        /**
         * The category of the Timer trigger.
         */
        type: string;
    }

    export interface ReleasesFilter {
        /**
         * Filter key enumeration.
         */
        name?: string;
        /**
         * The filtering value of the query.
         */
        values?: string[];
    }

    export interface ReleasesItem {
        /**
         * The create time of the published information.
         */
        creationTime: string;
        /**
         * The description of the published information.
         */
        description: string;
        /**
         * Finish time.
         */
        finishTime: string;
        /**
         * The ID of Function.
         */
        functionId: string;
        /**
         * The ID of function release.
         */
        id: string;
        /**
         * The last update time of the published information.
         */
        lastUpdateTime: string;
        /**
         * The historical version numbers released.
         */
        sourceRevisionNumber: number;
        /**
         * The status of function release.
         */
        status: string;
        /**
         * The target version number released.
         */
        targetRevisionNumber: number;
    }

    export interface ReleasesOrderBy {
        /**
         * Whether the sorting result is sorted in ascending order.
         */
        ascend?: boolean;
        /**
         * Key names used for sorting.
         */
        key?: string;
    }

    export interface TimersItem {
        /**
         * The ID of account.
         */
        accountId: string;
        /**
         * The creation time of the Timer trigger.
         */
        creationTime: string;
        /**
         * The description of the Timer trigger.
         */
        description: string;
        /**
         * The details of trigger configuration.
         */
        detailedConfig: string;
        /**
         * Whether the Timer trigger is enabled.
         */
        enabled: boolean;
        /**
         * The ID of Function.
         */
        functionId: string;
        /**
         * The ID of the Timer trigger.
         */
        id: string;
        /**
         * The image version of the Timer trigger.
         */
        imageVersion: string;
        /**
         * The last update time of the Timer trigger.
         */
        lastUpdateTime: string;
        /**
         * The name of the Timer trigger.
         */
        name: string;
        /**
         * The category of the Timer trigger.
         */
        type: string;
    }

}

export namespace vepfs {
    export interface FileSystemTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface FileSystemsFileSystem {
        /**
         * The id of the account.
         */
        accountId: string;
        /**
         * The bandwidth info of the vepfs file system.
         */
        bandwidth: number;
        /**
         * The capacity info of the vepfs file system.
         */
        capacityInfo: outputs.vepfs.FileSystemsFileSystemCapacityInfo;
        /**
         * The charge status of the vepfs file system.
         */
        chargeStatus: string;
        /**
         * The charge type of the vepfs file system.
         */
        chargeType: string;
        /**
         * The create time of the vepfs file system.
         */
        createTime: string;
        /**
         * The description of the vepfs file system.
         */
        description: string;
        /**
         * The expire time of the vepfs file system.
         */
        expireTime: string;
        /**
         * The id of the vepfs file system.
         */
        fileSystemId: string;
        /**
         * The Name of Vepfs File System. This field support fuzzy query.
         */
        fileSystemName: string;
        /**
         * The type of the vepfs file system.
         */
        fileSystemType: string;
        /**
         * The free time of the vepfs file system.
         */
        freeTime: string;
        /**
         * The id of the vepfs file system.
         */
        id: string;
        /**
         * The last modify time of the vepfs file system.
         */
        lastModifyTime: string;
        /**
         * The project of Vepfs File System.
         */
        project: string;
        /**
         * The protocol type of the vepfs file system.
         */
        protocolType: string;
        /**
         * The id of the region.
         */
        regionId: string;
        /**
         * The query status list of Vepfs File System.
         */
        status: string;
        /**
         * The stop service time of the vepfs file system.
         */
        stopServiceTime: string;
        /**
         * The Store Type of Vepfs File System.
         */
        storeType: string;
        /**
         * The store type cn name of the vepfs file system.
         */
        storeTypeCn: string;
        /**
         * The tags of the vepfs file system.
         */
        tags: outputs.vepfs.FileSystemsFileSystemTag[];
        /**
         * The version info of the vepfs file system.
         */
        version: string;
        /**
         * The zone id of File System.
         */
        zoneId: string;
        /**
         * The name of the zone.
         */
        zoneName: string;
    }

    export interface FileSystemsFileSystemCapacityInfo {
        /**
         * The total size. Unit: TiB.
         */
        totalTib: number;
        /**
         * The used size. Unit: GiB.
         */
        usedGib: number;
    }

    export interface FileSystemsFileSystemTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Type of Tags.
         */
        type: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface FilesetsFileset {
        /**
         * The bandwidth Qos of the vepfs fileset.
         */
        bandwidthQos: number;
        /**
         * The capacity limit of the vepfs fileset. Unit: GiB.
         */
        capacityLimit: number;
        /**
         * The used capacity of the vepfs fileset. Unit: GiB.
         */
        capacityUsed: number;
        /**
         * The create time of the vepfs fileset.
         */
        createTime: string;
        /**
         * Quota for the number of files or directories. A return of 0 indicates that there is no quota limit set for the number of directories after the file.
         */
        fileLimit: number;
        /**
         * The used file number of the vepfs fileset.
         */
        fileUsed: number;
        /**
         * The id of Vepfs Fileset.
         */
        filesetId: string;
        /**
         * The name of Vepfs Fileset. This field support fuzzy query.
         */
        filesetName: string;
        /**
         * The path of Vepfs Fileset. This field support fuzzy query.
         */
        filesetPath: string;
        /**
         * The id of the vepfs fileset.
         */
        id: string;
        /**
         * The IOPS Qos of the vepfs fileset.
         */
        iopsQos: number;
        /**
         * The max number of inode in the vepfs fileset.
         */
        maxInodeNum: number;
        /**
         * The query status list of Vepfs Fileset.
         */
        status: string;
    }

    export interface GetFileSystemsFileSystem {
        /**
         * The id of the account.
         */
        accountId: string;
        /**
         * The bandwidth info of the vepfs file system.
         */
        bandwidth: number;
        /**
         * The capacity info of the vepfs file system.
         */
        capacityInfo: outputs.vepfs.GetFileSystemsFileSystemCapacityInfo;
        /**
         * The charge status of the vepfs file system.
         */
        chargeStatus: string;
        /**
         * The charge type of the vepfs file system.
         */
        chargeType: string;
        /**
         * The create time of the vepfs file system.
         */
        createTime: string;
        /**
         * The description of the vepfs file system.
         */
        description: string;
        /**
         * The expire time of the vepfs file system.
         */
        expireTime: string;
        /**
         * The id of the vepfs file system.
         */
        fileSystemId: string;
        /**
         * The Name of Vepfs File System. This field support fuzzy query.
         */
        fileSystemName: string;
        /**
         * The type of the vepfs file system.
         */
        fileSystemType: string;
        /**
         * The free time of the vepfs file system.
         */
        freeTime: string;
        /**
         * The id of the vepfs file system.
         */
        id: string;
        /**
         * The last modify time of the vepfs file system.
         */
        lastModifyTime: string;
        /**
         * The project of Vepfs File System.
         */
        project: string;
        /**
         * The protocol type of the vepfs file system.
         */
        protocolType: string;
        /**
         * The id of the region.
         */
        regionId: string;
        /**
         * The query status list of Vepfs File System.
         */
        status: string;
        /**
         * The stop service time of the vepfs file system.
         */
        stopServiceTime: string;
        /**
         * The Store Type of Vepfs File System.
         */
        storeType: string;
        /**
         * The store type cn name of the vepfs file system.
         */
        storeTypeCn: string;
        /**
         * The tags of the vepfs file system.
         */
        tags: outputs.vepfs.GetFileSystemsFileSystemTag[];
        /**
         * The version info of the vepfs file system.
         */
        version: string;
        /**
         * The zone id of File System.
         */
        zoneId: string;
        /**
         * The name of the zone.
         */
        zoneName: string;
    }

    export interface GetFileSystemsFileSystemCapacityInfo {
        /**
         * The total size. Unit: TiB.
         */
        totalTib: number;
        /**
         * The used size. Unit: GiB.
         */
        usedGib: number;
    }

    export interface GetFileSystemsFileSystemTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Type of Tags.
         */
        type: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetFilesetsFileset {
        /**
         * The bandwidth Qos of the vepfs fileset.
         */
        bandwidthQos: number;
        /**
         * The capacity limit of the vepfs fileset. Unit: GiB.
         */
        capacityLimit: number;
        /**
         * The used capacity of the vepfs fileset. Unit: GiB.
         */
        capacityUsed: number;
        /**
         * The create time of the vepfs fileset.
         */
        createTime: string;
        /**
         * Quota for the number of files or directories. A return of 0 indicates that there is no quota limit set for the number of directories after the file.
         */
        fileLimit: number;
        /**
         * The used file number of the vepfs fileset.
         */
        fileUsed: number;
        /**
         * The id of Vepfs Fileset.
         */
        filesetId: string;
        /**
         * The name of Vepfs Fileset. This field support fuzzy query.
         */
        filesetName: string;
        /**
         * The path of Vepfs Fileset. This field support fuzzy query.
         */
        filesetPath: string;
        /**
         * The id of the vepfs fileset.
         */
        id: string;
        /**
         * The IOPS Qos of the vepfs fileset.
         */
        iopsQos: number;
        /**
         * The max number of inode in the vepfs fileset.
         */
        maxInodeNum: number;
        /**
         * The query status list of Vepfs Fileset.
         */
        status: string;
    }

    export interface GetMountServicesMountService {
        /**
         * The account id of the vepfs file system.
         */
        accountId: string;
        /**
         * The attached file system info of the mount service.
         */
        attachFileSystems: outputs.vepfs.GetMountServicesMountServiceAttachFileSystem[];
        /**
         * The created time of the mount service.
         */
        createTime: string;
        /**
         * The id of the mount service.
         */
        id: string;
        /**
         * The id of mount service.
         */
        mountServiceId: string;
        /**
         * The name of mount service. This field support fuzzy query.
         */
        mountServiceName: string;
        /**
         * The nodes info of the mount service.
         */
        nodes: outputs.vepfs.GetMountServicesMountServiceNode[];
        /**
         * The project of the mount service.
         */
        project: string;
        /**
         * The region id of the mount service.
         */
        regionId: string;
        /**
         * The query status list of mount service.
         */
        status: string;
        /**
         * The subnet id of the mount service.
         */
        subnetId: string;
        /**
         * The vpc id of the mount service.
         */
        vpcId: string;
        /**
         * The zone id of the mount service.
         */
        zoneId: string;
        /**
         * The zone name of the mount service.
         */
        zoneName: string;
    }

    export interface GetMountServicesMountServiceAttachFileSystem {
        /**
         * The account id of the vepfs file system.
         */
        accountId: string;
        /**
         * The id of the vepfs file system.
         */
        customerPath: string;
        /**
         * The id of Vepfs File System.
         */
        fileSystemId: string;
        /**
         * The name of the vepfs file system.
         */
        fileSystemName: string;
        /**
         * The query status list of mount service.
         */
        status: string;
    }

    export interface GetMountServicesMountServiceNode {
        /**
         * The default password of ecs instance.
         */
        defaultPassword: string;
        /**
         * The id of ecs instance.
         */
        nodeId: string;
    }

    export interface MountServiceAttachFileSystem {
        /**
         * The account id of the vepfs file system.
         */
        accountId: string;
        /**
         * The id of the vepfs file system.
         */
        customerPath: string;
        /**
         * The id of the vepfs file system.
         */
        fileSystemId: string;
        /**
         * The name of the vepfs file system.
         */
        fileSystemName: string;
        /**
         * The status of the mount service.
         */
        status: string;
    }

    export interface MountServiceNode {
        /**
         * The default password of ecs instance.
         */
        defaultPassword: string;
        /**
         * The id of ecs instance.
         */
        nodeId: string;
    }

    export interface MountServicesMountService {
        /**
         * The account id of the vepfs file system.
         */
        accountId: string;
        /**
         * The attached file system info of the mount service.
         */
        attachFileSystems: outputs.vepfs.MountServicesMountServiceAttachFileSystem[];
        /**
         * The created time of the mount service.
         */
        createTime: string;
        /**
         * The id of the mount service.
         */
        id: string;
        /**
         * The id of mount service.
         */
        mountServiceId: string;
        /**
         * The name of mount service. This field support fuzzy query.
         */
        mountServiceName: string;
        /**
         * The nodes info of the mount service.
         */
        nodes: outputs.vepfs.MountServicesMountServiceNode[];
        /**
         * The project of the mount service.
         */
        project: string;
        /**
         * The region id of the mount service.
         */
        regionId: string;
        /**
         * The query status list of mount service.
         */
        status: string;
        /**
         * The subnet id of the mount service.
         */
        subnetId: string;
        /**
         * The vpc id of the mount service.
         */
        vpcId: string;
        /**
         * The zone id of the mount service.
         */
        zoneId: string;
        /**
         * The zone name of the mount service.
         */
        zoneName: string;
    }

    export interface MountServicesMountServiceAttachFileSystem {
        /**
         * The account id of the vepfs file system.
         */
        accountId: string;
        /**
         * The id of the vepfs file system.
         */
        customerPath: string;
        /**
         * The id of Vepfs File System.
         */
        fileSystemId: string;
        /**
         * The name of the vepfs file system.
         */
        fileSystemName: string;
        /**
         * The query status list of mount service.
         */
        status: string;
    }

    export interface MountServicesMountServiceNode {
        /**
         * The default password of ecs instance.
         */
        defaultPassword: string;
        /**
         * The id of ecs instance.
         */
        nodeId: string;
    }

}

export namespace vke {
    export interface AddonsAddon {
        /**
         * The ID of the Cluster.
         */
        clusterId: string;
        /**
         * The config of addon.
         */
        config: string;
        /**
         * ClientToken when the addon is created successfully. ClientToken is a string that guarantees the idempotency of the request. This string is passed in by the caller.
         */
        createClientToken?: string;
        /**
         * Addon creation time. UTC+0 time in standard RFC3339 format.
         */
        createTime: string;
        /**
         * The deploy mode.
         */
        deployMode: string;
        /**
         * The deploy node type.
         */
        deployNodeType: string;
        /**
         * The name of the cluster.
         */
        name: string;
        /**
         * The status of the addon.
         */
        status: outputs.vke.AddonsAddonStatus;
        /**
         * The ClientToken when the last addon update succeeded. ClientToken is a string that guarantees the idempotency of the request. This string is passed in by the caller.
         */
        updateClientToken?: string;
        /**
         * The last time a request was accepted by the addon and executed or completed. UTC+0 time in standard RFC3339 format.
         */
        updateTime: string;
        /**
         * The name of the cluster.
         */
        version: string;
    }

    export interface AddonsAddonStatus {
        /**
         * The state condition in the current primary state of the cluster, that is, the reason for entering the primary state.
         */
        conditions: outputs.vke.AddonsAddonStatusCondition[];
        /**
         * The status of addon. the value contains `Creating`, `Running`, `Updating`, `Deleting`, `Failed`.
         */
        phase: string;
    }

    export interface AddonsAddonStatusCondition {
        /**
         * The state condition in the current main state of the addon, that is, the reason for entering the main state, there can be multiple reasons, the value contains `Progressing`, `Ok`, `Degraded`,`Unknown`, `ClusterNotRunning`, `CrashLoopBackOff`, `SchedulingFailed`, `NameConflict`, `ResourceCleanupFailed`, `ClusterVersionUpgrading`.
         */
        type: string;
    }

    export interface AddonsStatus {
        /**
         * The state condition in the current main state of the addon, that is, the reason for entering the main state, there can be multiple reasons, the value contains `Progressing`, `Ok`, `Degraded`,`Unknown`, `ClusterNotRunning`, `CrashLoopBackOff`, `SchedulingFailed`, `NameConflict`, `ResourceCleanupFailed`, `ClusterVersionUpgrading`.
         */
        conditionsType?: string;
        /**
         * The status of addon. the value contains `Creating`, `Running`, `Updating`, `Deleting`, `Failed`.
         */
        phase?: string;
    }

    export interface ClusterClusterConfig {
        /**
         * Cluster API Server public network access configuration.
         */
        apiServerPublicAccessConfig?: outputs.vke.ClusterClusterConfigApiServerPublicAccessConfig;
        /**
         * Cluster API Server public network access configuration, the value is `true` or `false`.
         */
        apiServerPublicAccessEnabled?: boolean;
        /**
         * [SkipDoc]The IpFamily configuration,the value is `Ipv4` or `DualStack`.
         */
        ipFamily: string;
        /**
         * Node public network access configuration, the value is `true` or `false`.
         */
        resourcePublicAccessDefaultEnabled?: boolean;
        /**
         * The subnet ID for the cluster control plane to communicate within the private network.
         * Up to 3 subnets can be selected from each available zone, and a maximum of 2 subnets can be added to each available zone.
         * Cannot support deleting configured subnets.
         */
        subnetIds: string[];
    }

    export interface ClusterClusterConfigApiServerPublicAccessConfig {
        /**
         * Public network access network configuration.
         */
        publicAccessNetworkConfig?: outputs.vke.ClusterClusterConfigApiServerPublicAccessConfigPublicAccessNetworkConfig;
    }

    export interface ClusterClusterConfigApiServerPublicAccessConfigPublicAccessNetworkConfig {
        /**
         * The peak bandwidth of the public IP, unit: Mbps.
         */
        bandwidth?: number;
        /**
         * Billing type of public IP, the value is `PostPaidByBandwidth` or `PostPaidByTraffic`.
         */
        billingType?: string;
    }

    export interface ClusterIrsaConfig {
        /**
         * The audience of the IRSA.
         */
        audience: string;
        /**
         * Whether to enable IRSA for the cluster.
         */
        enabled: boolean;
        /**
         * The issuer of the IRSA.
         */
        issuer: string;
        /**
         * The JWKS URL of the IRSA.
         */
        jwksUrl: string;
        /**
         * The OIDC trn of the IRSA.
         */
        oidcTrn: string;
        /**
         * The OpenID Connect configuration URL of the IRSA.
         */
        openIdConfigUrl: string;
    }

    export interface ClusterLoggingConfig {
        /**
         * The TLS log item ID of the collection target.
         */
        logProjectId: string;
        /**
         * Cluster logging options. This structure can only be modified and added, and cannot be deleted. When encountering a `cannot be deleted` error, please query the log setups of the current cluster and fill in the current `tf` file.
         */
        logSetups?: outputs.vke.ClusterLoggingConfigLogSetup[];
    }

    export interface ClusterLoggingConfigLogSetup {
        /**
         * Whether to enable the log option, true means enable, false means not enable, the default is false. When Enabled is changed from false to true, a new Topic will be created.
         */
        enabled?: boolean;
        /**
         * The storage time of logs in Log Service. After the specified log storage time is exceeded, the expired logs in this log topic will be automatically cleared. The unit is days, and the default is 30 days. The value range is 1 to 3650, specifying 3650 days means permanent storage.
         */
        logTtl?: number;
        /**
         * The current types of logs that can be enabled are:
         * Audit: Cluster audit logs.
         * KubeApiServer: kube-apiserver component logs.
         * KubeScheduler: kube-scheduler component logs.
         * KubeControllerManager: kube-controller-manager component logs.
         * Etcd: etcd component logs.
         * ClusterAutoscaler: cluster-autoscaler component logs.
         */
        logType: string;
    }

    export interface ClusterPodsConfig {
        /**
         * Flannel network configuration.
         */
        flannelConfig?: outputs.vke.ClusterPodsConfigFlannelConfig;
        /**
         * The container network model of the cluster, the value is `Flannel` or `VpcCniShared`. Flannel: Flannel network model, an independent Underlay container network solution, combined with the global routing capability of VPC, to achieve a high-performance network experience for the cluster. VpcCniShared: VPC-CNI network model, an Underlay container network solution based on the ENI of the private network elastic network card, with high network communication performance.
         */
        podNetworkMode: string;
        /**
         * VPC-CNI network configuration.
         */
        vpcCniConfig?: outputs.vke.ClusterPodsConfigVpcCniConfig;
    }

    export interface ClusterPodsConfigFlannelConfig {
        /**
         * The maximum number of single-node Pod instances for a Flannel container network, the value can be `16` or `32` or `64` or `128` or `256`.
         */
        maxPodsPerNode?: number;
        /**
         * Pod CIDR for the Flannel container network.
         */
        podCidrs?: string[];
    }

    export interface ClusterPodsConfigVpcCniConfig {
        /**
         * A list of Pod subnet IDs for the VPC-CNI container network.
         */
        subnetIds?: string[];
        /**
         * The private network where the cluster control plane network resides.
         */
        vpcId?: string;
    }

    export interface ClusterServicesConfig {
        /**
         * The IPv4 private network address exposed by the service.
         */
        serviceCidrsv4s: string[];
    }

    export interface ClusterTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface ClustersCluster {
        /**
         * The config of the cluster.
         */
        clusterConfig: outputs.vke.ClustersClusterClusterConfig;
        /**
         * ClientToken when the cluster is created successfully. ClientToken is a string that guarantees the idempotency of the request. This string is passed in by the caller.
         */
        createClientToken?: string;
        /**
         * Cluster creation time. UTC+0 time in standard RFC3339 format.
         */
        createTime: string;
        /**
         * The delete protection of the cluster, the value is `true` or `false`.
         */
        deleteProtectionEnabled: boolean;
        /**
         * The description of the cluster.
         */
        description: string;
        /**
         * Eip allocation Id.
         */
        eipAllocationId: string;
        /**
         * The ID of the Cluster.
         */
        id: string;
        /**
         * The IRSA configuration.
         */
        irsaConfigs: outputs.vke.ClustersClusterIrsaConfig[];
        /**
         * Kubeconfig data with private network access, returned in BASE64 encoding, it is suggested to use vkeKubeconfig instead.
         */
        kubeconfigPrivate: string;
        /**
         * Kubeconfig data with public network access, returned in BASE64 encoding, it is suggested to use vkeKubeconfig instead.
         */
        kubeconfigPublic: string;
        /**
         * The Kubernetes version information corresponding to the cluster, specific to the patch version.
         */
        kubernetesVersion: string;
        /**
         * Cluster log configuration information.
         */
        loggingConfigs: outputs.vke.ClustersClusterLoggingConfig[];
        /**
         * The name of the cluster.
         */
        name: string;
        /**
         * Statistics on the number of nodes corresponding to each master state in the cluster.
         */
        nodeStatistics: outputs.vke.ClustersClusterNodeStatistics;
        /**
         * The config of the pods.
         */
        podsConfig: outputs.vke.ClustersClusterPodsConfig;
        /**
         * The project name of the cluster.
         */
        projectName: string;
        /**
         * The config of the services.
         */
        servicesConfig: outputs.vke.ClustersClusterServicesConfig;
        /**
         * The status of the cluster.
         */
        status: outputs.vke.ClustersClusterStatus;
        /**
         * Tags.
         */
        tags: outputs.vke.ClustersClusterTag[];
        /**
         * The ClientToken when the last cluster update succeeded. ClientToken is a string that guarantees the idempotency of the request. This string is passed in by the caller.
         */
        updateClientToken?: string;
        /**
         * The last time a request was accepted by the cluster and executed or completed. UTC+0 time in standard RFC3339 format.
         */
        updateTime: string;
    }

    export interface ClustersClusterClusterConfig {
        /**
         * Endpoint information accessed by the cluster API Server.
         */
        apiServerEndpoints: outputs.vke.ClustersClusterClusterConfigApiServerEndpoints;
        /**
         * Cluster API Server public network access configuration.
         */
        apiServerPublicAccessConfig: outputs.vke.ClustersClusterClusterConfigApiServerPublicAccessConfig;
        /**
         * Cluster API Server public network access configuration, the value is `true` or `false`.
         */
        apiServerPublicAccessEnabled: boolean;
        /**
         * Node public network access configuration, the value is `true` or `false`.
         */
        resourcePublicAccessDefaultEnabled: boolean;
        /**
         * The security group used by the cluster control plane and nodes.
         */
        securityGroupIds: string[];
        /**
         * A list of Pod subnet IDs for the VPC-CNI container network.
         */
        subnetIds: string[];
        /**
         * The private network where the cluster control plane network resides.
         */
        vpcId: string;
    }

    export interface ClustersClusterClusterConfigApiServerEndpoints {
        /**
         * Endpoint address of the cluster API Server private network.
         */
        privateIp: outputs.vke.ClustersClusterClusterConfigApiServerEndpointsPrivateIp;
        /**
         * Endpoint address of the cluster API Server public network.
         */
        publicIp: outputs.vke.ClustersClusterClusterConfigApiServerEndpointsPublicIp;
    }

    export interface ClustersClusterClusterConfigApiServerEndpointsPrivateIp {
        /**
         * Ipv4 address.
         */
        ipv4: string;
    }

    export interface ClustersClusterClusterConfigApiServerEndpointsPublicIp {
        /**
         * Ipv4 address.
         */
        ipv4: string;
    }

    export interface ClustersClusterClusterConfigApiServerPublicAccessConfig {
        /**
         * IPv4 public network access whitelist. A null value means all network segments (0.0.0.0/0) are allowed to pass.
         */
        accessSourceIpsv4s: string[];
        /**
         * [SkipDoc]The IpFamily configuration,the value is `Ipv4` or `DualStack`.
         */
        ipFamily: string;
        /**
         * Public network access network configuration.
         */
        publicAccessNetworkConfig: outputs.vke.ClustersClusterClusterConfigApiServerPublicAccessConfigPublicAccessNetworkConfig;
    }

    export interface ClustersClusterClusterConfigApiServerPublicAccessConfigPublicAccessNetworkConfig {
        /**
         * The peak bandwidth of the public IP, unit: Mbps.
         */
        bandwidth: number;
        /**
         * Billing type of public IP, the value is `PostPaidByBandwidth` or `PostPaidByTraffic`.
         */
        billingType: string;
        /**
         * The ISP of public IP.
         */
        isp: string;
    }

    export interface ClustersClusterIrsaConfig {
        /**
         * The audience of the IRSA.
         */
        audience: string;
        /**
         * Whether to enable the log option, true means enable, false means not enable, the default is false. When Enabled is changed from false to true, a new Topic will be created.
         */
        enabled: boolean;
        /**
         * The issuer of the IRSA.
         */
        issuer: string;
        /**
         * The JWKS URL of the IRSA.
         */
        jwksUrl: string;
        /**
         * The OIDC trn of the IRSA.
         */
        oidcTrn: string;
        /**
         * The OpenID Connect configuration URL of the IRSA.
         */
        openIdConfigUrl: string;
    }

    export interface ClustersClusterLoggingConfig {
        /**
         * The TLS log item ID of the collection target.
         */
        logProjectId: string;
        /**
         * Cluster logging options.
         */
        logSetups: outputs.vke.ClustersClusterLoggingConfigLogSetup[];
    }

    export interface ClustersClusterLoggingConfigLogSetup {
        /**
         * Whether to enable the log option, true means enable, false means not enable, the default is false. When Enabled is changed from false to true, a new Topic will be created.
         */
        enabled: boolean;
        /**
         * The storage time of logs in Log Service. After the specified log storage time is exceeded, the expired logs in this log topic will be automatically cleared. The unit is days, and the default is 30 days. The value range is 1 to 3650, specifying 3650 days means permanent storage.
         */
        logTtl: number;
        /**
         * The currently enabled log type.
         */
        logType: string;
    }

    export interface ClustersClusterNodeStatistics {
        /**
         * Phase=Creating total number of nodes.
         */
        creatingCount: number;
        /**
         * Phase=Deleting total number of nodes.
         */
        deletingCount: number;
        /**
         * Phase=Failed total number of nodes.
         */
        failedCount: number;
        /**
         * Phase=Running total number of nodes.
         */
        runningCount: number;
        /**
         * (**Deprecated**) This field has been deprecated and is not recommended for use. Phase=Stopped total number of nodes.
         *
         * @deprecated This field has been deprecated and is not recommended for use.
         */
        stoppedCount: number;
        /**
         * The total count of Cluster query.
         */
        totalCount: number;
        /**
         * Phase=Updating total number of nodes.
         */
        updatingCount: number;
    }

    export interface ClustersClusterPodsConfig {
        /**
         * Flannel network configuration.
         */
        flannelConfig: outputs.vke.ClustersClusterPodsConfigFlannelConfig;
        /**
         * Container Pod Network Type (CNI), the value is `Flannel` or `VpcCniShared`.
         */
        podNetworkMode: string;
        /**
         * VPC-CNI network configuration.
         */
        vpcCniConfig: outputs.vke.ClustersClusterPodsConfigVpcCniConfig;
    }

    export interface ClustersClusterPodsConfigFlannelConfig {
        /**
         * The maximum number of single-node Pod instances for a Flannel container network.
         */
        maxPodsPerNode: number;
        /**
         * Pod CIDR for the Flannel container network.
         */
        podCidrs: string[];
    }

    export interface ClustersClusterPodsConfigVpcCniConfig {
        /**
         * A list of Pod subnet IDs for the VPC-CNI container network.
         */
        subnetIds: string[];
        /**
         * The private network where the cluster control plane network resides.
         */
        vpcId: string;
    }

    export interface ClustersClusterServicesConfig {
        /**
         * The IPv4 private network address exposed by the service.
         */
        serviceCidrsv4s: string[];
    }

    export interface ClustersClusterStatus {
        /**
         * The state condition in the current primary state of the cluster, that is, the reason for entering the primary state.
         */
        conditions: outputs.vke.ClustersClusterStatusCondition[];
        /**
         * The status of cluster. the value contains `Creating`, `Running`, `Updating`, `Deleting`, `Stopped`, `Failed`.
         */
        phase: string;
    }

    export interface ClustersClusterStatusCondition {
        /**
         * The Type of Tags.
         */
        type: string;
    }

    export interface ClustersClusterTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Type of Tags.
         */
        type: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface ClustersStatus {
        /**
         * The state condition in the current main state of the cluster, that is, the reason for entering the main state, there can be multiple reasons, the value contains `Progressing`, `Ok`, `Degraded`, `SetByProvider`, `Balance`, `Security`, `CreateError`, `ResourceCleanupFailed`, `LimitedByQuota`, `StockOut`,`Unknown`.
         */
        conditionsType?: string;
        /**
         * The status of cluster. the value contains `Creating`, `Running`, `Updating`, `Deleting`, `Stopped`, `Failed`.
         */
        phase?: string;
    }

    export interface ClustersTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface DefaultNodePoolBatchAttachInstance {
        /**
         * The flag of additional container storage enable, the value is `true` or `false`..Default is `false`.
         */
        additionalContainerStorageEnabled?: boolean;
        /**
         * The container storage path.When additionalContainerStorageEnabled is `false` will ignore.
         */
        containerStoragePath: string;
        /**
         * ID of the resource.
         */
        id: string;
        /**
         * The Image Id to the ECS Instance.
         */
        imageId: string;
        /**
         * The instance id.
         */
        instanceId: string;
        /**
         * The flag of keep instance name, the value is `true` or `false`.Default is `false`.
         */
        keepInstanceName?: boolean;
        /**
         * The status phase to the Node.
         */
        phase: string;
    }

    export interface DefaultNodePoolBatchAttachKubernetesConfig {
        /**
         * The Cordon of KubernetesConfig.
         */
        cordon?: boolean;
        /**
         * The Labels of KubernetesConfig.
         */
        labels?: outputs.vke.DefaultNodePoolBatchAttachKubernetesConfigLabel[];
        /**
         * The Taints of KubernetesConfig.
         */
        taints?: outputs.vke.DefaultNodePoolBatchAttachKubernetesConfigTaint[];
    }

    export interface DefaultNodePoolBatchAttachKubernetesConfigLabel {
        /**
         * The Key of Labels.
         */
        key: string;
        /**
         * The Value of Labels.
         */
        value?: string;
    }

    export interface DefaultNodePoolBatchAttachKubernetesConfigTaint {
        /**
         * The Effect of Taints. The value can be one of the following: `NoSchedule`, `NoExecute`, `PreferNoSchedule`, default value is `NoSchedule`.
         */
        effect?: string;
        /**
         * The Key of Taints.
         */
        key: string;
        /**
         * The Value of Taints.
         */
        value?: string;
    }

    export interface DefaultNodePoolBatchAttachNodeConfig {
        /**
         * Tags for Ecs.
         */
        ecsTags: outputs.vke.DefaultNodePoolBatchAttachNodeConfigEcsTag[];
        /**
         * The initializeScript of NodeConfig.
         */
        initializeScript: string;
        /**
         * The NamePrefix of NodeConfig.
         */
        namePrefix: string;
        /**
         * The PreScript of NodeConfig.
         */
        preScript: string;
        /**
         * The Security of NodeConfig.
         */
        securities: outputs.vke.DefaultNodePoolBatchAttachNodeConfigSecurity[];
    }

    export interface DefaultNodePoolBatchAttachNodeConfigEcsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface DefaultNodePoolBatchAttachNodeConfigSecurity {
        /**
         * The Login of Security.
         */
        logins: outputs.vke.DefaultNodePoolBatchAttachNodeConfigSecurityLogin[];
        /**
         * The SecurityGroupIds of Security.
         */
        securityGroupIds: string[];
        /**
         * The SecurityStrategies of Security.
         */
        securityStrategies: string[];
    }

    export interface DefaultNodePoolBatchAttachNodeConfigSecurityLogin {
        /**
         * The Password of Security.
         */
        password: string;
        /**
         * The SshKeyPairName of Security.
         */
        sshKeyPairName: string;
    }

    export interface DefaultNodePoolBatchAttachTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface DefaultNodePoolInstance {
        /**
         * The flag of additional container storage enable, the value is `true` or `false`..Default is `false`.
         */
        additionalContainerStorageEnabled?: boolean;
        /**
         * The container storage path.When additionalContainerStorageEnabled is `false` will ignore.
         */
        containerStoragePath: string;
        /**
         * ID of the resource.
         */
        id: string;
        /**
         * The Image Id to the ECS Instance.
         */
        imageId: string;
        /**
         * The instance id.
         */
        instanceId: string;
        /**
         * The flag of keep instance name, the value is `true` or `false`.Default is `false`.
         */
        keepInstanceName?: boolean;
        /**
         * The status phase to the Node.
         */
        phase: string;
    }

    export interface DefaultNodePoolKubernetesConfig {
        /**
         * The Cordon of KubernetesConfig.
         */
        cordon: boolean;
        /**
         * The Labels of KubernetesConfig.
         */
        labels?: outputs.vke.DefaultNodePoolKubernetesConfigLabel[];
        /**
         * The NamePrefix of node metadata.
         */
        namePrefix?: string;
        /**
         * The Taints of KubernetesConfig.
         */
        taints?: outputs.vke.DefaultNodePoolKubernetesConfigTaint[];
    }

    export interface DefaultNodePoolKubernetesConfigLabel {
        /**
         * The Key of Labels.
         */
        key?: string;
        /**
         * The Value of Labels.
         */
        value?: string;
    }

    export interface DefaultNodePoolKubernetesConfigTaint {
        /**
         * The Effect of Taints.
         */
        effect?: string;
        /**
         * The Key of Taints.
         */
        key?: string;
        /**
         * The Value of Taints.
         */
        value?: string;
    }

    export interface DefaultNodePoolNodeConfig {
        /**
         * Tags for Ecs.
         */
        ecsTags?: outputs.vke.DefaultNodePoolNodeConfigEcsTag[];
        /**
         * The initializeScript of NodeConfig.
         */
        initializeScript?: string;
        /**
         * The NamePrefix of NodeConfig.
         */
        namePrefix?: string;
        /**
         * The PreScript of NodeConfig.
         */
        preScript?: string;
        /**
         * The Security of NodeConfig.
         */
        security: outputs.vke.DefaultNodePoolNodeConfigSecurity;
    }

    export interface DefaultNodePoolNodeConfigEcsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface DefaultNodePoolNodeConfigSecurity {
        /**
         * The Login of Security.
         */
        login: outputs.vke.DefaultNodePoolNodeConfigSecurityLogin;
        /**
         * The SecurityGroupIds of Security.
         */
        securityGroupIds: string[];
        /**
         * The SecurityStrategies of Security.
         */
        securityStrategies?: string[];
    }

    export interface DefaultNodePoolNodeConfigSecurityLogin {
        /**
         * The Password of Security.
         */
        password?: string;
        /**
         * The SshKeyPairName of Security.
         */
        sshKeyPairName?: string;
    }

    export interface DefaultNodePoolTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetAddonsAddon {
        /**
         * The ID of the Cluster.
         */
        clusterId: string;
        /**
         * The config of addon.
         */
        config: string;
        /**
         * ClientToken when the addon is created successfully. ClientToken is a string that guarantees the idempotency of the request. This string is passed in by the caller.
         */
        createClientToken?: string;
        /**
         * Addon creation time. UTC+0 time in standard RFC3339 format.
         */
        createTime: string;
        /**
         * The deploy mode.
         */
        deployMode: string;
        /**
         * The deploy node type.
         */
        deployNodeType: string;
        /**
         * The name of the cluster.
         */
        name: string;
        /**
         * The status of the addon.
         */
        status: outputs.vke.GetAddonsAddonStatus;
        /**
         * The ClientToken when the last addon update succeeded. ClientToken is a string that guarantees the idempotency of the request. This string is passed in by the caller.
         */
        updateClientToken?: string;
        /**
         * The last time a request was accepted by the addon and executed or completed. UTC+0 time in standard RFC3339 format.
         */
        updateTime: string;
        /**
         * The name of the cluster.
         */
        version: string;
    }

    export interface GetAddonsAddonStatus {
        /**
         * The state condition in the current primary state of the cluster, that is, the reason for entering the primary state.
         */
        conditions: outputs.vke.GetAddonsAddonStatusCondition[];
        /**
         * The status of addon. the value contains `Creating`, `Running`, `Updating`, `Deleting`, `Failed`.
         */
        phase: string;
    }

    export interface GetAddonsAddonStatusCondition {
        /**
         * The state condition in the current main state of the addon, that is, the reason for entering the main state, there can be multiple reasons, the value contains `Progressing`, `Ok`, `Degraded`,`Unknown`, `ClusterNotRunning`, `CrashLoopBackOff`, `SchedulingFailed`, `NameConflict`, `ResourceCleanupFailed`, `ClusterVersionUpgrading`.
         */
        type: string;
    }

    export interface GetAddonsStatus {
        /**
         * The state condition in the current main state of the addon, that is, the reason for entering the main state, there can be multiple reasons, the value contains `Progressing`, `Ok`, `Degraded`,`Unknown`, `ClusterNotRunning`, `CrashLoopBackOff`, `SchedulingFailed`, `NameConflict`, `ResourceCleanupFailed`, `ClusterVersionUpgrading`.
         */
        conditionsType?: string;
        /**
         * The status of addon. the value contains `Creating`, `Running`, `Updating`, `Deleting`, `Failed`.
         */
        phase?: string;
    }

    export interface GetClustersCluster {
        /**
         * The config of the cluster.
         */
        clusterConfig: outputs.vke.GetClustersClusterClusterConfig;
        /**
         * ClientToken when the cluster is created successfully. ClientToken is a string that guarantees the idempotency of the request. This string is passed in by the caller.
         */
        createClientToken?: string;
        /**
         * Cluster creation time. UTC+0 time in standard RFC3339 format.
         */
        createTime: string;
        /**
         * The delete protection of the cluster, the value is `true` or `false`.
         */
        deleteProtectionEnabled: boolean;
        /**
         * The description of the cluster.
         */
        description: string;
        /**
         * Eip allocation Id.
         */
        eipAllocationId: string;
        /**
         * The ID of the Cluster.
         */
        id: string;
        /**
         * The IRSA configuration.
         */
        irsaConfigs: outputs.vke.GetClustersClusterIrsaConfig[];
        /**
         * Kubeconfig data with private network access, returned in BASE64 encoding, it is suggested to use vkeKubeconfig instead.
         */
        kubeconfigPrivate: string;
        /**
         * Kubeconfig data with public network access, returned in BASE64 encoding, it is suggested to use vkeKubeconfig instead.
         */
        kubeconfigPublic: string;
        /**
         * The Kubernetes version information corresponding to the cluster, specific to the patch version.
         */
        kubernetesVersion: string;
        /**
         * Cluster log configuration information.
         */
        loggingConfigs: outputs.vke.GetClustersClusterLoggingConfig[];
        /**
         * The name of the cluster.
         */
        name: string;
        /**
         * Statistics on the number of nodes corresponding to each master state in the cluster.
         */
        nodeStatistics: outputs.vke.GetClustersClusterNodeStatistics;
        /**
         * The config of the pods.
         */
        podsConfig: outputs.vke.GetClustersClusterPodsConfig;
        /**
         * The project name of the cluster.
         */
        projectName: string;
        /**
         * The config of the services.
         */
        servicesConfig: outputs.vke.GetClustersClusterServicesConfig;
        /**
         * The status of the cluster.
         */
        status: outputs.vke.GetClustersClusterStatus;
        /**
         * Tags.
         */
        tags: outputs.vke.GetClustersClusterTag[];
        /**
         * The ClientToken when the last cluster update succeeded. ClientToken is a string that guarantees the idempotency of the request. This string is passed in by the caller.
         */
        updateClientToken?: string;
        /**
         * The last time a request was accepted by the cluster and executed or completed. UTC+0 time in standard RFC3339 format.
         */
        updateTime: string;
    }

    export interface GetClustersClusterClusterConfig {
        /**
         * Endpoint information accessed by the cluster API Server.
         */
        apiServerEndpoints: outputs.vke.GetClustersClusterClusterConfigApiServerEndpoints;
        /**
         * Cluster API Server public network access configuration.
         */
        apiServerPublicAccessConfig: outputs.vke.GetClustersClusterClusterConfigApiServerPublicAccessConfig;
        /**
         * Cluster API Server public network access configuration, the value is `true` or `false`.
         */
        apiServerPublicAccessEnabled: boolean;
        /**
         * Node public network access configuration, the value is `true` or `false`.
         */
        resourcePublicAccessDefaultEnabled: boolean;
        /**
         * The security group used by the cluster control plane and nodes.
         */
        securityGroupIds: string[];
        /**
         * A list of Pod subnet IDs for the VPC-CNI container network.
         */
        subnetIds: string[];
        /**
         * The private network where the cluster control plane network resides.
         */
        vpcId: string;
    }

    export interface GetClustersClusterClusterConfigApiServerEndpoints {
        /**
         * Endpoint address of the cluster API Server private network.
         */
        privateIp: outputs.vke.GetClustersClusterClusterConfigApiServerEndpointsPrivateIp;
        /**
         * Endpoint address of the cluster API Server public network.
         */
        publicIp: outputs.vke.GetClustersClusterClusterConfigApiServerEndpointsPublicIp;
    }

    export interface GetClustersClusterClusterConfigApiServerEndpointsPrivateIp {
        /**
         * Ipv4 address.
         */
        ipv4: string;
    }

    export interface GetClustersClusterClusterConfigApiServerEndpointsPublicIp {
        /**
         * Ipv4 address.
         */
        ipv4: string;
    }

    export interface GetClustersClusterClusterConfigApiServerPublicAccessConfig {
        /**
         * IPv4 public network access whitelist. A null value means all network segments (0.0.0.0/0) are allowed to pass.
         */
        accessSourceIpsv4s: string[];
        /**
         * [SkipDoc]The IpFamily configuration,the value is `Ipv4` or `DualStack`.
         */
        ipFamily: string;
        /**
         * Public network access network configuration.
         */
        publicAccessNetworkConfig: outputs.vke.GetClustersClusterClusterConfigApiServerPublicAccessConfigPublicAccessNetworkConfig;
    }

    export interface GetClustersClusterClusterConfigApiServerPublicAccessConfigPublicAccessNetworkConfig {
        /**
         * The peak bandwidth of the public IP, unit: Mbps.
         */
        bandwidth: number;
        /**
         * Billing type of public IP, the value is `PostPaidByBandwidth` or `PostPaidByTraffic`.
         */
        billingType: string;
        /**
         * The ISP of public IP.
         */
        isp: string;
    }

    export interface GetClustersClusterIrsaConfig {
        /**
         * The audience of the IRSA.
         */
        audience: string;
        /**
         * Whether to enable the log option, true means enable, false means not enable, the default is false. When Enabled is changed from false to true, a new Topic will be created.
         */
        enabled: boolean;
        /**
         * The issuer of the IRSA.
         */
        issuer: string;
        /**
         * The JWKS URL of the IRSA.
         */
        jwksUrl: string;
        /**
         * The OIDC trn of the IRSA.
         */
        oidcTrn: string;
        /**
         * The OpenID Connect configuration URL of the IRSA.
         */
        openIdConfigUrl: string;
    }

    export interface GetClustersClusterLoggingConfig {
        /**
         * The TLS log item ID of the collection target.
         */
        logProjectId: string;
        /**
         * Cluster logging options.
         */
        logSetups: outputs.vke.GetClustersClusterLoggingConfigLogSetup[];
    }

    export interface GetClustersClusterLoggingConfigLogSetup {
        /**
         * Whether to enable the log option, true means enable, false means not enable, the default is false. When Enabled is changed from false to true, a new Topic will be created.
         */
        enabled: boolean;
        /**
         * The storage time of logs in Log Service. After the specified log storage time is exceeded, the expired logs in this log topic will be automatically cleared. The unit is days, and the default is 30 days. The value range is 1 to 3650, specifying 3650 days means permanent storage.
         */
        logTtl: number;
        /**
         * The currently enabled log type.
         */
        logType: string;
    }

    export interface GetClustersClusterNodeStatistics {
        /**
         * Phase=Creating total number of nodes.
         */
        creatingCount: number;
        /**
         * Phase=Deleting total number of nodes.
         */
        deletingCount: number;
        /**
         * Phase=Failed total number of nodes.
         */
        failedCount: number;
        /**
         * Phase=Running total number of nodes.
         */
        runningCount: number;
        /**
         * (**Deprecated**) This field has been deprecated and is not recommended for use. Phase=Stopped total number of nodes.
         *
         * @deprecated This field has been deprecated and is not recommended for use.
         */
        stoppedCount: number;
        /**
         * The total count of Cluster query.
         */
        totalCount: number;
        /**
         * Phase=Updating total number of nodes.
         */
        updatingCount: number;
    }

    export interface GetClustersClusterPodsConfig {
        /**
         * Flannel network configuration.
         */
        flannelConfig: outputs.vke.GetClustersClusterPodsConfigFlannelConfig;
        /**
         * Container Pod Network Type (CNI), the value is `Flannel` or `VpcCniShared`.
         */
        podNetworkMode: string;
        /**
         * VPC-CNI network configuration.
         */
        vpcCniConfig: outputs.vke.GetClustersClusterPodsConfigVpcCniConfig;
    }

    export interface GetClustersClusterPodsConfigFlannelConfig {
        /**
         * The maximum number of single-node Pod instances for a Flannel container network.
         */
        maxPodsPerNode: number;
        /**
         * Pod CIDR for the Flannel container network.
         */
        podCidrs: string[];
    }

    export interface GetClustersClusterPodsConfigVpcCniConfig {
        /**
         * A list of Pod subnet IDs for the VPC-CNI container network.
         */
        subnetIds: string[];
        /**
         * The private network where the cluster control plane network resides.
         */
        vpcId: string;
    }

    export interface GetClustersClusterServicesConfig {
        /**
         * The IPv4 private network address exposed by the service.
         */
        serviceCidrsv4s: string[];
    }

    export interface GetClustersClusterStatus {
        /**
         * The state condition in the current primary state of the cluster, that is, the reason for entering the primary state.
         */
        conditions: outputs.vke.GetClustersClusterStatusCondition[];
        /**
         * The status of cluster. the value contains `Creating`, `Running`, `Updating`, `Deleting`, `Stopped`, `Failed`.
         */
        phase: string;
    }

    export interface GetClustersClusterStatusCondition {
        /**
         * The Type of Tags.
         */
        type: string;
    }

    export interface GetClustersClusterTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Type of Tags.
         */
        type: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetClustersStatus {
        /**
         * The state condition in the current main state of the cluster, that is, the reason for entering the main state, there can be multiple reasons, the value contains `Progressing`, `Ok`, `Degraded`, `SetByProvider`, `Balance`, `Security`, `CreateError`, `ResourceCleanupFailed`, `LimitedByQuota`, `StockOut`,`Unknown`.
         */
        conditionsType?: string;
        /**
         * The status of cluster. the value contains `Creating`, `Running`, `Updating`, `Deleting`, `Stopped`, `Failed`.
         */
        phase?: string;
    }

    export interface GetClustersTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetKubeconfigsKubeconfig {
        /**
         * The Cluster ID of the Kubeconfig.
         */
        clusterId: string;
        /**
         * The create time of the Kubeconfig.
         */
        createTime: string;
        /**
         * The expire time of the Kubeconfig.
         */
        expireTime: string;
        /**
         * The ID of the Kubeconfig.
         */
        id: string;
        /**
         * Kubeconfig data with public/private network access, returned in BASE64 encoding.
         */
        kubeconfig: string;
        /**
         * The ID of the Kubeconfig.
         */
        kubeconfigId: string;
        /**
         * The type of the Kubeconfig.
         */
        type: string;
        /**
         * The account ID of the Kubeconfig.
         */
        userId: number;
    }

    export interface GetNodePoolsNodePool {
        /**
         * Is AdditionalContainerStorageEnabled of NodeConfig.
         */
        additionalContainerStorageEnabled: boolean;
        /**
         * Is auto renew of the PrePaid instance of NodeConfig.
         */
        autoRenew: boolean;
        /**
         * The AutoRenewPeriod of the PrePaid instance of NodeConfig.
         */
        autoRenewPeriod: number;
        /**
         * The ClusterId of NodePool.
         */
        clusterId: string;
        /**
         * The Condition of Status.
         */
        conditionTypes: string[];
        /**
         * The Cordon of KubernetesConfig.
         */
        cordon: boolean;
        /**
         * The ClientToken when successfully created.
         */
        createClientToken: string;
        /**
         * The CreateTime of NodePool.
         */
        createTime: string;
        /**
         * The DataVolume of NodeConfig.
         */
        dataVolumes: outputs.vke.GetNodePoolsNodePoolDataVolume[];
        /**
         * The DesiredReplicas of AutoScaling.
         */
        desiredReplicas: number;
        /**
         * Tags for Ecs.
         */
        ecsTags: outputs.vke.GetNodePoolsNodePoolEcsTag[];
        /**
         * Whether to enable the remedy function of the node pool.
         */
        enabled: boolean;
        /**
         * The IDs of HpcCluster.
         */
        hpcClusterIds: string[];
        /**
         * The ID of the remedy policy.
         */
        id: string;
        /**
         * The ImageId of NodeConfig.
         */
        imageId: string;
        /**
         * The InitializeScript of NodeConfig.
         */
        initializeScript: string;
        /**
         * The InstanceChargeType of NodeConfig.
         */
        instanceChargeType: string;
        /**
         * The InstanceTypeIds of NodeConfig.
         */
        instanceTypeIds: string[];
        /**
         * Whether to disable the function of automatically synchronizing labels and taints to existing nodes.
         */
        kubeConfigAutoSyncDisabled: boolean;
        /**
         * The NamePrefix of node metadata.
         */
        kubeConfigNamePrefix: string;
        /**
         * The KubeletConfig of KubernetesConfig.
         */
        kubeletConfigs: outputs.vke.GetNodePoolsNodePoolKubeletConfig[];
        /**
         * The LabelContent of KubernetesConfig.
         */
        labelContents: outputs.vke.GetNodePoolsNodePoolLabelContent[];
        /**
         * The login SshKeyPairName of NodeConfig.
         */
        loginKeyPairName: string;
        /**
         * The login type of NodeConfig.
         */
        loginType: string;
        /**
         * The Management Config of NodePool.
         */
        managements: outputs.vke.GetNodePoolsNodePoolManagement[];
        /**
         * The MaxReplicas of AutoScaling.
         */
        maxReplicas: number;
        /**
         * The MinReplicas of AutoScaling.
         */
        minReplicas: number;
        /**
         * The Name of NodePool.
         */
        name: string;
        /**
         * The NamePrefix of NodeConfig.
         */
        namePrefix: string;
        /**
         * The NodeStatistics of NodeConfig.
         */
        nodeStatistics: outputs.vke.GetNodePoolsNodePoolNodeStatistic[];
        /**
         * The period of the PrePaid instance of NodeConfig.
         */
        period: number;
        /**
         * The Phase of Status.
         */
        phase: string;
        /**
         * The PreScript of NodeConfig.
         */
        preScript: string;
        /**
         * The Priority of AutoScaling.
         */
        priority: number;
        /**
         * The project name of NodeConfig.
         */
        projectName: string;
        /**
         * The SecurityGroupIds of NodeConfig.
         */
        securityGroupIds: string[];
        /**
         * The SecurityStrategies of NodeConfig.
         */
        securityStrategies: string[];
        /**
         * The SecurityStrategyEnabled of NodeConfig.
         */
        securityStrategyEnabled: boolean;
        /**
         * The SubnetId of NodeConfig.
         */
        subnetIds: string[];
        /**
         * Multi-subnet scheduling strategy for nodes. The value can be `ZoneBalance` or `Priority`.
         */
        subnetPolicy: string;
        /**
         * The SystemVolume of NodeConfig.
         */
        systemVolumes: outputs.vke.GetNodePoolsNodePoolSystemVolume[];
        /**
         * Tags.
         */
        tags: outputs.vke.GetNodePoolsNodePoolTag[];
        /**
         * The TaintContent of NodeConfig.
         */
        taintContents: outputs.vke.GetNodePoolsNodePoolTaintContent[];
        /**
         * The ClientToken when last update was successful.
         */
        updateClientToken: string;
        /**
         * The UpdateTime time of NodePool.
         */
        updateTime: string;
    }

    export interface GetNodePoolsNodePoolDataVolume {
        /**
         * The target mount directory of the disk.
         */
        mountPoint: string;
        /**
         * The Size of SystemVolume.
         */
        size: string;
        /**
         * The Type of Tags.
         */
        type: string;
    }

    export interface GetNodePoolsNodePoolEcsTag {
        /**
         * The Key of Taint.
         */
        key: string;
        /**
         * The Value of Taint.
         */
        value: string;
    }

    export interface GetNodePoolsNodePoolKubeletConfig {
        /**
         * The FeatureGates of KubeletConfig.
         */
        featureGates: outputs.vke.GetNodePoolsNodePoolKubeletConfigFeatureGate[];
        /**
         * The TopologyManagerPolicy of KubeletConfig.
         */
        topologyManagerPolicy: string;
        /**
         * The TopologyManagerScope of KubeletConfig.
         */
        topologyManagerScope: string;
    }

    export interface GetNodePoolsNodePoolKubeletConfigFeatureGate {
        /**
         * Whether to enable QoSResourceManager.
         */
        qosResourceManager: boolean;
    }

    export interface GetNodePoolsNodePoolLabelContent {
        /**
         * The Key of Taint.
         */
        key: string;
        /**
         * The Value of Taint.
         */
        value: string;
    }

    export interface GetNodePoolsNodePoolManagement {
        /**
         * Whether to enable the remedy function of the node pool.
         */
        enabled: boolean;
        /**
         * The Remedy Config of NodePool.
         */
        remedyConfigs: outputs.vke.GetNodePoolsNodePoolManagementRemedyConfig[];
    }

    export interface GetNodePoolsNodePoolManagementRemedyConfig {
        /**
         * Whether to enable the remedy function of the node pool.
         */
        enabled: boolean;
        /**
         * The ID of the remedy policy.
         */
        id: string;
    }

    export interface GetNodePoolsNodePoolNodeStatistic {
        /**
         * The CreatingCount of Node.
         */
        creatingCount: number;
        /**
         * The DeletingCount of Node.
         */
        deletingCount: number;
        /**
         * The FailedCount of Node.
         */
        failedCount: number;
        /**
         * The RunningCount of Node.
         */
        runningCount: number;
        /**
         * (**Deprecated**) This field has been deprecated and is not recommended for use. The StartingCount of Node.
         *
         * @deprecated This field has been deprecated and is not recommended for use.
         */
        startingCount: number;
        /**
         * (**Deprecated**) This field has been deprecated and is not recommended for use. The StoppedCount of Node.
         *
         * @deprecated This field has been deprecated and is not recommended for use.
         */
        stoppedCount: number;
        /**
         * (**Deprecated**) This field has been deprecated and is not recommended for use. The StoppingCount of Node.
         *
         * @deprecated This field has been deprecated and is not recommended for use.
         */
        stoppingCount: number;
        /**
         * Returns the total amount of the data list.
         */
        totalCount: number;
        /**
         * The UpdatingCount of Node.
         */
        updatingCount: number;
    }

    export interface GetNodePoolsNodePoolSystemVolume {
        /**
         * The Size of SystemVolume.
         */
        size: string;
        /**
         * The Type of Tags.
         */
        type: string;
    }

    export interface GetNodePoolsNodePoolTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Type of Tags.
         */
        type: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetNodePoolsNodePoolTaintContent {
        /**
         * The Effect of Taint.
         */
        effect: string;
        /**
         * The Key of Taint.
         */
        key: string;
        /**
         * The Value of Taint.
         */
        value: string;
    }

    export interface GetNodePoolsStatus {
        /**
         * Indicates the status condition of the node pool in the active state. The value can be `Progressing` or `Ok` or `VersionPartlyUpgraded` or `StockOut` or `LimitedByQuota` or `Balance` or `Degraded` or `ClusterVersionUpgrading` or `Cluster` or `ResourceCleanupFailed` or `Unknown` or `ClusterNotRunning` or `SetByProvider`.
         */
        conditionsType?: string;
        /**
         * The Phase of Status. The value can be `Creating` or `Running` or `Updating` or `Deleting` or `Failed` or `Scaling`.
         */
        phase?: string;
    }

    export interface GetNodePoolsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetNodesNode {
        /**
         * Is Additional Container storage enables.
         */
        additionalContainerStorageEnabled: boolean;
        /**
         * The cluster id of node.
         */
        clusterId: string;
        /**
         * The Condition of Node.
         */
        conditionTypes: string[];
        /**
         * The Storage Path.
         */
        containerStoragePath: string;
        /**
         * The Cordon of KubernetesConfig.
         */
        cordon: boolean;
        /**
         * The Create Client Token.
         */
        createClientToken: string;
        /**
         * The create time of Node.
         */
        createTime: string;
        /**
         * The ID of Node.
         */
        id: string;
        /**
         * The ImageId of NodeConfig.
         */
        imageId: string;
        /**
         * The InitializeScript of NodeConfig.
         */
        initializeScript: string;
        /**
         * The instance id of node.
         */
        instanceId: string;
        /**
         * Is virtual node.
         */
        isVirtual: boolean;
        /**
         * The Label of KubernetesConfig.
         */
        labels: outputs.vke.GetNodesNodeLabel[];
        /**
         * The Name of Node.
         */
        name: string;
        /**
         * The node pool id.
         */
        nodePoolId: string;
        /**
         * The Phase of Node.
         */
        phase: string;
        /**
         * The PreScript of NodeConfig.
         */
        preScript: string;
        /**
         * The roles of node.
         */
        roles: string[];
        /**
         * The Taint of KubernetesConfig.
         */
        taints: outputs.vke.GetNodesNodeTaint[];
        /**
         * The update time of Node.
         */
        updateTime: string;
        /**
         * The zone id.
         */
        zoneId: string;
    }

    export interface GetNodesNodeLabel {
        /**
         * The Key of Taint.
         */
        key: string;
        /**
         * The Value of Taint.
         */
        value: string;
    }

    export interface GetNodesNodeTaint {
        /**
         * The Effect of Taint.
         */
        effect: string;
        /**
         * The Key of Taint.
         */
        key: string;
        /**
         * The Value of Taint.
         */
        value: string;
    }

    export interface GetNodesStatus {
        /**
         * The Type of Node Condition, the value is `Progressing` or `Ok` or `Unschedulable` or `InitilizeFailed` or `Unknown` or `NotReady` or `Security` or `Balance` or `ResourceCleanupFailed`.
         */
        conditionsType?: string;
        /**
         * The Phase of Node, the value is `Creating` or `Running` or `Updating` or `Deleting` or `Failed` or `Starting` or `Stopping` or `Stopped`.
         */
        phase?: string;
    }

    export interface GetPermissionsAccessPolicy {
        /**
         * The authorized time of the RBAC Permission.
         */
        authorizedAt: string;
        /**
         * The ID of the Authorizer.
         */
        authorizerId: number;
        /**
         * The name of the Authorizer.
         */
        authorizerName: string;
        /**
         * The type of the Authorizer.
         */
        authorizerType: string;
        /**
         * The ID of the Cluster.
         */
        clusterId: string;
        /**
         * The granted time of the RBAC Permission.
         */
        grantedAt: string;
        /**
         * The ID of the Grantee.
         */
        granteeId: number;
        /**
         * The type of Grantee. Valid values: `User`, `Role`.
         */
        granteeType: string;
        /**
         * The id of the RBAC Permission.
         */
        id: string;
        /**
         * Whether the RBAC Role is custom role.
         */
        isCustomRole: boolean;
        /**
         * The name of the Kube Role Binding.
         */
        kubeRoleBindingName: string;
        /**
         * The message of the RBAC Permission.
         */
        message: string;
        /**
         * The Namespace of the RBAC Permission.
         */
        namespace: string;
        /**
         * The revoked time of the RBAC Permission.
         */
        revokedAt: string;
        /**
         * The name of the RBAC Role.
         */
        roleName: string;
        /**
         * The status of RBAC Permission.
         */
        status: string;
    }

    export interface GetSupportAddonsAddon {
        /**
         * The categories of addons, the value is `Storage` or `Network` or `Monitor` or `Scheduler` or `Dns` or `Security` or `Gpu` or `Image`.
         */
        categories?: string[];
        /**
         * The deploy model.
         */
        deployMode: string;
        /**
         * The deploy node types, the value is `Node` or `VirtualNode`. Only effected when deployMode is `Unmanaged`.
         */
        deployNodeTypes: string[];
        /**
         * The name of the addon.
         */
        name: string;
        /**
         * The necessary of addon.
         */
        necessary?: string;
        /**
         * The container network model, the value is `Flannel` or `VpcCniShared`. Flannel: Flannel network model, an independent Underlay container network solution, combined with the global routing capability of VPC, to achieve a high-performance network experience for the cluster. VpcCniShared: VPC-CNI network model, an Underlay container network solution based on the ENI of the private network elastic network card, with high network communication performance.
         */
        podNetworkModes: string[];
        /**
         * The version info of addon.
         */
        versions: outputs.vke.GetSupportAddonsAddonVersion[];
    }

    export interface GetSupportAddonsAddonVersion {
        /**
         * The compatible version list.
         */
        compatibilities: outputs.vke.GetSupportAddonsAddonVersionCompatibility[];
        /**
         * The compatible version list.
         */
        compatibleVersions: string[];
        /**
         * The basic version info.
         */
        version: string;
    }

    export interface GetSupportAddonsAddonVersionCompatibility {
        /**
         * The Kubernetes Version of addon.
         */
        kubernetesVersion: string;
    }

    export interface GetSupportResourceTypesResource {
        /**
         * The scope of resource.
         */
        resourceScope: string;
        /**
         * The resource specifications info.
         */
        resourceSpecifications: string[];
        /**
         * The type of resource.
         */
        resourceType: string;
        /**
         * The id of zone.
         */
        zoneId: string;
    }

    export interface KubeconfigsKubeconfig {
        /**
         * The Cluster ID of the Kubeconfig.
         */
        clusterId: string;
        /**
         * The create time of the Kubeconfig.
         */
        createTime: string;
        /**
         * The expire time of the Kubeconfig.
         */
        expireTime: string;
        /**
         * The ID of the Kubeconfig.
         */
        id: string;
        /**
         * Kubeconfig data with public/private network access, returned in BASE64 encoding.
         */
        kubeconfig: string;
        /**
         * The ID of the Kubeconfig.
         */
        kubeconfigId: string;
        /**
         * The type of the Kubeconfig.
         */
        type: string;
        /**
         * The account ID of the Kubeconfig.
         */
        userId: number;
    }

    export interface NodeKubernetesConfig {
        /**
         * The Cordon of KubernetesConfig.
         */
        cordon: boolean;
        /**
         * The Labels of KubernetesConfig.
         */
        labels?: outputs.vke.NodeKubernetesConfigLabel[];
        /**
         * The Taints of KubernetesConfig.
         */
        taints: outputs.vke.NodeKubernetesConfigTaint[];
    }

    export interface NodeKubernetesConfigLabel {
        /**
         * The Key of Labels.
         */
        key?: string;
        /**
         * The Value of Labels.
         */
        value?: string;
    }

    export interface NodeKubernetesConfigTaint {
        /**
         * The Effect of Taints, the value can be `NoSchedule` or `NoExecute` or `PreferNoSchedule`.
         */
        effect?: string;
        /**
         * The Key of Taints.
         */
        key?: string;
        /**
         * The Value of Taints.
         */
        value?: string;
    }

    export interface NodePoolAutoScaling {
        /**
         * The DesiredReplicas of AutoScaling, default 0, range in minReplicas to max_replicas.
         */
        desiredReplicas: number;
        /**
         * Whether to enable the auto scaling function of the node pool. When a node needs to be manually added to the node pool, the value of this field must be `false`.
         */
        enabled: boolean;
        /**
         * The MaxReplicas of AutoScaling, default 10, range in 1~2000. This field is valid when the value of `enabled` is `true`.
         */
        maxReplicas?: number;
        /**
         * The MinReplicas of AutoScaling, default 0. This field is valid when the value of `enabled` is `true`.
         */
        minReplicas: number;
        /**
         * The Priority of AutoScaling, default 10, rang in 0~100. This field is valid when the value of `enabled` is `true` and the value of `subnetPolicy` is `Priority`.
         */
        priority: number;
        /**
         * Multi-subnet scheduling strategy for nodes. The value can be `ZoneBalance` or `Priority`.
         */
        subnetPolicy: string;
    }

    export interface NodePoolKubernetesConfig {
        /**
         * Whether to disable the function of automatically synchronizing labels and taints to existing nodes. Default is false.
         */
        autoSyncDisabled: boolean;
        /**
         * The Cordon of KubernetesConfig.
         */
        cordon: boolean;
        /**
         * The KubeletConfig of KubernetesConfig. After adding parameters, deleting parameters does not take effect.
         */
        kubeletConfig?: outputs.vke.NodePoolKubernetesConfigKubeletConfig;
        /**
         * The Labels of KubernetesConfig.
         */
        labels?: outputs.vke.NodePoolKubernetesConfigLabel[];
        /**
         * The NamePrefix of node metadata.
         */
        namePrefix?: string;
        /**
         * The Taints of KubernetesConfig.
         */
        taints?: outputs.vke.NodePoolKubernetesConfigTaint[];
    }

    export interface NodePoolKubernetesConfigKubeletConfig {
        /**
         * The FeatureGates of KubeletConfig.
         */
        featureGates?: outputs.vke.NodePoolKubernetesConfigKubeletConfigFeatureGates;
        /**
         * The TopologyManagerPolicy of KubeletConfig. Valid values: `none`, `restricted`, `best-effort`, `single-numa-node`. Default is `none`.
         */
        topologyManagerPolicy?: string;
        /**
         * The TopologyManagerScope of KubeletConfig. Valid values: `container`.
         */
        topologyManagerScope?: string;
    }

    export interface NodePoolKubernetesConfigKubeletConfigFeatureGates {
        /**
         * Whether to enable QoSResourceManager. Default is false.
         */
        qosResourceManager?: boolean;
    }

    export interface NodePoolKubernetesConfigLabel {
        /**
         * The Key of Labels.
         */
        key?: string;
        /**
         * The Value of Labels.
         */
        value?: string;
    }

    export interface NodePoolKubernetesConfigTaint {
        /**
         * The Effect of Taints, the value can be `NoSchedule` or `NoExecute` or `PreferNoSchedule`.
         */
        effect?: string;
        /**
         * The Key of Taints.
         */
        key?: string;
        /**
         * The Value of Taints.
         */
        value?: string;
    }

    export interface NodePoolManagement {
        /**
         * Whether to enable the management function of the node pool. Default is `false`.
         */
        enabled?: boolean;
        /**
         * The Remedy Config of NodePool. This field is valid when the value of `enabled` is `true`.
         */
        remedyConfig: outputs.vke.NodePoolManagementRemedyConfig;
    }

    export interface NodePoolManagementRemedyConfig {
        /**
         * Whether to enable the remedy function of the node pool. Default is `false`.
         */
        enabled?: boolean;
        /**
         * The ID of the remedy policy. This field is valid when the value of `enabled` is `true`.
         */
        id: string;
    }

    export interface NodePoolNodeConfig {
        /**
         * The AdditionalContainerStorageEnabled of NodeConfig.
         */
        additionalContainerStorageEnabled?: boolean;
        /**
         * Is AutoRenew of PrePaid instance of NodeConfig. Valid values: true, false. when InstanceChargeType is PrePaid, default value is true.
         */
        autoRenew: boolean;
        /**
         * The AutoRenewPeriod of PrePaid instance of NodeConfig. Valid values: 1, 2, 3, 6, 12. Unit: month. when InstanceChargeType is PrePaid and AutoRenew enable, default value is 1.
         */
        autoRenewPeriod: number;
        /**
         * The DataVolumes of NodeConfig.
         */
        dataVolumes?: outputs.vke.NodePoolNodeConfigDataVolume[];
        /**
         * Tags for Ecs.
         */
        ecsTags?: outputs.vke.NodePoolNodeConfigEcsTag[];
        /**
         * The IDs of HpcCluster, only one ID is supported currently.
         */
        hpcClusterIds?: string[];
        /**
         * The ImageId of NodeConfig.
         */
        imageId: string;
        /**
         * The initializeScript of NodeConfig.
         */
        initializeScript?: string;
        /**
         * The InstanceChargeType of PrePaid instance of NodeConfig. Valid values: PostPaid, PrePaid. Default value: PostPaid.
         */
        instanceChargeType?: string;
        /**
         * The InstanceTypeIds of NodeConfig. The value can get from volcengine.vke.getSupportResourceTypes datasource.
         */
        instanceTypeIds: string[];
        /**
         * The NamePrefix of NodeConfig.
         */
        namePrefix?: string;
        /**
         * The Period of PrePaid instance of NodeConfig. Valid values: 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 24, 36. Unit: month. when InstanceChargeType is PrePaid, default value is 12.
         */
        period: number;
        /**
         * The PreScript of NodeConfig.
         */
        preScript?: string;
        /**
         * The project name of the ecs instance.
         */
        projectName: string;
        /**
         * The Security of NodeConfig.
         */
        security: outputs.vke.NodePoolNodeConfigSecurity;
        /**
         * The SubnetIds of NodeConfig.
         */
        subnetIds: string[];
        /**
         * The SystemVolume of NodeConfig.
         */
        systemVolume: outputs.vke.NodePoolNodeConfigSystemVolume;
    }

    export interface NodePoolNodeConfigDataVolume {
        /**
         * The target mount directory of the disk. Must start with `/`.
         */
        mountPoint?: string;
        /**
         * The Size of DataVolumes, the value range in 20~32768. Default value is `20`.
         */
        size?: number;
        /**
         * The Type of DataVolumes, the value can be `PTSSD` or `ESSD_PL0` or `ESSD_FlexPL`. Default value is `ESSD_PL0`.
         */
        type?: string;
    }

    export interface NodePoolNodeConfigEcsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface NodePoolNodeConfigSecurity {
        /**
         * The Login of Security.
         */
        login?: outputs.vke.NodePoolNodeConfigSecurityLogin;
        /**
         * The SecurityGroupIds of Security.
         */
        securityGroupIds: string[];
        /**
         * The SecurityStrategies of Security, the value can be empty or `Hids`.
         */
        securityStrategies?: string[];
    }

    export interface NodePoolNodeConfigSecurityLogin {
        /**
         * The Password of Security, this field must be encoded with base64.
         */
        password?: string;
        /**
         * The SshKeyPairName of Security.
         */
        sshKeyPairName?: string;
    }

    export interface NodePoolNodeConfigSystemVolume {
        /**
         * The Size of SystemVolume, the value range in 20~2048.
         */
        size: number;
        /**
         * The Type of SystemVolume, the value can be `PTSSD` or `ESSD_PL0` or `ESSD_FlexPL`.
         */
        type: string;
    }

    export interface NodePoolNodeStatistic {
        /**
         * The CreatingCount of Node.
         */
        creatingCount: number;
        /**
         * The DeletingCount of Node.
         */
        deletingCount: number;
        /**
         * The FailedCount of Node.
         */
        failedCount: number;
        /**
         * The RunningCount of Node.
         */
        runningCount: number;
        /**
         * (**Deprecated**) This field has been deprecated and is not recommended for use. The StartingCount of Node.
         *
         * @deprecated This field has been deprecated and is not recommended for use.
         */
        startingCount: number;
        /**
         * (**Deprecated**) This field has been deprecated and is not recommended for use. The StoppedCount of Node.
         *
         * @deprecated This field has been deprecated and is not recommended for use.
         */
        stoppedCount: number;
        /**
         * (**Deprecated**) This field has been deprecated and is not recommended for use. The StoppingCount of Node.
         *
         * @deprecated This field has been deprecated and is not recommended for use.
         */
        stoppingCount: number;
        /**
         * The TotalCount of Node.
         */
        totalCount: number;
        /**
         * The UpdatingCount of Node.
         */
        updatingCount: number;
    }

    export interface NodePoolTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface NodePoolsNodePool {
        /**
         * Is AdditionalContainerStorageEnabled of NodeConfig.
         */
        additionalContainerStorageEnabled: boolean;
        /**
         * Is auto renew of the PrePaid instance of NodeConfig.
         */
        autoRenew: boolean;
        /**
         * The AutoRenewPeriod of the PrePaid instance of NodeConfig.
         */
        autoRenewPeriod: number;
        /**
         * The ClusterId of NodePool.
         */
        clusterId: string;
        /**
         * The Condition of Status.
         */
        conditionTypes: string[];
        /**
         * The Cordon of KubernetesConfig.
         */
        cordon: boolean;
        /**
         * The ClientToken when successfully created.
         */
        createClientToken: string;
        /**
         * The CreateTime of NodePool.
         */
        createTime: string;
        /**
         * The DataVolume of NodeConfig.
         */
        dataVolumes: outputs.vke.NodePoolsNodePoolDataVolume[];
        /**
         * The DesiredReplicas of AutoScaling.
         */
        desiredReplicas: number;
        /**
         * Tags for Ecs.
         */
        ecsTags: outputs.vke.NodePoolsNodePoolEcsTag[];
        /**
         * Whether to enable the remedy function of the node pool.
         */
        enabled: boolean;
        /**
         * The IDs of HpcCluster.
         */
        hpcClusterIds: string[];
        /**
         * The ID of the remedy policy.
         */
        id: string;
        /**
         * The ImageId of NodeConfig.
         */
        imageId: string;
        /**
         * The InitializeScript of NodeConfig.
         */
        initializeScript: string;
        /**
         * The InstanceChargeType of NodeConfig.
         */
        instanceChargeType: string;
        /**
         * The InstanceTypeIds of NodeConfig.
         */
        instanceTypeIds: string[];
        /**
         * Whether to disable the function of automatically synchronizing labels and taints to existing nodes.
         */
        kubeConfigAutoSyncDisabled: boolean;
        /**
         * The NamePrefix of node metadata.
         */
        kubeConfigNamePrefix: string;
        /**
         * The KubeletConfig of KubernetesConfig.
         */
        kubeletConfigs: outputs.vke.NodePoolsNodePoolKubeletConfig[];
        /**
         * The LabelContent of KubernetesConfig.
         */
        labelContents: outputs.vke.NodePoolsNodePoolLabelContent[];
        /**
         * The login SshKeyPairName of NodeConfig.
         */
        loginKeyPairName: string;
        /**
         * The login type of NodeConfig.
         */
        loginType: string;
        /**
         * The Management Config of NodePool.
         */
        managements: outputs.vke.NodePoolsNodePoolManagement[];
        /**
         * The MaxReplicas of AutoScaling.
         */
        maxReplicas: number;
        /**
         * The MinReplicas of AutoScaling.
         */
        minReplicas: number;
        /**
         * The Name of NodePool.
         */
        name: string;
        /**
         * The NamePrefix of NodeConfig.
         */
        namePrefix: string;
        /**
         * The NodeStatistics of NodeConfig.
         */
        nodeStatistics: outputs.vke.NodePoolsNodePoolNodeStatistic[];
        /**
         * The period of the PrePaid instance of NodeConfig.
         */
        period: number;
        /**
         * The Phase of Status.
         */
        phase: string;
        /**
         * The PreScript of NodeConfig.
         */
        preScript: string;
        /**
         * The Priority of AutoScaling.
         */
        priority: number;
        /**
         * The project name of NodeConfig.
         */
        projectName: string;
        /**
         * The SecurityGroupIds of NodeConfig.
         */
        securityGroupIds: string[];
        /**
         * The SecurityStrategies of NodeConfig.
         */
        securityStrategies: string[];
        /**
         * The SecurityStrategyEnabled of NodeConfig.
         */
        securityStrategyEnabled: boolean;
        /**
         * The SubnetId of NodeConfig.
         */
        subnetIds: string[];
        /**
         * Multi-subnet scheduling strategy for nodes. The value can be `ZoneBalance` or `Priority`.
         */
        subnetPolicy: string;
        /**
         * The SystemVolume of NodeConfig.
         */
        systemVolumes: outputs.vke.NodePoolsNodePoolSystemVolume[];
        /**
         * Tags.
         */
        tags: outputs.vke.NodePoolsNodePoolTag[];
        /**
         * The TaintContent of NodeConfig.
         */
        taintContents: outputs.vke.NodePoolsNodePoolTaintContent[];
        /**
         * The ClientToken when last update was successful.
         */
        updateClientToken: string;
        /**
         * The UpdateTime time of NodePool.
         */
        updateTime: string;
    }

    export interface NodePoolsNodePoolDataVolume {
        /**
         * The target mount directory of the disk.
         */
        mountPoint: string;
        /**
         * The Size of SystemVolume.
         */
        size: string;
        /**
         * The Type of Tags.
         */
        type: string;
    }

    export interface NodePoolsNodePoolEcsTag {
        /**
         * The Key of Taint.
         */
        key: string;
        /**
         * The Value of Taint.
         */
        value: string;
    }

    export interface NodePoolsNodePoolKubeletConfig {
        /**
         * The FeatureGates of KubeletConfig.
         */
        featureGates: outputs.vke.NodePoolsNodePoolKubeletConfigFeatureGate[];
        /**
         * The TopologyManagerPolicy of KubeletConfig.
         */
        topologyManagerPolicy: string;
        /**
         * The TopologyManagerScope of KubeletConfig.
         */
        topologyManagerScope: string;
    }

    export interface NodePoolsNodePoolKubeletConfigFeatureGate {
        /**
         * Whether to enable QoSResourceManager.
         */
        qosResourceManager: boolean;
    }

    export interface NodePoolsNodePoolLabelContent {
        /**
         * The Key of Taint.
         */
        key: string;
        /**
         * The Value of Taint.
         */
        value: string;
    }

    export interface NodePoolsNodePoolManagement {
        /**
         * Whether to enable the remedy function of the node pool.
         */
        enabled: boolean;
        /**
         * The Remedy Config of NodePool.
         */
        remedyConfigs: outputs.vke.NodePoolsNodePoolManagementRemedyConfig[];
    }

    export interface NodePoolsNodePoolManagementRemedyConfig {
        /**
         * Whether to enable the remedy function of the node pool.
         */
        enabled: boolean;
        /**
         * The ID of the remedy policy.
         */
        id: string;
    }

    export interface NodePoolsNodePoolNodeStatistic {
        /**
         * The CreatingCount of Node.
         */
        creatingCount: number;
        /**
         * The DeletingCount of Node.
         */
        deletingCount: number;
        /**
         * The FailedCount of Node.
         */
        failedCount: number;
        /**
         * The RunningCount of Node.
         */
        runningCount: number;
        /**
         * (**Deprecated**) This field has been deprecated and is not recommended for use. The StartingCount of Node.
         *
         * @deprecated This field has been deprecated and is not recommended for use.
         */
        startingCount: number;
        /**
         * (**Deprecated**) This field has been deprecated and is not recommended for use. The StoppedCount of Node.
         *
         * @deprecated This field has been deprecated and is not recommended for use.
         */
        stoppedCount: number;
        /**
         * (**Deprecated**) This field has been deprecated and is not recommended for use. The StoppingCount of Node.
         *
         * @deprecated This field has been deprecated and is not recommended for use.
         */
        stoppingCount: number;
        /**
         * Returns the total amount of the data list.
         */
        totalCount: number;
        /**
         * The UpdatingCount of Node.
         */
        updatingCount: number;
    }

    export interface NodePoolsNodePoolSystemVolume {
        /**
         * The Size of SystemVolume.
         */
        size: string;
        /**
         * The Type of Tags.
         */
        type: string;
    }

    export interface NodePoolsNodePoolTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Type of Tags.
         */
        type: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface NodePoolsNodePoolTaintContent {
        /**
         * The Effect of Taint.
         */
        effect: string;
        /**
         * The Key of Taint.
         */
        key: string;
        /**
         * The Value of Taint.
         */
        value: string;
    }

    export interface NodePoolsStatus {
        /**
         * Indicates the status condition of the node pool in the active state. The value can be `Progressing` or `Ok` or `VersionPartlyUpgraded` or `StockOut` or `LimitedByQuota` or `Balance` or `Degraded` or `ClusterVersionUpgrading` or `Cluster` or `ResourceCleanupFailed` or `Unknown` or `ClusterNotRunning` or `SetByProvider`.
         */
        conditionsType?: string;
        /**
         * The Phase of Status. The value can be `Creating` or `Running` or `Updating` or `Deleting` or `Failed` or `Scaling`.
         */
        phase?: string;
    }

    export interface NodePoolsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface NodesNode {
        /**
         * Is Additional Container storage enables.
         */
        additionalContainerStorageEnabled: boolean;
        /**
         * The cluster id of node.
         */
        clusterId: string;
        /**
         * The Condition of Node.
         */
        conditionTypes: string[];
        /**
         * The Storage Path.
         */
        containerStoragePath: string;
        /**
         * The Cordon of KubernetesConfig.
         */
        cordon: boolean;
        /**
         * The Create Client Token.
         */
        createClientToken: string;
        /**
         * The create time of Node.
         */
        createTime: string;
        /**
         * The ID of Node.
         */
        id: string;
        /**
         * The ImageId of NodeConfig.
         */
        imageId: string;
        /**
         * The InitializeScript of NodeConfig.
         */
        initializeScript: string;
        /**
         * The instance id of node.
         */
        instanceId: string;
        /**
         * Is virtual node.
         */
        isVirtual: boolean;
        /**
         * The Label of KubernetesConfig.
         */
        labels: outputs.vke.NodesNodeLabel[];
        /**
         * The Name of Node.
         */
        name: string;
        /**
         * The node pool id.
         */
        nodePoolId: string;
        /**
         * The Phase of Node.
         */
        phase: string;
        /**
         * The PreScript of NodeConfig.
         */
        preScript: string;
        /**
         * The roles of node.
         */
        roles: string[];
        /**
         * The Taint of KubernetesConfig.
         */
        taints: outputs.vke.NodesNodeTaint[];
        /**
         * The update time of Node.
         */
        updateTime: string;
        /**
         * The zone id.
         */
        zoneId: string;
    }

    export interface NodesNodeLabel {
        /**
         * The Key of Taint.
         */
        key: string;
        /**
         * The Value of Taint.
         */
        value: string;
    }

    export interface NodesNodeTaint {
        /**
         * The Effect of Taint.
         */
        effect: string;
        /**
         * The Key of Taint.
         */
        key: string;
        /**
         * The Value of Taint.
         */
        value: string;
    }

    export interface NodesStatus {
        /**
         * The Type of Node Condition, the value is `Progressing` or `Ok` or `Unschedulable` or `InitilizeFailed` or `Unknown` or `NotReady` or `Security` or `Balance` or `ResourceCleanupFailed`.
         */
        conditionsType?: string;
        /**
         * The Phase of Node, the value is `Creating` or `Running` or `Updating` or `Deleting` or `Failed` or `Starting` or `Stopping` or `Stopped`.
         */
        phase?: string;
    }

    export interface PermissionsAccessPolicy {
        /**
         * The authorized time of the RBAC Permission.
         */
        authorizedAt: string;
        /**
         * The ID of the Authorizer.
         */
        authorizerId: number;
        /**
         * The name of the Authorizer.
         */
        authorizerName: string;
        /**
         * The type of the Authorizer.
         */
        authorizerType: string;
        /**
         * The ID of the Cluster.
         */
        clusterId: string;
        /**
         * The granted time of the RBAC Permission.
         */
        grantedAt: string;
        /**
         * The ID of the Grantee.
         */
        granteeId: number;
        /**
         * The type of Grantee. Valid values: `User`, `Role`.
         */
        granteeType: string;
        /**
         * The id of the RBAC Permission.
         */
        id: string;
        /**
         * Whether the RBAC Role is custom role.
         */
        isCustomRole: boolean;
        /**
         * The name of the Kube Role Binding.
         */
        kubeRoleBindingName: string;
        /**
         * The message of the RBAC Permission.
         */
        message: string;
        /**
         * The Namespace of the RBAC Permission.
         */
        namespace: string;
        /**
         * The revoked time of the RBAC Permission.
         */
        revokedAt: string;
        /**
         * The name of the RBAC Role.
         */
        roleName: string;
        /**
         * The status of RBAC Permission.
         */
        status: string;
    }

    export interface SupportAddonsAddon {
        /**
         * The categories of addons, the value is `Storage` or `Network` or `Monitor` or `Scheduler` or `Dns` or `Security` or `Gpu` or `Image`.
         */
        categories?: string[];
        /**
         * The deploy model.
         */
        deployMode: string;
        /**
         * The deploy node types, the value is `Node` or `VirtualNode`. Only effected when deployMode is `Unmanaged`.
         */
        deployNodeTypes: string[];
        /**
         * The name of the addon.
         */
        name: string;
        /**
         * The necessary of addon.
         */
        necessary?: string;
        /**
         * The container network model, the value is `Flannel` or `VpcCniShared`. Flannel: Flannel network model, an independent Underlay container network solution, combined with the global routing capability of VPC, to achieve a high-performance network experience for the cluster. VpcCniShared: VPC-CNI network model, an Underlay container network solution based on the ENI of the private network elastic network card, with high network communication performance.
         */
        podNetworkModes: string[];
        /**
         * The version info of addon.
         */
        versions: outputs.vke.SupportAddonsAddonVersion[];
    }

    export interface SupportAddonsAddonVersion {
        /**
         * The compatible version list.
         */
        compatibilities: outputs.vke.SupportAddonsAddonVersionCompatibility[];
        /**
         * The compatible version list.
         */
        compatibleVersions: string[];
        /**
         * The basic version info.
         */
        version: string;
    }

    export interface SupportAddonsAddonVersionCompatibility {
        /**
         * The Kubernetes Version of addon.
         */
        kubernetesVersion: string;
    }

    export interface SupportResourceTypesResource {
        /**
         * The scope of resource.
         */
        resourceScope: string;
        /**
         * The resource specifications info.
         */
        resourceSpecifications: string[];
        /**
         * The type of resource.
         */
        resourceType: string;
        /**
         * The id of zone.
         */
        zoneId: string;
    }

}

export namespace vmp {
    export interface AlertingRuleAnnotation {
        /**
         * The name of the annotation.
         */
        name: string;
        /**
         * The value of the annotation.
         */
        value: string;
    }

    export interface AlertingRuleLabel {
        /**
         * The name of the label.
         */
        name: string;
        /**
         * The value of the label.
         */
        value: string;
    }

    export interface AlertingRuleLevel {
        /**
         * The comparator of the vmp alerting rule. Valid values: `>`, `>=`, `<`, `<=`, `==`, `!=`.
         */
        comparator: string;
        /**
         * The duration of the alerting rule. Valid values: `0s`, `1m`, `2m`, `5m`, `10m`.
         */
        for: string;
        /**
         * The level of the vmp alerting rule. Valid values: `P0`, `P1`, `P2`. The value of this field cannot be duplicate.
         */
        level: string;
        /**
         * The threshold of the vmp alerting rule.
         */
        threshold: number;
    }

    export interface AlertingRuleQuery {
        /**
         * The prom ql of query.
         */
        promQl: string;
        /**
         * The id of the workspace.
         */
        workspaceId: string;
    }

    export interface AlertingRulesAlertingRule {
        /**
         * The annotations of the vmp alerting rule.
         */
        annotations: outputs.vmp.AlertingRulesAlertingRuleAnnotation[];
        /**
         * The create time of the vmp alerting rule.
         */
        createTime: string;
        /**
         * The description of the vmp alerting rule.
         */
        description: string;
        /**
         * The id of the vmp alerting rule.
         */
        id: string;
        /**
         * The labels of the vmp alerting rule.
         */
        labels: outputs.vmp.AlertingRulesAlertingRuleLabel[];
        /**
         * The alerting levels of the vmp alerting rule.
         */
        levels: outputs.vmp.AlertingRulesAlertingRuleLevel[];
        /**
         * The name of vmp alerting rule. This field support fuzzy query.
         */
        name: string;
        /**
         * The notify group policy id of the vmp alerting rule.
         */
        notifyGroupPolicyId: string;
        /**
         * The notify policy id of the vmp alerting rule.
         */
        notifyPolicyId: string;
        /**
         * The alerting query of the vmp alerting rule.
         */
        queries: outputs.vmp.AlertingRulesAlertingRuleQuery[];
        /**
         * The status of vmp alerting rule. Valid values: `Running`, `Disabled`.
         */
        status: string;
        /**
         * The type of vmp alerting rule. Valid values: `vmp/PromQL`.
         */
        type: string;
        /**
         * The update time of the vmp alerting rule.
         */
        updateTime: string;
    }

    export interface AlertingRulesAlertingRuleAnnotation {
        /**
         * The name of vmp alerting rule. This field support fuzzy query.
         */
        name: string;
        /**
         * The value of the label.
         */
        value: string;
    }

    export interface AlertingRulesAlertingRuleLabel {
        /**
         * The name of the label.
         */
        key: string;
        /**
         * The value of the label.
         */
        value: string;
    }

    export interface AlertingRulesAlertingRuleLevel {
        /**
         * The comparator of the vmp alerting rule.
         */
        comparator: string;
        /**
         * The duration of the alerting rule.
         */
        for: string;
        /**
         * The level of the vmp alerting rule.
         */
        level: string;
        /**
         * The threshold of the vmp alerting rule.
         */
        threshold: number;
    }

    export interface AlertingRulesAlertingRuleQuery {
        /**
         * The prom ql of query.
         */
        promQl: string;
        /**
         * The workspace id of vmp alerting rule.
         */
        workspaceId: string;
    }

    export interface AlertsAlert {
        /**
         * The id of the vmp alerting rule.
         */
        alertingRuleId: string;
        /**
         * The alerting query of the vmp alerting rule.
         */
        alertingRuleQueries: outputs.vmp.AlertsAlertAlertingRuleQuery[];
        /**
         * The type of the vmp alerting rule.
         */
        alertingRuleType: string;
        /**
         * The current level of the vmp alert.
         */
        currentLevel: string;
        /**
         * The status of vmp alert. Valid values: `Pending`, `Active`, `Resolved`, `Disabled`.
         */
        currentPhase: string;
        /**
         * The id of the vmp alert.
         */
        id: string;
        /**
         * The start time of the vmp alert. Format: RFC3339.
         */
        initialAlertTimestamp: string;
        /**
         * The last time of the vmp alert. Format: RFC3339.
         */
        lastAlertTimestamp: string;
        /**
         * The alerting levels of the vmp alert.
         */
        levels: outputs.vmp.AlertsAlertLevel[];
        /**
         * The end time of the vmp alert. Format: RFC3339.
         */
        resolveAlertTimestamp: string;
        /**
         * The alerting resource of the vmp alert.
         */
        resources: outputs.vmp.AlertsAlertResource[];
    }

    export interface AlertsAlertAlertingRuleQuery {
        /**
         * The prom ql of query.
         */
        promQl: string;
        /**
         * The id of the workspace.
         */
        workspaceId: string;
    }

    export interface AlertsAlertLevel {
        /**
         * The comparator of the vmp alerting rule.
         */
        comparator: string;
        /**
         * The duration of the alerting rule.
         */
        for: string;
        /**
         * The level of vmp alert. Valid values: `P0`, `P1`, `P2`.
         */
        level: string;
        /**
         * The threshold of the vmp alerting rule.
         */
        threshold: number;
    }

    export interface AlertsAlertResource {
        /**
         * The labels of alerting resource.
         */
        labels: outputs.vmp.AlertsAlertResourceLabel[];
    }

    export interface AlertsAlertResourceLabel {
        /**
         * The key of the label.
         */
        key: string;
        /**
         * The value of the label.
         */
        value: string;
    }

    export interface ContactDingTalkBotWebhook {
        /**
         * The address of webhook.
         */
        address: string;
        /**
         * The mobiles of user.
         */
        atMobiles?: string[];
        /**
         * The ids of user.
         */
        atUserIds?: string[];
        /**
         * The secret key of webhook.
         */
        secretKey?: string;
    }

    export interface ContactGroupsContactGroup {
        /**
         * A list of contact IDs.
         */
        contactIds: string[];
        /**
         * The create time of contact group.
         */
        createTime: string;
        /**
         * The ID of contact group.
         */
        id: string;
        /**
         * The name of contact group.
         */
        name: string;
    }

    export interface ContactLarkBotWebhook {
        /**
         * The address of webhook.
         */
        address: string;
        /**
         * The secret key of webhook.
         */
        secretKey?: string;
    }

    export interface ContactPhoneNumber {
        /**
         * The country code of phone number. The value is `+86`.
         */
        countryCode: string;
        /**
         * The number of phone number.
         */
        number: string;
    }

    export interface ContactWeComBotWebhook {
        /**
         * The address of webhook.
         */
        address: string;
        /**
         * The ids of user.
         */
        atUserIds?: string[];
    }

    export interface ContactWebhook {
        /**
         * The address of webhook.
         */
        address: string;
        /**
         * The token of webhook.
         */
        token?: string;
    }

    export interface ContactsContact {
        /**
         * A list of contact group ids.
         */
        contactGroupIds: string[];
        /**
         * The create time of contact.
         */
        createTime: string;
        /**
         * The ding talk bot webhook of contact.
         */
        dingTalkBotWebhooks: outputs.vmp.ContactsContactDingTalkBotWebhook[];
        /**
         * The email of contact.
         */
        email: string;
        /**
         * Whether the email of contact active.
         */
        emailActive: boolean;
        /**
         * The ID of contact.
         */
        id: string;
        /**
         * The lark bot webhook of contact.
         */
        larkBotWebhooks: outputs.vmp.ContactsContactLarkBotWebhook[];
        /**
         * The name of contact.
         */
        name: string;
        /**
         * Whether phone number is active.
         */
        phoneNumberActive: boolean;
        /**
         * The phone number of contact.
         */
        phoneNumbers: outputs.vmp.ContactsContactPhoneNumber[];
        /**
         * The we com bot webhook of contact.
         */
        weComBotWebhooks: outputs.vmp.ContactsContactWeComBotWebhook[];
        /**
         * The webhook of contact.
         */
        webhooks: outputs.vmp.ContactsContactWebhook[];
    }

    export interface ContactsContactDingTalkBotWebhook {
        /**
         * The address of webhook.
         */
        address: string;
        /**
         * The mobiles of user.
         */
        atMobiles: string[];
        /**
         * The ids of user.
         */
        atUserIds: string[];
        /**
         * The secret key of webhook.
         */
        secretKey: string;
    }

    export interface ContactsContactLarkBotWebhook {
        /**
         * The address of webhook.
         */
        address: string;
        /**
         * The secret key of webhook.
         */
        secretKey: string;
    }

    export interface ContactsContactPhoneNumber {
        /**
         * The country code of phone number.
         */
        countryCode: string;
        /**
         * The number of phone number.
         */
        number: string;
    }

    export interface ContactsContactWeComBotWebhook {
        /**
         * The address of webhook.
         */
        address: string;
        /**
         * The ids of user.
         */
        atUserIds: string[];
    }

    export interface ContactsContactWebhook {
        /**
         * The address of webhook.
         */
        address: string;
        /**
         * The token of webhook.
         */
        token: string;
    }

    export interface GetAlertingRulesAlertingRule {
        /**
         * The annotations of the vmp alerting rule.
         */
        annotations: outputs.vmp.GetAlertingRulesAlertingRuleAnnotation[];
        /**
         * The create time of the vmp alerting rule.
         */
        createTime: string;
        /**
         * The description of the vmp alerting rule.
         */
        description: string;
        /**
         * The id of the vmp alerting rule.
         */
        id: string;
        /**
         * The labels of the vmp alerting rule.
         */
        labels: outputs.vmp.GetAlertingRulesAlertingRuleLabel[];
        /**
         * The alerting levels of the vmp alerting rule.
         */
        levels: outputs.vmp.GetAlertingRulesAlertingRuleLevel[];
        /**
         * The name of vmp alerting rule. This field support fuzzy query.
         */
        name: string;
        /**
         * The notify group policy id of the vmp alerting rule.
         */
        notifyGroupPolicyId: string;
        /**
         * The notify policy id of the vmp alerting rule.
         */
        notifyPolicyId: string;
        /**
         * The alerting query of the vmp alerting rule.
         */
        queries: outputs.vmp.GetAlertingRulesAlertingRuleQuery[];
        /**
         * The status of vmp alerting rule. Valid values: `Running`, `Disabled`.
         */
        status: string;
        /**
         * The type of vmp alerting rule. Valid values: `vmp/PromQL`.
         */
        type: string;
        /**
         * The update time of the vmp alerting rule.
         */
        updateTime: string;
    }

    export interface GetAlertingRulesAlertingRuleAnnotation {
        /**
         * The name of vmp alerting rule. This field support fuzzy query.
         */
        name: string;
        /**
         * The value of the label.
         */
        value: string;
    }

    export interface GetAlertingRulesAlertingRuleLabel {
        /**
         * The name of the label.
         */
        key: string;
        /**
         * The value of the label.
         */
        value: string;
    }

    export interface GetAlertingRulesAlertingRuleLevel {
        /**
         * The comparator of the vmp alerting rule.
         */
        comparator: string;
        /**
         * The duration of the alerting rule.
         */
        for: string;
        /**
         * The level of the vmp alerting rule.
         */
        level: string;
        /**
         * The threshold of the vmp alerting rule.
         */
        threshold: number;
    }

    export interface GetAlertingRulesAlertingRuleQuery {
        /**
         * The prom ql of query.
         */
        promQl: string;
        /**
         * The workspace id of vmp alerting rule.
         */
        workspaceId: string;
    }

    export interface GetAlertsAlert {
        /**
         * The id of the vmp alerting rule.
         */
        alertingRuleId: string;
        /**
         * The alerting query of the vmp alerting rule.
         */
        alertingRuleQueries: outputs.vmp.GetAlertsAlertAlertingRuleQuery[];
        /**
         * The type of the vmp alerting rule.
         */
        alertingRuleType: string;
        /**
         * The current level of the vmp alert.
         */
        currentLevel: string;
        /**
         * The status of vmp alert. Valid values: `Pending`, `Active`, `Resolved`, `Disabled`.
         */
        currentPhase: string;
        /**
         * The id of the vmp alert.
         */
        id: string;
        /**
         * The start time of the vmp alert. Format: RFC3339.
         */
        initialAlertTimestamp: string;
        /**
         * The last time of the vmp alert. Format: RFC3339.
         */
        lastAlertTimestamp: string;
        /**
         * The alerting levels of the vmp alert.
         */
        levels: outputs.vmp.GetAlertsAlertLevel[];
        /**
         * The end time of the vmp alert. Format: RFC3339.
         */
        resolveAlertTimestamp: string;
        /**
         * The alerting resource of the vmp alert.
         */
        resources: outputs.vmp.GetAlertsAlertResource[];
    }

    export interface GetAlertsAlertAlertingRuleQuery {
        /**
         * The prom ql of query.
         */
        promQl: string;
        /**
         * The id of the workspace.
         */
        workspaceId: string;
    }

    export interface GetAlertsAlertLevel {
        /**
         * The comparator of the vmp alerting rule.
         */
        comparator: string;
        /**
         * The duration of the alerting rule.
         */
        for: string;
        /**
         * The level of vmp alert. Valid values: `P0`, `P1`, `P2`.
         */
        level: string;
        /**
         * The threshold of the vmp alerting rule.
         */
        threshold: number;
    }

    export interface GetAlertsAlertResource {
        /**
         * The labels of alerting resource.
         */
        labels: outputs.vmp.GetAlertsAlertResourceLabel[];
    }

    export interface GetAlertsAlertResourceLabel {
        /**
         * The key of the label.
         */
        key: string;
        /**
         * The value of the label.
         */
        value: string;
    }

    export interface GetContactGroupsContactGroup {
        /**
         * A list of contact IDs.
         */
        contactIds: string[];
        /**
         * The create time of contact group.
         */
        createTime: string;
        /**
         * The ID of contact group.
         */
        id: string;
        /**
         * The name of contact group.
         */
        name: string;
    }

    export interface GetContactsContact {
        /**
         * A list of contact group ids.
         */
        contactGroupIds: string[];
        /**
         * The create time of contact.
         */
        createTime: string;
        /**
         * The ding talk bot webhook of contact.
         */
        dingTalkBotWebhooks: outputs.vmp.GetContactsContactDingTalkBotWebhook[];
        /**
         * The email of contact.
         */
        email: string;
        /**
         * Whether the email of contact active.
         */
        emailActive: boolean;
        /**
         * The ID of contact.
         */
        id: string;
        /**
         * The lark bot webhook of contact.
         */
        larkBotWebhooks: outputs.vmp.GetContactsContactLarkBotWebhook[];
        /**
         * The name of contact.
         */
        name: string;
        /**
         * Whether phone number is active.
         */
        phoneNumberActive: boolean;
        /**
         * The phone number of contact.
         */
        phoneNumbers: outputs.vmp.GetContactsContactPhoneNumber[];
        /**
         * The we com bot webhook of contact.
         */
        weComBotWebhooks: outputs.vmp.GetContactsContactWeComBotWebhook[];
        /**
         * The webhook of contact.
         */
        webhooks: outputs.vmp.GetContactsContactWebhook[];
    }

    export interface GetContactsContactDingTalkBotWebhook {
        /**
         * The address of webhook.
         */
        address: string;
        /**
         * The mobiles of user.
         */
        atMobiles: string[];
        /**
         * The ids of user.
         */
        atUserIds: string[];
        /**
         * The secret key of webhook.
         */
        secretKey: string;
    }

    export interface GetContactsContactLarkBotWebhook {
        /**
         * The address of webhook.
         */
        address: string;
        /**
         * The secret key of webhook.
         */
        secretKey: string;
    }

    export interface GetContactsContactPhoneNumber {
        /**
         * The country code of phone number.
         */
        countryCode: string;
        /**
         * The number of phone number.
         */
        number: string;
    }

    export interface GetContactsContactWeComBotWebhook {
        /**
         * The address of webhook.
         */
        address: string;
        /**
         * The ids of user.
         */
        atUserIds: string[];
    }

    export interface GetContactsContactWebhook {
        /**
         * The address of webhook.
         */
        address: string;
        /**
         * The token of webhook.
         */
        token: string;
    }

    export interface GetInstanceTypesInstanceType {
        /**
         * Maximum number of active sequences.
         */
        activeSeries: number;
        /**
         * Number of zone.
         */
        availabilityZoneReplicas: number;
        /**
         * Whether the workspace is exclusive.
         */
        dedicated: boolean;
        /**
         * The ID of instance type.
         */
        id: string;
        /**
         * Maximum write samples per second.
         */
        ingestSamplesPerSecond: number;
        /**
         * Maximum number of concurrent queries.
         */
        queryConcurrency: number;
        /**
         * Maximum Query QPS.
         */
        queryPerSecond: number;
        /**
         * Data replicas per az.
         */
        replicasPerZone: number;
        /**
         * Maximum data retention time.
         */
        retentionPeriod: string;
        /**
         * Maximum scan samples per second.
         */
        scanSamplesPerSecond: number;
        /**
         * Maximum number of scan sequences per second.
         */
        scanSeriesPerSecond: number;
    }

    export interface GetNotifyGroupPoliciesNotifyPolicy {
        /**
         * The create time of notify group policy.
         */
        createTime: string;
        /**
         * The description of notify group policy.
         */
        description: string;
        /**
         * The id of the notify group policy.
         */
        id: string;
        /**
         * The levels of the notify group policy.
         */
        levels: outputs.vmp.GetNotifyGroupPoliciesNotifyPolicyLevel[];
        /**
         * The name of notify group policy.
         */
        name: string;
    }

    export interface GetNotifyGroupPoliciesNotifyPolicyLevel {
        /**
         * The aggregate dimension.
         */
        groupBies: string[];
        /**
         * The aggregation cycle.
         */
        groupInterval: string;
        /**
         * The wait time.
         */
        groupWait: string;
        /**
         * The level of the policy.
         */
        level: string;
        /**
         * The notification cycle.
         */
        repeatInterval: string;
    }

    export interface GetNotifyPoliciesNotifyPolicy {
        /**
         * The channel notify template for the alarm notification policy.
         */
        channelNotifyTemplateIds: string[];
        /**
         * The create time of notify policy.
         */
        createTime: string;
        /**
         * The description of notify policy.
         */
        description: string;
        /**
         * The id of the notify policy.
         */
        id: string;
        /**
         * The levels of the notify policy.
         */
        levels: outputs.vmp.GetNotifyPoliciesNotifyPolicyLevel[];
        /**
         * The name of notify policy.
         */
        name: string;
    }

    export interface GetNotifyPoliciesNotifyPolicyLevel {
        /**
         * The alarm notification method of the alarm notification policy.
         */
        channels: string[];
        /**
         * The contact group for the alarm notification policy.
         */
        contactGroupIds: string[];
        /**
         * The level of the policy.
         */
        level: string;
        /**
         * The resolved alarm notification method of the alarm notification policy.
         */
        resolvedChannels: string[];
    }

    export interface GetNotifyTemplatesNotifyTemplate {
        /**
         * The active notify template info.
         */
        actives: outputs.vmp.GetNotifyTemplatesNotifyTemplateActive[];
        /**
         * The channel of notify template. Valid values: `LarkBotWebhook`, `DingTalkBotWebhook`, `WeComBotWebhook`.
         */
        channel: string;
        /**
         * The create time of notify template.
         */
        createTime: string;
        /**
         * The description of notify template.
         */
        description: string;
        /**
         * The ID of notify template.
         */
        id: string;
        /**
         * The name of notify template. This field support fuzzy query.
         */
        name: string;
        /**
         * The resolved notify template info.
         */
        resolveds: outputs.vmp.GetNotifyTemplatesNotifyTemplateResolved[];
        /**
         * The update time of notify template.
         */
        updateTime: string;
    }

    export interface GetNotifyTemplatesNotifyTemplateActive {
        /**
         * The content of notify template.
         */
        content: string;
        /**
         * The title of notify template.
         */
        title: string;
    }

    export interface GetNotifyTemplatesNotifyTemplateResolved {
        /**
         * The content of notify template.
         */
        content: string;
        /**
         * The title of notify template.
         */
        title: string;
    }

    export interface GetRuleFilesFile {
        /**
         * The content of rule file.
         */
        content: string;
        /**
         * The create time of rule file.
         */
        createTime: string;
        /**
         * The description of rule file.
         */
        description: string;
        /**
         * The ID of rule file.
         */
        id: string;
        /**
         * The last update time of rule file.
         */
        lastUpdateTime: string;
        /**
         * The name of rule file.
         */
        name: string;
        /**
         * The rule count number of rule file.
         */
        ruleCount: number;
        /**
         * The status of rule file.
         */
        status: string;
    }

    export interface GetRulesRule {
        /**
         * The expr of rule.
         */
        expr: string;
        /**
         * The kind of rule.
         */
        kind: string;
        /**
         * The labels of rule.
         */
        labels: outputs.vmp.GetRulesRuleLabel[];
        /**
         * The last evaluation of rule.
         */
        lastEvaluation: string;
        /**
         * The name of rule.
         */
        name: string;
        /**
         * The reason of rule.
         */
        reason: string;
        /**
         * The name of rule file.
         */
        ruleFileName: string;
        /**
         * The name of rule group.
         */
        ruleGroupName: string;
        /**
         * The status of rule.
         */
        status: string;
    }

    export interface GetRulesRuleLabel {
        /**
         * The key of label.
         */
        key: string;
        /**
         * The value of label.
         */
        value: string;
    }

    export interface GetWorkspacesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        values: string[];
    }

    export interface GetWorkspacesWorkspace {
        /**
         * The create time of workspace.
         */
        createTime: string;
        /**
         * Whether enable delete protection.
         */
        deleteProtectionEnabled: boolean;
        /**
         * The description of workspace.
         */
        description: string;
        /**
         * The ID of workspace.
         */
        id: string;
        /**
         * The id of instance type.
         */
        instanceTypeId: string;
        /**
         * The name of workspace.
         */
        name: string;
        /**
         * The overdue reclaim time.
         */
        overdueReclaimTime: string;
        /**
         * The project name of vmp workspace.
         */
        projectName: string;
        /**
         * The prometheus push intranet endpoint.
         */
        prometheusPushIntranetEndpoint: string;
        /**
         * The prometheus query intranet endpoint.
         */
        prometheusQueryIntranetEndpoint: string;
        /**
         * The prometheus write intranet endpoint.
         */
        prometheusWriteIntranetEndpoint: string;
        /**
         * The status of workspace.
         */
        status: string;
        /**
         * The tags of vmp workspace.
         */
        tags: outputs.vmp.GetWorkspacesWorkspaceTag[];
        /**
         * The username of workspace.
         */
        username: string;
    }

    export interface GetWorkspacesWorkspaceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface InstanceTypesInstanceType {
        /**
         * Maximum number of active sequences.
         */
        activeSeries: number;
        /**
         * Number of zone.
         */
        availabilityZoneReplicas: number;
        /**
         * Whether the workspace is exclusive.
         */
        dedicated: boolean;
        /**
         * The ID of instance type.
         */
        id: string;
        /**
         * Maximum write samples per second.
         */
        ingestSamplesPerSecond: number;
        /**
         * Maximum number of concurrent queries.
         */
        queryConcurrency: number;
        /**
         * Maximum Query QPS.
         */
        queryPerSecond: number;
        /**
         * Data replicas per az.
         */
        replicasPerZone: number;
        /**
         * Maximum data retention time.
         */
        retentionPeriod: string;
        /**
         * Maximum scan samples per second.
         */
        scanSamplesPerSecond: number;
        /**
         * Maximum number of scan sequences per second.
         */
        scanSeriesPerSecond: number;
    }

    export interface NotifyGroupPoliciesNotifyPolicy {
        /**
         * The create time of notify group policy.
         */
        createTime: string;
        /**
         * The description of notify group policy.
         */
        description: string;
        /**
         * The id of the notify group policy.
         */
        id: string;
        /**
         * The levels of the notify group policy.
         */
        levels: outputs.vmp.NotifyGroupPoliciesNotifyPolicyLevel[];
        /**
         * The name of notify group policy.
         */
        name: string;
    }

    export interface NotifyGroupPoliciesNotifyPolicyLevel {
        /**
         * The aggregate dimension.
         */
        groupBies: string[];
        /**
         * The aggregation cycle.
         */
        groupInterval: string;
        /**
         * The wait time.
         */
        groupWait: string;
        /**
         * The level of the policy.
         */
        level: string;
        /**
         * The notification cycle.
         */
        repeatInterval: string;
    }

    export interface NotifyGroupPolicyLevel {
        /**
         * The aggregate dimension, the value can be `__rule__`.
         */
        groupBies: string[];
        /**
         * The aggregation cycle. Integer form, unit is second.
         */
        groupInterval: string;
        /**
         * The wait time. Integer form, unit is second.
         */
        groupWait: string;
        /**
         * The level of the policy, the value can be one of the following: `P0`, `P1`, `P2`.
         */
        level: string;
        /**
         * The notification cycle. Integer form, unit is second.
         */
        repeatInterval: string;
    }

    export interface NotifyPoliciesNotifyPolicy {
        /**
         * The channel notify template for the alarm notification policy.
         */
        channelNotifyTemplateIds: string[];
        /**
         * The create time of notify policy.
         */
        createTime: string;
        /**
         * The description of notify policy.
         */
        description: string;
        /**
         * The id of the notify policy.
         */
        id: string;
        /**
         * The levels of the notify policy.
         */
        levels: outputs.vmp.NotifyPoliciesNotifyPolicyLevel[];
        /**
         * The name of notify policy.
         */
        name: string;
    }

    export interface NotifyPoliciesNotifyPolicyLevel {
        /**
         * The alarm notification method of the alarm notification policy.
         */
        channels: string[];
        /**
         * The contact group for the alarm notification policy.
         */
        contactGroupIds: string[];
        /**
         * The level of the policy.
         */
        level: string;
        /**
         * The resolved alarm notification method of the alarm notification policy.
         */
        resolvedChannels: string[];
    }

    export interface NotifyPolicyLevel {
        /**
         * The alarm notification method of the alarm notification policy, the optional value can be `Email`, `Webhook`, `LarkBotWebhook`, `DingTalkBotWebhook`, `WeComBotWebhook`.
         */
        channels: string[];
        /**
         * The contact group for the alarm notification policy.
         */
        contactGroupIds: string[];
        /**
         * The level of the policy, the value can be one of the following: `P0`, `P1`, `P2`.
         */
        level: string;
        /**
         * The resolved alarm notification method of the alarm notification policy, the optional value can be `Email`, `Webhook`, `LarkBotWebhook`, `DingTalkBotWebhook`, `WeComBotWebhook`.
         */
        resolvedChannels?: string[];
    }

    export interface NotifyTemplateActive {
        /**
         * The content of notify template.
         */
        content: string;
        /**
         * The title of notify template.
         */
        title: string;
    }

    export interface NotifyTemplateResolved {
        /**
         * The content of notify template.
         */
        content: string;
        /**
         * The title of notify template.
         */
        title: string;
    }

    export interface NotifyTemplatesNotifyTemplate {
        /**
         * The active notify template info.
         */
        actives: outputs.vmp.NotifyTemplatesNotifyTemplateActive[];
        /**
         * The channel of notify template. Valid values: `LarkBotWebhook`, `DingTalkBotWebhook`, `WeComBotWebhook`.
         */
        channel: string;
        /**
         * The create time of notify template.
         */
        createTime: string;
        /**
         * The description of notify template.
         */
        description: string;
        /**
         * The ID of notify template.
         */
        id: string;
        /**
         * The name of notify template. This field support fuzzy query.
         */
        name: string;
        /**
         * The resolved notify template info.
         */
        resolveds: outputs.vmp.NotifyTemplatesNotifyTemplateResolved[];
        /**
         * The update time of notify template.
         */
        updateTime: string;
    }

    export interface NotifyTemplatesNotifyTemplateActive {
        /**
         * The content of notify template.
         */
        content: string;
        /**
         * The title of notify template.
         */
        title: string;
    }

    export interface NotifyTemplatesNotifyTemplateResolved {
        /**
         * The content of notify template.
         */
        content: string;
        /**
         * The title of notify template.
         */
        title: string;
    }

    export interface RuleFilesFile {
        /**
         * The content of rule file.
         */
        content: string;
        /**
         * The create time of rule file.
         */
        createTime: string;
        /**
         * The description of rule file.
         */
        description: string;
        /**
         * The ID of rule file.
         */
        id: string;
        /**
         * The last update time of rule file.
         */
        lastUpdateTime: string;
        /**
         * The name of rule file.
         */
        name: string;
        /**
         * The rule count number of rule file.
         */
        ruleCount: number;
        /**
         * The status of rule file.
         */
        status: string;
    }

    export interface RulesRule {
        /**
         * The expr of rule.
         */
        expr: string;
        /**
         * The kind of rule.
         */
        kind: string;
        /**
         * The labels of rule.
         */
        labels: outputs.vmp.RulesRuleLabel[];
        /**
         * The last evaluation of rule.
         */
        lastEvaluation: string;
        /**
         * The name of rule.
         */
        name: string;
        /**
         * The reason of rule.
         */
        reason: string;
        /**
         * The name of rule file.
         */
        ruleFileName: string;
        /**
         * The name of rule group.
         */
        ruleGroupName: string;
        /**
         * The status of rule.
         */
        status: string;
    }

    export interface RulesRuleLabel {
        /**
         * The key of label.
         */
        key: string;
        /**
         * The value of label.
         */
        value: string;
    }

    export interface WorkspaceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface WorkspacesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        values: string[];
    }

    export interface WorkspacesWorkspace {
        /**
         * The create time of workspace.
         */
        createTime: string;
        /**
         * Whether enable delete protection.
         */
        deleteProtectionEnabled: boolean;
        /**
         * The description of workspace.
         */
        description: string;
        /**
         * The ID of workspace.
         */
        id: string;
        /**
         * The id of instance type.
         */
        instanceTypeId: string;
        /**
         * The name of workspace.
         */
        name: string;
        /**
         * The overdue reclaim time.
         */
        overdueReclaimTime: string;
        /**
         * The project name of vmp workspace.
         */
        projectName: string;
        /**
         * The prometheus push intranet endpoint.
         */
        prometheusPushIntranetEndpoint: string;
        /**
         * The prometheus query intranet endpoint.
         */
        prometheusQueryIntranetEndpoint: string;
        /**
         * The prometheus write intranet endpoint.
         */
        prometheusWriteIntranetEndpoint: string;
        /**
         * The status of workspace.
         */
        status: string;
        /**
         * The tags of vmp workspace.
         */
        tags: outputs.vmp.WorkspacesWorkspaceTag[];
        /**
         * The username of workspace.
         */
        username: string;
    }

    export interface WorkspacesWorkspaceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

}

export namespace vpc {
    export interface FlowLogTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface FlowLogsFlowLog {
        /**
         * The aggregation interval of flow log. Unit: minute. Valid values: `1`, `5`, `10`.
         */
        aggregationInterval: number;
        /**
         * The business status of flow log.
         */
        businessStatus: string;
        /**
         * The created time of flow log.
         */
        createdAt: string;
        /**
         * The description of flow log.
         */
        description: string;
        /**
         * The ID of flow log.
         */
        flowLogId: string;
        /**
         * The name of flow log.
         */
        flowLogName: string;
        /**
         * The ID of flow log.
         */
        id: string;
        /**
         * The reason why flow log is locked.
         */
        lockReason: string;
        /**
         * The ID of log project.
         */
        logProjectId: string;
        /**
         * The ID of log topic.
         */
        logTopicId: string;
        /**
         * The project name of flow log.
         */
        projectName: string;
        /**
         * The ID of resource.
         */
        resourceId: string;
        /**
         * The type of resource. Valid values: `vpc`, `subnet`, `eni`.
         */
        resourceType: string;
        /**
         * The status of flow log. Valid values: `Active`, `Pending`, `Inactive`, `Creating`, `Deleting`.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.vpc.FlowLogsFlowLogTag[];
        /**
         * The type of traffic. Valid values: `All`, `Allow`, `Drop`.
         */
        trafficType: string;
        /**
         * The updated time of flow log.
         */
        updatedAt: string;
        /**
         * The ID of VPC.
         */
        vpcId: string;
    }

    export interface FlowLogsFlowLogTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface FlowLogsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetFlowLogsFlowLog {
        /**
         * The aggregation interval of flow log. Unit: minute. Valid values: `1`, `5`, `10`.
         */
        aggregationInterval: number;
        /**
         * The business status of flow log.
         */
        businessStatus: string;
        /**
         * The created time of flow log.
         */
        createdAt: string;
        /**
         * The description of flow log.
         */
        description: string;
        /**
         * The ID of flow log.
         */
        flowLogId: string;
        /**
         * The name of flow log.
         */
        flowLogName: string;
        /**
         * The ID of flow log.
         */
        id: string;
        /**
         * The reason why flow log is locked.
         */
        lockReason: string;
        /**
         * The ID of log project.
         */
        logProjectId: string;
        /**
         * The ID of log topic.
         */
        logTopicId: string;
        /**
         * The project name of flow log.
         */
        projectName: string;
        /**
         * The ID of resource.
         */
        resourceId: string;
        /**
         * The type of resource. Valid values: `vpc`, `subnet`, `eni`.
         */
        resourceType: string;
        /**
         * The status of flow log. Valid values: `Active`, `Pending`, `Inactive`, `Creating`, `Deleting`.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.vpc.GetFlowLogsFlowLogTag[];
        /**
         * The type of traffic. Valid values: `All`, `Allow`, `Drop`.
         */
        trafficType: string;
        /**
         * The updated time of flow log.
         */
        updatedAt: string;
        /**
         * The ID of VPC.
         */
        vpcId: string;
    }

    export interface GetFlowLogsFlowLogTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetFlowLogsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetHaVipsHaVip {
        /**
         * The account id of the Ha Vip.
         */
        accountId: string;
        /**
         * The associated eip address of the Ha Vip.
         */
        associatedEipAddress: string;
        /**
         * The associated eip id of the Ha Vip.
         */
        associatedEipId: string;
        /**
         * The associated instance ids of the Ha Vip.
         */
        associatedInstanceIds: string[];
        /**
         * The associated instance type of the Ha Vip.
         */
        associatedInstanceType: string;
        /**
         * The create time of the Ha Vip.
         */
        createdAt: string;
        /**
         * The description of the Ha Vip.
         */
        description: string;
        /**
         * The id of the Ha Vip.
         */
        haVipId: string;
        /**
         * The name of Ha Vip.
         */
        haVipName: string;
        /**
         * The id of the Ha Vip.
         */
        id: string;
        /**
         * The ip address of Ha Vip.
         */
        ipAddress: string;
        /**
         * The master instance id of the Ha Vip.
         */
        masterInstanceId: string;
        /**
         * The project name of Ha Vip.
         */
        projectName: string;
        /**
         * The status of Ha Vip.
         */
        status: string;
        /**
         * The id of subnet.
         */
        subnetId: string;
        /**
         * Tags.
         */
        tags: outputs.vpc.GetHaVipsHaVipTag[];
        /**
         * The update time of the Ha Vip.
         */
        updatedAt: string;
        /**
         * The id of vpc.
         */
        vpcId: string;
    }

    export interface GetHaVipsHaVipTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetHaVipsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetIpv6AddressBandwidthsIpv6AddressBandwidth {
        /**
         * The ID of the Ipv6AddressBandwidth.
         */
        allocationId: string;
        /**
         * Peek bandwidth of the Ipv6 address.
         */
        bandwidth: number;
        /**
         * BillingType of the Ipv6 bandwidth.
         */
        billingType: string;
        /**
         * The BusinessStatus of the Ipv6AddressBandwidth.
         */
        businessStatus: string;
        /**
         * Creation time of the Ipv6AddressBandwidth.
         */
        creationTime: string;
        /**
         * Delete time of the Ipv6AddressBandwidth.
         */
        deleteTime: string;
        /**
         * The ID of the Ipv6AddressBandwidth.
         */
        id: string;
        /**
         * The ID of the associated instance.
         */
        instanceId: string;
        /**
         * The type of the associated instance.
         */
        instanceType: string;
        /**
         * The IPv6 address.
         */
        ipv6Address: string;
        /**
         * ISP of the ipv6 address.
         */
        isp: string;
        /**
         * The BusinessStatus of the Ipv6AddressBandwidth.
         */
        lockReason: string;
        /**
         * The network type of the ipv6 address.
         */
        networkType: string;
        /**
         * Overdue time of the Ipv6AddressBandwidth.
         */
        overdueTime: string;
        /**
         * The status of the Ipv6AddressBandwidth.
         */
        status: string;
        /**
         * Update time of the Ipv6AddressBandwidth.
         */
        updateTime: string;
    }

    export interface GetIpv6AddressesIpv6Address {
        /**
         * The IPv6 address.
         */
        ipv6Address: string;
    }

    export interface GetIpv6GatewaysIpv6Gateway {
        /**
         * Creation time of the Ipv6Gateway.
         */
        creationTime: string;
        /**
         * The description of the Ipv6Gateway.
         */
        description: string;
        /**
         * The ID of the Ipv6Gateway.
         */
        id: string;
        /**
         * The ID of the Ipv6Gateway.
         */
        ipv6GatewayId: string;
        /**
         * The name of the Ipv6Gateway.
         */
        name: string;
        /**
         * The Status of the Ipv6Gateway.
         */
        status: string;
        /**
         * Update time of the Ipv6Gateway.
         */
        updateTime: string;
        /**
         * The id of the VPC which the Ipv6Gateway belongs to.
         */
        vpcId: string;
    }

    export interface GetNetworkAclsNetworkAcl {
        /**
         * The count of Network acl entry.
         */
        aclEntryCount: number;
        /**
         * Creation time of Network Acl.
         */
        creationTime: string;
        /**
         * The description of entry.
         */
        description: string;
        /**
         * The egress entries info of Network Acl.
         */
        egressAclEntries: outputs.vpc.GetNetworkAclsNetworkAclEgressAclEntry[];
        /**
         * The ID of Network Acl.
         */
        id: string;
        /**
         * The ingress entries info of Network Acl.
         */
        ingressAclEntries: outputs.vpc.GetNetworkAclsNetworkAclIngressAclEntry[];
        /**
         * The ID of Network Acl.
         */
        networkAclId: string;
        /**
         * The name of Network Acl.
         */
        networkAclName: string;
        /**
         * The project name of the network acl.
         */
        projectName: string;
        /**
         * The resources info of Network Acl.
         */
        resources: outputs.vpc.GetNetworkAclsNetworkAclResource[];
        /**
         * The Status of Network Acl.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.vpc.GetNetworkAclsNetworkAclTag[];
        /**
         * Update time of Network Acl.
         */
        updateTime: string;
        /**
         * The vpc id of Network Acl.
         */
        vpcId: string;
    }

    export interface GetNetworkAclsNetworkAclEgressAclEntry {
        /**
         * The description of entry.
         */
        description: string;
        /**
         * The DestinationCidrIp of entry.
         */
        destinationCidrIp: string;
        /**
         * The id of entry.
         */
        networkAclEntryId: string;
        /**
         * The name of entry.
         */
        networkAclEntryName: string;
        /**
         * The policy of entry.
         */
        policy: string;
        /**
         * The port of entry.
         */
        port: string;
        /**
         * The priority of entry.
         */
        priority: number;
        /**
         * The protocol of entry.
         */
        protocol: string;
    }

    export interface GetNetworkAclsNetworkAclIngressAclEntry {
        /**
         * The description of entry.
         */
        description: string;
        /**
         * The id of entry.
         */
        networkAclEntryId: string;
        /**
         * The name of entry.
         */
        networkAclEntryName: string;
        /**
         * The policy of entry.
         */
        policy: string;
        /**
         * The port of entry.
         */
        port: string;
        /**
         * The priority of entry.
         */
        priority: number;
        /**
         * The protocol of entry.
         */
        protocol: string;
        /**
         * The SourceCidrIp of entry.
         */
        sourceCidrIp: string;
    }

    export interface GetNetworkAclsNetworkAclResource {
        /**
         * The resource id of Network Acl.
         */
        resourceId: string;
        /**
         * The Status of Network Acl.
         */
        status: string;
    }

    export interface GetNetworkAclsNetworkAclTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetNetworkAclsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetNetworkInterfacesNetworkInterface {
        /**
         * The account id of the ENI creator.
         */
        accountId: string;
        /**
         * The IP address of the EIP to which the ENI associates.
         */
        associatedElasticIpAddress: string;
        /**
         * The allocation id of the EIP to which the ENI associates.
         */
        associatedElasticIpId: string;
        /**
         * The create time of the ENI.
         */
        createdAt: string;
        /**
         * The description of the ENI.
         */
        description: string;
        /**
         * The id of the device to which the ENI is bound.
         */
        deviceId: string;
        /**
         * The id of the ENI.
         */
        id: string;
        /**
         * The IPv6 address list of the ENI.
         */
        ipv6Sets: string[];
        /**
         * The mac address of the ENI.
         */
        macAddress: string;
        /**
         * The id of the ENI.
         */
        networkInterfaceId: string;
        /**
         * A name of ENI.
         */
        networkInterfaceName: string;
        /**
         * The enable of port security.
         */
        portSecurityEnabled: boolean;
        /**
         * The primary IP address of the ENI.
         */
        primaryIpAddress: string;
        /**
         * The IP address of secondary private network interface.
         */
        privateIpSets: outputs.vpc.GetNetworkInterfacesNetworkInterfacePrivateIpSet[];
        /**
         * The ProjectName of the ENI.
         */
        projectName: string;
        /**
         * The list of the security group id to which the secondary ENI belongs.
         */
        securityGroupIds: string[];
        /**
         * Whether the network card has been authorized to be used by other account services.
         */
        serviceManaged: boolean;
        /**
         * A status of ENI, Optional choice contains `Creating`, `Available`, `Attaching`, `InUse`, `Detaching`, `Deleting`.
         */
        status: string;
        /**
         * An id of the subnet to which the ENI is connected.
         */
        subnetId: string;
        /**
         * Tags.
         */
        tags: outputs.vpc.GetNetworkInterfacesNetworkInterfaceTag[];
        /**
         * A type of ENI, Optional choice contains `primary`, `secondary`.
         */
        type: string;
        /**
         * The last update time of the ENI.
         */
        updatedAt: string;
        /**
         * An id of the virtual private cloud (VPC) to which the ENI belongs.
         */
        vpcId: string;
        /**
         * The name of the virtual private cloud (VPC) to which the ENI belongs.
         */
        vpcName: string;
        /**
         * The zone ID.
         */
        zoneId: string;
    }

    export interface GetNetworkInterfacesNetworkInterfacePrivateIpSet {
        /**
         * The public IP that secondary private network IP associated with.
         */
        associatedElasticIps: outputs.vpc.GetNetworkInterfacesNetworkInterfacePrivateIpSetAssociatedElasticIp[];
        /**
         * Whether the network interface is primary IP address.
         */
        primary: boolean;
        /**
         * The secondary private network IP address of the network interface card.
         */
        privateIpAddress: string;
    }

    export interface GetNetworkInterfacesNetworkInterfacePrivateIpSetAssociatedElasticIp {
        /**
         * The public IP ID.
         */
        allocationId: string;
        /**
         * The public IP address.
         */
        eipAddress: string;
    }

    export interface GetNetworkInterfacesNetworkInterfaceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetNetworkInterfacesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetPrefixListsPrefixList {
        /**
         * Number of associated resources for prefix list.
         */
        associationCount: number;
        /**
         * CIDR address block information for prefix list.
         */
        cidrs: string[];
        /**
         * The creation time of the prefix list.
         */
        creationTime: string;
        /**
         * Description.
         */
        description: string;
        /**
         * The id of the prefix list.
         */
        id: string;
        /**
         * IP version of prefix list.
         */
        ipVersion: string;
        /**
         * Maximum number of entries, which is the maximum number of items that can be added to the prefix list.
         */
        maxEntries: number;
        /**
         * Collection of resources associated with VPC prefix list.
         */
        prefixListAssociations: outputs.vpc.GetPrefixListsPrefixListPrefixListAssociation[];
        /**
         * The prefix list entries.
         */
        prefixListEntries: outputs.vpc.GetPrefixListsPrefixListPrefixListEntry[];
        /**
         * The prefix list id.
         */
        prefixListId: string;
        /**
         * A Name of prefix list.
         */
        prefixListName: string;
        /**
         * The status of the prefix list.
         */
        status: string;
        /**
         * The update time of the prefix list.
         */
        updateTime: string;
    }

    export interface GetPrefixListsPrefixListPrefixListAssociation {
        /**
         * Associated resource ID.
         */
        resourceId: string;
        /**
         * Related resource types.
         */
        resourceType: string;
    }

    export interface GetPrefixListsPrefixListPrefixListEntry {
        /**
         * CIDR address blocks for prefix list entries.
         */
        cidr: string;
        /**
         * Description.
         */
        description: string;
        /**
         * The prefix list id.
         */
        prefixListId: string;
    }

    export interface GetPrefixListsTagFilter {
        /**
         * The key of the tag.
         */
        key?: string;
        /**
         * The values of the tag.
         */
        values?: string[];
    }

    export interface GetRouteEntriesRouteEntry {
        /**
         * The description of the route entry.
         */
        description: string;
        /**
         * A destination CIDR block of route entry.
         */
        destinationCidrBlock: string;
        /**
         * The id of the route entry.
         */
        id: string;
        /**
         * An id of next hop.
         */
        nextHopId: string;
        /**
         * The name of the next hop.
         */
        nextHopName: string;
        /**
         * A type of next hop, Optional choice contains `Instance`, `NetworkInterface`, `NatGW`, `VpnGW`.
         */
        nextHopType: string;
        /**
         * The id of the route entry.
         */
        routeEntryId: string;
        /**
         * A name of route entry.
         */
        routeEntryName: string;
        /**
         * An id of route table.
         */
        routeTableId: string;
        /**
         * The status of the route entry.
         */
        status: string;
        /**
         * The type of the route entry.
         */
        type: string;
        /**
         * The id of the virtual private cloud (VPC) to which the route entry belongs.
         */
        vpcId: string;
    }

    export interface GetRouteTablesRouteTable {
        /**
         * The account id of the route table creator.
         */
        accountId: string;
        /**
         * The create time of the route table.
         */
        creationTime: string;
        /**
         * The description of the route table.
         */
        description: string;
        /**
         * The id of the route table.
         */
        id: string;
        /**
         * The ProjectName of the route table.
         */
        projectName: string;
        /**
         * The id of the route table.
         */
        routeTableId: string;
        /**
         * A name of route table.
         */
        routeTableName: string;
        /**
         * The type of the route table.
         */
        routeTableType: string;
        /**
         * The list of the subnet ids to which the entry table associates.
         */
        subnetIds: string[];
        /**
         * Tags.
         */
        tags: outputs.vpc.GetRouteTablesRouteTableTag[];
        /**
         * The last update time of the route table.
         */
        updateTime: string;
        /**
         * An id of VPC.
         */
        vpcId: string;
        /**
         * The name of the virtual private cloud (VPC) to which the route entry belongs.
         */
        vpcName: string;
    }

    export interface GetRouteTablesRouteTableTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetRouteTablesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetSecurityGroupRulesSecurityGroupRule {
        /**
         * Cidr ip of egress/ingress Rule.
         */
        cidrIp: string;
        /**
         * The creation time of security group rule.
         */
        creationTime: string;
        /**
         * description of a group rule.
         */
        description: string;
        /**
         * Direction of rule, ingress (inbound) or egress (outbound).
         */
        direction: string;
        /**
         * Access strategy.
         */
        policy: string;
        /**
         * Port end of egress/ingress Rule.
         */
        portEnd: number;
        /**
         * Port start of egress/ingress Rule.
         */
        portStart: number;
        /**
         * Priority of a security group rule.
         */
        priority: number;
        /**
         * Protocol of the SecurityGroup, the value can be `tcp` or `udp` or `icmp` or `all`.
         */
        protocol: string;
        /**
         * SecurityGroup ID.
         */
        securityGroupId: string;
        /**
         * ID of the source security group whose access permission you want to set.
         */
        sourceGroupId: string;
        /**
         * The update time of security group rule.
         */
        updateTime: string;
    }

    export interface GetSecurityGroupsSecurityGroup {
        /**
         * The creation time of SecurityGroup.
         */
        creationTime: string;
        /**
         * The description of SecurityGroup.
         */
        description: string;
        /**
         * The ID of SecurityGroup.
         */
        id: string;
        /**
         * The ProjectName of SecurityGroup.
         */
        projectName: string;
        /**
         * The ID of SecurityGroup.
         */
        securityGroupId: string;
        /**
         * The Name of SecurityGroup.
         */
        securityGroupName: string;
        /**
         * The Status of SecurityGroup.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.vpc.GetSecurityGroupsSecurityGroupTag[];
        /**
         * The type of SecurityGroup.
         */
        type: string;
        /**
         * The ID of vpc where security group is located.
         */
        vpcId: string;
    }

    export interface GetSecurityGroupsSecurityGroupTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetSecurityGroupsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetSubnetsSubnet {
        /**
         * The account ID which the subnet belongs to.
         */
        accountId: string;
        /**
         * The count of available ip address.
         */
        availableIpAddressCount: number;
        /**
         * The cidr block of Subnet.
         */
        cidrBlock: string;
        /**
         * Creation time of Subnet.
         */
        creationTime: string;
        /**
         * The description of Subnet.
         */
        description: string;
        /**
         * The ID of Subnet.
         */
        id: string;
        /**
         * The IPv6 CIDR block of the VPC.
         */
        ipv6CidrBlock: string;
        /**
         * The ID of network acl which this subnet associate with.
         */
        networkAclId: string;
        /**
         * The route table information.
         */
        routeTable: outputs.vpc.GetSubnetsSubnetRouteTable;
        /**
         * The ID of route table which subnet associated with.
         */
        routeTableId: string;
        /**
         * The route table type.
         */
        routeTableType: string;
        /**
         * The Status of Subnet.
         */
        status: string;
        /**
         * The subnet name to query.
         */
        subnetName: string;
        /**
         * Tags.
         */
        tags: outputs.vpc.GetSubnetsSubnetTag[];
        /**
         * The Count of ipv4.
         */
        totalIpv4Count: number;
        /**
         * Update time of Subnet.
         */
        updateTime: string;
        /**
         * The ID of VPC which subnet belongs to.
         */
        vpcId: string;
        /**
         * The ID of zone which subnet belongs to.
         */
        zoneId: string;
    }

    export interface GetSubnetsSubnetRouteTable {
        /**
         * The ID of route table which subnet associated with.
         */
        routeTableId: string;
        /**
         * The route table type.
         */
        routeTableType: string;
    }

    export interface GetSubnetsSubnetTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetSubnetsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetTrafficMirrorFilterRulesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetTrafficMirrorFilterRulesTrafficMirrorFilterRule {
        /**
         * The create time of traffic mirror filter rule.
         */
        createdAt: string;
        /**
         * The description of traffic mirror filter rule.
         */
        description: string;
        /**
         * The destination cidr block of traffic mirror filter rule.
         */
        destinationCidrBlock: string;
        /**
         * The destination port range of traffic mirror filter rule.
         */
        destinationPortRange: string;
        /**
         * The ID of traffic mirror filter rule.
         */
        id: string;
        /**
         * The policy of traffic mirror filter rule.
         */
        policy: string;
        /**
         * The priority of traffic mirror filter rule.
         */
        priority: number;
        /**
         * The protocol of traffic mirror filter rule.
         */
        protocol: string;
        /**
         * The source cidr block of traffic mirror filter rule.
         */
        sourceCidrBlock: string;
        /**
         * The source port range of traffic mirror filter rule.
         */
        sourcePortRange: string;
        /**
         * The status of traffic mirror filter rule.
         */
        status: string;
        /**
         * The traffic direction of traffic mirror filter rule.
         */
        trafficDirection: string;
        /**
         * The ID of traffic mirror filter.
         */
        trafficMirrorFilterId: string;
        /**
         * The ID of traffic mirror filter rule.
         */
        trafficMirrorFilterRuleId: string;
        /**
         * The last update time of traffic mirror filter rule.
         */
        updatedAt: string;
    }

    export interface GetTrafficMirrorFiltersTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetTrafficMirrorFiltersTrafficMirrorFilter {
        /**
         * The create time of traffic mirror filter rule.
         */
        createdAt: string;
        /**
         * The description of traffic mirror filter rule.
         */
        description: string;
        /**
         * The ingress filter rules of traffic mirror filter.
         */
        egressFilterRules: outputs.vpc.GetTrafficMirrorFiltersTrafficMirrorFilterEgressFilterRule[];
        /**
         * The ID of traffic mirror filter.
         */
        id: string;
        /**
         * The ingress filter rules of traffic mirror filter.
         */
        ingressFilterRules: outputs.vpc.GetTrafficMirrorFiltersTrafficMirrorFilterIngressFilterRule[];
        /**
         * The project name of traffic mirror filter.
         */
        projectName: string;
        /**
         * The status of traffic mirror filter.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.vpc.GetTrafficMirrorFiltersTrafficMirrorFilterTag[];
        /**
         * The ID of traffic mirror filter.
         */
        trafficMirrorFilterId: string;
        /**
         * The name of traffic mirror filter.
         */
        trafficMirrorFilterName: string;
        /**
         * The last update time of traffic mirror filter.
         */
        updatedAt: string;
    }

    export interface GetTrafficMirrorFiltersTrafficMirrorFilterEgressFilterRule {
        /**
         * The create time of traffic mirror filter rule.
         */
        createdAt: string;
        /**
         * The description of traffic mirror filter rule.
         */
        description: string;
        /**
         * The destination cidr block of traffic mirror filter rule.
         */
        destinationCidrBlock: string;
        /**
         * The destination port range of traffic mirror filter rule.
         */
        destinationPortRange: string;
        /**
         * The policy of traffic mirror filter rule.
         */
        policy: string;
        /**
         * The priority of traffic mirror filter rule.
         */
        priority: number;
        /**
         * The protocol of traffic mirror filter rule.
         */
        protocol: string;
        /**
         * The source cidr block of traffic mirror filter rule.
         */
        sourceCidrBlock: string;
        /**
         * The source port range of traffic mirror filter rule.
         */
        sourcePortRange: string;
        /**
         * The status of traffic mirror filter.
         */
        status: string;
        /**
         * The traffic direction of traffic mirror filter rule.
         */
        trafficDirection: string;
        /**
         * The ID of traffic mirror filter.
         */
        trafficMirrorFilterId: string;
        /**
         * The ID of traffic mirror filter rule.
         */
        trafficMirrorFilterRuleId: string;
        /**
         * The last update time of traffic mirror filter.
         */
        updatedAt: string;
    }

    export interface GetTrafficMirrorFiltersTrafficMirrorFilterIngressFilterRule {
        /**
         * The create time of traffic mirror filter rule.
         */
        createdAt: string;
        /**
         * The description of traffic mirror filter rule.
         */
        description: string;
        /**
         * The destination cidr block of traffic mirror filter rule.
         */
        destinationCidrBlock: string;
        /**
         * The destination port range of traffic mirror filter rule.
         */
        destinationPortRange: string;
        /**
         * The policy of traffic mirror filter rule.
         */
        policy: string;
        /**
         * The priority of traffic mirror filter rule.
         */
        priority: number;
        /**
         * The protocol of traffic mirror filter rule.
         */
        protocol: string;
        /**
         * The source cidr block of traffic mirror filter rule.
         */
        sourceCidrBlock: string;
        /**
         * The source port range of traffic mirror filter rule.
         */
        sourcePortRange: string;
        /**
         * The status of traffic mirror filter.
         */
        status: string;
        /**
         * The traffic direction of traffic mirror filter rule.
         */
        trafficDirection: string;
        /**
         * The ID of traffic mirror filter.
         */
        trafficMirrorFilterId: string;
        /**
         * The ID of traffic mirror filter rule.
         */
        trafficMirrorFilterRuleId: string;
        /**
         * The last update time of traffic mirror filter.
         */
        updatedAt: string;
    }

    export interface GetTrafficMirrorFiltersTrafficMirrorFilterTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetTrafficMirrorSessionsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetTrafficMirrorSessionsTrafficMirrorSession {
        /**
         * The business status of traffic mirror session.
         */
        businessStatus: string;
        /**
         * The create time of traffic mirror session.
         */
        createdAt: string;
        /**
         * The description of traffic mirror session.
         */
        description: string;
        /**
         * The ID of traffic mirror session.
         */
        id: string;
        /**
         * The lock reason of traffic mirror session.
         */
        lockReason: string;
        /**
         * The packet length of traffic mirror session.
         */
        packetLength: number;
        /**
         * The priority of traffic mirror session.
         */
        priority: number;
        /**
         * The project name of traffic mirror session.
         */
        projectName: string;
        /**
         * The status of traffic mirror session.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.vpc.GetTrafficMirrorSessionsTrafficMirrorSessionTag[];
        /**
         * The ID of traffic mirror filter.
         */
        trafficMirrorFilterId: string;
        /**
         * The ID of traffic mirror session.
         */
        trafficMirrorSessionId: string;
        /**
         * The name of traffic mirror session.
         */
        trafficMirrorSessionName: string;
        /**
         * The IDs of traffic mirror source.
         */
        trafficMirrorSourceIds: string[];
        /**
         * The ID of traffic mirror target.
         */
        trafficMirrorTargetId: string;
        /**
         * The update time of traffic mirror session.
         */
        updatedAt: string;
        /**
         * The ID of virtual network.
         */
        virtualNetworkId: number;
    }

    export interface GetTrafficMirrorSessionsTrafficMirrorSessionTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetTrafficMirrorTargetsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetTrafficMirrorTargetsTrafficMirrorTarget {
        /**
         * The create time of traffic mirror target.
         */
        createdAt: string;
        /**
         * The description of traffic mirror target.
         */
        description: string;
        /**
         * The ID of traffic mirror target.
         */
        id: string;
        /**
         * The instance id of traffic mirror target.
         */
        instanceId: string;
        /**
         * The instance type of traffic mirror target.
         */
        instanceType: string;
        /**
         * The project name of traffic mirror target.
         */
        projectName: string;
        /**
         * The status of traffic mirror target.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.vpc.GetTrafficMirrorTargetsTrafficMirrorTargetTag[];
        /**
         * The ID of traffic mirror target.
         */
        trafficMirrorTargetId: string;
        /**
         * The name of traffic mirror target.
         */
        trafficMirrorTargetName: string;
        /**
         * The update time of traffic mirror target.
         */
        updatedAt: string;
    }

    export interface GetTrafficMirrorTargetsTrafficMirrorTargetTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetVpcsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetVpcsVpc {
        /**
         * The account ID of VPC.
         */
        accountId: string;
        /**
         * The associate cen list of VPC.
         */
        associateCens: outputs.vpc.GetVpcsVpcAssociateCen[];
        /**
         * The auxiliary cidr block list of VPC.
         */
        auxiliaryCidrBlocks: string[];
        /**
         * The cidr block of VPC.
         */
        cidrBlock: string;
        /**
         * The create time of VPC.
         */
        creationTime: string;
        /**
         * The description of VPC.
         */
        description: string;
        /**
         * The dns server list of VPC.
         */
        dnsServers: string[];
        /**
         * The IPv6 CIDR block of the VPC.
         */
        ipv6CidrBlock: string;
        /**
         * The nat gateway ID list of VPC.
         */
        natGatewayIds: string[];
        /**
         * The ProjectName of the VPC.
         */
        projectName: string;
        /**
         * The route table ID list of VPC.
         */
        routeTableIds: string[];
        /**
         * The secondary cidr block list of VPC.
         */
        secondaryCidrBlocks: string[];
        /**
         * The security group ID list of VPC.
         */
        securityGroupIds: string[];
        /**
         * The status of VPC.
         */
        status: string;
        /**
         * The subnet ID list of VPC.
         */
        subnetIds: string[];
        /**
         * Tags.
         */
        tags: outputs.vpc.GetVpcsVpcTag[];
        /**
         * The update time of VPC.
         */
        updateTime: string;
        /**
         * The ID of VPC.
         */
        vpcId: string;
        /**
         * The vpc name to query.
         */
        vpcName: string;
    }

    export interface GetVpcsVpcAssociateCen {
        /**
         * The ID of CEN.
         */
        cenId: string;
        /**
         * The owner ID of CEN.
         */
        cenOwnerId: string;
        /**
         * The status of CEN.
         */
        cenStatus: string;
    }

    export interface GetVpcsVpcTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface HaVipTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface HaVipsHaVip {
        /**
         * The account id of the Ha Vip.
         */
        accountId: string;
        /**
         * The associated eip address of the Ha Vip.
         */
        associatedEipAddress: string;
        /**
         * The associated eip id of the Ha Vip.
         */
        associatedEipId: string;
        /**
         * The associated instance ids of the Ha Vip.
         */
        associatedInstanceIds: string[];
        /**
         * The associated instance type of the Ha Vip.
         */
        associatedInstanceType: string;
        /**
         * The create time of the Ha Vip.
         */
        createdAt: string;
        /**
         * The description of the Ha Vip.
         */
        description: string;
        /**
         * The id of the Ha Vip.
         */
        haVipId: string;
        /**
         * The name of Ha Vip.
         */
        haVipName: string;
        /**
         * The id of the Ha Vip.
         */
        id: string;
        /**
         * The ip address of Ha Vip.
         */
        ipAddress: string;
        /**
         * The master instance id of the Ha Vip.
         */
        masterInstanceId: string;
        /**
         * The project name of Ha Vip.
         */
        projectName: string;
        /**
         * The status of Ha Vip.
         */
        status: string;
        /**
         * The id of subnet.
         */
        subnetId: string;
        /**
         * Tags.
         */
        tags: outputs.vpc.HaVipsHaVipTag[];
        /**
         * The update time of the Ha Vip.
         */
        updatedAt: string;
        /**
         * The id of vpc.
         */
        vpcId: string;
    }

    export interface HaVipsHaVipTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface HaVipsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface Ipv6AddressBandwidthsIpv6AddressBandwidth {
        /**
         * The ID of the Ipv6AddressBandwidth.
         */
        allocationId: string;
        /**
         * Peek bandwidth of the Ipv6 address.
         */
        bandwidth: number;
        /**
         * BillingType of the Ipv6 bandwidth.
         */
        billingType: string;
        /**
         * The BusinessStatus of the Ipv6AddressBandwidth.
         */
        businessStatus: string;
        /**
         * Creation time of the Ipv6AddressBandwidth.
         */
        creationTime: string;
        /**
         * Delete time of the Ipv6AddressBandwidth.
         */
        deleteTime: string;
        /**
         * The ID of the Ipv6AddressBandwidth.
         */
        id: string;
        /**
         * The ID of the associated instance.
         */
        instanceId: string;
        /**
         * The type of the associated instance.
         */
        instanceType: string;
        /**
         * The IPv6 address.
         */
        ipv6Address: string;
        /**
         * ISP of the ipv6 address.
         */
        isp: string;
        /**
         * The BusinessStatus of the Ipv6AddressBandwidth.
         */
        lockReason: string;
        /**
         * The network type of the ipv6 address.
         */
        networkType: string;
        /**
         * Overdue time of the Ipv6AddressBandwidth.
         */
        overdueTime: string;
        /**
         * The status of the Ipv6AddressBandwidth.
         */
        status: string;
        /**
         * Update time of the Ipv6AddressBandwidth.
         */
        updateTime: string;
    }

    export interface Ipv6AddressesIpv6Address {
        /**
         * The IPv6 address.
         */
        ipv6Address: string;
    }

    export interface Ipv6GatewaysIpv6Gateway {
        /**
         * Creation time of the Ipv6Gateway.
         */
        creationTime: string;
        /**
         * The description of the Ipv6Gateway.
         */
        description: string;
        /**
         * The ID of the Ipv6Gateway.
         */
        id: string;
        /**
         * The ID of the Ipv6Gateway.
         */
        ipv6GatewayId: string;
        /**
         * The name of the Ipv6Gateway.
         */
        name: string;
        /**
         * The Status of the Ipv6Gateway.
         */
        status: string;
        /**
         * Update time of the Ipv6Gateway.
         */
        updateTime: string;
        /**
         * The id of the VPC which the Ipv6Gateway belongs to.
         */
        vpcId: string;
    }

    export interface NetworkAclEgressAclEntry {
        /**
         * The description of entry.
         */
        description?: string;
        /**
         * The DestinationCidrIp of entry.
         */
        destinationCidrIp?: string;
        /**
         * The id of entry.
         */
        networkAclEntryId: string;
        /**
         * The name of entry.
         */
        networkAclEntryName?: string;
        /**
         * The policy of entry. Default is `accept`. The value can be `accept` or `drop`.
         */
        policy?: string;
        /**
         * The port of entry. Default is `-1/-1`. When Protocol is `all`, `icmp` or `gre`, the port range is `-1/-1`, which means no port restriction.When the Protocol is `tcp` or `udp`, the port range is `1~65535`, and the format is `1/200`, `80/80`,which means port 1 to port 200, port 80.
         */
        port?: string;
        /**
         * The priority of entry.
         */
        priority: number;
        /**
         * The protocol of entry. The value can be `icmp` or `gre` or `tcp` or `udp` or `all`. Default is `all`.
         */
        protocol?: string;
    }

    export interface NetworkAclIngressAclEntry {
        /**
         * The description of entry.
         */
        description?: string;
        /**
         * The id of entry.
         */
        networkAclEntryId: string;
        /**
         * The name of entry.
         */
        networkAclEntryName?: string;
        /**
         * The policy of entry, default is `accept`. The value can be `accept` or `drop`.
         */
        policy?: string;
        /**
         * The port of entry. Default is `-1/-1`. When Protocol is `all`, `icmp` or `gre`, the port range is `-1/-1`, which means no port restriction. When the Protocol is `tcp` or `udp`, the port range is `1~65535`, and the format is `1/200`, `80/80`, which means port 1 to port 200, port 80.
         */
        port?: string;
        /**
         * The priority of entry.
         */
        priority: number;
        /**
         * The protocol of entry, default is `all`. The value can be `icmp` or `gre` or `tcp` or `udp` or `all`.
         */
        protocol?: string;
        /**
         * The SourceCidrIp of entry.
         */
        sourceCidrIp?: string;
    }

    export interface NetworkAclTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface NetworkAclsNetworkAcl {
        /**
         * The count of Network acl entry.
         */
        aclEntryCount: number;
        /**
         * Creation time of Network Acl.
         */
        creationTime: string;
        /**
         * The description of entry.
         */
        description: string;
        /**
         * The egress entries info of Network Acl.
         */
        egressAclEntries: outputs.vpc.NetworkAclsNetworkAclEgressAclEntry[];
        /**
         * The ID of Network Acl.
         */
        id: string;
        /**
         * The ingress entries info of Network Acl.
         */
        ingressAclEntries: outputs.vpc.NetworkAclsNetworkAclIngressAclEntry[];
        /**
         * The ID of Network Acl.
         */
        networkAclId: string;
        /**
         * The name of Network Acl.
         */
        networkAclName: string;
        /**
         * The project name of the network acl.
         */
        projectName: string;
        /**
         * The resources info of Network Acl.
         */
        resources: outputs.vpc.NetworkAclsNetworkAclResource[];
        /**
         * The Status of Network Acl.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.vpc.NetworkAclsNetworkAclTag[];
        /**
         * Update time of Network Acl.
         */
        updateTime: string;
        /**
         * The vpc id of Network Acl.
         */
        vpcId: string;
    }

    export interface NetworkAclsNetworkAclEgressAclEntry {
        /**
         * The description of entry.
         */
        description: string;
        /**
         * The DestinationCidrIp of entry.
         */
        destinationCidrIp: string;
        /**
         * The id of entry.
         */
        networkAclEntryId: string;
        /**
         * The name of entry.
         */
        networkAclEntryName: string;
        /**
         * The policy of entry.
         */
        policy: string;
        /**
         * The port of entry.
         */
        port: string;
        /**
         * The priority of entry.
         */
        priority: number;
        /**
         * The protocol of entry.
         */
        protocol: string;
    }

    export interface NetworkAclsNetworkAclIngressAclEntry {
        /**
         * The description of entry.
         */
        description: string;
        /**
         * The id of entry.
         */
        networkAclEntryId: string;
        /**
         * The name of entry.
         */
        networkAclEntryName: string;
        /**
         * The policy of entry.
         */
        policy: string;
        /**
         * The port of entry.
         */
        port: string;
        /**
         * The priority of entry.
         */
        priority: number;
        /**
         * The protocol of entry.
         */
        protocol: string;
        /**
         * The SourceCidrIp of entry.
         */
        sourceCidrIp: string;
    }

    export interface NetworkAclsNetworkAclResource {
        /**
         * The resource id of Network Acl.
         */
        resourceId: string;
        /**
         * The Status of Network Acl.
         */
        status: string;
    }

    export interface NetworkAclsNetworkAclTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface NetworkAclsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface NetworkInterfaceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface NetworkInterfacesNetworkInterface {
        /**
         * The account id of the ENI creator.
         */
        accountId: string;
        /**
         * The IP address of the EIP to which the ENI associates.
         */
        associatedElasticIpAddress: string;
        /**
         * The allocation id of the EIP to which the ENI associates.
         */
        associatedElasticIpId: string;
        /**
         * The create time of the ENI.
         */
        createdAt: string;
        /**
         * The description of the ENI.
         */
        description: string;
        /**
         * The id of the device to which the ENI is bound.
         */
        deviceId: string;
        /**
         * The id of the ENI.
         */
        id: string;
        /**
         * The IPv6 address list of the ENI.
         */
        ipv6Sets: string[];
        /**
         * The mac address of the ENI.
         */
        macAddress: string;
        /**
         * The id of the ENI.
         */
        networkInterfaceId: string;
        /**
         * A name of ENI.
         */
        networkInterfaceName: string;
        /**
         * The enable of port security.
         */
        portSecurityEnabled: boolean;
        /**
         * The primary IP address of the ENI.
         */
        primaryIpAddress: string;
        /**
         * The IP address of secondary private network interface.
         */
        privateIpSets: outputs.vpc.NetworkInterfacesNetworkInterfacePrivateIpSet[];
        /**
         * The ProjectName of the ENI.
         */
        projectName: string;
        /**
         * The list of the security group id to which the secondary ENI belongs.
         */
        securityGroupIds: string[];
        /**
         * Whether the network card has been authorized to be used by other account services.
         */
        serviceManaged: boolean;
        /**
         * A status of ENI, Optional choice contains `Creating`, `Available`, `Attaching`, `InUse`, `Detaching`, `Deleting`.
         */
        status: string;
        /**
         * An id of the subnet to which the ENI is connected.
         */
        subnetId: string;
        /**
         * Tags.
         */
        tags: outputs.vpc.NetworkInterfacesNetworkInterfaceTag[];
        /**
         * A type of ENI, Optional choice contains `primary`, `secondary`.
         */
        type: string;
        /**
         * The last update time of the ENI.
         */
        updatedAt: string;
        /**
         * An id of the virtual private cloud (VPC) to which the ENI belongs.
         */
        vpcId: string;
        /**
         * The name of the virtual private cloud (VPC) to which the ENI belongs.
         */
        vpcName: string;
        /**
         * The zone ID.
         */
        zoneId: string;
    }

    export interface NetworkInterfacesNetworkInterfacePrivateIpSet {
        /**
         * The public IP that secondary private network IP associated with.
         */
        associatedElasticIps: outputs.vpc.NetworkInterfacesNetworkInterfacePrivateIpSetAssociatedElasticIp[];
        /**
         * Whether the network interface is primary IP address.
         */
        primary: boolean;
        /**
         * The secondary private network IP address of the network interface card.
         */
        privateIpAddress: string;
    }

    export interface NetworkInterfacesNetworkInterfacePrivateIpSetAssociatedElasticIp {
        /**
         * The public IP ID.
         */
        allocationId: string;
        /**
         * The public IP address.
         */
        eipAddress: string;
    }

    export interface NetworkInterfacesNetworkInterfaceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface NetworkInterfacesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface PrefixListPrefixListAssociation {
        /**
         * Associated resource ID.
         */
        resourceId: string;
        /**
         * Related resource types.
         */
        resourceType: string;
    }

    export interface PrefixListPrefixListEntry {
        /**
         * CIDR of prefix list entries.
         */
        cidr?: string;
        /**
         * Description of prefix list entries.
         */
        description?: string;
    }

    export interface PrefixListTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface PrefixListsPrefixList {
        /**
         * Number of associated resources for prefix list.
         */
        associationCount: number;
        /**
         * CIDR address block information for prefix list.
         */
        cidrs: string[];
        /**
         * The creation time of the prefix list.
         */
        creationTime: string;
        /**
         * Description.
         */
        description: string;
        /**
         * The id of the prefix list.
         */
        id: string;
        /**
         * IP version of prefix list.
         */
        ipVersion: string;
        /**
         * Maximum number of entries, which is the maximum number of items that can be added to the prefix list.
         */
        maxEntries: number;
        /**
         * Collection of resources associated with VPC prefix list.
         */
        prefixListAssociations: outputs.vpc.PrefixListsPrefixListPrefixListAssociation[];
        /**
         * The prefix list entries.
         */
        prefixListEntries: outputs.vpc.PrefixListsPrefixListPrefixListEntry[];
        /**
         * The prefix list id.
         */
        prefixListId: string;
        /**
         * A Name of prefix list.
         */
        prefixListName: string;
        /**
         * The status of the prefix list.
         */
        status: string;
        /**
         * The update time of the prefix list.
         */
        updateTime: string;
    }

    export interface PrefixListsPrefixListPrefixListAssociation {
        /**
         * Associated resource ID.
         */
        resourceId: string;
        /**
         * Related resource types.
         */
        resourceType: string;
    }

    export interface PrefixListsPrefixListPrefixListEntry {
        /**
         * CIDR address blocks for prefix list entries.
         */
        cidr: string;
        /**
         * Description.
         */
        description: string;
        /**
         * The prefix list id.
         */
        prefixListId: string;
    }

    export interface PrefixListsTagFilter {
        /**
         * The key of the tag.
         */
        key?: string;
        /**
         * The values of the tag.
         */
        values?: string[];
    }

    export interface RouteEntriesRouteEntry {
        /**
         * The description of the route entry.
         */
        description: string;
        /**
         * A destination CIDR block of route entry.
         */
        destinationCidrBlock: string;
        /**
         * The id of the route entry.
         */
        id: string;
        /**
         * An id of next hop.
         */
        nextHopId: string;
        /**
         * The name of the next hop.
         */
        nextHopName: string;
        /**
         * A type of next hop, Optional choice contains `Instance`, `NetworkInterface`, `NatGW`, `VpnGW`.
         */
        nextHopType: string;
        /**
         * The id of the route entry.
         */
        routeEntryId: string;
        /**
         * A name of route entry.
         */
        routeEntryName: string;
        /**
         * An id of route table.
         */
        routeTableId: string;
        /**
         * The status of the route entry.
         */
        status: string;
        /**
         * The type of the route entry.
         */
        type: string;
        /**
         * The id of the virtual private cloud (VPC) to which the route entry belongs.
         */
        vpcId: string;
    }

    export interface RouteTableTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface RouteTablesRouteTable {
        /**
         * The account id of the route table creator.
         */
        accountId: string;
        /**
         * The create time of the route table.
         */
        creationTime: string;
        /**
         * The description of the route table.
         */
        description: string;
        /**
         * The id of the route table.
         */
        id: string;
        /**
         * The ProjectName of the route table.
         */
        projectName: string;
        /**
         * The id of the route table.
         */
        routeTableId: string;
        /**
         * A name of route table.
         */
        routeTableName: string;
        /**
         * The type of the route table.
         */
        routeTableType: string;
        /**
         * The list of the subnet ids to which the entry table associates.
         */
        subnetIds: string[];
        /**
         * Tags.
         */
        tags: outputs.vpc.RouteTablesRouteTableTag[];
        /**
         * The last update time of the route table.
         */
        updateTime: string;
        /**
         * An id of VPC.
         */
        vpcId: string;
        /**
         * The name of the virtual private cloud (VPC) to which the route entry belongs.
         */
        vpcName: string;
    }

    export interface RouteTablesRouteTableTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface RouteTablesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface SecurityGroupRulesSecurityGroupRule {
        /**
         * Cidr ip of egress/ingress Rule.
         */
        cidrIp: string;
        /**
         * The creation time of security group rule.
         */
        creationTime: string;
        /**
         * description of a group rule.
         */
        description: string;
        /**
         * Direction of rule, ingress (inbound) or egress (outbound).
         */
        direction: string;
        /**
         * Access strategy.
         */
        policy: string;
        /**
         * Port end of egress/ingress Rule.
         */
        portEnd: number;
        /**
         * Port start of egress/ingress Rule.
         */
        portStart: number;
        /**
         * Priority of a security group rule.
         */
        priority: number;
        /**
         * Protocol of the SecurityGroup, the value can be `tcp` or `udp` or `icmp` or `all`.
         */
        protocol: string;
        /**
         * SecurityGroup ID.
         */
        securityGroupId: string;
        /**
         * ID of the source security group whose access permission you want to set.
         */
        sourceGroupId: string;
        /**
         * The update time of security group rule.
         */
        updateTime: string;
    }

    export interface SecurityGroupTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface SecurityGroupsSecurityGroup {
        /**
         * The creation time of SecurityGroup.
         */
        creationTime: string;
        /**
         * The description of SecurityGroup.
         */
        description: string;
        /**
         * The ID of SecurityGroup.
         */
        id: string;
        /**
         * The ProjectName of SecurityGroup.
         */
        projectName: string;
        /**
         * The ID of SecurityGroup.
         */
        securityGroupId: string;
        /**
         * The Name of SecurityGroup.
         */
        securityGroupName: string;
        /**
         * The Status of SecurityGroup.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.vpc.SecurityGroupsSecurityGroupTag[];
        /**
         * The type of SecurityGroup.
         */
        type: string;
        /**
         * The ID of vpc where security group is located.
         */
        vpcId: string;
    }

    export interface SecurityGroupsSecurityGroupTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface SecurityGroupsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface SubnetTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface SubnetsSubnet {
        /**
         * The account ID which the subnet belongs to.
         */
        accountId: string;
        /**
         * The count of available ip address.
         */
        availableIpAddressCount: number;
        /**
         * The cidr block of Subnet.
         */
        cidrBlock: string;
        /**
         * Creation time of Subnet.
         */
        creationTime: string;
        /**
         * The description of Subnet.
         */
        description: string;
        /**
         * The ID of Subnet.
         */
        id: string;
        /**
         * The IPv6 CIDR block of the VPC.
         */
        ipv6CidrBlock: string;
        /**
         * The ID of network acl which this subnet associate with.
         */
        networkAclId: string;
        /**
         * The route table information.
         */
        routeTable: outputs.vpc.SubnetsSubnetRouteTable;
        /**
         * The ID of route table which subnet associated with.
         */
        routeTableId: string;
        /**
         * The route table type.
         */
        routeTableType: string;
        /**
         * The Status of Subnet.
         */
        status: string;
        /**
         * The subnet name to query.
         */
        subnetName: string;
        /**
         * Tags.
         */
        tags: outputs.vpc.SubnetsSubnetTag[];
        /**
         * The Count of ipv4.
         */
        totalIpv4Count: number;
        /**
         * Update time of Subnet.
         */
        updateTime: string;
        /**
         * The ID of VPC which subnet belongs to.
         */
        vpcId: string;
        /**
         * The ID of zone which subnet belongs to.
         */
        zoneId: string;
    }

    export interface SubnetsSubnetRouteTable {
        /**
         * The ID of route table which subnet associated with.
         */
        routeTableId: string;
        /**
         * The route table type.
         */
        routeTableType: string;
    }

    export interface SubnetsSubnetTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface SubnetsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface TrafficMirrorFilterRulesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface TrafficMirrorFilterRulesTrafficMirrorFilterRule {
        /**
         * The create time of traffic mirror filter rule.
         */
        createdAt: string;
        /**
         * The description of traffic mirror filter rule.
         */
        description: string;
        /**
         * The destination cidr block of traffic mirror filter rule.
         */
        destinationCidrBlock: string;
        /**
         * The destination port range of traffic mirror filter rule.
         */
        destinationPortRange: string;
        /**
         * The ID of traffic mirror filter rule.
         */
        id: string;
        /**
         * The policy of traffic mirror filter rule.
         */
        policy: string;
        /**
         * The priority of traffic mirror filter rule.
         */
        priority: number;
        /**
         * The protocol of traffic mirror filter rule.
         */
        protocol: string;
        /**
         * The source cidr block of traffic mirror filter rule.
         */
        sourceCidrBlock: string;
        /**
         * The source port range of traffic mirror filter rule.
         */
        sourcePortRange: string;
        /**
         * The status of traffic mirror filter rule.
         */
        status: string;
        /**
         * The traffic direction of traffic mirror filter rule.
         */
        trafficDirection: string;
        /**
         * The ID of traffic mirror filter.
         */
        trafficMirrorFilterId: string;
        /**
         * The ID of traffic mirror filter rule.
         */
        trafficMirrorFilterRuleId: string;
        /**
         * The last update time of traffic mirror filter rule.
         */
        updatedAt: string;
    }

    export interface TrafficMirrorFilterTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface TrafficMirrorFiltersTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface TrafficMirrorFiltersTrafficMirrorFilter {
        /**
         * The create time of traffic mirror filter rule.
         */
        createdAt: string;
        /**
         * The description of traffic mirror filter rule.
         */
        description: string;
        /**
         * The ingress filter rules of traffic mirror filter.
         */
        egressFilterRules: outputs.vpc.TrafficMirrorFiltersTrafficMirrorFilterEgressFilterRule[];
        /**
         * The ID of traffic mirror filter.
         */
        id: string;
        /**
         * The ingress filter rules of traffic mirror filter.
         */
        ingressFilterRules: outputs.vpc.TrafficMirrorFiltersTrafficMirrorFilterIngressFilterRule[];
        /**
         * The project name of traffic mirror filter.
         */
        projectName: string;
        /**
         * The status of traffic mirror filter.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.vpc.TrafficMirrorFiltersTrafficMirrorFilterTag[];
        /**
         * The ID of traffic mirror filter.
         */
        trafficMirrorFilterId: string;
        /**
         * The name of traffic mirror filter.
         */
        trafficMirrorFilterName: string;
        /**
         * The last update time of traffic mirror filter.
         */
        updatedAt: string;
    }

    export interface TrafficMirrorFiltersTrafficMirrorFilterEgressFilterRule {
        /**
         * The create time of traffic mirror filter rule.
         */
        createdAt: string;
        /**
         * The description of traffic mirror filter rule.
         */
        description: string;
        /**
         * The destination cidr block of traffic mirror filter rule.
         */
        destinationCidrBlock: string;
        /**
         * The destination port range of traffic mirror filter rule.
         */
        destinationPortRange: string;
        /**
         * The policy of traffic mirror filter rule.
         */
        policy: string;
        /**
         * The priority of traffic mirror filter rule.
         */
        priority: number;
        /**
         * The protocol of traffic mirror filter rule.
         */
        protocol: string;
        /**
         * The source cidr block of traffic mirror filter rule.
         */
        sourceCidrBlock: string;
        /**
         * The source port range of traffic mirror filter rule.
         */
        sourcePortRange: string;
        /**
         * The status of traffic mirror filter.
         */
        status: string;
        /**
         * The traffic direction of traffic mirror filter rule.
         */
        trafficDirection: string;
        /**
         * The ID of traffic mirror filter.
         */
        trafficMirrorFilterId: string;
        /**
         * The ID of traffic mirror filter rule.
         */
        trafficMirrorFilterRuleId: string;
        /**
         * The last update time of traffic mirror filter.
         */
        updatedAt: string;
    }

    export interface TrafficMirrorFiltersTrafficMirrorFilterIngressFilterRule {
        /**
         * The create time of traffic mirror filter rule.
         */
        createdAt: string;
        /**
         * The description of traffic mirror filter rule.
         */
        description: string;
        /**
         * The destination cidr block of traffic mirror filter rule.
         */
        destinationCidrBlock: string;
        /**
         * The destination port range of traffic mirror filter rule.
         */
        destinationPortRange: string;
        /**
         * The policy of traffic mirror filter rule.
         */
        policy: string;
        /**
         * The priority of traffic mirror filter rule.
         */
        priority: number;
        /**
         * The protocol of traffic mirror filter rule.
         */
        protocol: string;
        /**
         * The source cidr block of traffic mirror filter rule.
         */
        sourceCidrBlock: string;
        /**
         * The source port range of traffic mirror filter rule.
         */
        sourcePortRange: string;
        /**
         * The status of traffic mirror filter.
         */
        status: string;
        /**
         * The traffic direction of traffic mirror filter rule.
         */
        trafficDirection: string;
        /**
         * The ID of traffic mirror filter.
         */
        trafficMirrorFilterId: string;
        /**
         * The ID of traffic mirror filter rule.
         */
        trafficMirrorFilterRuleId: string;
        /**
         * The last update time of traffic mirror filter.
         */
        updatedAt: string;
    }

    export interface TrafficMirrorFiltersTrafficMirrorFilterTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface TrafficMirrorSessionTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface TrafficMirrorSessionsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface TrafficMirrorSessionsTrafficMirrorSession {
        /**
         * The business status of traffic mirror session.
         */
        businessStatus: string;
        /**
         * The create time of traffic mirror session.
         */
        createdAt: string;
        /**
         * The description of traffic mirror session.
         */
        description: string;
        /**
         * The ID of traffic mirror session.
         */
        id: string;
        /**
         * The lock reason of traffic mirror session.
         */
        lockReason: string;
        /**
         * The packet length of traffic mirror session.
         */
        packetLength: number;
        /**
         * The priority of traffic mirror session.
         */
        priority: number;
        /**
         * The project name of traffic mirror session.
         */
        projectName: string;
        /**
         * The status of traffic mirror session.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.vpc.TrafficMirrorSessionsTrafficMirrorSessionTag[];
        /**
         * The ID of traffic mirror filter.
         */
        trafficMirrorFilterId: string;
        /**
         * The ID of traffic mirror session.
         */
        trafficMirrorSessionId: string;
        /**
         * The name of traffic mirror session.
         */
        trafficMirrorSessionName: string;
        /**
         * The IDs of traffic mirror source.
         */
        trafficMirrorSourceIds: string[];
        /**
         * The ID of traffic mirror target.
         */
        trafficMirrorTargetId: string;
        /**
         * The update time of traffic mirror session.
         */
        updatedAt: string;
        /**
         * The ID of virtual network.
         */
        virtualNetworkId: number;
    }

    export interface TrafficMirrorSessionsTrafficMirrorSessionTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface TrafficMirrorTargetTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface TrafficMirrorTargetsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface TrafficMirrorTargetsTrafficMirrorTarget {
        /**
         * The create time of traffic mirror target.
         */
        createdAt: string;
        /**
         * The description of traffic mirror target.
         */
        description: string;
        /**
         * The ID of traffic mirror target.
         */
        id: string;
        /**
         * The instance id of traffic mirror target.
         */
        instanceId: string;
        /**
         * The instance type of traffic mirror target.
         */
        instanceType: string;
        /**
         * The project name of traffic mirror target.
         */
        projectName: string;
        /**
         * The status of traffic mirror target.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.vpc.TrafficMirrorTargetsTrafficMirrorTargetTag[];
        /**
         * The ID of traffic mirror target.
         */
        trafficMirrorTargetId: string;
        /**
         * The name of traffic mirror target.
         */
        trafficMirrorTargetName: string;
        /**
         * The update time of traffic mirror target.
         */
        updatedAt: string;
    }

    export interface TrafficMirrorTargetsTrafficMirrorTargetTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface VpcAssociateCen {
        /**
         * The ID of CEN.
         */
        cenId: string;
        /**
         * The owner ID of CEN.
         */
        cenOwnerId: string;
        /**
         * The status of CEN.
         */
        cenStatus: string;
    }

    export interface VpcTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface VpcsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface VpcsVpc {
        /**
         * The account ID of VPC.
         */
        accountId: string;
        /**
         * The associate cen list of VPC.
         */
        associateCens: outputs.vpc.VpcsVpcAssociateCen[];
        /**
         * The auxiliary cidr block list of VPC.
         */
        auxiliaryCidrBlocks: string[];
        /**
         * The cidr block of VPC.
         */
        cidrBlock: string;
        /**
         * The create time of VPC.
         */
        creationTime: string;
        /**
         * The description of VPC.
         */
        description: string;
        /**
         * The dns server list of VPC.
         */
        dnsServers: string[];
        /**
         * The IPv6 CIDR block of the VPC.
         */
        ipv6CidrBlock: string;
        /**
         * The nat gateway ID list of VPC.
         */
        natGatewayIds: string[];
        /**
         * The ProjectName of the VPC.
         */
        projectName: string;
        /**
         * The route table ID list of VPC.
         */
        routeTableIds: string[];
        /**
         * The secondary cidr block list of VPC.
         */
        secondaryCidrBlocks: string[];
        /**
         * The security group ID list of VPC.
         */
        securityGroupIds: string[];
        /**
         * The status of VPC.
         */
        status: string;
        /**
         * The subnet ID list of VPC.
         */
        subnetIds: string[];
        /**
         * Tags.
         */
        tags: outputs.vpc.VpcsVpcTag[];
        /**
         * The update time of VPC.
         */
        updateTime: string;
        /**
         * The ID of VPC.
         */
        vpcId: string;
        /**
         * The vpc name to query.
         */
        vpcName: string;
    }

    export interface VpcsVpcAssociateCen {
        /**
         * The ID of CEN.
         */
        cenId: string;
        /**
         * The owner ID of CEN.
         */
        cenOwnerId: string;
        /**
         * The status of CEN.
         */
        cenStatus: string;
    }

    export interface VpcsVpcTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

}

export namespace vpn {
    export interface ConnectionsVpnConnection {
        /**
         * The account ID of the VPN connection.
         */
        accountId: string;
        /**
         * The attach status of VPN connection.
         */
        attachStatus: string;
        /**
         * The attach type of VPN connection. Valid values: `VpnGateway`, `TransitRouter`.
         */
        attachType: string;
        /**
         * The business status of IPsec connection, valid when the attach type is 'TransitRouter'.
         */
        businessStatus: string;
        /**
         * The connect status of the VPN connection.
         */
        connectStatus: string;
        /**
         * The create time of VPN connection.
         */
        creationTime: string;
        /**
         * An ID of customer gateway.
         */
        customerGatewayId: string;
        /**
         * The delete time of resource, valid when the attach type is 'TransitRouter'.
         */
        deletedTime: string;
        /**
         * The description of the VPN connection.
         */
        description: string;
        /**
         * The dpd action of the VPN connection.
         */
        dpdAction: string;
        /**
         * The ID of the VPN connection.
         */
        id: string;
        /**
         * The auth alg of the ike config of the VPN connection.
         */
        ikeConfigAuthAlg: string;
        /**
         * The dk group of the ike config of the VPN connection.
         */
        ikeConfigDhGroup: string;
        /**
         * The enc alg of the ike config of the VPN connection.
         */
        ikeConfigEncAlg: string;
        /**
         * The lifetime of the ike config of the VPN connection.
         */
        ikeConfigLifetime: number;
        /**
         * The localId of the ike config of the VPN connection.
         */
        ikeConfigLocalId: string;
        /**
         * The mode of the ike config of the VPN connection.
         */
        ikeConfigMode: string;
        /**
         * The psk of the ike config of the VPN connection.
         */
        ikeConfigPsk: string;
        /**
         * The remote id of the ike config of the VPN connection.
         */
        ikeConfigRemoteId: string;
        /**
         * The version of the ike config of the VPN connection.
         */
        ikeConfigVersion: string;
        /**
         * The ip address of transit router, valid when the attach type is 'TransitRouter'.
         */
        ipAddress: string;
        /**
         * The auth alg of the ipsec config of the VPN connection.
         */
        ipsecConfigAuthAlg: string;
        /**
         * The dh group of the ipsec config of the VPN connection.
         */
        ipsecConfigDhGroup: string;
        /**
         * The enc alg of the ipsec config of the VPN connection.
         */
        ipsecConfigEncAlg: string;
        /**
         * The lifetime of the ike config of the VPN connection.
         */
        ipsecConfigLifetime: number;
        /**
         * The local subnet of the VPN connection.
         */
        localSubnets: string[];
        /**
         * Whether to enable the connection log.
         */
        logEnabled: boolean;
        /**
         * The nat traversal of the VPN connection.
         */
        natTraversal: boolean;
        /**
         * Whether to initiate negotiation mode immediately.
         */
        negotiateInstantly: boolean;
        /**
         * The overdue time of resource, valid when the attach type is 'TransitRouter'.
         */
        overdueTime: string;
        /**
         * The remote subnet of the VPN connection.
         */
        remoteSubnets: string[];
        /**
         * The status of IPSec connection. Valid values: `Creating`, `Deleting`, `Pending`, `Available`.
         */
        status: string;
        /**
         * An ID of transit router.
         */
        transitRouterId: string;
        /**
         * The update time of VPN connection.
         */
        updateTime: string;
        /**
         * The ID of the VPN connection.
         */
        vpnConnectionId: string;
        /**
         * The name of the VPN connection.
         */
        vpnConnectionName: string;
        /**
         * An ID of VPN gateway.
         */
        vpnGatewayId: string;
        /**
         * The zone id of transit router, valid when the attach type is 'TransitRouter'.
         */
        zoneId: string;
    }

    export interface CustomerGatewaysCustomerGateway {
        /**
         * The account ID of the customer gateway.
         */
        accountId: string;
        /**
         * The connection count of the customer gateway.
         */
        connectionCount: number;
        /**
         * The create time of customer gateway.
         */
        creationTime: string;
        /**
         * The ID of the customer gateway.
         */
        customerGatewayId: string;
        /**
         * The name of the customer gateway.
         */
        customerGatewayName: string;
        /**
         * The description of the customer gateway.
         */
        description: string;
        /**
         * The ID of the customer gateway.
         */
        id: string;
        /**
         * A IP address of the customer gateway.
         */
        ipAddress: string;
        /**
         * The status of the customer gateway.
         */
        status: string;
        /**
         * The update time of customer gateway.
         */
        updateTime: string;
    }

    export interface GatewayRoutesVpnGatewayRoute {
        /**
         * The create time of VPN gateway route.
         */
        creationTime: string;
        /**
         * A destination cidr block.
         */
        destinationCidrBlock: string;
        /**
         * The ID of the VPN gateway route.
         */
        id: string;
        /**
         * An ID of next hop.
         */
        nextHopId: string;
        /**
         * The status of the VPN gateway route.
         */
        status: string;
        /**
         * The update time of VPN gateway route.
         */
        updateTime: string;
        /**
         * An ID of VPN gateway.
         */
        vpnGatewayId: string;
        /**
         * The ID of the VPN gateway route.
         */
        vpnGatewayRouteId: string;
    }

    export interface GatewayTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GatewaysTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GatewaysVpnGateway {
        /**
         * The account ID of the VPN gateway.
         */
        accountId: string;
        /**
         * The bandwidth of the VPN gateway.
         */
        bandwidth: number;
        /**
         * The BillingType of the VPN gateway.
         */
        billingType: string;
        /**
         * The business status of the VPN gateway.
         */
        businessStatus: string;
        /**
         * The connection count of the VPN gateway.
         */
        connectionCount: number;
        /**
         * The create time of VPN gateway.
         */
        creationTime: string;
        /**
         * The deleted time of the VPN gateway.
         */
        deletedTime: string;
        /**
         * The description of the VPN gateway.
         */
        description: string;
        /**
         * The expired time of the VPN gateway.
         */
        expiredTime: string;
        /**
         * The ID of the VPN gateway.
         */
        id: string;
        /**
         * A IP address of the VPN gateway.
         */
        ipAddress: string;
        /**
         * Whether IPSec is enabled.
         */
        ipsecEnabled: boolean;
        /**
         * The lock reason of the VPN gateway.
         */
        lockReason: string;
        /**
         * The project name of the VPN gateway.
         */
        projectName: string;
        /**
         * The route count of the VPN gateway.
         */
        routeCount: number;
        /**
         * Whether ssl is enabled.
         */
        sslEnabled: boolean;
        /**
         * The max connections of ssl.
         */
        sslMaxConnections: number;
        /**
         * The status of the VPN gateway.
         */
        status: string;
        /**
         * A subnet ID of the VPN gateway.
         */
        subnetId?: string;
        /**
         * Tags.
         */
        tags: outputs.vpn.GatewaysVpnGatewayTag[];
        /**
         * The update time of VPN gateway.
         */
        updateTime: string;
        /**
         * A VPC ID of the VPN gateway.
         */
        vpcId: string;
        /**
         * The ID of the VPN gateway.
         */
        vpnGatewayId: string;
        /**
         * The name of the VPN gateway.
         */
        vpnGatewayName: string;
    }

    export interface GatewaysVpnGatewayTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetConnectionsVpnConnection {
        /**
         * The account ID of the VPN connection.
         */
        accountId: string;
        /**
         * The attach status of VPN connection.
         */
        attachStatus: string;
        /**
         * The attach type of VPN connection. Valid values: `VpnGateway`, `TransitRouter`.
         */
        attachType: string;
        /**
         * The business status of IPsec connection, valid when the attach type is 'TransitRouter'.
         */
        businessStatus: string;
        /**
         * The connect status of the VPN connection.
         */
        connectStatus: string;
        /**
         * The create time of VPN connection.
         */
        creationTime: string;
        /**
         * An ID of customer gateway.
         */
        customerGatewayId: string;
        /**
         * The delete time of resource, valid when the attach type is 'TransitRouter'.
         */
        deletedTime: string;
        /**
         * The description of the VPN connection.
         */
        description: string;
        /**
         * The dpd action of the VPN connection.
         */
        dpdAction: string;
        /**
         * The ID of the VPN connection.
         */
        id: string;
        /**
         * The auth alg of the ike config of the VPN connection.
         */
        ikeConfigAuthAlg: string;
        /**
         * The dk group of the ike config of the VPN connection.
         */
        ikeConfigDhGroup: string;
        /**
         * The enc alg of the ike config of the VPN connection.
         */
        ikeConfigEncAlg: string;
        /**
         * The lifetime of the ike config of the VPN connection.
         */
        ikeConfigLifetime: number;
        /**
         * The localId of the ike config of the VPN connection.
         */
        ikeConfigLocalId: string;
        /**
         * The mode of the ike config of the VPN connection.
         */
        ikeConfigMode: string;
        /**
         * The psk of the ike config of the VPN connection.
         */
        ikeConfigPsk: string;
        /**
         * The remote id of the ike config of the VPN connection.
         */
        ikeConfigRemoteId: string;
        /**
         * The version of the ike config of the VPN connection.
         */
        ikeConfigVersion: string;
        /**
         * The ip address of transit router, valid when the attach type is 'TransitRouter'.
         */
        ipAddress: string;
        /**
         * The auth alg of the ipsec config of the VPN connection.
         */
        ipsecConfigAuthAlg: string;
        /**
         * The dh group of the ipsec config of the VPN connection.
         */
        ipsecConfigDhGroup: string;
        /**
         * The enc alg of the ipsec config of the VPN connection.
         */
        ipsecConfigEncAlg: string;
        /**
         * The lifetime of the ike config of the VPN connection.
         */
        ipsecConfigLifetime: number;
        /**
         * The local subnet of the VPN connection.
         */
        localSubnets: string[];
        /**
         * Whether to enable the connection log.
         */
        logEnabled: boolean;
        /**
         * The nat traversal of the VPN connection.
         */
        natTraversal: boolean;
        /**
         * Whether to initiate negotiation mode immediately.
         */
        negotiateInstantly: boolean;
        /**
         * The overdue time of resource, valid when the attach type is 'TransitRouter'.
         */
        overdueTime: string;
        /**
         * The remote subnet of the VPN connection.
         */
        remoteSubnets: string[];
        /**
         * The status of IPSec connection. Valid values: `Creating`, `Deleting`, `Pending`, `Available`.
         */
        status: string;
        /**
         * An ID of transit router.
         */
        transitRouterId: string;
        /**
         * The update time of VPN connection.
         */
        updateTime: string;
        /**
         * The ID of the VPN connection.
         */
        vpnConnectionId: string;
        /**
         * The name of the VPN connection.
         */
        vpnConnectionName: string;
        /**
         * An ID of VPN gateway.
         */
        vpnGatewayId: string;
        /**
         * The zone id of transit router, valid when the attach type is 'TransitRouter'.
         */
        zoneId: string;
    }

    export interface GetCustomerGatewaysCustomerGateway {
        /**
         * The account ID of the customer gateway.
         */
        accountId: string;
        /**
         * The connection count of the customer gateway.
         */
        connectionCount: number;
        /**
         * The create time of customer gateway.
         */
        creationTime: string;
        /**
         * The ID of the customer gateway.
         */
        customerGatewayId: string;
        /**
         * The name of the customer gateway.
         */
        customerGatewayName: string;
        /**
         * The description of the customer gateway.
         */
        description: string;
        /**
         * The ID of the customer gateway.
         */
        id: string;
        /**
         * A IP address of the customer gateway.
         */
        ipAddress: string;
        /**
         * The status of the customer gateway.
         */
        status: string;
        /**
         * The update time of customer gateway.
         */
        updateTime: string;
    }

    export interface GetGatewayRoutesVpnGatewayRoute {
        /**
         * The create time of VPN gateway route.
         */
        creationTime: string;
        /**
         * A destination cidr block.
         */
        destinationCidrBlock: string;
        /**
         * The ID of the VPN gateway route.
         */
        id: string;
        /**
         * An ID of next hop.
         */
        nextHopId: string;
        /**
         * The status of the VPN gateway route.
         */
        status: string;
        /**
         * The update time of VPN gateway route.
         */
        updateTime: string;
        /**
         * An ID of VPN gateway.
         */
        vpnGatewayId: string;
        /**
         * The ID of the VPN gateway route.
         */
        vpnGatewayRouteId: string;
    }

    export interface GetGatewaysTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetGatewaysVpnGateway {
        /**
         * The account ID of the VPN gateway.
         */
        accountId: string;
        /**
         * The bandwidth of the VPN gateway.
         */
        bandwidth: number;
        /**
         * The BillingType of the VPN gateway.
         */
        billingType: string;
        /**
         * The business status of the VPN gateway.
         */
        businessStatus: string;
        /**
         * The connection count of the VPN gateway.
         */
        connectionCount: number;
        /**
         * The create time of VPN gateway.
         */
        creationTime: string;
        /**
         * The deleted time of the VPN gateway.
         */
        deletedTime: string;
        /**
         * The description of the VPN gateway.
         */
        description: string;
        /**
         * The expired time of the VPN gateway.
         */
        expiredTime: string;
        /**
         * The ID of the VPN gateway.
         */
        id: string;
        /**
         * A IP address of the VPN gateway.
         */
        ipAddress: string;
        /**
         * Whether IPSec is enabled.
         */
        ipsecEnabled: boolean;
        /**
         * The lock reason of the VPN gateway.
         */
        lockReason: string;
        /**
         * The project name of the VPN gateway.
         */
        projectName: string;
        /**
         * The route count of the VPN gateway.
         */
        routeCount: number;
        /**
         * Whether ssl is enabled.
         */
        sslEnabled: boolean;
        /**
         * The max connections of ssl.
         */
        sslMaxConnections: number;
        /**
         * The status of the VPN gateway.
         */
        status: string;
        /**
         * A subnet ID of the VPN gateway.
         */
        subnetId?: string;
        /**
         * Tags.
         */
        tags: outputs.vpn.GetGatewaysVpnGatewayTag[];
        /**
         * The update time of VPN gateway.
         */
        updateTime: string;
        /**
         * A VPC ID of the VPN gateway.
         */
        vpcId: string;
        /**
         * The ID of the VPN gateway.
         */
        vpnGatewayId: string;
        /**
         * The name of the VPN gateway.
         */
        vpnGatewayName: string;
    }

    export interface GetGatewaysVpnGatewayTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GetSslVpnClientCertsSslVpnClientCert {
        /**
         * The CA certificate.
         */
        caCertificate: string;
        /**
         * The status of the ssl vpn client cert.
         */
        certificateStatus: string;
        /**
         * The client certificate.
         */
        clientCertificate: string;
        /**
         * The key of the ssl vpn client.
         */
        clientKey: string;
        /**
         * The creation time of the ssl vpn client cert.
         */
        creationTime: string;
        /**
         * The description of the ssl vpn client cert.
         */
        description: string;
        /**
         * The expired time of the ssl vpn client cert.
         */
        expiredTime: string;
        /**
         * The id of the ssl vpn client cert.
         */
        id: string;
        /**
         * The config of the open vpn client.
         */
        openVpnClientConfig: string;
        /**
         * The id of the ssl vpn client cert.
         */
        sslVpnClientCertId: string;
        /**
         * The name of the ssl vpn client cert.
         */
        sslVpnClientCertName: string;
        /**
         * The id of the ssl vpn server.
         */
        sslVpnServerId: string;
        /**
         * The status of the ssl vpn client.
         */
        status: string;
        /**
         * The update time of the ssl vpn client cert.
         */
        updateTime: string;
    }

    export interface GetSslVpnServersSslVpnServer {
        /**
         * The authentication algorithm of the SSL server.
         * Values:
         * `SHA1` (default)
         * `MD5`
         * `None` (do not use encryption).
         */
        auth: string;
        /**
         * The encryption algorithm of the SSL server.
         * Values:
         * `AES-128-CBC` (default)
         * `AES-192-CBC`
         * `AES-256-CBC`
         * `None` (do not use encryption).
         */
        cipher: string;
        /**
         * SSL client network segment.
         */
        clientIpPool: string;
        /**
         * Whether to compress the transmitted data. The default value is false.
         */
        compress: boolean;
        /**
         * The creation time.
         */
        creationTime: string;
        /**
         * The description of the ssl server.
         */
        description: string;
        /**
         * The SSL VPN server id.
         */
        id: string;
        /**
         * The local network segment of the SSL server. The local network segment is the address segment that the client accesses through the SSL VPN connection.
         */
        localSubnets: string[];
        /**
         * The port of the ssl server.
         */
        port: number;
        /**
         * The project name of the ssl server.
         */
        projectName: string;
        /**
         * The protocol used by the SSL server. Valid values are `TCP`, `UDP`. Default Value: `UDP`.
         */
        protocol: string;
        /**
         * The id of the ssl vpn server.
         */
        sslVpnServerId: string;
        /**
         * The name of the ssl vpn server.
         */
        sslVpnServerName: string;
        /**
         * The status of the ssl vpn server.
         */
        status: string;
        /**
         * The update time.
         */
        updateTime: string;
        /**
         * The id of the vpn gateway.
         */
        vpnGatewayId: string;
    }

    export interface SslVpnClientCertsSslVpnClientCert {
        /**
         * The CA certificate.
         */
        caCertificate: string;
        /**
         * The status of the ssl vpn client cert.
         */
        certificateStatus: string;
        /**
         * The client certificate.
         */
        clientCertificate: string;
        /**
         * The key of the ssl vpn client.
         */
        clientKey: string;
        /**
         * The creation time of the ssl vpn client cert.
         */
        creationTime: string;
        /**
         * The description of the ssl vpn client cert.
         */
        description: string;
        /**
         * The expired time of the ssl vpn client cert.
         */
        expiredTime: string;
        /**
         * The id of the ssl vpn client cert.
         */
        id: string;
        /**
         * The config of the open vpn client.
         */
        openVpnClientConfig: string;
        /**
         * The id of the ssl vpn client cert.
         */
        sslVpnClientCertId: string;
        /**
         * The name of the ssl vpn client cert.
         */
        sslVpnClientCertName: string;
        /**
         * The id of the ssl vpn server.
         */
        sslVpnServerId: string;
        /**
         * The status of the ssl vpn client.
         */
        status: string;
        /**
         * The update time of the ssl vpn client cert.
         */
        updateTime: string;
    }

    export interface SslVpnServersSslVpnServer {
        /**
         * The authentication algorithm of the SSL server.
         * Values:
         * `SHA1` (default)
         * `MD5`
         * `None` (do not use encryption).
         */
        auth: string;
        /**
         * The encryption algorithm of the SSL server.
         * Values:
         * `AES-128-CBC` (default)
         * `AES-192-CBC`
         * `AES-256-CBC`
         * `None` (do not use encryption).
         */
        cipher: string;
        /**
         * SSL client network segment.
         */
        clientIpPool: string;
        /**
         * Whether to compress the transmitted data. The default value is false.
         */
        compress: boolean;
        /**
         * The creation time.
         */
        creationTime: string;
        /**
         * The description of the ssl server.
         */
        description: string;
        /**
         * The SSL VPN server id.
         */
        id: string;
        /**
         * The local network segment of the SSL server. The local network segment is the address segment that the client accesses through the SSL VPN connection.
         */
        localSubnets: string[];
        /**
         * The port of the ssl server.
         */
        port: number;
        /**
         * The project name of the ssl server.
         */
        projectName: string;
        /**
         * The protocol used by the SSL server. Valid values are `TCP`, `UDP`. Default Value: `UDP`.
         */
        protocol: string;
        /**
         * The id of the ssl vpn server.
         */
        sslVpnServerId: string;
        /**
         * The name of the ssl vpn server.
         */
        sslVpnServerName: string;
        /**
         * The status of the ssl vpn server.
         */
        status: string;
        /**
         * The update time.
         */
        updateTime: string;
        /**
         * The id of the vpn gateway.
         */
        vpnGatewayId: string;
    }

}

export namespace waf {
    export interface AclRuleAccurateGroup {
        /**
         * Details of advanced conditions.
         */
        accurateRules: outputs.waf.AclRuleAccurateGroupAccurateRule[];
        /**
         * The logical relationship of advanced conditions.
         */
        logic: number;
    }

    export interface AclRuleAccurateGroupAccurateRule {
        /**
         * The HTTP object to be added to the advanced conditions.
         */
        httpObj: string;
        /**
         * The matching field for HTTP objects.
         */
        objType: number;
        /**
         * The logical operator for the condition.
         */
        opretar: number;
        /**
         * Operate the properties of the http object.
         */
        property: number;
        /**
         * The value to be matched.
         */
        valueString: string;
    }

    export interface AclRuleHostGroup {
        /**
         * The ID of the domain group.
         */
        hostGroupId: number;
        /**
         * Rule name.
         */
        name: string;
    }

    export interface AclRuleIpGroup {
        /**
         * Required if IpAddType = 2.
         */
        ipGroupId: number;
        /**
         * Rule name.
         */
        name: string;
    }

    export interface AclRulesRule {
        /**
         * Advanced conditions.
         */
        accurateGroup: outputs.waf.AclRulesRuleAccurateGroup;
        /**
         * Action to be taken on requests that match the rule.
         */
        action: string;
        /**
         * Whether to set advanced conditions.
         */
        advanced: number;
        /**
         * IP address.
         */
        clientIp: string;
        /**
         * Rule description.
         */
        description: string;
        /**
         * The enabled status of the rule.
         */
        enable: number;
        /**
         * Type of domain name addition.
         */
        hostAddType: number;
        /**
         * The ID of host group.
         */
        hostGroupIds: number[];
        /**
         * The list of domain name groups.
         */
        hostGroups: outputs.waf.AclRulesRuleHostGroup[];
        /**
         * Single or multiple domain names are supported.
         */
        hostLists: string[];
        /**
         * Rule ID.
         */
        id: number;
        /**
         * Type of IP address addition.
         */
        ipAddType: number;
        /**
         * The ID of the IP address group.
         */
        ipGroupIds: number[];
        /**
         * The list of domain name groups.
         */
        ipGroups: outputs.waf.AclRulesRuleIpGroup[];
        /**
         * Single or multiple IP addresses are supported.
         */
        ipLists: string[];
        /**
         * Country or region code.
         */
        ipLocationCountries: string[];
        /**
         * Domestic region code.
         */
        ipLocationSubregions: string[];
        /**
         * Rule name.
         */
        name: string;
        /**
         * Rule unique identifier, precise search.
         */
        ruleTag: string;
        /**
         * Update time of the rule.
         */
        updateTime: string;
        /**
         * The path of Matching.
         */
        url: string;
    }

    export interface AclRulesRuleAccurateGroup {
        /**
         * Details of advanced conditions.
         */
        accurateRules: outputs.waf.AclRulesRuleAccurateGroupAccurateRule[];
        /**
         * The logical relationship of advanced conditions.
         */
        logic: number;
    }

    export interface AclRulesRuleAccurateGroupAccurateRule {
        /**
         * The HTTP object to be added to the advanced conditions.
         */
        httpObj: string;
        /**
         * The matching field for HTTP objects.
         */
        objType: number;
        /**
         * The logical operator for the condition.
         */
        opretar: number;
        /**
         * Operate the properties of the http object.
         */
        property: number;
        /**
         * The value to be matched.
         */
        valueString: string;
    }

    export interface AclRulesRuleHostGroup {
        /**
         * The ID of host group.
         */
        hostGroupId: number;
        /**
         * Rule name.
         */
        name: string;
    }

    export interface AclRulesRuleIpGroup {
        /**
         * The ID of the IP address group.
         */
        ipGroupId: number;
        /**
         * Rule name.
         */
        name: string;
    }

    export interface BotAnalyseProtectRuleAccurateGroup {
        /**
         * Request characteristic information of the rule group.
         */
        accurateRules?: outputs.waf.BotAnalyseProtectRuleAccurateGroupAccurateRule[];
        /**
         * In the rule group, the high-level conditional operation relationships corresponding to each rule.
         */
        logic?: number;
    }

    export interface BotAnalyseProtectRuleAccurateGroupAccurateRule {
        /**
         * Custom object.
         */
        httpObj?: string;
        /**
         * matching field.
         */
        objType?: number;
        /**
         * The logical operator for the condition.
         */
        opretar?: number;
        /**
         * Operate the properties of the http object.
         */
        property?: number;
        /**
         * The value to be matched.
         */
        valueString?: string;
    }

    export interface BotAnalyseProtectRuleRuleGroup {
        /**
         * Rule group information.
         */
        group: outputs.waf.BotAnalyseProtectRuleRuleGroupGroup;
        /**
         * Specific rule information within the rule group.
         */
        rules: outputs.waf.BotAnalyseProtectRuleRuleGroupRule[];
    }

    export interface BotAnalyseProtectRuleRuleGroupGroup {
        /**
         * After the rule creation is completed, the priority of the automatically generated rule group.
         */
        accurateGroupPriority: number;
        /**
         * Request characteristic information of the rule group.
         */
        accurateRules: outputs.waf.BotAnalyseProtectRuleRuleGroupGroupAccurateRule[];
        /**
         * Rule unique identifier.
         */
        id: number;
        /**
         * In the rule group, the high-level conditional operation relationships corresponding to each rule.
         */
        logic: number;
    }

    export interface BotAnalyseProtectRuleRuleGroupGroupAccurateRule {
        /**
         * Custom object.
         */
        httpObj: string;
        /**
         * matching field.
         */
        objType: number;
        /**
         * The logical operator for the condition.
         */
        opretar: number;
        /**
         * Operate the properties of the http object.
         */
        property: number;
        /**
         * The value to be matched.
         */
        valueString: string;
    }

    export interface BotAnalyseProtectRuleRuleGroupRule {
        /**
         * Advanced conditions.
         */
        accurateGroup: outputs.waf.BotAnalyseProtectRuleRuleGroupRuleAccurateGroup;
        /**
         * After the rule creation is completed, the priority of the automatically generated rule group.
         */
        accurateGroupPriority: number;
        /**
         * Perform the action after verification/challenge.
         */
        actionAfterVerification: number;
        /**
         * perform the action.
         */
        actionType: number;
        /**
         * Limit the duration.
         */
        effectTime: number;
        /**
         * Whether to enable the rules.
         */
        enable: number;
        /**
         * Exemption time takes effect when the execution action is human-machine challenge /JS/ Proof of work.
         */
        exemptionTime: number;
        /**
         * Statistical objects, with multiple objects separated by commas.
         */
        field: string;
        /**
         * Website domain names that require the setting of protection rules.
         */
        host: string;
        /**
         * Rule unique identifier.
         */
        id: number;
        /**
         * The name of rule.
         */
        name: string;
        /**
         * JS challenge/human-machine verification pass rate.
         */
        passRatio: number;
        /**
         * The requested path.
         */
        path: string;
        /**
         * The path access frequency threshold is enabled when StatisticalType=1.
         */
        pathThreshold: number;
        /**
         * Priority of rule effectiveness.
         */
        rulePriority: number;
        /**
         * Rule label, that is, the complete rule ID.
         */
        ruleTag: string;
        /**
         * The IP proportion of the same statistical object needs to be configured when StatisticalType=3.
         */
        singleProportion: number;
        /**
         * The maximum number of ips of the same statistical object is enabled when StatisticalType=2.
         */
        singleThreshold: number;
        /**
         * The duration of statistics.
         */
        statisticalDuration: number;
        /**
         * Statistical content and methods.
         */
        statisticalType: number;
        /**
         * Rule update time.
         */
        updateTime: string;
    }

    export interface BotAnalyseProtectRuleRuleGroupRuleAccurateGroup {
        /**
         * After the rule creation is completed, the priority of the automatically generated rule group.
         */
        accurateGroupPriority: number;
        /**
         * Request characteristic information of the rule group.
         */
        accurateRules: outputs.waf.BotAnalyseProtectRuleRuleGroupRuleAccurateGroupAccurateRule[];
        /**
         * Rule unique identifier.
         */
        id: number;
        /**
         * In the rule group, the high-level conditional operation relationships corresponding to each rule.
         */
        logic: number;
    }

    export interface BotAnalyseProtectRuleRuleGroupRuleAccurateGroupAccurateRule {
        /**
         * Custom object.
         */
        httpObj: string;
        /**
         * matching field.
         */
        objType: number;
        /**
         * The logical operator for the condition.
         */
        opretar: number;
        /**
         * Operate the properties of the http object.
         */
        property: number;
        /**
         * The value to be matched.
         */
        valueString: string;
    }

    export interface BotAnalyseProtectRulesData {
        /**
         * The number of statistical protection rules enabled under the current domain name.
         */
        enableCount: number;
        /**
         * Protective path.
         */
        path: string;
        /**
         * Details of the rule group.
         */
        ruleGroups: outputs.waf.BotAnalyseProtectRulesDataRuleGroup[];
        /**
         * The total count of query.
         */
        totalCount: number;
    }

    export interface BotAnalyseProtectRulesDataRuleGroup {
        /**
         * Rule group information.
         */
        group: outputs.waf.BotAnalyseProtectRulesDataRuleGroupGroup;
        /**
         * Specific rule information within the rule group.
         */
        rules: outputs.waf.BotAnalyseProtectRulesDataRuleGroupRule[];
    }

    export interface BotAnalyseProtectRulesDataRuleGroupGroup {
        /**
         * After the rule creation is completed, the priority of the automatically generated rule group.
         */
        accurateGroupPriority: number;
        /**
         * Request characteristic information of the rule group.
         */
        accurateRules: outputs.waf.BotAnalyseProtectRulesDataRuleGroupGroupAccurateRule[];
        /**
         * Rule unique identifier.
         */
        id: number;
        /**
         * In the rule group, the high-level conditional operation relationships corresponding to each rule.
         */
        logic: number;
    }

    export interface BotAnalyseProtectRulesDataRuleGroupGroupAccurateRule {
        /**
         * Custom object.
         */
        httpObj: string;
        /**
         * matching field.
         */
        objType: number;
        /**
         * The logical operator for the condition.
         */
        opretar: number;
        /**
         * Operate the properties of the http object.
         */
        property: number;
        /**
         * The value to be matched.
         */
        valueString: string;
    }

    export interface BotAnalyseProtectRulesDataRuleGroupRule {
        /**
         * Advanced conditions.
         */
        accurateGroup: outputs.waf.BotAnalyseProtectRulesDataRuleGroupRuleAccurateGroup;
        /**
         * After the rule creation is completed, the priority of the automatically generated rule group.
         */
        accurateGroupPriority: number;
        /**
         * Perform actions after human-machine verification /JS challenges.
         */
        actionAfterVerification: number;
        /**
         * perform the action.
         */
        actionType: number;
        /**
         * Limit the duration.
         */
        effectTime: number;
        /**
         * Whether to enable the rules.
         */
        enable: number;
        /**
         * Exemption time.
         */
        exemptionTime: number;
        /**
         * statistical object.
         */
        field: string;
        /**
         * Website domain names that require the setting of protection rules.
         */
        host: string;
        /**
         * Rule unique identifier.
         */
        id: number;
        /**
         * The name of the rule.
         */
        name: string;
        /**
         * JS challenge/human-machine verification pass rate.
         */
        passRatio: number;
        /**
         * Protective path.
         */
        path: string;
        /**
         * Threshold of path access times.
         */
        pathThreshold: number;
        /**
         * Rule execution priority.
         */
        rulePriority: number;
        /**
         * Unique identification of rules.
         */
        ruleTag: string;
        /**
         * The IP proportion of the same statistical object.
         */
        singleProportion: number;
        /**
         * The maximum number of ips for the same statistical object.
         */
        singleThreshold: number;
        /**
         * The duration of the statistics.
         */
        statisticalDuration: number;
        /**
         * Statistical content method.
         */
        statisticalType: number;
        /**
         * Rule update time.
         */
        updateTime: string;
    }

    export interface BotAnalyseProtectRulesDataRuleGroupRuleAccurateGroup {
        /**
         * After the rule creation is completed, the priority of the automatically generated rule group.
         */
        accurateGroupPriority: number;
        /**
         * Request characteristic information of the rule group.
         */
        accurateRules: outputs.waf.BotAnalyseProtectRulesDataRuleGroupRuleAccurateGroupAccurateRule[];
        /**
         * Rule unique identifier.
         */
        id: number;
        /**
         * In the rule group, the high-level conditional operation relationships corresponding to each rule.
         */
        logic: number;
    }

    export interface BotAnalyseProtectRulesDataRuleGroupRuleAccurateGroupAccurateRule {
        /**
         * Custom object.
         */
        httpObj: string;
        /**
         * matching field.
         */
        objType: number;
        /**
         * The logical operator for the condition.
         */
        opretar: number;
        /**
         * Operate the properties of the http object.
         */
        property: number;
        /**
         * The value to be matched.
         */
        valueString: string;
    }

    export interface CcRuleAccurateGroup {
        /**
         * Details of advanced conditions.
         */
        accurateRules: outputs.waf.CcRuleAccurateGroupAccurateRule[];
        /**
         * The logical relationship of advanced conditions.
         */
        logic: number;
    }

    export interface CcRuleAccurateGroupAccurateRule {
        /**
         * The HTTP object to be added to the advanced conditions.
         */
        httpObj: string;
        /**
         * The matching field for HTTP objects.
         */
        objType: number;
        /**
         * The logical operator for the condition.
         */
        opretar: number;
        /**
         * Operate the properties of the http object.
         */
        property: number;
        /**
         * The value to be matched.
         */
        valueString: string;
    }

    export interface CcRuleCronConf {
        /**
         * The weekly cycle days and cycle time periods.
         */
        crontab: string;
        /**
         * The threshold of the number of requests for path access.
         */
        pathThreshold: number;
        /**
         * The threshold of the number of visits to each statistical object.
         */
        singleThreshold: number;
    }

    export interface CcRuleRuleGroup {
        /**
         * Rule group information.
         */
        group: outputs.waf.CcRuleRuleGroupGroup;
        /**
         * Specific rule information within the rule group.
         */
        rules: outputs.waf.CcRuleRuleGroupRule[];
    }

    export interface CcRuleRuleGroupGroup {
        /**
         * After the rule creation is completed, the priority of the automatically generated rule group.
         */
        accurateGroupPriority: number;
        /**
         * Request characteristic information of the rule group.
         */
        accurateRules: outputs.waf.CcRuleRuleGroupGroupAccurateRule[];
        /**
         * The ID of Rule group.
         */
        id: number;
        /**
         * In the rule group, the high-level conditional operation relationships corresponding to each rule.
         */
        logic: number;
    }

    export interface CcRuleRuleGroupGroupAccurateRule {
        /**
         * The HTTP object to be added to the advanced conditions.
         */
        httpObj: string;
        /**
         * The matching field for HTTP objects.
         */
        objType: number;
        /**
         * The logical operator for the condition.
         */
        opretar: number;
        /**
         * Operate the properties of the http object.
         */
        property: number;
        /**
         * The value to be matched.
         */
        valueString: string;
    }

    export interface CcRuleRuleGroupRule {
        /**
         * Advanced conditions.
         */
        accurateGroup: outputs.waf.CcRuleRuleGroupRuleAccurateGroup;
        /**
         * After the rule creation is completed, the priority of the automatically generated rule group.
         */
        accurateGroupPriority: number;
        /**
         * The actions performed on subsequent requests after meeting the statistical conditions.
         */
        ccType: number;
        /**
         * The statistical period of the strategy.
         */
        countTime: number;
        /**
         * Details of the periodic loop configuration.
         */
        cronConfs: outputs.waf.CcRuleRuleGroupRuleCronConf[];
        /**
         * Whether to set the cycle to take effect.
         */
        cronEnable: number;
        /**
         * Limit the duration, that is, the effective duration of the action.
         */
        effectTime: number;
        /**
         * Whether to enable the rules.
         */
        enable: number;
        /**
         * Strategy exemption time.
         */
        exemptionTime: number;
        /**
         * statistical object.
         */
        field: string;
        /**
         * Website domain names that require the setting of protection rules.
         */
        host: string;
        /**
         * The ID of Rule group.
         */
        id: number;
        /**
         * The name of cc rule.
         */
        name: string;
        /**
         * The threshold of the total number of times the request path is accessed.
         */
        pathThreshold: number;
        /**
         * Rule execution priority.
         */
        rulePriority: number;
        /**
         * Rule label, that is, the complete rule ID.
         */
        ruleTag: string;
        /**
         * The threshold of the number of times each statistical object accesses the request path.
         */
        singleThreshold: number;
        /**
         * Rule update time.
         */
        updateTime: string;
        /**
         * The website request path that needs protection.
         */
        url: string;
    }

    export interface CcRuleRuleGroupRuleAccurateGroup {
        /**
         * After the rule creation is completed, the priority of the automatically generated rule group.
         */
        accurateGroupPriority: number;
        /**
         * Details of advanced conditions.
         */
        accurateRules: outputs.waf.CcRuleRuleGroupRuleAccurateGroupAccurateRule[];
        /**
         * The ID of Rule group.
         */
        id: number;
        /**
         * The logical relationship of advanced conditions.
         */
        logic: number;
    }

    export interface CcRuleRuleGroupRuleAccurateGroupAccurateRule {
        /**
         * The HTTP object to be added to the advanced conditions.
         */
        httpObj: string;
        /**
         * The matching field for HTTP objects.
         */
        objType: number;
        /**
         * The logical operator for the condition.
         */
        opretar: number;
        /**
         * Operate the properties of the http object.
         */
        property: number;
        /**
         * The value to be matched.
         */
        valueString: string;
    }

    export interface CcRuleRuleGroupRuleCronConf {
        /**
         * The weekly cycle days and cycle time periods.
         */
        crontab: string;
        /**
         * The threshold of the number of requests for path access.
         */
        pathThreshold: number;
        /**
         * The threshold of the number of visits to each statistical object.
         */
        singleThreshold: number;
    }

    export interface CcRulesData {
        /**
         * The total number of enabled rules within the rule group.
         */
        enableCount: number;
        /**
         * The creation time of the rule group.
         */
        insertTime: string;
        /**
         * Details of the rule group.
         */
        ruleGroups: outputs.waf.CcRulesDataRuleGroup[];
        /**
         * The total count of query.
         */
        totalCount: number;
        /**
         * Fuzzy search by the requested path.
         */
        url: string;
    }

    export interface CcRulesDataRuleGroup {
        /**
         * Rule group information.
         */
        group: outputs.waf.CcRulesDataRuleGroupGroup;
        /**
         * Specific rule information within the rule group.
         */
        rules: outputs.waf.CcRulesDataRuleGroupRule[];
    }

    export interface CcRulesDataRuleGroupGroup {
        /**
         * After the rule creation is completed, the priority of the automatically generated rule group.
         */
        accurateGroupPriority: number;
        /**
         * Request characteristic information of the rule group.
         */
        accurateRules: outputs.waf.CcRulesDataRuleGroupGroupAccurateRule[];
        /**
         * The ID of Rule group.
         */
        id: number;
        /**
         * In the rule group, the high-level conditional operation relationships corresponding to each rule.
         */
        logic: number;
    }

    export interface CcRulesDataRuleGroupGroupAccurateRule {
        /**
         * Custom object.
         */
        httpObj: string;
        /**
         * matching field.
         */
        objType: number;
        /**
         * The logical operator for the condition.
         */
        opretar: number;
        /**
         * Operate the properties of the http object.
         */
        property: number;
        /**
         * The value to be matched.
         */
        valueString: string;
    }

    export interface CcRulesDataRuleGroupRule {
        /**
         * Advanced conditions.
         */
        accurateGroup: outputs.waf.CcRulesDataRuleGroupRuleAccurateGroup;
        /**
         * After the rule creation is completed, the priority of the automatically generated rule group.
         */
        accurateGroupPriority: number;
        /**
         * The actions performed on subsequent requests after meeting the statistical conditions.
         */
        ccType: number;
        /**
         * The statistical period of the strategy.
         */
        countTime: number;
        /**
         * Details of the periodic loop configuration.
         */
        cronConfs: outputs.waf.CcRulesDataRuleGroupRuleCronConf[];
        /**
         * Whether to set the cycle to take effect.
         */
        cronEnable: number;
        /**
         * Limit the duration, that is, the effective duration of the action.
         */
        effectTime: number;
        /**
         * Whether the rule is enabled.
         */
        enable: number;
        /**
         * Strategy exemption time.
         */
        exemptionTime: number;
        /**
         * statistical object.
         */
        field: string;
        /**
         * Website domain names that require the setting of protection rules.
         */
        host: string;
        /**
         * The ID of Rule group.
         */
        id: number;
        /**
         * The Name of Rule group.
         */
        name: string;
        /**
         * The threshold of the number of requests for path access.
         */
        pathThreshold: number;
        /**
         * Rule execution priority.
         */
        rulePriority: number;
        /**
         * Search precisely according to the rule ID.
         */
        ruleTag: string;
        /**
         * The threshold of the number of visits to each statistical object.
         */
        singleThreshold: number;
        /**
         * Rule update time.
         */
        updateTime: string;
        /**
         * Fuzzy search by the requested path.
         */
        url: string;
    }

    export interface CcRulesDataRuleGroupRuleAccurateGroup {
        /**
         * After the rule creation is completed, the priority of the automatically generated rule group.
         */
        accurateGroupPriority: number;
        /**
         * Request characteristic information of the rule group.
         */
        accurateRules: outputs.waf.CcRulesDataRuleGroupRuleAccurateGroupAccurateRule[];
        /**
         * The ID of Rule group.
         */
        id: number;
        /**
         * In the rule group, the high-level conditional operation relationships corresponding to each rule.
         */
        logic: number;
    }

    export interface CcRulesDataRuleGroupRuleAccurateGroupAccurateRule {
        /**
         * Custom object.
         */
        httpObj: string;
        /**
         * matching field.
         */
        objType: number;
        /**
         * The logical operator for the condition.
         */
        opretar: number;
        /**
         * Operate the properties of the http object.
         */
        property: number;
        /**
         * The value to be matched.
         */
        valueString: string;
    }

    export interface CcRulesDataRuleGroupRuleCronConf {
        /**
         * The weekly cycle days and cycle time periods.
         */
        crontab: string;
        /**
         * The threshold of the number of requests for path access.
         */
        pathThreshold: number;
        /**
         * The threshold of the number of visits to each statistical object.
         */
        singleThreshold: number;
    }

    export interface CustomBotAccurate {
        /**
         * Details of advanced conditions.
         */
        accurateRules: outputs.waf.CustomBotAccurateAccurateRule[];
        /**
         * The logical relationship of advanced conditions.
         */
        logic: number;
    }

    export interface CustomBotAccurateAccurateRule {
        /**
         * The HTTP object to be added to the advanced conditions.
         */
        httpObj: string;
        /**
         * The matching field for HTTP objects.
         */
        objType: number;
        /**
         * The logical operator for the condition.
         */
        opretar: number;
        /**
         * Operate the properties of the http object.
         */
        property: number;
        /**
         * The value to be matched.
         */
        valueString: string;
    }

    export interface CustomBotsData {
        /**
         * Advanced conditions.
         */
        accurate: outputs.waf.CustomBotsDataAccurate;
        /**
         * The execution action of the Bot.
         */
        action: string;
        /**
         * Whether to set advanced conditions.
         */
        advanced: number;
        /**
         * bot name.
         */
        botType: string;
        /**
         * The description of bot.
         */
        description: string;
        /**
         * Whether to enable bot.
         */
        enable: number;
        /**
         * The actual count bits of the rule unique identifier (corresponding to the RuleTag).
         */
        id: number;
        /**
         * Rule unique identifier.
         */
        ruleTag: string;
        /**
         * The update time.
         */
        updateTime: string;
    }

    export interface CustomBotsDataAccurate {
        /**
         * Details of advanced conditions.
         */
        accurateRules: outputs.waf.CustomBotsDataAccurateAccurateRule[];
        /**
         * The logical relationship of advanced conditions.
         */
        logic: number;
    }

    export interface CustomBotsDataAccurateAccurateRule {
        /**
         * The HTTP object to be added to the advanced conditions.
         */
        httpObj: string;
        /**
         * The matching field for HTTP objects.
         */
        objType: number;
        /**
         * The logical operator for the condition.
         */
        opretar: number;
        /**
         * Operate the properties of the http object.
         */
        property: number;
        /**
         * The value to be matched.
         */
        valueString: string;
    }

    export interface CustomPageAccurate {
        /**
         * Details of advanced conditions.
         */
        accurateRules: outputs.waf.CustomPageAccurateAccurateRule[];
        /**
         * The logical relationship of advanced conditions.
         */
        logic: number;
    }

    export interface CustomPageAccurateAccurateRule {
        /**
         * The HTTP object to be added to the advanced conditions.
         */
        httpObj: string;
        /**
         * The matching field for HTTP objects.
         */
        objType: number;
        /**
         * The logical operator for the condition.
         */
        opretar: number;
        /**
         * Operate the properties of the http object.
         */
        property: number;
        /**
         * The value to be matched.
         */
        valueString: string;
    }

    export interface CustomPagesData {
        /**
         * Advanced conditions.
         */
        accurate: outputs.waf.CustomPagesDataAccurate;
        /**
         * Whether to configure advanced conditions.
         */
        advanced: number;
        /**
         * The layout content of the response page.
         */
        body: string;
        /**
         * Fill in ALL, which means this rule will take effect on all IP addresses.
         */
        clientIp: string;
        /**
         * Custom HTTP code returned when the request is blocked. Required if PageMode=0 or 1.
         */
        code: string;
        /**
         * The layout template of the response page. Required if PageMode=0 or 1.
         */
        contentType: string;
        /**
         * Rule description.
         */
        description: string;
        /**
         * Whether to enable the rule.
         */
        enable: number;
        /**
         * The ID of the advanced conditional rule group.
         */
        groupId: number;
        /**
         * Request header information.
         */
        header: string;
        /**
         * The domain names that need to be viewed.
         */
        host: string;
        /**
         * The ID of rule.
         */
        id: number;
        /**
         * The ID of Region.
         */
        isolationId: string;
        /**
         * Rule name.
         */
        name: string;
        /**
         * The layout template of the response page.
         */
        pageMode: number;
        /**
         * Action to be taken on requests that match the rule.
         */
        policy: number;
        /**
         * The path where users should be redirected.
         */
        redirectUrl: string;
        /**
         * Unique identification of the rules.
         */
        ruleTag: string;
        /**
         * Rule update time.
         */
        updateTime: string;
        /**
         * Match the path.
         */
        url: string;
    }

    export interface CustomPagesDataAccurate {
        /**
         * Details of advanced conditions.
         */
        accurateRules: outputs.waf.CustomPagesDataAccurateAccurateRule[];
        /**
         * The logical relationship of advanced conditions.
         */
        logic: number;
    }

    export interface CustomPagesDataAccurateAccurateRule {
        /**
         * The HTTP object to be added to the advanced conditions.
         */
        httpObj: string;
        /**
         * The matching field for HTTP objects.
         */
        objType: number;
        /**
         * The logical operator for the condition.
         */
        opretar: number;
        /**
         * Operate the properties of the http object.
         */
        property: number;
        /**
         * The value to be matched.
         */
        valueString: string;
    }

    export interface DomainsData {
        /**
         * Access mode.
         */
        accessMode: number;
        /**
         * High-defense instance IP.
         */
        advancedDefenseIp: string;
        /**
         * Whether the API protection policy has been enabled.
         */
        apiEnable: number;
        /**
         * The status of the attack.
         */
        attackStatus: number;
        /**
         * Whether to enable the intelligent CC protection strategy.
         */
        autoCcEnable: number;
        /**
         * The configuration of source station.
         */
        backendGroups: outputs.waf.DomainsDataBackendGroup[];
        /**
         * Whether the blacklist strategy has been enabled.
         */
        blackIpEnable: number;
        /**
         * Whether the regional ban strategy has been activated.
         */
        blackLctEnable: number;
        /**
         * Whether the cc protection strategy has been enabled.
         */
        ccEnable: number;
        /**
         * When the protocol type is HTTPS, the bound certificate ID needs to be entered.
         */
        certificateId: number;
        /**
         * The name of the certificate.
         */
        certificateName: string;
        /**
         * The method of obtaining the client IP.
         */
        clientIpLocation: number;
        /**
         * The client requests the maximum value of body.
         */
        clientMaxBodySize: number;
        /**
         * Access port information.
         */
        cloudAccessConfigs: outputs.waf.DomainsDataCloudAccessConfig[];
        /**
         * The CNAME value generated by the WAF instance.
         */
        cname: string;
        /**
         * Whether the custom Bot classification strategy has been enabled.
         */
        customBotEnable: number;
        /**
         * Custom Header.
         */
        customHeaders: string[];
        /**
         * Whether the custom response interception strategy has been enabled.
         */
        customRspEnable: number;
        /**
         * The protection mode of the instance.
         */
        defenceMode: number;
        /**
         * Whether to activate the strategy for preventing the leakage of sensitive information.
         */
        dlpEnable: number;
        /**
         * The domain name of the protected website that needs to be queried.
         */
        domain: string;
        /**
         * Whether to enable HTTP 2.0.
         */
        enableHttp2: number;
        /**
         * Whether it supports protecting IPv6 requests.
         */
        enableIpv6: number;
        /**
         * The number of long connection multiplexes.
         */
        keepAliveRequest: number;
        /**
         * Long connection retention time.
         */
        keepAliveTimeOut: number;
        /**
         * The types of load balancing algorithms.
         */
        lbAlgorithm: string;
        /**
         * Whether to enable protocol following.
         */
        protocolFollow: number;
        /**
         * Access port information.
         */
        protocolPorts: outputs.waf.DomainsDataProtocolPorts;
        /**
         * Access protocol types.
         */
        protocols: string;
        /**
         * Whether to enable proxy configuration.
         */
        proxyConfig: number;
        /**
         * The timeout period for establishing a connection between the WAF and the backend server.
         */
        proxyConnectTimeOut: number;
        /**
         * The number of reusable WAF origin long connections.
         */
        proxyKeepAlive: number;
        /**
         * Idle long connection timeout period.
         */
        proxyKeepAliveTimeOut: number;
        /**
         * The timeout period during which WAF reads the response from the backend server.
         */
        proxyReadTimeOut: number;
        /**
         * The number of retries for WAF back to source.
         */
        proxyRetry: number;
        /**
         * The timeout period during which the WAF transmits the request to the backend server.
         */
        proxyWriteTimeOut: number;
        /**
         * Connect to the source return mode.
         */
        publicRealServer: number;
        /**
         * domain region that need to be protected by WAF.
         */
        region: string;
        /**
         * The IP of the WAF protection instance.
         */
        serverIps: string;
        /**
         * WAF source IP.
         */
        srcIps: string;
        /**
         * Encryption kit.
         */
        sslCiphers: string[];
        /**
         * TLS protocol version.
         */
        sslProtocols: string[];
        /**
         * The status of access.
         */
        status: number;
        /**
         * Whether the managed Bot classification strategy has been enabled.
         */
        systemBotEnable: number;
        /**
         * Whether to enable the page tamper proof policy.
         */
        tamperProofEnable: number;
        /**
         * Whether to enable the log service.
         */
        tlsEnable: number;
        /**
         * The update time.
         */
        updateTime: string;
        /**
         * The ID of vpc.
         */
        vpcId: string;
        /**
         * Whether the vulnerability protection strategy has been enabled.
         */
        wafEnable: number;
        /**
         * Whether to enable the whitening strategy for vulnerability protection requests.
         */
        wafWhiteReqEnable: number;
        /**
         * Whether the whitelist strategy has been enabled.
         */
        whiteEnable: number;
        /**
         * Whether to enable the whitening strategy for vulnerability protection fields.
         */
        whiteFieldEnable: number;
    }

    export interface DomainsDataBackendGroup {
        /**
         * Access port number.
         */
        accessPorts: number[];
        /**
         * The details of the source station group.
         */
        backends: outputs.waf.DomainsDataBackendGroupBackend[];
        /**
         * Source station group name. Works only on modified scenes.
         */
        name: string;
    }

    export interface DomainsDataBackendGroupBackend {
        /**
         * Source station IP address.
         */
        ip: string;
        /**
         * The port number corresponding to the listener.
         */
        port: number;
        /**
         * The type of Listener protocol.
         */
        protocol: string;
        /**
         * The weight of the source station rules.
         */
        weight: number;
    }

    export interface DomainsDataCloudAccessConfig {
        /**
         * The access protocol needs to be consistent with the monitoring protocol.
         */
        accessProtocol: string;
        /**
         * The ID of instance.
         */
        instanceId: string;
        /**
         * The ID of listener.
         */
        listenerId: string;
        /**
         * The port number corresponding to the listener.
         */
        port: string;
        /**
         * The type of Listener protocol.
         */
        protocol: string;
    }

    export interface DomainsDataProtocolPorts {
        /**
         * Ports supported by the HTTP protocol.
         */
        http: number[];
        /**
         * Ports supported by the HTTPs protocol.
         */
        https: number[];
    }

    export interface GetAclRulesRule {
        /**
         * Advanced conditions.
         */
        accurateGroup: outputs.waf.GetAclRulesRuleAccurateGroup;
        /**
         * Action to be taken on requests that match the rule.
         */
        action: string;
        /**
         * Whether to set advanced conditions.
         */
        advanced: number;
        /**
         * IP address.
         */
        clientIp: string;
        /**
         * Rule description.
         */
        description: string;
        /**
         * The enabled status of the rule.
         */
        enable: number;
        /**
         * Type of domain name addition.
         */
        hostAddType: number;
        /**
         * The ID of host group.
         */
        hostGroupIds: number[];
        /**
         * The list of domain name groups.
         */
        hostGroups: outputs.waf.GetAclRulesRuleHostGroup[];
        /**
         * Single or multiple domain names are supported.
         */
        hostLists: string[];
        /**
         * Rule ID.
         */
        id: number;
        /**
         * Type of IP address addition.
         */
        ipAddType: number;
        /**
         * The ID of the IP address group.
         */
        ipGroupIds: number[];
        /**
         * The list of domain name groups.
         */
        ipGroups: outputs.waf.GetAclRulesRuleIpGroup[];
        /**
         * Single or multiple IP addresses are supported.
         */
        ipLists: string[];
        /**
         * Country or region code.
         */
        ipLocationCountries: string[];
        /**
         * Domestic region code.
         */
        ipLocationSubregions: string[];
        /**
         * Rule name.
         */
        name: string;
        /**
         * Rule unique identifier, precise search.
         */
        ruleTag: string;
        /**
         * Update time of the rule.
         */
        updateTime: string;
        /**
         * The path of Matching.
         */
        url: string;
    }

    export interface GetAclRulesRuleAccurateGroup {
        /**
         * Details of advanced conditions.
         */
        accurateRules: outputs.waf.GetAclRulesRuleAccurateGroupAccurateRule[];
        /**
         * The logical relationship of advanced conditions.
         */
        logic: number;
    }

    export interface GetAclRulesRuleAccurateGroupAccurateRule {
        /**
         * The HTTP object to be added to the advanced conditions.
         */
        httpObj: string;
        /**
         * The matching field for HTTP objects.
         */
        objType: number;
        /**
         * The logical operator for the condition.
         */
        opretar: number;
        /**
         * Operate the properties of the http object.
         */
        property: number;
        /**
         * The value to be matched.
         */
        valueString: string;
    }

    export interface GetAclRulesRuleHostGroup {
        /**
         * The ID of host group.
         */
        hostGroupId: number;
        /**
         * Rule name.
         */
        name: string;
    }

    export interface GetAclRulesRuleIpGroup {
        /**
         * The ID of the IP address group.
         */
        ipGroupId: number;
        /**
         * Rule name.
         */
        name: string;
    }

    export interface GetBotAnalyseProtectRulesData {
        /**
         * The number of statistical protection rules enabled under the current domain name.
         */
        enableCount: number;
        /**
         * Protective path.
         */
        path: string;
        /**
         * Details of the rule group.
         */
        ruleGroups: outputs.waf.GetBotAnalyseProtectRulesDataRuleGroup[];
        /**
         * The total count of query.
         */
        totalCount: number;
    }

    export interface GetBotAnalyseProtectRulesDataRuleGroup {
        /**
         * Rule group information.
         */
        group: outputs.waf.GetBotAnalyseProtectRulesDataRuleGroupGroup;
        /**
         * Specific rule information within the rule group.
         */
        rules: outputs.waf.GetBotAnalyseProtectRulesDataRuleGroupRule[];
    }

    export interface GetBotAnalyseProtectRulesDataRuleGroupGroup {
        /**
         * After the rule creation is completed, the priority of the automatically generated rule group.
         */
        accurateGroupPriority: number;
        /**
         * Request characteristic information of the rule group.
         */
        accurateRules: outputs.waf.GetBotAnalyseProtectRulesDataRuleGroupGroupAccurateRule[];
        /**
         * Rule unique identifier.
         */
        id: number;
        /**
         * In the rule group, the high-level conditional operation relationships corresponding to each rule.
         */
        logic: number;
    }

    export interface GetBotAnalyseProtectRulesDataRuleGroupGroupAccurateRule {
        /**
         * Custom object.
         */
        httpObj: string;
        /**
         * matching field.
         */
        objType: number;
        /**
         * The logical operator for the condition.
         */
        opretar: number;
        /**
         * Operate the properties of the http object.
         */
        property: number;
        /**
         * The value to be matched.
         */
        valueString: string;
    }

    export interface GetBotAnalyseProtectRulesDataRuleGroupRule {
        /**
         * Advanced conditions.
         */
        accurateGroup: outputs.waf.GetBotAnalyseProtectRulesDataRuleGroupRuleAccurateGroup;
        /**
         * After the rule creation is completed, the priority of the automatically generated rule group.
         */
        accurateGroupPriority: number;
        /**
         * Perform actions after human-machine verification /JS challenges.
         */
        actionAfterVerification: number;
        /**
         * perform the action.
         */
        actionType: number;
        /**
         * Limit the duration.
         */
        effectTime: number;
        /**
         * Whether to enable the rules.
         */
        enable: number;
        /**
         * Exemption time.
         */
        exemptionTime: number;
        /**
         * statistical object.
         */
        field: string;
        /**
         * Website domain names that require the setting of protection rules.
         */
        host: string;
        /**
         * Rule unique identifier.
         */
        id: number;
        /**
         * The name of the rule.
         */
        name: string;
        /**
         * JS challenge/human-machine verification pass rate.
         */
        passRatio: number;
        /**
         * Protective path.
         */
        path: string;
        /**
         * Threshold of path access times.
         */
        pathThreshold: number;
        /**
         * Rule execution priority.
         */
        rulePriority: number;
        /**
         * Unique identification of rules.
         */
        ruleTag: string;
        /**
         * The IP proportion of the same statistical object.
         */
        singleProportion: number;
        /**
         * The maximum number of ips for the same statistical object.
         */
        singleThreshold: number;
        /**
         * The duration of the statistics.
         */
        statisticalDuration: number;
        /**
         * Statistical content method.
         */
        statisticalType: number;
        /**
         * Rule update time.
         */
        updateTime: string;
    }

    export interface GetBotAnalyseProtectRulesDataRuleGroupRuleAccurateGroup {
        /**
         * After the rule creation is completed, the priority of the automatically generated rule group.
         */
        accurateGroupPriority: number;
        /**
         * Request characteristic information of the rule group.
         */
        accurateRules: outputs.waf.GetBotAnalyseProtectRulesDataRuleGroupRuleAccurateGroupAccurateRule[];
        /**
         * Rule unique identifier.
         */
        id: number;
        /**
         * In the rule group, the high-level conditional operation relationships corresponding to each rule.
         */
        logic: number;
    }

    export interface GetBotAnalyseProtectRulesDataRuleGroupRuleAccurateGroupAccurateRule {
        /**
         * Custom object.
         */
        httpObj: string;
        /**
         * matching field.
         */
        objType: number;
        /**
         * The logical operator for the condition.
         */
        opretar: number;
        /**
         * Operate the properties of the http object.
         */
        property: number;
        /**
         * The value to be matched.
         */
        valueString: string;
    }

    export interface GetCcRulesData {
        /**
         * The total number of enabled rules within the rule group.
         */
        enableCount: number;
        /**
         * The creation time of the rule group.
         */
        insertTime: string;
        /**
         * Details of the rule group.
         */
        ruleGroups: outputs.waf.GetCcRulesDataRuleGroup[];
        /**
         * The total count of query.
         */
        totalCount: number;
        /**
         * Fuzzy search by the requested path.
         */
        url: string;
    }

    export interface GetCcRulesDataRuleGroup {
        /**
         * Rule group information.
         */
        group: outputs.waf.GetCcRulesDataRuleGroupGroup;
        /**
         * Specific rule information within the rule group.
         */
        rules: outputs.waf.GetCcRulesDataRuleGroupRule[];
    }

    export interface GetCcRulesDataRuleGroupGroup {
        /**
         * After the rule creation is completed, the priority of the automatically generated rule group.
         */
        accurateGroupPriority: number;
        /**
         * Request characteristic information of the rule group.
         */
        accurateRules: outputs.waf.GetCcRulesDataRuleGroupGroupAccurateRule[];
        /**
         * The ID of Rule group.
         */
        id: number;
        /**
         * In the rule group, the high-level conditional operation relationships corresponding to each rule.
         */
        logic: number;
    }

    export interface GetCcRulesDataRuleGroupGroupAccurateRule {
        /**
         * Custom object.
         */
        httpObj: string;
        /**
         * matching field.
         */
        objType: number;
        /**
         * The logical operator for the condition.
         */
        opretar: number;
        /**
         * Operate the properties of the http object.
         */
        property: number;
        /**
         * The value to be matched.
         */
        valueString: string;
    }

    export interface GetCcRulesDataRuleGroupRule {
        /**
         * Advanced conditions.
         */
        accurateGroup: outputs.waf.GetCcRulesDataRuleGroupRuleAccurateGroup;
        /**
         * After the rule creation is completed, the priority of the automatically generated rule group.
         */
        accurateGroupPriority: number;
        /**
         * The actions performed on subsequent requests after meeting the statistical conditions.
         */
        ccType: number;
        /**
         * The statistical period of the strategy.
         */
        countTime: number;
        /**
         * Details of the periodic loop configuration.
         */
        cronConfs: outputs.waf.GetCcRulesDataRuleGroupRuleCronConf[];
        /**
         * Whether to set the cycle to take effect.
         */
        cronEnable: number;
        /**
         * Limit the duration, that is, the effective duration of the action.
         */
        effectTime: number;
        /**
         * Whether the rule is enabled.
         */
        enable: number;
        /**
         * Strategy exemption time.
         */
        exemptionTime: number;
        /**
         * statistical object.
         */
        field: string;
        /**
         * Website domain names that require the setting of protection rules.
         */
        host: string;
        /**
         * The ID of Rule group.
         */
        id: number;
        /**
         * The Name of Rule group.
         */
        name: string;
        /**
         * The threshold of the number of requests for path access.
         */
        pathThreshold: number;
        /**
         * Rule execution priority.
         */
        rulePriority: number;
        /**
         * Search precisely according to the rule ID.
         */
        ruleTag: string;
        /**
         * The threshold of the number of visits to each statistical object.
         */
        singleThreshold: number;
        /**
         * Rule update time.
         */
        updateTime: string;
        /**
         * Fuzzy search by the requested path.
         */
        url: string;
    }

    export interface GetCcRulesDataRuleGroupRuleAccurateGroup {
        /**
         * After the rule creation is completed, the priority of the automatically generated rule group.
         */
        accurateGroupPriority: number;
        /**
         * Request characteristic information of the rule group.
         */
        accurateRules: outputs.waf.GetCcRulesDataRuleGroupRuleAccurateGroupAccurateRule[];
        /**
         * The ID of Rule group.
         */
        id: number;
        /**
         * In the rule group, the high-level conditional operation relationships corresponding to each rule.
         */
        logic: number;
    }

    export interface GetCcRulesDataRuleGroupRuleAccurateGroupAccurateRule {
        /**
         * Custom object.
         */
        httpObj: string;
        /**
         * matching field.
         */
        objType: number;
        /**
         * The logical operator for the condition.
         */
        opretar: number;
        /**
         * Operate the properties of the http object.
         */
        property: number;
        /**
         * The value to be matched.
         */
        valueString: string;
    }

    export interface GetCcRulesDataRuleGroupRuleCronConf {
        /**
         * The weekly cycle days and cycle time periods.
         */
        crontab: string;
        /**
         * The threshold of the number of requests for path access.
         */
        pathThreshold: number;
        /**
         * The threshold of the number of visits to each statistical object.
         */
        singleThreshold: number;
    }

    export interface GetCustomBotsData {
        /**
         * Advanced conditions.
         */
        accurate: outputs.waf.GetCustomBotsDataAccurate;
        /**
         * The execution action of the Bot.
         */
        action: string;
        /**
         * Whether to set advanced conditions.
         */
        advanced: number;
        /**
         * bot name.
         */
        botType: string;
        /**
         * The description of bot.
         */
        description: string;
        /**
         * Whether to enable bot.
         */
        enable: number;
        /**
         * The actual count bits of the rule unique identifier (corresponding to the RuleTag).
         */
        id: number;
        /**
         * Rule unique identifier.
         */
        ruleTag: string;
        /**
         * The update time.
         */
        updateTime: string;
    }

    export interface GetCustomBotsDataAccurate {
        /**
         * Details of advanced conditions.
         */
        accurateRules: outputs.waf.GetCustomBotsDataAccurateAccurateRule[];
        /**
         * The logical relationship of advanced conditions.
         */
        logic: number;
    }

    export interface GetCustomBotsDataAccurateAccurateRule {
        /**
         * The HTTP object to be added to the advanced conditions.
         */
        httpObj: string;
        /**
         * The matching field for HTTP objects.
         */
        objType: number;
        /**
         * The logical operator for the condition.
         */
        opretar: number;
        /**
         * Operate the properties of the http object.
         */
        property: number;
        /**
         * The value to be matched.
         */
        valueString: string;
    }

    export interface GetCustomPagesData {
        /**
         * Advanced conditions.
         */
        accurate: outputs.waf.GetCustomPagesDataAccurate;
        /**
         * Whether to configure advanced conditions.
         */
        advanced: number;
        /**
         * The layout content of the response page.
         */
        body: string;
        /**
         * Fill in ALL, which means this rule will take effect on all IP addresses.
         */
        clientIp: string;
        /**
         * Custom HTTP code returned when the request is blocked. Required if PageMode=0 or 1.
         */
        code: string;
        /**
         * The layout template of the response page. Required if PageMode=0 or 1.
         */
        contentType: string;
        /**
         * Rule description.
         */
        description: string;
        /**
         * Whether to enable the rule.
         */
        enable: number;
        /**
         * The ID of the advanced conditional rule group.
         */
        groupId: number;
        /**
         * Request header information.
         */
        header: string;
        /**
         * The domain names that need to be viewed.
         */
        host: string;
        /**
         * The ID of rule.
         */
        id: number;
        /**
         * The ID of Region.
         */
        isolationId: string;
        /**
         * Rule name.
         */
        name: string;
        /**
         * The layout template of the response page.
         */
        pageMode: number;
        /**
         * Action to be taken on requests that match the rule.
         */
        policy: number;
        /**
         * The path where users should be redirected.
         */
        redirectUrl: string;
        /**
         * Unique identification of the rules.
         */
        ruleTag: string;
        /**
         * Rule update time.
         */
        updateTime: string;
        /**
         * Match the path.
         */
        url: string;
    }

    export interface GetCustomPagesDataAccurate {
        /**
         * Details of advanced conditions.
         */
        accurateRules: outputs.waf.GetCustomPagesDataAccurateAccurateRule[];
        /**
         * The logical relationship of advanced conditions.
         */
        logic: number;
    }

    export interface GetCustomPagesDataAccurateAccurateRule {
        /**
         * The HTTP object to be added to the advanced conditions.
         */
        httpObj: string;
        /**
         * The matching field for HTTP objects.
         */
        objType: number;
        /**
         * The logical operator for the condition.
         */
        opretar: number;
        /**
         * Operate the properties of the http object.
         */
        property: number;
        /**
         * The value to be matched.
         */
        valueString: string;
    }

    export interface GetDomainsData {
        /**
         * Access mode.
         */
        accessMode: number;
        /**
         * High-defense instance IP.
         */
        advancedDefenseIp: string;
        /**
         * Whether the API protection policy has been enabled.
         */
        apiEnable: number;
        /**
         * The status of the attack.
         */
        attackStatus: number;
        /**
         * Whether to enable the intelligent CC protection strategy.
         */
        autoCcEnable: number;
        /**
         * The configuration of source station.
         */
        backendGroups: outputs.waf.GetDomainsDataBackendGroup[];
        /**
         * Whether the blacklist strategy has been enabled.
         */
        blackIpEnable: number;
        /**
         * Whether the regional ban strategy has been activated.
         */
        blackLctEnable: number;
        /**
         * Whether the cc protection strategy has been enabled.
         */
        ccEnable: number;
        /**
         * When the protocol type is HTTPS, the bound certificate ID needs to be entered.
         */
        certificateId: number;
        /**
         * The name of the certificate.
         */
        certificateName: string;
        /**
         * The method of obtaining the client IP.
         */
        clientIpLocation: number;
        /**
         * The client requests the maximum value of body.
         */
        clientMaxBodySize: number;
        /**
         * Access port information.
         */
        cloudAccessConfigs: outputs.waf.GetDomainsDataCloudAccessConfig[];
        /**
         * The CNAME value generated by the WAF instance.
         */
        cname: string;
        /**
         * Whether the custom Bot classification strategy has been enabled.
         */
        customBotEnable: number;
        /**
         * Custom Header.
         */
        customHeaders: string[];
        /**
         * Whether the custom response interception strategy has been enabled.
         */
        customRspEnable: number;
        /**
         * The protection mode of the instance.
         */
        defenceMode: number;
        /**
         * Whether to activate the strategy for preventing the leakage of sensitive information.
         */
        dlpEnable: number;
        /**
         * The domain name of the protected website that needs to be queried.
         */
        domain: string;
        /**
         * Whether to enable HTTP 2.0.
         */
        enableHttp2: number;
        /**
         * Whether it supports protecting IPv6 requests.
         */
        enableIpv6: number;
        /**
         * The number of long connection multiplexes.
         */
        keepAliveRequest: number;
        /**
         * Long connection retention time.
         */
        keepAliveTimeOut: number;
        /**
         * The types of load balancing algorithms.
         */
        lbAlgorithm: string;
        /**
         * Whether to enable protocol following.
         */
        protocolFollow: number;
        /**
         * Access port information.
         */
        protocolPorts: outputs.waf.GetDomainsDataProtocolPorts;
        /**
         * Access protocol types.
         */
        protocols: string;
        /**
         * Whether to enable proxy configuration.
         */
        proxyConfig: number;
        /**
         * The timeout period for establishing a connection between the WAF and the backend server.
         */
        proxyConnectTimeOut: number;
        /**
         * The number of reusable WAF origin long connections.
         */
        proxyKeepAlive: number;
        /**
         * Idle long connection timeout period.
         */
        proxyKeepAliveTimeOut: number;
        /**
         * The timeout period during which WAF reads the response from the backend server.
         */
        proxyReadTimeOut: number;
        /**
         * The number of retries for WAF back to source.
         */
        proxyRetry: number;
        /**
         * The timeout period during which the WAF transmits the request to the backend server.
         */
        proxyWriteTimeOut: number;
        /**
         * Connect to the source return mode.
         */
        publicRealServer: number;
        /**
         * domain region that need to be protected by WAF.
         */
        region: string;
        /**
         * The IP of the WAF protection instance.
         */
        serverIps: string;
        /**
         * WAF source IP.
         */
        srcIps: string;
        /**
         * Encryption kit.
         */
        sslCiphers: string[];
        /**
         * TLS protocol version.
         */
        sslProtocols: string[];
        /**
         * The status of access.
         */
        status: number;
        /**
         * Whether the managed Bot classification strategy has been enabled.
         */
        systemBotEnable: number;
        /**
         * Whether to enable the page tamper proof policy.
         */
        tamperProofEnable: number;
        /**
         * Whether to enable the log service.
         */
        tlsEnable: number;
        /**
         * The update time.
         */
        updateTime: string;
        /**
         * The ID of vpc.
         */
        vpcId: string;
        /**
         * Whether the vulnerability protection strategy has been enabled.
         */
        wafEnable: number;
        /**
         * Whether to enable the whitening strategy for vulnerability protection requests.
         */
        wafWhiteReqEnable: number;
        /**
         * Whether the whitelist strategy has been enabled.
         */
        whiteEnable: number;
        /**
         * Whether to enable the whitening strategy for vulnerability protection fields.
         */
        whiteFieldEnable: number;
    }

    export interface GetDomainsDataBackendGroup {
        /**
         * Access port number.
         */
        accessPorts: number[];
        /**
         * The details of the source station group.
         */
        backends: outputs.waf.GetDomainsDataBackendGroupBackend[];
        /**
         * Source station group name. Works only on modified scenes.
         */
        name: string;
    }

    export interface GetDomainsDataBackendGroupBackend {
        /**
         * Source station IP address.
         */
        ip: string;
        /**
         * The port number corresponding to the listener.
         */
        port: number;
        /**
         * The type of Listener protocol.
         */
        protocol: string;
        /**
         * The weight of the source station rules.
         */
        weight: number;
    }

    export interface GetDomainsDataCloudAccessConfig {
        /**
         * The access protocol needs to be consistent with the monitoring protocol.
         */
        accessProtocol: string;
        /**
         * The ID of instance.
         */
        instanceId: string;
        /**
         * The ID of listener.
         */
        listenerId: string;
        /**
         * The port number corresponding to the listener.
         */
        port: string;
        /**
         * The type of Listener protocol.
         */
        protocol: string;
    }

    export interface GetDomainsDataProtocolPorts {
        /**
         * Ports supported by the HTTP protocol.
         */
        http: number[];
        /**
         * Ports supported by the HTTPs protocol.
         */
        https: number[];
    }

    export interface GetHostGroupsHostGroupList {
        /**
         * Domain name group description.
         */
        description: string;
        /**
         * The number of domain names contained in the domain name group.
         */
        hostCount: number;
        /**
         * The ID of the domain name group.
         */
        hostGroupId: number;
        /**
         * Domain names that need to be added to this domain name group.
         */
        hostLists: string[];
        /**
         * The name of the domain name group.
         */
        name: string;
        /**
         * The list of associated rules.
         */
        relatedRules: outputs.waf.GetHostGroupsHostGroupListRelatedRule[];
        /**
         * Domain name group update time.
         */
        updateTime: string;
    }

    export interface GetHostGroupsHostGroupListRelatedRule {
        /**
         * The name of the rule.
         */
        ruleName: string;
        /**
         * The rule ID associated with domain name groups.
         */
        ruleTag: string;
        /**
         * The type of the rule.
         */
        ruleType: string;
    }

    export interface GetIpGroupsIpGroupList {
        /**
         * The number of IP addresses within the address group.
         */
        ipCount: number;
        /**
         * The ID of the ip group.
         */
        ipGroupId: number;
        /**
         * The IP address to be added.
         */
        ipLists: string[];
        /**
         * The name of the ip group.
         */
        name: string;
        /**
         * The list of associated rules.
         */
        relatedRules: outputs.waf.GetIpGroupsIpGroupListRelatedRule[];
        /**
         * ip group update time.
         */
        updateTime: string;
    }

    export interface GetIpGroupsIpGroupListRelatedRule {
        /**
         * The information of the protected domain names associated with the rules.
         */
        host: string;
        /**
         * The name of the rule.
         */
        ruleName: string;
        /**
         * Query the association rule ID.
         */
        ruleTag: string;
        /**
         * The type of the rule.
         */
        ruleType: string;
    }

    export interface GetProhibitionsIpAggGroup {
        /**
         * The number of attacks on the source IP of this attack.
         */
        dropCount: number;
        /**
         * Attack source IP.
         */
        ip: string;
        /**
         * Attack type filtering.
         */
        reason: outputs.waf.GetProhibitionsIpAggGroupReason;
        /**
         * Name of the ban rule.
         */
        ruleName: string;
        /**
         * Ban rule ID.
         */
        ruleTag: string;
        /**
         * IP banned status.
         */
        status: number;
        /**
         * Status update time.
         */
        updateTime: string;
    }

    export interface GetProhibitionsIpAggGroupReason {
        /**
         * The number of visits to the blacklist.
         */
        black: number;
        /**
         * The number of Bot attacks.
         */
        bot: number;
        /**
         * The number of geographical location access control.
         */
        geoBlack: number;
        /**
         * The number of CC attacks.
         */
        httpFlood: number;
        /**
         * The number of API parameter exceptions.
         */
        paramAbnormal: number;
        /**
         * The number of API routing exceptions.
         */
        routeAbnormal: number;
        /**
         * The number of times sensitive information is leaked.
         */
        sensitiveInfo: number;
        /**
         * The number of Web vulnerability attacks.
         */
        webVulnerability: number;
    }

    export interface GetServiceCertificatesData {
        /**
         * Associate the domain name of this certificate.
         */
        applicableDomains: string;
        /**
         * The description of the certificate.
         */
        description: string;
        /**
         * The expiration time of the certificate.
         */
        expireTime: string;
        /**
         * The ID of the certificate.
         */
        id: number;
        /**
         * The time when the certificate was added.
         */
        insertTime: string;
        /**
         * The name of the certificate.
         */
        name: string;
    }

    export interface GetSystemBotsData {
        /**
         * The execution action of the Bot.
         */
        action: string;
        /**
         * The name of Bot.
         */
        botType: string;
        /**
         * The description of Bot.
         */
        description: string;
        /**
         * Whether to enable Bot.
         */
        enable: number;
        /**
         * The rule ID corresponding to Bot.
         */
        ruleTag: string;
    }

    export interface HostGroupRelatedRule {
        /**
         * The name of the rule.
         */
        ruleName: string;
        /**
         * The ID of the rule.
         */
        ruleTag: string;
        /**
         * The type of the rule.
         */
        ruleType: string;
    }

    export interface HostGroupsHostGroupList {
        /**
         * Domain name group description.
         */
        description: string;
        /**
         * The number of domain names contained in the domain name group.
         */
        hostCount: number;
        /**
         * The ID of the domain name group.
         */
        hostGroupId: number;
        /**
         * Domain names that need to be added to this domain name group.
         */
        hostLists: string[];
        /**
         * The name of the domain name group.
         */
        name: string;
        /**
         * The list of associated rules.
         */
        relatedRules: outputs.waf.HostGroupsHostGroupListRelatedRule[];
        /**
         * Domain name group update time.
         */
        updateTime: string;
    }

    export interface HostGroupsHostGroupListRelatedRule {
        /**
         * The name of the rule.
         */
        ruleName: string;
        /**
         * The rule ID associated with domain name groups.
         */
        ruleTag: string;
        /**
         * The type of the rule.
         */
        ruleType: string;
    }

    export interface IpGroupRelatedRule {
        /**
         * The information of the protected domain names associated with the rules.
         */
        host: string;
        /**
         * The name of the rule.
         */
        ruleName: string;
        /**
         * The ID of the rule.
         */
        ruleTag: string;
        /**
         * The type of the rule.
         */
        ruleType: string;
    }

    export interface IpGroupsIpGroupList {
        /**
         * The number of IP addresses within the address group.
         */
        ipCount: number;
        /**
         * The ID of the ip group.
         */
        ipGroupId: number;
        /**
         * The IP address to be added.
         */
        ipLists: string[];
        /**
         * The name of the ip group.
         */
        name: string;
        /**
         * The list of associated rules.
         */
        relatedRules: outputs.waf.IpGroupsIpGroupListRelatedRule[];
        /**
         * ip group update time.
         */
        updateTime: string;
    }

    export interface IpGroupsIpGroupListRelatedRule {
        /**
         * The information of the protected domain names associated with the rules.
         */
        host: string;
        /**
         * The name of the rule.
         */
        ruleName: string;
        /**
         * Query the association rule ID.
         */
        ruleTag: string;
        /**
         * The type of the rule.
         */
        ruleType: string;
    }

    export interface ProhibitionsIpAggGroup {
        /**
         * The number of attacks on the source IP of this attack.
         */
        dropCount: number;
        /**
         * Attack source IP.
         */
        ip: string;
        /**
         * Attack type filtering.
         */
        reason: outputs.waf.ProhibitionsIpAggGroupReason;
        /**
         * Name of the ban rule.
         */
        ruleName: string;
        /**
         * Ban rule ID.
         */
        ruleTag: string;
        /**
         * IP banned status.
         */
        status: number;
        /**
         * Status update time.
         */
        updateTime: string;
    }

    export interface ProhibitionsIpAggGroupReason {
        /**
         * The number of visits to the blacklist.
         */
        black: number;
        /**
         * The number of Bot attacks.
         */
        bot: number;
        /**
         * The number of geographical location access control.
         */
        geoBlack: number;
        /**
         * The number of CC attacks.
         */
        httpFlood: number;
        /**
         * The number of API parameter exceptions.
         */
        paramAbnormal: number;
        /**
         * The number of API routing exceptions.
         */
        routeAbnormal: number;
        /**
         * The number of times sensitive information is leaked.
         */
        sensitiveInfo: number;
        /**
         * The number of Web vulnerability attacks.
         */
        webVulnerability: number;
    }

    export interface ServiceCertificatesData {
        /**
         * Associate the domain name of this certificate.
         */
        applicableDomains: string;
        /**
         * The description of the certificate.
         */
        description: string;
        /**
         * The expiration time of the certificate.
         */
        expireTime: string;
        /**
         * The ID of the certificate.
         */
        id: number;
        /**
         * The time when the certificate was added.
         */
        insertTime: string;
        /**
         * The name of the certificate.
         */
        name: string;
    }

    export interface SystemBotsData {
        /**
         * The execution action of the Bot.
         */
        action: string;
        /**
         * The name of Bot.
         */
        botType: string;
        /**
         * The description of Bot.
         */
        description: string;
        /**
         * Whether to enable Bot.
         */
        enable: number;
        /**
         * The rule ID corresponding to Bot.
         */
        ruleTag: string;
    }

    export interface VulnerabilityAdvanceConfig {
        /**
         * Configuration of the automatic blocking capability for directory traversal.
         */
        autoTraversal: outputs.waf.VulnerabilityAdvanceConfigAutoTraversal;
        /**
         * Configuration of high-frequency scanning automatic blocking capability.
         */
        freqScan: outputs.waf.VulnerabilityAdvanceConfigFreqScan;
    }

    export interface VulnerabilityAdvanceConfigAutoTraversal {
        /**
         * Rule switch, controlling whether the current rule takes effect.
         */
        enable?: boolean;
        /**
         * Rule detail.
         */
        rule?: outputs.waf.VulnerabilityAdvanceConfigAutoTraversalRule;
        /**
         * Directory traversal automatically blocks the rule label, that is, the complete rule ID.
         */
        ruleTag?: string;
    }

    export interface VulnerabilityAdvanceConfigAutoTraversalRule {
        /**
         * Disposal action.
         */
        action: number;
        /**
         * Disposal action.
         */
        countTime: number;
        /**
         * Ban time (seconds).
         */
        effectTime: number;
        /**
         * The body records the units displayed at the front end of the length: s, min, hour, and day.
         */
        effectTimeViewUnit: string;
        /**
         * statistical object.
         */
        field: string;
        /**
         * The number of request triggers.
         */
        hitRequestCount: number;
        /**
         * Hit percentage: 0-99.
         */
        responseHttpStatusHitPercent: number;
        /**
         * Response status code.
         */
        responseHttpStatuses: number[];
    }

    export interface VulnerabilityAdvanceConfigFreqScan {
        /**
         * Rule switch, controlling whether the current rule takes effect.
         */
        enable?: boolean;
        /**
         * Rule detail.
         */
        rule?: outputs.waf.VulnerabilityAdvanceConfigFreqScanRule;
        /**
         * Directory traversal automatically blocks the rule label, that is, the complete rule ID.
         */
        ruleTag?: string;
    }

    export interface VulnerabilityAdvanceConfigFreqScanRule {
        /**
         * Disposal action.
         */
        action: number;
        /**
         * Disposal action.
         */
        countTime: number;
        /**
         * Ban time (seconds).
         */
        effectTime: number;
        /**
         * The body records the units displayed at the front end of the length: s, min, hour, and day.
         */
        effectTimeViewUnit: string;
        /**
         * statistical object.
         */
        field: string;
        /**
         * The number of request triggers.
         */
        hitRequestCount: number;
    }

    export interface VulnerabilityRuleDetail {
        /**
         * The accuracy of the rules. Only when updating the custom vulnerability rules.
         */
        accuracy: number;
        /**
         * The ID of CVE. Only when updating the custom vulnerability rules.
         */
        cveId: string;
        /**
         * The description of the rules. Only when updating the custom vulnerability rules.
         */
        description: string;
        /**
         * Risk grade. Only when updating the custom vulnerability rules.
         */
        riskLevel: number;
        /**
         * The name of rule. Only when updating the custom vulnerability rules.
         */
        ruleName: string;
        /**
         * First-level rule category. Only when updating the custom vulnerability rules.
         */
        ruleSetName: string;
        /**
         * Rule label, that is, the complete rule ID. Only when updating the custom vulnerability rules.
         */
        ruleTag: string;
        /**
         * Secondary rule category. Only when updating the custom vulnerability rules.
         */
        subcategory: string;
        /**
         * The update time of the rules. Only when updating the custom vulnerability rules.
         */
        updateTime: string;
    }

    export interface VulnerabilitySystemRuleSwitch {
        /**
         * Custom rule switch.
         */
        customSystemRuleSwitch?: number;
        /**
         * The ID of rule.
         */
        ruleId?: number;
    }

    export interface WafDomainBackendGroup {
        /**
         * Access port number.
         */
        accessPorts: number[];
        /**
         * The details of the source station group.
         */
        backends: outputs.waf.WafDomainBackendGroupBackend[];
        /**
         * Source station group name.
         */
        name: string;
    }

    export interface WafDomainBackendGroupBackend {
        /**
         * Source station IP address.
         */
        ip: string;
        /**
         * Source station port number.
         */
        port: number;
        /**
         * The agreement of Source Station.
         */
        protocol: string;
        /**
         * The weight of the source station rules.
         */
        weight: number;
    }

    export interface WafDomainCloudAccessConfig {
        /**
         * The access protocol needs to be consistent with the monitoring protocol.
         */
        accessProtocol: string;
        /**
         * The ID of instance.
         */
        instanceId: string;
        /**
         * The name of instance. Works only on modified scenes.
         */
        instanceName: string;
        /**
         * The ID of listener.
         */
        listenerId: string;
        /**
         * Whether the instance is unbound from the alb and is unbound on the ALB side. Works only on modified scenes.
         */
        lostAssociationFromAlb: number;
        /**
         * The port number corresponding to the listener.
         */
        port: string;
        /**
         * The type of Listener protocol.
         */
        protocol: string;
    }

    export interface WafDomainExtraDefenceModeLbInstance {
        /**
         * Set the protection mode for exceptional ALB instances. Works only on modified scenes.
         */
        defenceMode?: number;
        /**
         * The Id of ALB instance. Works only on modified scenes.
         */
        instanceId?: string;
    }

    export interface WafDomainProtocolPorts {
        /**
         * Ports supported by the HTTP protocol.
         */
        http: number[];
        /**
         * Ports supported by the HTTPs protocol.
         */
        https: number[];
    }

    export interface WafDomainTlsFieldsConfig {
        /**
         * The configuration of Headers. Works only on modified scenes.
         */
        headersConfig?: outputs.waf.WafDomainTlsFieldsConfigHeadersConfig;
    }

    export interface WafDomainTlsFieldsConfigHeadersConfig {
        /**
         * Whether the log contains this field. Works only on modified scenes.
         */
        enable?: number;
        /**
         * For the use of composite fields, exclude the fields in the keyword list from the JSON of the fields. Works only on modified scenes.
         */
        excludedKeyLists?: string[];
        /**
         * Create statistical indexes for the fields of the list. Works only on modified scenes.
         */
        statisticalKeyLists?: string[];
    }

}
