// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export namespace alb {
    export interface AclAclEntry {
        /**
         * The description of the AclEntry.
         */
        description?: string;
        /**
         * The content of the AclEntry.
         */
        entry: string;
    }

    export interface AclsAcl {
        /**
         * The entries info of acl.
         */
        aclEntries: outputs.alb.AclsAclAclEntry[];
        /**
         * The count of acl entry.
         */
        aclEntryCount: number;
        /**
         * The ID of Acl.
         */
        aclId: string;
        /**
         * The name of acl.
         */
        aclName: string;
        /**
         * Creation time of Acl.
         */
        createTime: string;
        /**
         * The description of Acl.
         */
        description: string;
        /**
         * The ID of Acl.
         */
        id: string;
        /**
         * The listeners of acl.
         */
        listeners: outputs.alb.AclsAclListener[];
        /**
         * The name of project.
         */
        projectName: string;
        /**
         * Update time of Acl.
         */
        updateTime: string;
    }

    export interface AclsAclAclEntry {
        /**
         * The description of Acl.
         */
        description: string;
        /**
         * The info of entry.
         */
        entry: string;
    }

    export interface AclsAclListener {
        /**
         * The type of acl.
         */
        aclType: string;
        /**
         * The ID of Listener.
         */
        listenerId: string;
        /**
         * The Name of Listener.
         */
        listenerName: string;
        /**
         * The port info of listener.
         */
        port: number;
        /**
         * The protocol info of listener.
         */
        protocol: string;
    }

    export interface AlbEipBillingConfig {
        /**
         * The peek bandwidth of the Ipv6 EIP which automatically assigned to the Alb. Unit: Mbps.
         */
        bandwidth: number;
        /**
         * The billing type of the EIP which automatically assigned to the Alb. Valid values: `PostPaidByBandwidth`, `PostPaidByTraffic`.
         */
        eipBillingType: string;
        /**
         * The ISP of the Ipv6 EIP which automatically associated to the Alb, the value can be `BGP`.
         */
        isp: string;
    }

    export interface AlbIpv6EipBillingConfig {
        /**
         * The peek bandwidth of the EIP which automatically assigned to the Alb. Unit: Mbps.
         */
        bandwidth: number;
        /**
         * The billing type of the Tpv6 EIP which automatically assigned to the Alb. Valid values: `PostPaidByBandwidth`, `PostPaidByTraffic`.
         */
        billingType: string;
        /**
         * The ISP of the EIP which automatically associated to the Alb, the value can be `BGP`.
         *
         * The `ipv6EipBillingConfig` object supports the following:
         */
        isp: string;
    }

    export interface AlbTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface AlbZoneMapping {
        /**
         * The IP address information of the Alb in this availability zone.
         */
        loadBalancerAddresses: outputs.alb.AlbZoneMappingLoadBalancerAddress[];
        /**
         * The subnet id of the Alb in this availability zone.
         */
        subnetId: string;
        /**
         * The availability zone id of the Alb.
         */
        zoneId: string;
    }

    export interface AlbZoneMappingLoadBalancerAddress {
        /**
         * The Eip address of the Alb in this availability zone.
         */
        eipAddress: string;
        /**
         * The Eip id of alb instance in this availability zone.
         */
        eipId: string;
        /**
         * The Eni address of the Alb in this availability zone.
         */
        eniAddress: string;
        /**
         * The Eni id of the Alb in this availability zone.
         */
        eniId: string;
        /**
         * The Eni Ipv6 address of the Alb in this availability zone.
         */
        eniIpv6Address: string;
        /**
         * The Ipv6 Eip id of alb instance in this availability zone.
         */
        ipv6EipId: string;
    }

    export interface AlbsAlb {
        /**
         * The access log information of the Alb.
         */
        accessLogs: outputs.alb.AlbsAlbAccessLog[];
        /**
         * The address ip version of the Alb, valid value: `IPv4`, `DualStack`.
         */
        addressIpVersion: string;
        /**
         * The business status of the Alb, valid value:`Normal`, `FinancialLocked`.
         */
        businessStatus: string;
        /**
         * The create time of the Alb.
         */
        createTime: string;
        /**
         * The deletion protection function of the Alb instance is turned on or off.
         */
        deleteProtection: string;
        /**
         * The expected deleted time of the Alb. This parameter has a query value only when the status of the Alb instance is `FinancialLocked`.
         */
        deletedTime: string;
        /**
         * The description of the Alb.
         */
        description: string;
        /**
         * The DNS name.
         */
        dnsName: string;
        /**
         * The health log information of the Alb.
         */
        healthLogs: outputs.alb.AlbsAlbHealthLog[];
        /**
         * The ID of the Alb.
         */
        id: string;
        /**
         * The listener information of the Alb.
         */
        listeners: outputs.alb.AlbsAlbListener[];
        /**
         * The billing type of the Alb.
         */
        loadBalancerBillingType: number;
        /**
         * The ID of the Alb.
         */
        loadBalancerId: string;
        /**
         * The name of the Alb.
         */
        loadBalancerName: string;
        /**
         * The local addresses of the Alb.
         */
        localAddresses: string[];
        /**
         * The reason why Alb is locked. This parameter has a query value only when the status of the Alb instance is `FinancialLocked`.
         */
        lockReason: string;
        /**
         * The overdue time of the Alb. This parameter has a query value only when the status of the Alb instance is `FinancialLocked`.
         */
        overdueTime: string;
        /**
         * The project name of the Alb.
         */
        projectName: string;
        /**
         * The status of the Alb.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.alb.AlbsAlbTag[];
        /**
         * The tls access log information of the Alb.
         */
        tlsAccessLogs: outputs.alb.AlbsAlbTlsAccessLog[];
        /**
         * The type of the Alb, valid value: `public`, `private`.
         */
        type: string;
        /**
         * The update time of the Alb.
         */
        updateTime: string;
        /**
         * The vpc id which Alb belongs to.
         */
        vpcId: string;
        /**
         * Configuration information of the Alb instance in different Availability Zones.
         */
        zoneMappings: outputs.alb.AlbsAlbZoneMapping[];
    }

    export interface AlbsAlbAccessLog {
        /**
         * The bucket name where the logs are stored.
         */
        bucketName: string;
        /**
         * Whether the tls access log function is enabled.
         */
        enabled: boolean;
    }

    export interface AlbsAlbHealthLog {
        /**
         * Whether the tls access log function is enabled.
         */
        enabled: boolean;
        /**
         * The TLS project id bound to the access log.
         */
        projectId: string;
        /**
         * The TLS topic id bound to the access log.
         */
        topicId: string;
    }

    export interface AlbsAlbListener {
        /**
         * The listener id of the Alb.
         */
        listenerId: string;
        /**
         * The listener name of the Alb.
         */
        listenerName: string;
    }

    export interface AlbsAlbTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface AlbsAlbTlsAccessLog {
        /**
         * Whether the tls access log function is enabled.
         */
        enabled: boolean;
        /**
         * The TLS project id bound to the access log.
         */
        projectId: string;
        /**
         * The TLS topic id bound to the access log.
         */
        topicId: string;
    }

    export interface AlbsAlbZoneMapping {
        /**
         * The IP address information of the Alb in this availability zone.
         */
        loadBalancerAddresses: outputs.alb.AlbsAlbZoneMappingLoadBalancerAddress[];
        /**
         * The subnet id of the Alb in this availability zone.
         */
        subnetId: string;
        /**
         * The availability zone id of the Alb.
         */
        zoneId: string;
    }

    export interface AlbsAlbZoneMappingLoadBalancerAddress {
        /**
         * The Eip address of the Alb.
         */
        eipAddress: string;
        /**
         * The Eip id of alb instance in this availability zone.
         */
        eipId: string;
        /**
         * The Eip information of the Alb in this availability zone.
         */
        eips: outputs.alb.AlbsAlbZoneMappingLoadBalancerAddressEip[];
        /**
         * The private ip address of the Alb.
         */
        eniAddress: string;
        /**
         * The Eni id of the Alb in this availability zone.
         */
        eniId: string;
        /**
         * The Eni Ipv6 address of the Alb in this availability zone.
         */
        eniIpv6Address: string;
        /**
         * The Ipv6 Eip id of alb instance in this availability zone.
         */
        ipv6EipId: string;
        /**
         * The Ipv6 Eip information of the Alb in this availability zone.
         */
        ipv6Eips: outputs.alb.AlbsAlbZoneMappingLoadBalancerAddressIpv6Eip[];
    }

    export interface AlbsAlbZoneMappingLoadBalancerAddressEip {
        /**
         * The association mode of the Alb. This parameter has a query value only when the type of the Eip is `anycast`.
         */
        associationMode: string;
        /**
         * The peek bandwidth of the Ipv6 Eip assigned to Alb. Units: Mbps.
         */
        bandwidth: number;
        /**
         * The Eip address of the Alb.
         */
        eipAddress: string;
        /**
         * The billing type of the Eip assigned to Alb. And optional choice contains `PostPaidByBandwidth` or `PostPaidByTraffic`.
         */
        eipBillingType: string;
        /**
         * The Eip type of the Alb.
         */
        eipType: string;
        /**
         * The ISP of the Ipv6 Eip assigned to Alb, the value can be `BGP`.
         */
        isp: string;
        /**
         * The pop locations of the Alb. This parameter has a query value only when the type of the Eip is `anycast`.
         */
        popLocations: outputs.alb.AlbsAlbZoneMappingLoadBalancerAddressEipPopLocation[];
        /**
         * The security protection types of the Alb.
         */
        securityProtectionTypes: string[];
    }

    export interface AlbsAlbZoneMappingLoadBalancerAddressEipPopLocation {
        /**
         * The pop id of the Anycast Eip.
         */
        popId: string;
        /**
         * The pop name of the Anycast Eip.
         */
        popName: string;
    }

    export interface AlbsAlbZoneMappingLoadBalancerAddressIpv6Eip {
        /**
         * The peek bandwidth of the Ipv6 Eip assigned to Alb. Units: Mbps.
         */
        bandwidth: number;
        /**
         * The billing type of the Ipv6 Eip assigned to Alb. And optional choice contains `PostPaidByBandwidth` or `PostPaidByTraffic`.
         */
        billingType: string;
        /**
         * The ISP of the Ipv6 Eip assigned to Alb, the value can be `BGP`.
         */
        isp: string;
    }

    export interface AlbsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface CaCertificatesCertificate {
        /**
         * The ID of the CA certificate.
         */
        caCertificateId: string;
        /**
         * The name of the CA certificate.
         */
        caCertificateName: string;
        /**
         * The type of the CA certificate.
         */
        certificateType: string;
        /**
         * The create time of the CA Certificate.
         */
        createTime: string;
        /**
         * The description of the CA certificate.
         */
        description: string;
        /**
         * The domain name of the CA Certificate.
         */
        domainName: string;
        /**
         * The expire time of the CA Certificate.
         */
        expiredAt: string;
        /**
         * The ID list of the CA Listener.
         */
        listeners: string[];
        /**
         * The project name of the CA certificate.
         */
        projectName: string;
        /**
         * The status of the CA Certificate.
         */
        status: string;
    }

    export interface CertificatesCertificate {
        /**
         * The ID of the Certificate.
         */
        certificateId: string;
        /**
         * The Name of Certificate.
         */
        certificateName: string;
        /**
         * The type of the Certificate.
         */
        certificateType: string;
        /**
         * The create time of the Certificate.
         */
        createTime: string;
        /**
         * The description of the Certificate.
         */
        description: string;
        /**
         * The domain name of the Certificate.
         */
        domainName: string;
        /**
         * The expire time of the Certificate.
         */
        expiredAt: string;
        /**
         * The ID of the Certificate.
         */
        id: string;
        /**
         * The ID list of the Listener.
         */
        listeners: string[];
        /**
         * The ProjectName of the Certificate.
         */
        projectName: string;
        /**
         * The status of the Certificate.
         */
        status: string;
    }

    export interface CustomizedCfgsCfg {
        /**
         * The create time of CustomizedCfg.
         */
        createTime: string;
        /**
         * The content of CustomizedCfg.
         */
        customizedCfgContent: string;
        /**
         * The ID of CustomizedCfg.
         */
        customizedCfgId: string;
        /**
         * The name of the CustomizedCfg.
         */
        customizedCfgName: string;
        /**
         * The description of CustomizedCfg.
         */
        description: string;
        /**
         * The ID of CustomizedCfg.
         */
        id: string;
        /**
         * The listeners of CustomizedCfg.
         */
        listeners: outputs.alb.CustomizedCfgsCfgListener[];
        /**
         * The project name of the CustomizedCfg.
         */
        projectName: string;
        /**
         * The status of CustomizedCfg.
         */
        status: string;
        /**
         * The update time of CustomizedCfg.
         */
        updateTime: string;
    }

    export interface CustomizedCfgsCfgListener {
        /**
         * The id of the listener.
         */
        listenerId: string;
        /**
         * The Name of Listener.
         */
        listenerName: string;
        /**
         * The port info of listener.
         */
        port: number;
        /**
         * The protocol info of listener.
         */
        protocol: string;
    }

    export interface HealthCheckTemplatesHealthCheckTemplate {
        /**
         * The description of health check template.
         */
        description: string;
        /**
         * The domain name to health check.
         */
        healthCheckDomain: string;
        /**
         * The normal HTTP status code for health check, the default is http_2xx, http_3xx, separated by commas.
         */
        healthCheckHttpCode: string;
        /**
         * The HTTP version of health check.
         */
        healthCheckHttpVersion: string;
        /**
         * The interval for performing health checks, the default value is 2, and the value is 1-300.
         */
        healthCheckInterval: number;
        /**
         * The health check method,default is `GET`,support `GET` and ``HEAD.
         */
        healthCheckMethod: string;
        /**
         * The protocol of health check,only support HTTP.
         */
        healthCheckProtocol: string;
        /**
         * The ID of health check template.
         */
        healthCheckTemplateId: string;
        /**
         * The name of health check template to query.
         */
        healthCheckTemplateName: string;
        /**
         * The timeout of health check response,the default value is 2, and the value is 1-60.
         */
        healthCheckTimeout: number;
        /**
         * The uri to health check,default is `/`.
         */
        healthCheckUri: string;
        /**
         * The healthy threshold of the health check, the default is 3, the value is 2-10.
         */
        healthyThreshold: number;
        /**
         * The id of the health check template.
         */
        id: string;
        /**
         * The unhealthy threshold of the health check, the default is 3, the value is 2-10.
         */
        unhealthyThreshold: number;
    }

    export interface ListenerDomainExtensionsDomainExtension {
        /**
         * The server certificate ID that domain used.
         */
        certificateId: string;
        /**
         * The domain.
         */
        domain: string;
        /**
         * The extension domain ID.
         */
        domainExtensionId: string;
        /**
         * The ID of the Listener.
         */
        id: string;
        /**
         * A Listener ID.
         */
        listenerId: string;
    }

    export interface ListenersListener {
        /**
         * The ID of the access control policy group bound to the listener, only returned when the AclStatus parameter is on.
         */
        aclIds: string[];
        /**
         * Whether to enable the access control function,valid value is on or off.
         */
        aclStatus: string;
        /**
         * The access control type.
         */
        aclType: string;
        /**
         * CA certificate ID associated with HTTPS listener.
         */
        caCertificateId: string;
        /**
         * The server certificate ID that domain used.
         */
        certificateId: string;
        /**
         * The create time of the Listener.
         */
        createTime: string;
        /**
         * The customized configuration ID, the value is empty string when not bound.
         */
        customizedCfgId: string;
        /**
         * The description of listener.
         */
        description: string;
        /**
         * The HTTPS listener association list of extension domains for.
         */
        domainExtensions: outputs.alb.ListenersListenerDomainExtension[];
        /**
         * The HTTP2 feature switch,valid value is on or off.
         */
        enableHttp2: string;
        /**
         * The QUIC feature switch,valid value is on or off.
         */
        enableQuic: string;
        /**
         * The enable status of the Listener.
         */
        enabled: string;
        /**
         * The ID of the Listener.
         */
        id: string;
        /**
         * The ID of the Listener.
         */
        listenerId: string;
        /**
         * The name of the Listener.
         */
        listenerName: string;
        /**
         * The id of the Alb.
         */
        loadBalancerId: string;
        /**
         * The port receiving request of the Listener.
         */
        port: number;
        /**
         * The project name of the listener.
         */
        projectName: string;
        /**
         * The protocol of the Listener.
         */
        protocol: string;
        /**
         * The ID of server group.
         */
        serverGroupId: string;
        /**
         * The list of server groups with associated listeners.
         */
        serverGroups: outputs.alb.ListenersListenerServerGroup[];
        /**
         * The status of the Listener.
         */
        status: string;
        /**
         * The update time of the Listener.
         */
        updateTime: string;
    }

    export interface ListenersListenerDomainExtension {
        /**
         * The server certificate ID that domain used.
         */
        certificateId: string;
        /**
         * The domain.
         */
        domain: string;
        /**
         * The extension domain ID.
         */
        domainExtensionId: string;
        /**
         * The ID of the Listener.
         */
        listenerId: string;
    }

    export interface ListenersListenerServerGroup {
        /**
         * The ID of server group.
         */
        serverGroupId: string;
        /**
         * The name of server group.
         */
        serverGroupName: string;
    }

    export interface RuleRedirectConfig {
        /**
         * The redirect domain, only support exact domain name.
         */
        redirectDomain: string;
        /**
         * The redirect http code, support 301(default), 302, 307, 308.
         */
        redirectHttpCode?: string;
        /**
         * The redirect port.
         */
        redirectPort: string;
        /**
         * The redirect protocol, support HTTP, HTTPS(default).
         */
        redirectProtocol?: string;
        /**
         * The redirect URI.
         */
        redirectUri: string;
    }

    export interface RuleRewriteConfig {
        /**
         * Rewrite path.
         */
        rewritePath: string;
    }

    export interface RulesRule {
        /**
         * The Description of Rule.
         */
        description: string;
        /**
         * The Domain of Rule.
         */
        domain: string;
        /**
         * The Id of Rule.
         */
        id: string;
        /**
         * Redirect related configuration.
         */
        redirectConfigs: outputs.alb.RulesRuleRedirectConfig[];
        /**
         * The list of rewrite configurations.
         */
        rewriteConfigs: outputs.alb.RulesRuleRewriteConfig[];
        /**
         * Rewrite configuration switch for forwarding rules, only allows configuration and takes effect when RuleAction is empty (i.e., forwarding to server group). Only available for whitelist users, please submit an application to experience. Supported values are as follows:
         * on: enable.
         * off: disable.
         */
        rewriteEnabled: string;
        /**
         * The forwarding rule action, if this parameter is empty, forward to server group, if value is `Redirect`, will redirect.
         */
        ruleAction: string;
        /**
         * The Id of Rule.
         */
        ruleId: string;
        /**
         * The Id of Server Group.
         */
        serverGroupId: string;
        /**
         * Forwarding rule QPS rate limiting switch:
         * on: enable.
         * off: disable (default).
         */
        trafficLimitEnabled: string;
        /**
         * When Rules.N.TrafficLimitEnabled is turned on, this field is required. Requests per second. Valid values are between 100 and 100000.
         */
        trafficLimitQps: number;
        /**
         * The Url of Rule.
         */
        url: string;
    }

    export interface RulesRuleRedirectConfig {
        /**
         * The redirect domain.
         */
        redirectDomain: string;
        /**
         * The redirect HTTP code,support 301(default), 302, 307, 308.
         */
        redirectHttpCode: string;
        /**
         * The redirect port.
         */
        redirectPort: string;
        /**
         * The redirect protocol,support HTTP,HTTPS(default).
         */
        redirectProtocol: string;
        /**
         * The redirect URI.
         */
        redirectUri: string;
    }

    export interface RulesRuleRewriteConfig {
        /**
         * Rewrite path.
         */
        rewritePath: string;
    }

    export interface ServerGroupHealthCheck {
        /**
         * The domain of health check.
         */
        domain: string;
        /**
         * The enable status of health check function. Valid values: `on`, `off`. Default is `on`.
         */
        enabled?: string;
        /**
         * The healthy threshold of health check. Valid value range in 2~10. Default is 3.
         */
        healthyThreshold?: number;
        /**
         * The normal http status code of health check, the value can be `http2xx` or `http3xx` or `http4xx` or `http5xx`.
         */
        httpCode: string;
        /**
         * The http version of health check. Valid values: `HTTP1.0`, `HTTP1.1`. Default is `HTTP1.0`.
         */
        httpVersion?: string;
        /**
         * The interval executing health check. Unit: second. Valid value range in 1~300. Default is 2.
         */
        interval?: number;
        /**
         * The method of health check. Valid values: `GET` or `HEAD`. Default is `HEAD`.
         */
        method?: string;
        /**
         * The response timeout of health check. Unit: second. Valid value range in 1~60. Default is 2.
         */
        timeout?: number;
        /**
         * The unhealthy threshold of health check. Valid value range in 2~10. Default is 3.
         */
        unhealthyThreshold?: number;
        /**
         * The uri of health check.
         */
        uri: string;
    }

    export interface ServerGroupServersServer {
        /**
         * The description of the instance.
         */
        description: string;
        /**
         * The server id of instance in ServerGroup.
         */
        id: string;
        /**
         * The ID of ecs instance or the network card bound to ecs instance.
         */
        instanceId: string;
        /**
         * The private ip of the instance.
         */
        ip: string;
        /**
         * The port receiving request.
         */
        port: number;
        /**
         * The server id of instance in ServerGroup.
         */
        serverId: string;
        /**
         * The type of instance. Optional choice contains `ecs`, `eni`.
         */
        type: string;
        /**
         * The weight of the instance.
         */
        weight: number;
    }

    export interface ServerGroupStickySessionConfig {
        /**
         * The cookie name of the sticky session. This field is required when the value of the `stickySessionType` is `server`.
         */
        cookie: string;
        /**
         * The cookie timeout of the sticky session. Unit: second. Valid value range in 1~86400. Default is 1000. This field is required when the value of the `stickySessionType` is `insert`.
         */
        cookieTimeout?: number;
        /**
         * The enable status of sticky session. Valid values: `on`, `off`. Default is `off`.
         */
        stickySessionEnabled?: string;
        /**
         * The cookie handle type of the sticky session. Valid values: `insert`, `server`. Default is `insert`. This field is required when the value of the `stickySessionEnabled` is `on`.
         */
        stickySessionType?: string;
    }

    export interface ServerGroupsServerGroup {
        /**
         * The create time of the Alb server group.
         */
        createTime: string;
        /**
         * The description of the server group server.
         */
        description: string;
        /**
         * The health check config of the Alb server group.
         */
        healthChecks: outputs.alb.ServerGroupsServerGroupHealthCheck[];
        /**
         * The ID of the Alb server group.
         */
        id: string;
        /**
         * The listener information of the Alb server group.
         */
        listeners: string[];
        /**
         * The project name of Alb server group.
         */
        projectName: string;
        /**
         * The scheduler algorithm of the Alb server group.
         */
        scheduler: string;
        /**
         * The server count of the Alb server group.
         */
        serverCount: number;
        /**
         * The ID of the Alb server group.
         */
        serverGroupId: string;
        /**
         * The name of the Alb server group.
         */
        serverGroupName: string;
        /**
         * The type of Alb server group. Valid values: `instance`, `ip`.
         */
        serverGroupType: string;
        /**
         * The server information of the Alb server group.
         */
        servers: outputs.alb.ServerGroupsServerGroupServer[];
        /**
         * The status of the Alb server group.
         */
        status: string;
        /**
         * The sticky session config of the Alb server group.
         */
        stickySessionConfigs: outputs.alb.ServerGroupsServerGroupStickySessionConfig[];
        /**
         * The update time of the Alb server group.
         */
        updateTime: string;
        /**
         * The vpc id of the Alb server group.
         */
        vpcId: string;
    }

    export interface ServerGroupsServerGroupHealthCheck {
        /**
         * The domain of health check.
         */
        domain: string;
        /**
         * The enable status of health check function.
         */
        enabled: string;
        /**
         * The healthy threshold of health check.
         */
        healthyThreshold: number;
        httpCode?: string;
        httpVersion?: string;
        /**
         * The interval executing health check.
         */
        interval: number;
        /**
         * The method of health check.
         */
        method: string;
        protocol?: string;
        timeout?: number;
        /**
         * The unhealthy threshold of health check.
         */
        unhealthyThreshold: number;
        /**
         * The uri of health check.
         */
        uri: string;
    }

    export interface ServerGroupsServerGroupServer {
        /**
         * The description of the server group server.
         */
        description: string;
        /**
         * The id of the ecs instance or the network interface.
         */
        instanceId: string;
        /**
         * The private ip of the server group server.
         */
        ip: string;
        /**
         * The port receiving request of the server group server.
         */
        port: number;
        /**
         * Whether to enable the remote IP function.
         */
        remoteEnabled: string;
        /**
         * The id of the server group server.
         */
        serverId: string;
        /**
         * The type of the server group server.
         */
        type: string;
        /**
         * The weight of the server group server.
         */
        weight: number;
    }

    export interface ServerGroupsServerGroupStickySessionConfig {
        /**
         * The cookie name of the sticky session.
         */
        cookie: string;
        /**
         * The cookie timeout of the sticky session.
         */
        cookieTimeout: number;
        /**
         * The enable status of sticky session.
         */
        stickySessionEnabled: string;
        /**
         * The cookie handle type of the sticky session.
         */
        stickySessionType: string;
    }

    export interface ZonesZone {
        /**
         * The id of the zone.
         */
        id: string;
        /**
         * The id of the zone.
         */
        zoneId: string;
    }

}

export namespace autoscaling {
    export interface ScalingActivitiesActivity {
        /**
         * The Actual Type.
         */
        activityType: string;
        /**
         * The Actual Adjustment Instance Number.
         */
        actualAdjustInstanceNumber: number;
        /**
         * The Cooldown time.
         */
        cooldown: number;
        /**
         * The create time of Scaling Activity.
         */
        createdAt: string;
        /**
         * The Current Instance Number.
         */
        currentInstanceNumber: number;
        /**
         * The expected run time of Scaling Activity.
         */
        expectedRunTime: string;
        /**
         * The ID of Scaling Activity.
         */
        id: string;
        /**
         * The Max Instance Number.
         */
        maxInstanceNumber: number;
        /**
         * The Min Instance Number.
         */
        minInstanceNumber: number;
        /**
         * The related instances.
         */
        relatedInstances: outputs.autoscaling.ScalingActivitiesActivityRelatedInstance[];
        /**
         * The Result of Scaling Activity.
         */
        resultMsg: string;
        /**
         * The ID of Scaling Activity.
         */
        scalingActivityId: string;
        /**
         * A Id of Scaling Group.
         */
        scalingGroupId: string;
        /**
         * A status code of Scaling Activity. Valid values: Init, Running, Success, PartialSuccess, Error, Rejected, Exception.
         */
        statusCode: string;
        /**
         * The stopped time of Scaling Activity.
         */
        stoppedAt: string;
        /**
         * The task category of Scaling Activity.
         */
        taskCategory: string;
    }

    export interface ScalingActivitiesActivityRelatedInstance {
        /**
         * The Instance ID.
         */
        instanceId: string;
        /**
         * The message of Instance.
         */
        message: string;
        /**
         * The Operation Type.
         */
        operateType: string;
        /**
         * The Status.
         */
        status: string;
    }

    export interface ScalingConfigurationTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface ScalingConfigurationVolume {
        /**
         * The delete with instance flag of volume. Valid values: true, false. Default value: true.
         */
        deleteWithInstance?: boolean;
        /**
         * The size of volume. System disk value range: 10 - 500. The value range of the data disk: 10 - 8192.
         */
        size: number;
        /**
         * The type of volume.
         */
        volumeType: string;
    }

    export interface ScalingConfigurationsScalingConfiguration {
        /**
         * The create time of the scaling configuration.
         */
        createdAt: string;
        /**
         * The EIP bandwidth which the scaling configuration set.
         */
        eipBandwidth: number;
        /**
         * The EIP ISP which the scaling configuration set.
         */
        eipBillingType: string;
        /**
         * The EIP ISP which the scaling configuration set.
         */
        eipIsp: string;
        /**
         * The ECS hostname which the scaling configuration set.
         */
        hostName: string;
        /**
         * The ID of the HPC cluster to which the instance belongs. Valid only when InstanceTypes.N specifies High Performance Computing GPU Type.
         */
        hpcClusterId: string;
        /**
         * The id of the scaling configuration.
         */
        id: string;
        /**
         * The ECS image id which the scaling configuration set.
         */
        imageId: string;
        /**
         * The ECS instance description which the scaling configuration set.
         */
        instanceDescription: string;
        /**
         * The ECS instance name which the scaling configuration set.
         */
        instanceName: string;
        /**
         * The list of the ECS instance type which the scaling configuration set.
         */
        instanceTypes: string[];
        /**
         * Assign IPv6 address to instance network card. Possible values:
         * 0: Do not assign IPv6 address.
         * 1: Assign IPv6 address and the system will automatically assign an IPv6 subnet for you.
         */
        ipv6AddressCount: number;
        /**
         * The ECS key pair name which the scaling configuration set.
         */
        keyPairName: string;
        /**
         * The lifecycle state of the scaling configuration.
         */
        lifecycleState: string;
        /**
         * The project to which the instance created by the scaling configuration belongs.
         */
        projectName: string;
        /**
         * The id of the scaling configuration.
         */
        scalingConfigurationId: string;
        /**
         * The name of the scaling configuration.
         */
        scalingConfigurationName: string;
        /**
         * An id of scaling group.
         */
        scalingGroupId: string;
        /**
         * The Ecs security enhancement strategy which the scaling configuration set.
         */
        securityEnhancementStrategy: string;
        /**
         * The list of the security group id of the networkInterface which the scaling configuration set.
         */
        securityGroupIds: string[];
        /**
         * The preemption policy of the instance. Valid Value: NoSpot (default), SpotAsPriceGo.
         */
        spotStrategy: string;
        /**
         * The label of the instance created by the scaling configuration.
         */
        tags: outputs.autoscaling.ScalingConfigurationsScalingConfigurationTag[];
        /**
         * The create time of the scaling configuration.
         */
        updatedAt: string;
        /**
         * The ECS user data which the scaling configuration set.
         */
        userData: string;
        /**
         * The list of volume of the scaling configuration.
         */
        volumes: outputs.autoscaling.ScalingConfigurationsScalingConfigurationVolume[];
    }

    export interface ScalingConfigurationsScalingConfigurationTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface ScalingConfigurationsScalingConfigurationVolume {
        /**
         * The delete with instance flag of volume.
         */
        deleteWithInstance: boolean;
        /**
         * The size of volume.
         */
        size: number;
        /**
         * The type of volume.
         */
        volumeType: string;
    }

    export interface ScalingGroupLaunchTemplateOverride {
        /**
         * The instance type.
         */
        instanceType: string;
    }

    export interface ScalingGroupServerGroupAttribute {
        loadBalancerId: string;
        /**
         * The port receiving request of the server group. Value range: 1 ~ 65535.
         */
        port: number;
        /**
         * The id of the server group.
         */
        serverGroupId: string;
        /**
         * The weight of the instance. Value range: 0 ~ 100.
         */
        weight: number;
    }

    export interface ScalingGroupTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface ScalingGroupsScalingGroup {
        /**
         * The scaling configuration id which used by the scaling group.
         */
        activeScalingConfigurationId: string;
        /**
         * The create time of the scaling group.
         */
        createdAt: string;
        /**
         * The list of db instance ids.
         */
        dbInstanceIds: string[];
        /**
         * The default cooldown interval of the scaling group.
         */
        defaultCooldown: number;
        /**
         * The desire instance number of the scaling group.
         */
        desireInstanceNumber: number;
        /**
         * The health check type of the scaling group.
         */
        healthCheckType: string;
        /**
         * The id of the scaling group.
         */
        id: string;
        /**
         * The instance terminate policy of the scaling group.
         */
        instanceTerminatePolicy: string;
        /**
         * The ID of the launch template bound to the scaling group.
         */
        launchTemplateId: string;
        /**
         * Instance start template information.
         */
        launchTemplateOverrides: outputs.autoscaling.ScalingGroupsScalingGroupLaunchTemplateOverride[];
        /**
         * The version of the launch template bound to the scaling group.
         */
        launchTemplateVersion: string;
        /**
         * The lifecycle state of the scaling group.
         */
        lifecycleState: string;
        /**
         * Grace period for health check of CLB instance in elastic group.
         */
        loadBalancerHealthCheckGracePeriod: number;
        /**
         * The max instance number of the scaling group.
         */
        maxInstanceNumber: number;
        /**
         * The min instance number of the scaling group.
         */
        minInstanceNumber: number;
        /**
         * The multi az policy of the scaling group. Valid values: PRIORITY, BALANCE.
         */
        multiAzPolicy: string;
        /**
         * The project name of the scaling group.
         */
        projectName: string;
        /**
         * The id of the scaling group.
         */
        scalingGroupId: string;
        /**
         * The name of the scaling group.
         */
        scalingGroupName: string;
        /**
         * The scaling mode of the scaling group.
         */
        scalingMode: string;
        /**
         * The list of server group attributes.
         */
        serverGroupAttributes: outputs.autoscaling.ScalingGroupsScalingGroupServerGroupAttribute[];
        /**
         * The number of stopped instances.
         */
        stoppedInstanceCount: number;
        /**
         * The list of the subnet id to which the ENI is connected.
         */
        subnetIds: string[];
        /**
         * Tags.
         */
        tags: outputs.autoscaling.ScalingGroupsScalingGroupTag[];
        /**
         * The total instance count of the scaling group.
         */
        totalInstanceCount: number;
        /**
         * The create time of the scaling group.
         */
        updatedAt: string;
        /**
         * The VPC id of the scaling group.
         */
        vpcId: string;
    }

    export interface ScalingGroupsScalingGroupLaunchTemplateOverride {
        /**
         * The instance type.
         */
        instanceType: string;
        /**
         * Weight of instance specifications.
         */
        weightedCapacity: number;
    }

    export interface ScalingGroupsScalingGroupServerGroupAttribute {
        /**
         * The load balancer id.
         */
        loadBalancerId: string;
        /**
         * The port receiving request of the server group.
         */
        port: number;
        /**
         * The server group id.
         */
        serverGroupId: string;
        /**
         * The weight of the instance.
         */
        weight: number;
    }

    export interface ScalingGroupsScalingGroupTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface ScalingInstancesScalingInstance {
        /**
         * The time when the instance was added to the scaling group.
         */
        createdTime: string;
        /**
         * The creation type of the instances. Valid values: AutoCreated, Attached.
         */
        creationType: string;
        /**
         * Whether to host the instance to a scaling group.
         */
        entrusted: boolean;
        /**
         * The id of the scaling instance.
         */
        id: string;
        /**
         * The id of the scaling instance.
         */
        instanceId: string;
        /**
         * The id of the scaling configuration id.
         */
        scalingConfigurationId: string;
        /**
         * The id of the scaling group.
         */
        scalingGroupId: string;
        /**
         * The id of the scaling policy.
         */
        scalingPolicyId: string;
        /**
         * The status of instances. Valid values: Init, Pending, Pending:Wait, InService, Error, Removing, Removing:Wait, Stopped, Protected.
         */
        status: string;
    }

    export interface ScalingLifecycleHookLifecycleCommand {
        /**
         * Batch job command ID, which indicates the batch job command to be executed after triggering the lifecycle hook and installed in the instance.
         */
        commandId: string;
        /**
         * Parameters and parameter values in batch job commands.
         * The number of parameters ranges from 0 to 60.
         */
        parameters?: string;
    }

    export interface ScalingLifecycleHooksLifecycleHook {
        /**
         * The id of the lifecycle hook.
         */
        id: string;
        /**
         * Batch job command.
         */
        lifecycleCommands: outputs.autoscaling.ScalingLifecycleHooksLifecycleHookLifecycleCommand[];
        /**
         * The id of the lifecycle hook.
         */
        lifecycleHookId: string;
        /**
         * The name of the lifecycle hook.
         */
        lifecycleHookName: string;
        /**
         * The policy of the lifecycle hook.
         */
        lifecycleHookPolicy: string;
        /**
         * The timeout of the lifecycle hook.
         */
        lifecycleHookTimeout: number;
        /**
         * The type of the lifecycle hook.
         */
        lifecycleHookType: string;
        /**
         * An id of scaling group id.
         */
        scalingGroupId: string;
    }

    export interface ScalingLifecycleHooksLifecycleHookLifecycleCommand {
        /**
         * Batch job command ID, which indicates the batch job command to be executed after triggering the lifecycle hook and installed in the instance.
         */
        commandId: string;
        /**
         * Parameters and parameter values in batch job commands.
         * The number of parameters ranges from 0 to 60.
         */
        parameters: string;
    }

    export interface ScalingPoliciesScalingPolicy {
        /**
         * The adjustment type of the scaling policy.
         */
        adjustmentType: string;
        /**
         * The adjustment value of the scaling policy.
         */
        adjustmentValue: number;
        /**
         * The comparison operator of the alarm policy condition of the scaling policy.
         */
        alarmPolicyConditionComparisonOperator: string;
        /**
         * The metric name of the alarm policy condition of the scaling policy.
         */
        alarmPolicyConditionMetricName: string;
        /**
         * The comparison operator of the alarm policy condition of the scaling policy.
         */
        alarmPolicyConditionMetricUnit: string;
        /**
         * The threshold of the alarm policy condition of the scaling policy.
         */
        alarmPolicyConditionThreshold: string;
        /**
         * The evaluation count of the alarm policy of the scaling policy.
         */
        alarmPolicyEvaluationCount: number;
        /**
         * The rule type of the alarm policy of the scaling policy.
         */
        alarmPolicyRuleType: string;
        /**
         * The cooldown of the scaling policy.
         */
        cooldown: number;
        /**
         * The id of the scaling policy.
         */
        id: string;
        /**
         * An id of the scaling group to which the scaling policy belongs.
         */
        scalingGroupId: string;
        /**
         * The id of the scaling policy.
         */
        scalingPolicyId: string;
        /**
         * The name of the scaling policy.
         */
        scalingPolicyName: string;
        /**
         * A type of scaling policy. Valid values: Scheduled, Recurrence, Manual, Alarm.
         */
        scalingPolicyType: string;
        /**
         * The launch time of the scheduled policy of the scaling policy.
         */
        scheduledPolicyLaunchTime: string;
        /**
         * The recurrence end time of the scheduled policy of the scaling policy.
         */
        scheduledPolicyRecurrenceEndTime: string;
        /**
         * The recurrence start time of the scheduled policy of the scaling policy.
         */
        scheduledPolicyRecurrenceStartTime: string;
        /**
         * The recurrence type of the scheduled policy of the scaling policy.
         */
        scheduledPolicyRecurrenceType: string;
        /**
         * The recurrence value of the scheduled policy of the scaling policy.
         */
        scheduledPolicyRecurrenceValue: string;
        /**
         * The status of the scaling policy.
         */
        status: string;
    }

}

export namespace bandwidth_package {
    export interface BandwidthPackageTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface BandwidthPackagesPackage {
        /**
         * The bandwidth of the bandwidth package.
         */
        bandwidth: number;
        /**
         * The id of the bandwidth package.
         */
        bandwidthPackageId: string;
        /**
         * Shared bandwidth package name to be queried.
         */
        bandwidthPackageName: string;
        /**
         * The billing type of the bandwidth package.
         */
        billingType: string;
        /**
         * The business status of the bandwidth package.
         */
        businessStatus: string;
        /**
         * The creation time of the bandwidth package.
         */
        creationTime: string;
        /**
         * The deleted time of the bandwidth package.
         */
        deletedTime: string;
        /**
         * List of public IP information included in the shared bandwidth package.
         */
        eipAddresses: outputs.bandwidth_package.BandwidthPackagesPackageEipAddress[];
        /**
         * The expiration time of the bandwidth package.
         */
        expiredTime: string;
        /**
         * The id of the bandwidth package.
         */
        id: string;
        /**
         * Line types for shared bandwidth packages.
         */
        isp: string;
        /**
         * The overdue time of the bandwidth package.
         */
        overdueTime: string;
        /**
         * The project name of the bandwidth package to be queried.
         */
        projectName: string;
        /**
         * The IP protocol values for shared bandwidth packages are as follows: `IPv4`: IPv4 protocol. `IPv6`: IPv6 protocol.
         */
        protocol: string;
        /**
         * Security protection types for shared bandwidth packages. Parameter - N: Indicates the number of security protection types, currently only supports taking 1. Value: `AntiDDoS_Enhanced`.
         */
        securityProtectionTypes: string[];
        /**
         * The status of the bandwidth package.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.bandwidth_package.BandwidthPackagesPackageTag[];
        /**
         * The update time of the bandwidth package.
         */
        updateTime: string;
    }

    export interface BandwidthPackagesPackageEipAddress {
        /**
         * The id of the eip.
         */
        allocationId: string;
        /**
         * The eip address.
         */
        eipAddress: string;
    }

    export interface BandwidthPackagesPackageTag {
        /**
         * The key of the tag.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface BandwidthPackagesTagFilter {
        /**
         * The key of the tag.
         */
        key: string;
        /**
         * The values of the tag.
         */
        values: string[];
    }

}

export namespace bioos {
    export interface ClusterSharedConfig {
        /**
         * Whether to enable a shared cluster. This value must be `true`.
         */
        enable: boolean;
    }

    export interface ClusterVkeConfig {
        /**
         * The id of the vke cluster.
         */
        clusterId: string;
        /**
         * The name of the StorageClass that the vke cluster has installed.
         */
        storageClass: string;
    }

    export interface ClustersItem {
        /**
         * Whether there is a bound workspace.
         */
        bound: boolean;
        /**
         * The description of the cluster.
         */
        description: string;
        /**
         * The id of the bioos cluster.
         */
        id: string;
        /**
         * The name of the cluster.
         */
        name: string;
        /**
         * whether it is a public cluster.
         */
        public: boolean;
        /**
         * The configuration of the shared cluster.
         */
        sharedConfigs: outputs.bioos.ClustersItemSharedConfig[];
        /**
         * The start time of the cluster.
         */
        startTime: number;
        /**
         * The status of the clusters.
         */
        status: string;
        /**
         * The end time of the cluster.
         */
        stoppedTime: number;
        /**
         * The id of the vke cluster.
         */
        vkeConfigId: string;
        /**
         * The name of the StorageClass that the vke cluster has installed.
         */
        vkeConfigStorageClass: string;
    }

    export interface ClustersItemSharedConfig {
        /**
         * Whether to enable a shared cluster. This value must be `true`.
         */
        enable: boolean;
    }

    export interface WorkspacesItem {
        /**
         * The URL of the cover.
         */
        coverDownloadUrl: string;
        /**
         * The creation time of the workspace.
         */
        createTime: number;
        /**
         * The description of the workspace.
         */
        description: string;
        /**
         * The id of the workspace.
         */
        id: string;
        /**
         * The name of the workspace.
         */
        name: string;
        /**
         * The name of the owner of the workspace.
         */
        ownerName: string;
        /**
         * The role of the user.
         */
        role: string;
        /**
         * S3 bucket address.
         */
        s3Bucket: string;
        /**
         * The update time of the workspace.
         */
        updateTime: number;
    }

}

export namespace cdn {
    export interface CdnDomainSharedCname {
        /**
         * Assign a CNAME to the accelerated domain.
         */
        cname: string;
        /**
         * Specify whether to enable shared CNAME.
         */
        switch: boolean;
    }

    export interface CdnDomainTag {
        /**
         * The key of the tag.
         */
        key: string;
        /**
         * The value of the tag.
         */
        value: string;
    }

    export interface CertificatesCertInfo {
        /**
         * ID indicating the certificate.
         */
        certId: string;
        /**
         * The domain name to which the certificate is issued.
         */
        certName: string;
        /**
         * The domain name associated with the certificate. If the certificate is not yet associated with any domain name, the parameter value is null.
         */
        configuredDomain: string;
        /**
         * The remark of the cert.
         */
        desc: string;
        /**
         * The domain names included in the SAN field of the certificate.
         */
        dnsName: string;
        /**
         * The issuance time of the certificate is indicated. The unit is Unix timestamp.
         */
        effectiveTime: number;
        /**
         * The expiration time of the certificate is indicated. The unit is Unix timestamp.
         */
        expireTime: number;
        /**
         * Specify the location for storing the certificate. The parameter can take the following values: `volcCertCenter`: indicates that the certificate will be stored in the certificate center.`cdnCertHosting`: indicates that the certificate will be hosted on the content delivery network.
         */
        source: string;
        /**
         * Specify one or more states to retrieve certificates in those states. By default, all certificates in all states are returned. You can specify the following states. Multiple states are separated by commas. running: Retrieves certificates with a validity period greater than 30 days. expired: Retrieves certificates that have already expired. expiring_soon: Retrieves certificates with a validity period less than or equal to 30 days but have not yet expired.
         */
        status: string;
    }

    export interface ConfigsDomainConfig {
        /**
         * The cname of the domain.
         */
        cname: string;
        /**
         * The create time of the domain.
         */
        createTime: number;
        /**
         * The domain name.
         */
        domain: string;
        /**
         * Indicates whether the configuration of this domain name is allowed to be changed.
         */
        lockStatus: string;
        /**
         * The project name.
         */
        project: string;
        /**
         * The service region of the domain.
         */
        serviceRegion: string;
        /**
         * The service type of the domain.
         */
        serviceType: string;
        /**
         * The status of the domain.
         */
        status: string;
        /**
         * The update time of the domain.
         */
        updateTime: number;
    }

    export interface DomainsDomain {
        /**
         * The list of backup origin servers for accelerating this domain name. If no backup origin server is configured for this acceleration domain name, the parameter value is null.
         */
        backupOrigins: string[];
        /**
         * Indicates the role of the accelerated domain in the shared cache configuration. This parameter can take the following values: `targetHost`: Indicates that there is a shared cache configuration where the role of the accelerated domain is the target domain.`cacheSharedOn`: Indicates that there is a shared cache configuration where the role of the accelerated domain is the configured domain.`""`: This parameter value is empty, indicating that the accelerated domain does not exist in any shared cache configuration.
         */
        cacheShared: string;
        /**
         * If CacheShared is cache_shared_on, it means the target domain name that shares cache with the accelerated domain name. If CacheShared is targetHost or an empty value, the parameter value is empty.
         */
        cacheSharedTargetHost: string;
        /**
         * The CNAME address of the domain is automatically assigned when adding the domain.
         */
        cname: string;
        /**
         * The creation time of the domain.
         */
        createTime: number;
        /**
         * Search by specifying domain name keywords, with fuzzy matching.
         */
        domain: string;
        /**
         * Indicates the locked status of the accelerated domain.
         */
        domainLocks: outputs.cdn.DomainsDomainDomainLock[];
        /**
         * Specify HTTPS configuration to filter accelerated domains. The optional values for this parameter are as follows: `true`: Indicates that the accelerated domain has enabled HTTPS function.`false`: Indicates that the accelerated domain has not enabled HTTPS function.
         */
        https: boolean;
        /**
         * Specify IPv6 configuration to filter accelerated domain names. The optional values for this parameter are as follows: `true`: Indicates that the accelerated domain name supports requests using IPv6 addresses.`false`: Indicates that the accelerated domain name does not support requests using IPv6 addresses.
         */
        ipv6: boolean;
        /**
         * Indicates whether the accelerated domain name is a conflicting domain name. By default, each accelerated domain name is unique in the content delivery network. If you need to add an accelerated domain name that already exists in the content delivery network, you need to submit a ticket. If the domain name is added successfully, it becomes a conflicting domain name.
         */
        isConflictDomain: boolean;
        /**
         * Configure the origin protocol for the accelerated domain.
         */
        originProtocol: string;
        /**
         * Specify a primary origin server for filtering accelerated domains.
         */
        primaryOrigins: string[];
        /**
         * The project name of the domain.
         */
        project: string;
        /**
         * Indicates the acceleration area. The parameter can take the following values: `chineseMainland`: Indicates mainland China. `global`: Indicates global. `outsideChineseMainland`: Indicates global (excluding mainland China).
         */
        serviceRegion: string;
        /**
         * The business type of the domain name is indicated by this parameter. The possible values are: `download`: for file downloads. `web`: for web pages. `video`: for audio and video on demand.
         */
        serviceType: string;
        /**
         * The status of the domain.
         */
        status: string;
        /**
         * Filter by specified domain name tags, up to 10 tags can be specified. Each tag is entered as a string in the format of key:value.
         */
        tags: outputs.cdn.DomainsDomainTag[];
        /**
         * The update time of the domain.
         */
        updateTime: number;
    }

    export interface DomainsDomainDomainLock {
        /**
         * If the Status is on, this parameter value records the reason for the lock.
         */
        remark: string;
        /**
         * The status of the domain.
         */
        status: string;
    }

    export interface DomainsDomainTag {
        /**
         * The key of the tag.
         */
        key: string;
        /**
         * The value of the tag.
         */
        value: string;
    }

    export interface SharedConfigAllowIpAccessRule {
        /**
         * The entries in this list are an array of IP addresses and CIDR network segments. The total number of entries cannot exceed 3,000. The IP addresses and segments can be in IPv4 and IPv6 format. Duplicate entries in the list will be removed and will not count towards the limit.
         */
        rules: string[];
    }

    export interface SharedConfigAllowRefererAccessRule {
        /**
         * Indicates whether an empty Referer header, or a request without a Referer header, is not allowed. Default is false.
         */
        allowEmpty?: boolean;
        /**
         * The content indicating the Referer whitelist.
         */
        commonType: outputs.cdn.SharedConfigAllowRefererAccessRuleCommonType;
    }

    export interface SharedConfigAllowRefererAccessRuleCommonType {
        /**
         * This list is case-sensitive when matching requests. Default is true.
         */
        ignoreCase?: boolean;
        /**
         * The entries in this list are an array of IP addresses and CIDR network segments. The total number of entries cannot exceed 3,000. The IP addresses and segments can be in IPv4 and IPv6 format. Duplicate entries in the list will be removed and will not count towards the limit.
         */
        rules: string[];
    }

    export interface SharedConfigCommonMatchList {
        /**
         * The content indicating the Referer blacklist.
         */
        commonType: outputs.cdn.SharedConfigCommonMatchListCommonType;
    }

    export interface SharedConfigCommonMatchListCommonType {
        /**
         * This list is case-sensitive when matching requests. Default is true.
         */
        ignoreCase?: boolean;
        /**
         * The entries in this list are an array of IP addresses and CIDR network segments. The total number of entries cannot exceed 3,000. The IP addresses and segments can be in IPv4 and IPv6 format. Duplicate entries in the list will be removed and will not count towards the limit.
         */
        rules: string[];
    }

    export interface SharedConfigDenyIpAccessRule {
        /**
         * The entries in this list are an array of IP addresses and CIDR network segments. The total number of entries cannot exceed 3,000. The IP addresses and segments can be in IPv4 and IPv6 format. Duplicate entries in the list will be removed and will not count towards the limit.
         */
        rules: string[];
    }

    export interface SharedConfigDenyRefererAccessRule {
        /**
         * Indicates whether an empty Referer header, or a request without a Referer header, is not allowed. Default is false.
         */
        allowEmpty?: boolean;
        /**
         * The content indicating the Referer blacklist.
         */
        commonType: outputs.cdn.SharedConfigDenyRefererAccessRuleCommonType;
    }

    export interface SharedConfigDenyRefererAccessRuleCommonType {
        /**
         * This list is case-sensitive when matching requests. Default is true.
         */
        ignoreCase?: boolean;
        /**
         * The entries in this list are an array of IP addresses and CIDR network segments. The total number of entries cannot exceed 3,000. The IP addresses and segments can be in IPv4 and IPv6 format. Duplicate entries in the list will be removed and will not count towards the limit.
         */
        rules: string[];
    }

    export interface SharedConfigsConfigData {
        /**
         * The configuration for IP whitelist corresponds to ConfigType allow_ip_access_rule.
         */
        allowIpAccessRules: outputs.cdn.SharedConfigsConfigDataAllowIpAccessRule[];
        /**
         * The configuration for the Referer whitelist corresponds to ConfigType allow_referer_access_rule.
         */
        allowRefererAccessRules: outputs.cdn.SharedConfigsConfigDataAllowRefererAccessRule[];
        /**
         * The configuration for a common list is represented by ConfigType common_match_list.
         */
        commonMatchLists: outputs.cdn.SharedConfigsConfigDataCommonMatchList[];
        /**
         * The name of the shared config.
         */
        configName: string;
        /**
         * The type of the shared config.
         */
        configType: string;
        /**
         * The configuration for IP blacklist is denoted by ConfigType deny_ip_access_rule.
         */
        denyIpAccessRules: outputs.cdn.SharedConfigsConfigDataDenyIpAccessRule[];
        /**
         * The configuration for the Referer blacklist corresponds to ConfigType deny_referer_access_rule.
         */
        denyRefererAccessRules: outputs.cdn.SharedConfigsConfigDataDenyRefererAccessRule[];
        /**
         * The number of domains.
         */
        domainCount: number;
        /**
         * The name of the project.
         */
        projectName: string;
        /**
         * The update time of the shared config.
         */
        updateTime: number;
    }

    export interface SharedConfigsConfigDataAllowIpAccessRule {
        /**
         * The entries in this list are an array of IP addresses and CIDR network segments. The total number of entries cannot exceed 3,000. The IP addresses and segments can be in IPv4 and IPv6 format. Duplicate entries in the list will be removed and will not count towards the limit.
         */
        rules: string[];
    }

    export interface SharedConfigsConfigDataAllowRefererAccessRule {
        /**
         * Indicates whether an empty Referer header, or a request without a Referer header, is not allowed. Default is false.
         */
        allowEmpty: boolean;
        /**
         * The content indicating the Referer blacklist.
         */
        commonTypes: outputs.cdn.SharedConfigsConfigDataAllowRefererAccessRuleCommonType[];
    }

    export interface SharedConfigsConfigDataAllowRefererAccessRuleCommonType {
        /**
         * This list is case-sensitive when matching requests. Default is true.
         */
        ignoreCase: boolean;
        /**
         * The entries in this list are an array of IP addresses and CIDR network segments. The total number of entries cannot exceed 3,000. The IP addresses and segments can be in IPv4 and IPv6 format. Duplicate entries in the list will be removed and will not count towards the limit.
         */
        rules: string[];
    }

    export interface SharedConfigsConfigDataCommonMatchList {
        /**
         * The content indicating the Referer blacklist.
         */
        commonTypes: outputs.cdn.SharedConfigsConfigDataCommonMatchListCommonType[];
    }

    export interface SharedConfigsConfigDataCommonMatchListCommonType {
        /**
         * This list is case-sensitive when matching requests. Default is true.
         */
        ignoreCase: boolean;
        /**
         * The entries in this list are an array of IP addresses and CIDR network segments. The total number of entries cannot exceed 3,000. The IP addresses and segments can be in IPv4 and IPv6 format. Duplicate entries in the list will be removed and will not count towards the limit.
         */
        rules: string[];
    }

    export interface SharedConfigsConfigDataDenyIpAccessRule {
        /**
         * The entries in this list are an array of IP addresses and CIDR network segments. The total number of entries cannot exceed 3,000. The IP addresses and segments can be in IPv4 and IPv6 format. Duplicate entries in the list will be removed and will not count towards the limit.
         */
        rules: string[];
    }

    export interface SharedConfigsConfigDataDenyRefererAccessRule {
        /**
         * Indicates whether an empty Referer header, or a request without a Referer header, is not allowed. Default is false.
         */
        allowEmpty: boolean;
        /**
         * The content indicating the Referer blacklist.
         */
        commonTypes: outputs.cdn.SharedConfigsConfigDataDenyRefererAccessRuleCommonType[];
    }

    export interface SharedConfigsConfigDataDenyRefererAccessRuleCommonType {
        /**
         * This list is case-sensitive when matching requests. Default is true.
         */
        ignoreCase: boolean;
        /**
         * The entries in this list are an array of IP addresses and CIDR network segments. The total number of entries cannot exceed 3,000. The IP addresses and segments can be in IPv4 and IPv6 format. Duplicate entries in the list will be removed and will not count towards the limit.
         */
        rules: string[];
    }

}

export namespace cen {
    export interface AttachInstancesAttachInstance {
        /**
         * A cen ID.
         */
        cenId: string;
        /**
         * The create time of the cen attaching instance.
         */
        creationTime: string;
        /**
         * An instance ID.
         */
        instanceId: string;
        /**
         * The owner ID of the instance.
         */
        instanceOwnerId: string;
        /**
         * A region id of instance.
         */
        instanceRegionId: string;
        /**
         * An instance type.
         */
        instanceType: string;
        /**
         * The status of the cen attaching instance.
         */
        status: string;
    }

    export interface BandwidthPackageTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface BandwidthPackagesBandwidthPackage {
        /**
         * The account ID of the cen bandwidth package.
         */
        accountId: string;
        /**
         * The bandwidth of the cen bandwidth package.
         */
        bandwidth: number;
        /**
         * The billing type of the cen bandwidth package.
         */
        billingType: string;
        /**
         * The business status of the cen bandwidth package.
         */
        businessStatus: string;
        /**
         * The ID of the cen bandwidth package.
         */
        cenBandwidthPackageId: string;
        /**
         * The name of the cen bandwidth package.
         */
        cenBandwidthPackageName: string;
        /**
         * The cen IDs of the bandwidth package.
         */
        cenIds: string[];
        /**
         * The create time of the cen bandwidth package.
         */
        creationTime: string;
        /**
         * The deleted time of the cen bandwidth package.
         */
        deletedTime: string;
        /**
         * The description of the cen bandwidth package.
         */
        description: string;
        /**
         * The expired time of the cen bandwidth package.
         */
        expiredTime: string;
        /**
         * The ID of the cen bandwidth package.
         */
        id: string;
        /**
         * A local geographic region set id.
         */
        localGeographicRegionSetId: string;
        /**
         * A peer geographic region set id.
         */
        peerGeographicRegionSetId: string;
        /**
         * The ProjectName of the cen bandwidth package.
         */
        projectName: string;
        /**
         * The remain bandwidth of the cen bandwidth package.
         */
        remainingBandwidth: number;
        /**
         * The status of the cen bandwidth package.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.cen.BandwidthPackagesBandwidthPackageTag[];
        /**
         * The update time of the cen bandwidth package.
         */
        updateTime: string;
    }

    export interface BandwidthPackagesBandwidthPackageTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface BandwidthPackagesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface CenTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface CensCen {
        /**
         * The account ID of the cen.
         */
        accountId: string;
        /**
         * A list of bandwidth package IDs of the cen.
         */
        cenBandwidthPackageIds: string[];
        /**
         * The ID of the cen.
         */
        cenId: string;
        /**
         * The name of the cen.
         */
        cenName: string;
        /**
         * The create time of the cen.
         */
        creationTime: string;
        /**
         * The description of the cen.
         */
        description: string;
        /**
         * The ID of the cen.
         */
        id: string;
        /**
         * The ProjectName of the cen instance.
         */
        projectName: string;
        /**
         * The status of the cen.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.cen.CensCenTag[];
        /**
         * The update time of the cen.
         */
        updateTime: string;
    }

    export interface CensCenTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface CensTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface InterRegionBandwidthsInterRegionBandwidth {
        /**
         * The bandwidth of the cen inter region bandwidth.
         */
        bandwidth: number;
        /**
         * The cen ID of the cen inter region bandwidth.
         */
        cenId: string;
        /**
         * The create time of the cen inter region bandwidth.
         */
        creationTime: string;
        /**
         * The ID of the cen inter region bandwidth.
         */
        id: string;
        /**
         * The ID of the cen inter region bandwidth.
         */
        interRegionBandwidthId: string;
        /**
         * The local region id of the cen inter region bandwidth.
         */
        localRegionId: string;
        /**
         * The peer region id of the cen inter region bandwidth.
         */
        peerRegionId: string;
        /**
         * The status of the cen inter region bandwidth.
         */
        status: string;
        /**
         * The update time of the cen inter region bandwidth.
         */
        updateTime: string;
    }

    export interface RouteEntriesCenRouteEntry {
        /**
         * The AS path of the cen route entry.
         */
        asPaths: string[];
        /**
         * A cen ID.
         */
        cenId: string;
        /**
         * A destination cidr block.
         */
        destinationCidrBlock: string;
        /**
         * An instance ID.
         */
        instanceId: string;
        /**
         * An instance region ID.
         */
        instanceRegionId: string;
        /**
         * An instance type.
         */
        instanceType: string;
        /**
         * The publish status of the cen route entry.
         */
        publishStatus: string;
        /**
         * The status of the cen route entry.
         */
        status: string;
    }

    export interface ServiceRouteEntriesServiceRouteEntry {
        /**
         * A cen ID.
         */
        cenId: string;
        /**
         * The create time of the cen service route entry.
         */
        creationTime: string;
        /**
         * The description of the cen service route entry.
         */
        description: string;
        /**
         * A destination cidr block.
         */
        destinationCidrBlock: string;
        /**
         * Publishing scope of cloud service access routes. Valid values are `LocalDCGW`(default), `Custom`.
         */
        publishMode: string;
        /**
         * The publish instances. A maximum of 100 can be uploaded in one request.
         */
        publishToInstances: outputs.cen.ServiceRouteEntriesServiceRouteEntryPublishToInstance[];
        /**
         * A service region id.
         */
        serviceRegionId: string;
        /**
         * A service VPC id.
         */
        serviceVpcId: string;
        /**
         * The status of the cen service route entry.
         */
        status: string;
    }

    export interface ServiceRouteEntriesServiceRouteEntryPublishToInstance {
        /**
         * Cloud service access routes need to publish the network instance ID.
         */
        instanceId: string;
        /**
         * The region where the cloud service access route needs to be published.
         */
        instanceRegionId: string;
        /**
         * The network instance type that needs to be published for cloud service access routes. The values are as follows: `VPC`, `DCGW`.
         */
        instanceType: string;
    }

    export interface ServiceRouteEntryPublishToInstance {
        /**
         * Cloud service access routes need to publish the network instance ID.
         */
        instanceId?: string;
        /**
         * The region where the cloud service access route needs to be published.
         */
        instanceRegionId?: string;
        /**
         * The network instance type that needs to be published for cloud service access routes. The values are as follows: `VPC`, `DCGW`.
         */
        instanceType?: string;
    }

}

export namespace clb {
    export interface AclAclEntry {
        /**
         * The description of the AclEntry.
         */
        description?: string;
        /**
         * The content of the AclEntry.
         */
        entry: string;
    }

    export interface AclsAcl {
        /**
         * The count of acl entry.
         */
        aclEntryCount: number;
        /**
         * The ID of Acl.
         */
        aclId: string;
        /**
         * The name of acl.
         */
        aclName: string;
        /**
         * Creation time of Acl.
         */
        createTime: string;
        /**
         * The description of Acl.
         */
        description: string;
        /**
         * The ID of Acl.
         */
        id: string;
        /**
         * The listeners of Acl.
         */
        listeners: string[];
        /**
         * The ProjectName of Acl.
         */
        projectName: string;
        /**
         * Update time of Acl.
         */
        updateTime: string;
    }

    export interface CertificateTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface CertificatesCertificate {
        /**
         * The ID of the Certificate.
         */
        certificateId: string;
        /**
         * The name of the Certificate.
         */
        certificateName: string;
        /**
         * The create time of the Certificate.
         */
        createTime: string;
        /**
         * The description of the Certificate.
         */
        description: string;
        /**
         * The domain name of the Certificate.
         */
        domainName: string;
        /**
         * The expire time of the Certificate.
         */
        expiredAt: string;
        /**
         * The ID of the Certificate.
         */
        id: string;
        /**
         * The ID list of the Listener.
         */
        listeners: string[];
        /**
         * The ProjectName of Certificate.
         */
        projectName: string;
        /**
         * Tags.
         */
        tags: outputs.clb.CertificatesCertificateTag[];
    }

    export interface CertificatesCertificateTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface CertificatesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface ClbEipBillingConfig {
        /**
         * The peek bandwidth of the EIP which automatically assigned to CLB.
         */
        bandwidth: number;
        /**
         * The billing type of the EIP which automatically assigned to CLB. And optional choice contains `PostPaidByBandwidth` or `PostPaidByTraffic` or `PrePaid`.When creating a `PrePaid` public CLB, this field must be specified as `PrePaid` simultaneously.When the LoadBalancerBillingType changes from `PostPaid` to `PrePaid`, please manually modify the value of this field to `PrePaid` simultaneously.
         */
        eipBillingType: string;
        /**
         * The ISP of the EIP which automatically associated to CLB, the value can be `BGP` or `ChinaMobile` or `ChinaUnicom` or `ChinaTelecom` or `SingleLine_BGP` or `Static_BGP` or `Fusion_BGP`.
         */
        isp: string;
    }

    export interface ClbTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface ClbsClb {
        /**
         * The address ip version of the Clb.
         */
        addressIpVersion: string;
        /**
         * The business status of the Clb.
         */
        businessStatus: string;
        /**
         * The create time of the Clb.
         */
        createTime: string;
        /**
         * The expected recycle time of the Clb.
         */
        deletedTime: string;
        /**
         * The description of the Clb.
         */
        description: string;
        /**
         * The Eip address of the Clb.
         */
        eipAddress: string;
        /**
         * The eip billing config of the Clb.
         */
        eipBillingConfigs: outputs.clb.ClbsClbEipBillingConfig[];
        /**
         * The Eip ID of the Clb.
         */
        eipId: string;
        /**
         * The private ip address of the Clb.
         */
        eniAddress: string;
        /**
         * The Eni ID of the Clb.
         */
        eniId: string;
        /**
         * The eni ipv6 address of the Clb.
         */
        eniIpv6Address: string;
        /**
         * The expired time of the CLB.
         */
        expiredTime: string;
        /**
         * The ID of the Clb.
         */
        id: string;
        /**
         * The billing status of the CLB.
         */
        instanceStatus: number;
        /**
         * The ipv6 address bandwidth information of the Clb.
         */
        ipv6AddressBandwidths: outputs.clb.ClbsClbIpv6AddressBandwidth[];
        /**
         * The Ipv6 Eip ID of the Clb.
         */
        ipv6EipId: string;
        /**
         * The billing type of the Clb.
         */
        loadBalancerBillingType: string;
        /**
         * The ID of the Clb.
         */
        loadBalancerId: string;
        /**
         * The name of the Clb.
         */
        loadBalancerName: string;
        /**
         * The specifications of the Clb.
         */
        loadBalancerSpec: string;
        /**
         * The reason why Clb is locked.
         */
        lockReason: string;
        /**
         * The master zone ID of the CLB.
         */
        masterZoneId: string;
        /**
         * The modification protection reason of the Clb.
         */
        modificationProtectionReason: string;
        /**
         * The modification protection status of the Clb.
         */
        modificationProtectionStatus: string;
        /**
         * The over reclaim time of the CLB.
         */
        overdueReclaimTime: string;
        /**
         * The overdue time of the Clb.
         */
        overdueTime: string;
        /**
         * The ProjectName of Clb.
         */
        projectName: string;
        /**
         * The reclaim time of the CLB.
         */
        reclaimTime: string;
        /**
         * The remain renew times of the CLB. When the value of the renewType is `AutoRenew`, the query returns this field.
         */
        remainRenewTimes: number;
        /**
         * The renew period times of the CLB. When the value of the renewType is `AutoRenew`, the query returns this field.
         */
        renewPeriodTimes: number;
        /**
         * The renew type of the CLB. When the value of the loadBalancerBillingType is `PrePaid`, the query returns this field.
         */
        renewType: string;
        /**
         * The slave zone ID of the CLB.
         */
        slaveZoneId: string;
        /**
         * The status of the Clb.
         */
        status: string;
        /**
         * The subnet ID of the Clb.
         */
        subnetId: string;
        /**
         * Tags.
         */
        tags: outputs.clb.ClbsClbTag[];
        /**
         * The type of the Clb.
         */
        type: string;
        /**
         * The update time of the Clb.
         */
        updateTime: string;
        /**
         * The id of the VPC.
         */
        vpcId: string;
    }

    export interface ClbsClbEipBillingConfig {
        /**
         * The peek bandwidth of the Ipv6 EIP assigned to CLB. Units: Mbps.
         */
        bandwidth: number;
        /**
         * The billing type of the EIP assigned to CLB. And optional choice contains `PostPaidByBandwidth` or `PostPaidByTraffic` or `PrePaid`.
         */
        eipBillingType: string;
        /**
         * The ISP of the Ipv6 EIP assigned to CLB, the value can be `BGP`.
         */
        isp: string;
    }

    export interface ClbsClbIpv6AddressBandwidth {
        /**
         * The peek bandwidth of the Ipv6 EIP assigned to CLB. Units: Mbps.
         */
        bandwidth: number;
        /**
         * The bandwidth package id of the Ipv6 EIP assigned to CLB.
         */
        bandwidthPackageId: string;
        /**
         * The billing type of the Ipv6 EIP assigned to CLB. And optional choice contains `PostPaidByBandwidth` or `PostPaidByTraffic`.
         */
        billingType: string;
        /**
         * The ISP of the Ipv6 EIP assigned to CLB, the value can be `BGP`.
         */
        isp: string;
        /**
         * The network type of the CLB Ipv6 address.
         */
        networkType: string;
    }

    export interface ClbsClbTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface ClbsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface ListenerHealthCheck {
        /**
         * The domain of health check.
         */
        domain?: string;
        /**
         * The enable status of health check function. Optional choice contains `on`, `off`.
         */
        enabled?: string;
        /**
         * The healthy threshold of health check, default 3, range in 2~10.
         */
        healthyThreshold?: number;
        /**
         * The normal http status code of health check, the value can be `http2xx` or `http3xx` or `http4xx` or `http5xx`.
         */
        httpCode?: string;
        /**
         * The interval executing health check, default 2, range in 1~300.
         */
        interval?: number;
        /**
         * The method of health check, the value can be `GET` or `HEAD`.
         */
        method?: string;
        /**
         * The response timeout of health check, default 2, range in 1~60..
         */
        timeout?: number;
        /**
         * The UDP expect of health check. This field must be specified simultaneously with field `udpRequest`.
         */
        udpExpect?: string;
        /**
         * The UDP request of health check. This field must be specified simultaneously with field `udpExpect`.
         */
        udpRequest?: string;
        /**
         * The unhealthy threshold of health check, default 3, range in 2~10.
         */
        unHealthyThreshold?: number;
        /**
         * The uri of health check.
         */
        uri?: string;
    }

    export interface ListenersListener {
        /**
         * The acl ID list to which the Listener is bound.
         */
        aclIds: string[];
        /**
         * The acl status of the Listener.
         */
        aclStatus: string;
        /**
         * The acl type of the Listener.
         */
        aclType: string;
        /**
         * The bandwidth of the Listener. Unit: Mbps.
         */
        bandwidth: number;
        /**
         * The ID of the certificate which is associated with the Listener.
         */
        certificateId: string;
        /**
         * Whether to enable connection drain of the Listener.
         */
        connectionDrainEnabled: string;
        /**
         * The connection drain timeout of the Listener.
         */
        connectionDrainTimeout: number;
        /**
         * The name of the cookie for session persistence configured on the backend server.
         */
        cookie: string;
        /**
         * The create time of the Listener.
         */
        createTime: string;
        /**
         * The enable status of the Listener.
         */
        enabled: string;
        /**
         * The domain of health check.
         */
        healthCheckDomain: string;
        /**
         * The enable status of health check function.
         */
        healthCheckEnabled: string;
        /**
         * The healthy threshold of health check.
         */
        healthCheckHealthyThreshold: number;
        /**
         * The normal http status code of health check.
         */
        healthCheckHttpCode: string;
        /**
         * The interval executing health check.
         */
        healthCheckInterval: number;
        /**
         * The method of health check.
         */
        healthCheckMethod: string;
        /**
         * The response timeout of health check.
         */
        healthCheckTimeout: number;
        /**
         * The expected response string for the health check.
         */
        healthCheckUdpExpect: string;
        /**
         * A request string to perform a health check.
         */
        healthCheckUdpRequest: string;
        /**
         * The unhealthy threshold of health check.
         */
        healthCheckUnHealthyThreshold: number;
        /**
         * The uri of health check.
         */
        healthCheckUri: string;
        /**
         * The ID of the Listener.
         */
        id: string;
        /**
         * The ID of the Listener.
         */
        listenerId: string;
        /**
         * The name of the Listener.
         */
        listenerName: string;
        /**
         * The persistence timeout of the Listener.
         */
        persistenceTimeout: number;
        /**
         * The persistence type of the Listener.
         */
        persistenceType: string;
        /**
         * The port receiving request of the Listener.
         */
        port: number;
        /**
         * The protocol of the Listener.
         */
        protocol: string;
        /**
         * Whether to enable proxy protocol.
         */
        proxyProtocolType: string;
        /**
         * The ID of the backend server group which is associated with the Listener.
         */
        serverGroupId: string;
        /**
         * The status of the Listener.
         */
        status: string;
        /**
         * The update time of the Listener.
         */
        updateTime: string;
    }

    export interface RulesRule {
        /**
         * The Description of Rule.
         */
        description: string;
        /**
         * The Domain of Rule.
         */
        domain: string;
        /**
         * The Id of Rule.
         */
        id: string;
        /**
         * The Id of Rule.
         */
        ruleId: string;
        /**
         * The Id of Server Group.
         */
        serverGroupId: string;
        /**
         * The Url of Rule.
         */
        url: string;
    }

    export interface ServerGroupServersServer {
        /**
         * The description of the instance.
         */
        description: string;
        /**
         * The server id of instance in ServerGroup.
         */
        id: string;
        /**
         * The ID of ecs instance or the network card bound to ecs instance.
         */
        instanceId: string;
        /**
         * The private ip of the instance.
         */
        ip: string;
        /**
         * The port receiving request.
         */
        port: number;
        /**
         * The server id of instance in ServerGroup.
         */
        serverId: string;
        /**
         * The type of instance. Optional choice contains `ecs`, `eni`.
         */
        type: string;
        /**
         * The weight of the instance.
         */
        weight: number;
    }

    export interface ServerGroupsGroup {
        /**
         * The address ip version of the ServerGroup.
         */
        addressIpVersion: string;
        /**
         * The create time of the ServerGroup.
         */
        createTime: string;
        /**
         * The description of the ServerGroup.
         */
        description: string;
        /**
         * The ID of the ServerGroup.
         */
        id: string;
        /**
         * The ID of the ServerGroup.
         */
        serverGroupId: string;
        /**
         * The name of the ServerGroup.
         */
        serverGroupName: string;
        /**
         * The update time of the ServerGroup.
         */
        updateTime: string;
    }

    export interface ZonesMasterZone {
        /**
         * The slave zones list.
         */
        slaveZones: outputs.clb.ZonesMasterZoneSlaveZone[];
        /**
         * The master zone id.
         */
        zoneId: string;
    }

    export interface ZonesMasterZoneSlaveZone {
        /**
         * The master zone id.
         */
        zoneId: string;
    }

}

export namespace cloud_monitor {
    export interface ContactGroupsGroup {
        /**
         * The id of the account.
         */
        accountId: string;
        /**
         * Contact information in the contact group.
         */
        contacts: outputs.cloud_monitor.ContactGroupsGroupContact[];
        /**
         * The create time.
         */
        createdAt: string;
        /**
         * The description of the contact group.
         */
        description: string;
        /**
         * The id of the contact group.
         */
        id: string;
        /**
         * Search for keywords in contact group names, supports fuzzy search.
         */
        name: string;
        /**
         * The update time.
         */
        updatedAt: string;
    }

    export interface ContactGroupsGroupContact {
        /**
         * The email of contact.
         */
        email: string;
        /**
         * The id of the contact group.
         */
        id: string;
        /**
         * Search for keywords in contact group names, supports fuzzy search.
         */
        name: string;
        /**
         * The phone of contact.
         */
        phone: string;
    }

    export interface ContactsContact {
        /**
         * The email of contact.
         */
        email: string;
        /**
         * The ID of contact.
         */
        id: string;
        /**
         * The name of contact.
         */
        name: string;
        /**
         * The phone of contact.
         */
        phone: string;
    }

    export interface EventRuleEffectiveTime {
        /**
         * End time for rule activation.
         */
        endTime: string;
        /**
         * Start time for rule activation.
         */
        startTime: string;
    }

    export interface EventRuleFilterPattern {
        /**
         * Event source corresponding to pattern matching.
         */
        source: string;
        /**
         * The list of corresponding event types in pattern matching, currently set to match any.
         */
        types: string[];
    }

    export interface EventRuleMessageQueue {
        /**
         * The kafka instance id.
         */
        instanceId: string;
        /**
         * The region.
         */
        region: string;
        /**
         * The topic name.
         */
        topic: string;
        /**
         * The message queue type, only support kafka now.
         */
        type: string;
        /**
         * The vpc id.
         */
        vpcId: string;
    }

    export interface EventRuleTlsTarget {
        /**
         * The project id.
         */
        projectId: string;
        /**
         * The project name.
         */
        projectName: string;
        /**
         * The Chinese region name.
         */
        regionNameCn: string;
        /**
         * The English region name.
         */
        regionNameEn: string;
        /**
         * The topic id.
         */
        topicId: string;
    }

    export interface EventRulesRule {
        /**
         * The id of the account.
         */
        accountId: string;
        /**
         * When the alarm notification method is phone, SMS, or email, the triggered alarm contact group ID.
         */
        contactGroupIds: string[];
        /**
         * List of contact methods.
         */
        contactMethods: string[];
        /**
         * The create time.
         */
        createdAt: number;
        /**
         * The description of the rule.
         */
        description: string;
        /**
         * The end time of the rule.
         */
        effectEndAt: string;
        /**
         * The start time of the rule.
         */
        effectStartAt: string;
        /**
         * When the alarm notification method is alarm callback, it triggers the callback address.
         */
        endpoint: string;
        /**
         * The name of the event bus.
         */
        eventBusName: string;
        /**
         * The source of the event.
         */
        eventSource: string;
        /**
         * The event type.
         */
        eventTypes: string[];
        /**
         * Filter mode, also known as event matching rules. Custom matching rules are not currently supported.
         */
        filterPatterns: outputs.cloud_monitor.EventRulesRuleFilterPattern[];
        /**
         * The id of the rule.
         */
        id: string;
        /**
         * The level of the rule.
         */
        level: string;
        /**
         * The triggered message queue when the alarm notification method is Kafka message queue.
         */
        messageQueues: outputs.cloud_monitor.EventRulesRuleMessageQueue[];
        /**
         * The name of the region.
         */
        region: string;
        /**
         * The id of the rule.
         */
        ruleId: string;
        /**
         * Rule name, search rules by name using fuzzy search.
         */
        ruleName: string;
        /**
         * Enable the state of the rule.
         */
        status: string;
        /**
         * The alarm method for log service triggers the configuration of the log service.
         */
        tlsTargets: outputs.cloud_monitor.EventRulesRuleTlsTarget[];
        /**
         * The updated time.
         */
        updatedAt: number;
    }

    export interface EventRulesRuleFilterPattern {
        /**
         * Event source.
         */
        source: string;
        /**
         * The message queue type, only support kafka now.
         */
        types: string[];
    }

    export interface EventRulesRuleMessageQueue {
        /**
         * The kafka instance id.
         */
        instanceId: string;
        /**
         * The name of the region.
         */
        region: string;
        /**
         * The topic name.
         */
        topic: string;
        /**
         * The message queue type, only support kafka now.
         */
        type: string;
        /**
         * The vpc id.
         */
        vpcId: string;
    }

    export interface EventRulesRuleTlsTarget {
        /**
         * The project id.
         */
        projectId: string;
        /**
         * The project name.
         */
        projectName: string;
        /**
         * The Chinese region name.
         */
        regionNameCn: string;
        /**
         * The English region name.
         */
        regionNameEn: string;
        /**
         * The topic id.
         */
        topicId: string;
        /**
         * The topic name.
         */
        topicName: string;
    }

    export interface RuleCondition {
        /**
         * The comparison operation of the cloud monitor rule. Valid values: `>`, `>=`, `<`, `<=`, `!=`, `=`.
         */
        comparisonOperator: string;
        /**
         * The metric name of the cloud monitor rule.
         */
        metricName: string;
        /**
         * The metric unit of the cloud monitor rule.
         */
        metricUnit: string;
        period: string;
        /**
         * The statistics of the cloud monitor rule. Valid values: `avg`, `max`, `min`.
         */
        statistics: string;
        /**
         * The threshold of the cloud monitor rule.
         */
        threshold: string;
    }

    export interface RuleOriginalDimension {
        /**
         * The key of the dimension.
         */
        key: string;
        /**
         * The value of the dimension.
         */
        values: string[];
    }

    export interface RuleRecoveryNotify {
        /**
         * Whether to enable the recovery notify function.
         */
        enable?: boolean;
    }

    export interface RulesRule {
        /**
         * The alert methods of the cloud monitor rule.
         */
        alertMethods: string[];
        /**
         * The alert state of the cloud monitor rule. Valid values: `altering`, `normal`.
         */
        alertState: string;
        /**
         * The condition operator of the cloud monitor rule. Valid values: `&&`, `||`.
         */
        conditionOperator: string;
        /**
         * The conditions of the cloud monitor rule.
         */
        conditions: outputs.cloud_monitor.RulesRuleCondition[];
        /**
         * The contact group ids of the cloud monitor rule.
         */
        contactGroupIds: string[];
        /**
         * The created time of the cloud monitor rule.
         */
        createdAt: string;
        /**
         * The description of the cloud monitor rule.
         */
        description: string;
        /**
         * The effect end time of the cloud monitor rule.
         */
        effectEndAt: string;
        /**
         * The effect start time of the cloud monitor rule.
         */
        effectStartAt: string;
        /**
         * The enable state of the cloud monitor rule. Valid values: `enable`, `disable`.
         */
        enableState: string;
        /**
         * The evaluation count of the cloud monitor rule.
         */
        evaluationCount: number;
        /**
         * The id of the cloud monitor rule.
         */
        id: string;
        /**
         * The level of the cloud monitor rule. Valid values: `critical`, `warning`, `notice`.
         */
        level: string;
        /**
         * Whether to enable the multiple conditions function of the cloud monitor rule.
         */
        multipleConditions: boolean;
        /**
         * The namespace of the cloud monitor rule.
         */
        namespace: string;
        /**
         * The original dimensions of the cloud monitor rule.
         */
        originalDimensions: outputs.cloud_monitor.RulesRuleOriginalDimension[];
        /**
         * The region id of the cloud monitor rule.
         */
        regions: string[];
        /**
         * The name of the cloud monitor rule. This field support fuzzy query.
         */
        ruleName: string;
        /**
         * The silence time of the cloud monitor rule. Unit in minutes.
         */
        silenceTime: number;
        /**
         * The sub namespace of the cloud monitor rule.
         */
        subNamespace: string;
        /**
         * The updated time of the cloud monitor rule.
         */
        updatedAt: string;
        /**
         * The web hook of the cloud monitor rule.
         */
        webHook: string;
    }

    export interface RulesRuleCondition {
        /**
         * The comparison operation of the cloud monitor rule.
         */
        comparisonOperator: string;
        /**
         * The metric name of the cloud monitor rule.
         */
        metricName: string;
        /**
         * The metric unit of the cloud monitor rule.
         */
        metricUnit: string;
        /**
         * The period of the cloud monitor rule.
         */
        period: string;
        /**
         * The statistics of the cloud monitor rule.
         */
        statistics: string;
        /**
         * The threshold of the cloud monitor rule.
         */
        threshold: string;
    }

    export interface RulesRuleOriginalDimension {
        /**
         * The key of the dimension.
         */
        key: string;
        /**
         * The value of the dimension.
         */
        values: string[];
    }

}

export namespace cloudfs {
    export interface AccessesAccess {
        /**
         * The account id of access.
         */
        accessAccountId: number;
        /**
         * The id of access.
         */
        accessId: string;
        /**
         * The service name of access.
         */
        accessServiceName: string;
        /**
         * The creation time.
         */
        createdTime: string;
        /**
         * The name of file system.
         */
        fsName: string;
        /**
         * Whether is default access.
         */
        isDefault: boolean;
        /**
         * The id of security group.
         */
        securityGroupId: string;
        /**
         * The status of access.
         */
        status: string;
        /**
         * The id of subnet.
         */
        subnetId: string;
        /**
         * The id of vpc.
         */
        vpcId: string;
        /**
         * Whether to enable all vpc route.
         */
        vpcRouteEnabled: boolean;
    }

    export interface FileSystemsFileSystem {
        /**
         * The capacity of cache.
         */
        cacheCapacityTib: number;
        /**
         * The plan of cache.
         */
        cachePlan: string;
        /**
         * The creation time.
         */
        createdTime: string;
        /**
         * The ID of file system.
         */
        id: string;
        /**
         * The mode of file system.
         */
        mode: string;
        /**
         * The point mount.
         */
        mountPoint: string;
        /**
         * The name of file system.
         */
        name: string;
        /**
         * The id of region.
         */
        regionId: string;
        /**
         * The id of security group.
         */
        securityGroupId: string;
        /**
         * The status of file system.
         */
        status: string;
        /**
         * The id of subnet.
         */
        subnetId: string;
        /**
         * The tos bucket.
         */
        tosBucket: string;
        /**
         * The tos prefix.
         */
        tosPrefix: string;
        /**
         * The id of vpc.
         */
        vpcId: string;
        /**
         * The id of zone.
         */
        zoneId: string;
    }

    export interface NamespacesNamespace {
        /**
         * The creation time of the namespace.
         */
        createdTime: string;
        /**
         * The ID of the namespace.
         */
        id: string;
        /**
         * Whether the tos bucket is your own bucket.
         */
        isMyBucket: boolean;
        /**
         * Whether the namespace is read-only.
         */
        readOnly: boolean;
        /**
         * Whether the namespace is the official service for volcengine.
         */
        serviceManaged: boolean;
        /**
         * The status of the namespace.
         */
        status: string;
        /**
         * The name of tos bucket.
         */
        tosBucket: string;
        /**
         * The tos prefix.
         */
        tosPrefix: string;
    }

    export interface NsQuotasQuota {
        /**
         * The ID of account.
         */
        accountId: number;
        /**
         * The name of fs.
         */
        fsName: string;
        /**
         * The count of cloud fs namespace.
         */
        nsCount: number;
        /**
         * This file stores the number of namespaces under the instance.
         */
        nsCountPerFs: number;
        /**
         * The quota of cloud fs namespace.
         */
        nsQuota: number;
        /**
         * This file stores the total namespace quota under the instance.
         */
        nsQuotaPerFs: number;
        /**
         * Whether is enough of cloud fs namespace.
         */
        quotaEnough: boolean;
    }

    export interface QuotasQuota {
        /**
         * The ID of account.
         */
        accountId: number;
        /**
         * The count of cloud fs.
         */
        fsCount: number;
        /**
         * The quota of cloud fs.
         */
        fsQuota: number;
        /**
         * Whether is enough of cloud fs.
         */
        quotaEnough: boolean;
    }

}

export namespace config {
    export interface AssumeRole {
        assumeRoleSessionName: string;
        assumeRoleTrn: string;
        durationSeconds: number;
        policy?: string;
    }

}

export namespace cr {
    export interface AuthorizationTokensToken {
        /**
         * The expiration time of the temporary access token.
         */
        expireTime: string;
        /**
         * The Temporary access token.
         */
        token: string;
        /**
         * The username for login repository instance.
         */
        username: string;
    }

    export interface EndpointsEndpoint {
        /**
         * Whether public endpoint is enabled.
         */
        enabled: boolean;
        /**
         * The CR instance name.
         */
        registry: string;
        /**
         * The status of public endpoint.
         */
        status: string;
    }

    export interface NamespacesNamespace {
        /**
         * The time when namespace created.
         */
        createTime: string;
        /**
         * The name of OCI repository.
         */
        name: string;
    }

    export interface RegistriesRegistry {
        /**
         * The charge type of registry.
         */
        chargeType: string;
        /**
         * The creation time of registry.
         */
        createTime: string;
        /**
         * The domain of registry.
         */
        domains: outputs.cr.RegistriesRegistryDomain[];
        /**
         * The name of registry.
         */
        name: string;
        /**
         * The status of registry.
         */
        status: outputs.cr.RegistriesRegistryStatus;
        /**
         * The type of registry.
         */
        type: string;
        /**
         * The status of user.
         */
        userStatus: string;
        /**
         * The username of cr instance.
         */
        username: string;
    }

    export interface RegistriesRegistryDomain {
        /**
         * The domain of registry.
         */
        domain: string;
        /**
         * The type of registry.
         */
        type: string;
    }

    export interface RegistriesRegistryStatus {
        /**
         * The condition of registry.
         */
        conditions: string[];
        /**
         * The phase of status.
         */
        phase: string;
    }

    export interface RegistriesStatus {
        /**
         * The condition of registry.
         */
        condition?: string;
        /**
         * The phase of status.
         */
        phase?: string;
    }

    export interface RegistryDomain {
        /**
         * The domain of registry.
         */
        domain: string;
        /**
         * The type of registry.
         */
        type: string;
    }

    export interface RegistryStatus {
        /**
         * The condition of registry.
         */
        conditions: string[];
        /**
         * The phase status of registry.
         */
        phase: string;
    }

    export interface RepositoriesRepository {
        /**
         * The access level of repository.
         */
        accessLevel: string;
        /**
         * The creation time of repository.
         */
        createTime: string;
        /**
         * The description of repository.
         */
        description: string;
        /**
         * The name of repository.
         */
        name: string;
        /**
         * The namespace of repository.
         */
        namespace: string;
        /**
         * The last update time of repository.
         */
        updateTime: string;
    }

    export interface StateStatus {
        /**
         * The condition of instance.
         */
        conditions: string[];
        /**
         * The phase status of instance.
         */
        phase: string;
    }

    export interface TagChartAttribute {
        /**
         * The Helm version.
         */
        apiVersion: string;
        /**
         * The name of OCI product.
         */
        name: string;
        /**
         * The Helm Chart version.
         */
        version: string;
    }

    export interface TagImageAttribute {
        /**
         * The image architecture.
         */
        architecture: string;
        /**
         * The image author.
         */
        author: string;
        /**
         * The digest of image.
         */
        digest: string;
        /**
         * The iamge os.
         */
        os: string;
    }

    export interface TagsTag {
        /**
         * The chart attribute,valid when tag type is Chart.
         */
        chartAttribute: outputs.cr.TagsTagChartAttribute;
        /**
         * The digest of image.
         */
        digest: string;
        /**
         * The list of image attributes,valid when tag type is Image.
         */
        imageAttributes: outputs.cr.TagsTagImageAttribute[];
        /**
         * The name of OCI product tag.
         */
        name: string;
        /**
         * The last push time of OCI product.
         */
        pushTime: string;
        /**
         * The size of OCI product.
         */
        size: number;
        /**
         * The type of OCI product tag.
         */
        type: string;
    }

    export interface TagsTagChartAttribute {
        /**
         * The Helm version.
         */
        apiVersion: string;
        /**
         * The name of OCI product tag.
         */
        name: string;
        /**
         * The Helm Chart version.
         */
        version: string;
    }

    export interface TagsTagImageAttribute {
        /**
         * The image architecture.
         */
        architecture: string;
        /**
         * The image author.
         */
        author: string;
        /**
         * The digest of image.
         */
        digest: string;
        /**
         * The iamge os.
         */
        os: string;
    }

    export interface VpcEndpointVpc {
        /**
         * The id of the account. When you need to expose the Enterprise Edition instance to a VPC under another primary account, you need to specify the ID of the primary account to which the VPC belongs.
         */
        accountId: number;
        /**
         * The id of the subnet. If not specified, the subnet with the most remaining IPs under the VPC will be automatically selected.
         */
        subnetId: string;
        /**
         * The id of the vpc.
         */
        vpcId?: string;
    }

    export interface VpcEndpointsEndpoint {
        /**
         * The CR registry name.
         */
        registry: string;
        /**
         * List of vpc information.
         */
        vpcs: outputs.cr.VpcEndpointsEndpointVpc[];
    }

    export interface VpcEndpointsEndpointVpc {
        /**
         * The id of the account.
         */
        accountId: number;
        /**
         * The creation time.
         */
        createTime: string;
        /**
         * The IP address of the mirror repository in the VPC.
         */
        ip: string;
        /**
         * The region id.
         */
        region: string;
        /**
         * The status of the vpc endpoint.
         */
        status: string;
        /**
         * The ID of the subnet.
         */
        subnetId: string;
        /**
         * The ID of the vpc.
         */
        vpcId: string;
    }

}

export namespace direct_connect {
    export interface BgpPeersBgpPeer {
        /**
         * The id of account.
         */
        accountId: string;
        /**
         * The key of auth.
         */
        authKey: string;
        /**
         * The id of bgp peer.
         */
        bgpPeerId: string;
        /**
         * The name of bgp peer.
         */
        bgpPeerName: string;
        /**
         * The create time of bgp peer.
         */
        creationTime: string;
        /**
         * The Description of bgp peer.
         */
        description: string;
        /**
         * The local asn of bgp peer.
         */
        localAsn: number;
        /**
         * The remote asn of bgp peer.
         */
        remoteAsn: number;
        /**
         * The session status of bgp peer.
         */
        sessionStatus: string;
        /**
         * The status of bgp peer.
         */
        status: string;
        /**
         * The update time of bgp peer.
         */
        updateTime: string;
        /**
         * The id of virtual interface.
         */
        virtualInterfaceId: string;
    }

    export interface ConnectionTag {
        /**
         * The tag key.
         */
        key?: string;
        /**
         * The tag value.
         */
        value?: string;
    }

    export interface ConnectionsDirectConnectConnection {
        /**
         * The account ID which the physical leased line belongs.
         */
        accountId: string;
        /**
         * The bandwidth of direct connect.
         */
        bandwidth: number;
        /**
         * The dedicated line billing type,only support `1` for yearly and monthly billing currently.
         */
        billingType: number;
        /**
         * The dedicated line billing status.
         */
        businessStatus: string;
        /**
         * The connection type of physical leased line,valid value contains `SharedConnection`,`DedicatedConnection`.
         */
        connectionType: string;
        /**
         * The creation time of direct connect.
         */
        creationTime: string;
        /**
         * The dedicated line contact email.
         */
        customerContactEmail: string;
        /**
         * The dedicated line contact phone.
         */
        customerContactPhone: string;
        /**
         * The dedicated line contact name.
         */
        customerName: string;
        /**
         * The expected resource force collection time.
         */
        deletedTime: string;
        /**
         * The description of direct connect connection.
         */
        description: string;
        /**
         * The ID of the physical leased line access point.
         */
        directConnectAccessPointId: string;
        /**
         * The ID of direct connect connection.
         */
        directConnectConnectionId: string;
        /**
         * The name of directi connect connection.
         */
        directConnectConnectionName: string;
        /**
         * The expect bandwidth of direct connect.
         */
        expectBandwidth: number;
        /**
         * The expired time.
         */
        expiredTime: string;
        /**
         * The operator of the physical leased line,valid value contains `ChinaTelecom`,`ChinaMobile`,`ChinaUnicom`,`ChinaOther`.
         */
        lineOperator: string;
        /**
         * The account ID of physical leased line to which the shared leased line belongs.If the physical leased line type is an exclusive leased line,this parameter returns empty.
         */
        parentConnectionAccountId: string;
        /**
         * The ID of the physical leased line to which the shared leased line belongs. If the physical leased line type is an exclusive leased line, this parameter returns empty.
         */
        parentConnectionId: string;
        /**
         * The peer access point of the physical leased line.
         */
        peerLocation: string;
        /**
         * The dedicated line port spec.
         */
        portSpec: string;
        /**
         * The port type of direct connect.
         */
        portType: string;
        /**
         * The status of physical leased line.
         */
        status: string;
        /**
         * All tags that physical leased line added.
         */
        tags: outputs.direct_connect.ConnectionsDirectConnectConnectionTag[];
        /**
         * The update time of direct connect.
         */
        updateTime: string;
        /**
         * The vlan ID of shared connection,if `connectionType` is `DedicatedConnection`,this parameter returns 0.
         */
        vlanId: number;
    }

    export interface ConnectionsDirectConnectConnectionTag {
        /**
         * The tag key of cloud resource instance.
         */
        key: string;
        /**
         * The tag value of cloud resource instance.
         */
        value: string;
    }

    export interface ConnectionsTagFilter {
        /**
         * The tag key of cloud resource instance.
         */
        key?: string;
        /**
         * The tag value of cloud resource instance.
         */
        value?: string;
    }

    export interface GatewayRoutesDirectConnectGatewayRoute {
        /**
         * The id of account.
         */
        accountId: string;
        /**
         * The create time.
         */
        creationTime: string;
        /**
         * The cidr block.
         */
        destinationCidrBlock: string;
        /**
         * The id of direct connect gateway.
         */
        directConnectGatewayId: string;
        /**
         * The id of direct connect gateway route.
         */
        directConnectGatewayRouteId: string;
        /**
         * The id of next hop.
         */
        nextHopId: string;
        /**
         * The type of next hop.
         */
        nextHopType: string;
        /**
         * The type of route. The value can be BGP or CEN or Static.
         */
        routeType: string;
        /**
         * The status info.
         */
        status: string;
    }

    export interface GatewayTag {
        /**
         * The tag key.
         */
        key?: string;
        /**
         * The tag value.
         */
        value?: string;
    }

    export interface GatewaysDirectConnectGateway {
        /**
         * The account ID that direct connect gateway belongs.
         */
        accountId: string;
        /**
         * The CEN information associated with the direct connect gateway.
         */
        associateCens: outputs.direct_connect.GatewaysDirectConnectGatewayAssociateCen[];
        /**
         * The business status of direct connect gateway.
         */
        businessStatus: string;
        /**
         * The creation time of direct connect gateway.
         */
        creationTime: string;
        /**
         * The expected resource force collection time. Only when the resource is frozen due to arrears, this parameter will have a return value, otherwise it will return a null value.
         */
        deletedTime: string;
        /**
         * The description of direct connect gateway.
         */
        description: string;
        /**
         * The direct connect gateway ID.
         */
        directConnectGatewayId: string;
        /**
         * The direst connect gateway name.
         */
        directConnectGatewayName: string;
        /**
         * The reason of the direct connect gateway locked.
         */
        lockReason: string;
        /**
         * The resource freeze time. Only when the resource is frozen due to arrears, this parameter will have a return value, otherwise it will return a null value.
         */
        overdueTime: string;
        /**
         * The status of direct connect gateway.
         */
        status: string;
        /**
         * The tags that direct connect gateway added.
         */
        tags: outputs.direct_connect.GatewaysDirectConnectGatewayTag[];
        /**
         * The update time of direct connect gateway.
         */
        updateTime: string;
    }

    export interface GatewaysDirectConnectGatewayAssociateCen {
        /**
         * The CEN ID which direct connect gateway belongs.
         */
        cenId: string;
        /**
         * The CEN owner's ID.
         */
        cenOwnerId: string;
        /**
         * The CEN status.
         */
        cenStatus: string;
    }

    export interface GatewaysDirectConnectGatewayTag {
        /**
         * The tag key of cloud resource instance.
         */
        key: string;
        /**
         * The tag value of cloud resource instance.
         */
        value: string;
    }

    export interface GatewaysTagFilter {
        /**
         * The tag key of cloud resource instance.
         */
        key?: string;
        /**
         * The tag value of cloud resource instance.
         */
        value?: string;
    }

    export interface VirtualInterfaceTag {
        /**
         * The tag key.
         */
        key?: string;
        /**
         * The tag value.
         */
        value?: string;
    }

    export interface VirtualInterfacesTagFilter {
        /**
         * The tag key of cloud resource instance.
         */
        key?: string;
        /**
         * The tag value of cloud resource instance.
         */
        value?: string;
    }

    export interface VirtualInterfacesVirtualInterface {
        /**
         * The account ID which this virtual interface belongs.
         */
        accountId: string;
        /**
         * The band width limit of virtual interface,in Mbps.
         */
        bandwidth: number;
        /**
         * The BFD detect interval.
         */
        bfdDetectInterval: number;
        /**
         * The BFD detect times.
         */
        bfdDetectMultiplier: number;
        /**
         * The creation time of virtual interface.
         */
        creationTime: string;
        /**
         * The description of the virtual interface.
         */
        description: string;
        /**
         * The direct connect connection ID that associated with this virtual interface.
         */
        directConnectConnectionId: string;
        /**
         * The direct connect gateway ID that associated with this virtual interface.
         */
        directConnectGatewayId: string;
        /**
         * Whether enable BFD detect.
         */
        enableBfd: boolean;
        /**
         * Whether enable NQA detect.
         */
        enableNqa: boolean;
        /**
         * The local IP that associated with this virtual interface.
         */
        localIp: string;
        /**
         * The NQA detect interval.
         */
        nqaDetectInterval: number;
        /**
         * The NAQ detect times.
         */
        nqaDetectMultiplier: number;
        /**
         * The peer IP that associated with this virtual interface.
         */
        peerIp: string;
        /**
         * The route type of virtual interface.
         */
        routeType: string;
        /**
         * The status of virtaul interface.
         */
        status: string;
        /**
         * The tags that direct connect gateway added.
         */
        tags: outputs.direct_connect.VirtualInterfacesVirtualInterfaceTag[];
        /**
         * The update time of virtual interface.
         */
        updateTime: string;
        /**
         * The virtual interface ID.
         */
        virtualInterfaceId: string;
        /**
         * The name of virtual interface.
         */
        virtualInterfaceName: string;
        /**
         * The VLAN ID of virtual interface.
         */
        vlanId: number;
    }

    export interface VirtualInterfacesVirtualInterfaceTag {
        /**
         * The tag key of cloud resource instance.
         */
        key: string;
        /**
         * The tag value of cloud resource instance.
         */
        value: string;
    }

}

export namespace ebs {
    export interface VolumeTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface VolumesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface VolumesVolume {
        billingType: number;
        createdAt: string;
        deleteWithInstance: boolean;
        description: string;
        deviceName: string;
        expiredTime: string;
        id: string;
        imageId: string;
        /**
         * The Id of instance.
         */
        instanceId: string;
        /**
         * The Kind of Volume.
         */
        kind: string;
        payType: string;
        renewType: number;
        size: number;
        status: string;
        /**
         * Tags.
         */
        tags: outputs.ebs.VolumesVolumeTag[];
        tradeStatus: number;
        updatedAt: string;
        volumeId: string;
        /**
         * The name of Volume.
         */
        volumeName: string;
        /**
         * The type of Volume.
         */
        volumeType: string;
        /**
         * The Id of Zone.
         */
        zoneId: string;
    }

    export interface VolumesVolumeTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

}

export namespace ecs {
    export interface AvailableResourcesAvailableZone {
        /**
         * The resource information of the available zone.
         */
        availableResources: outputs.ecs.AvailableResourcesAvailableZoneAvailableResource[];
        /**
         * The id of the region.
         */
        regionId: string;
        /**
         * The resource status of the available zone. Valid values: `Available`, `SoldOut`.
         */
        status: string;
        /**
         * The id of available zone.
         */
        zoneId: string;
    }

    export interface AvailableResourcesAvailableZoneAvailableResource {
        /**
         * The supported resource information.
         */
        supportedResources: outputs.ecs.AvailableResourcesAvailableZoneAvailableResourceSupportedResource[];
        /**
         * The type of resource. Valid values: `InstanceType`, `DedicatedHost`.
         */
        type: string;
    }

    export interface AvailableResourcesAvailableZoneAvailableResourceSupportedResource {
        /**
         * The resource status of the available zone. Valid values: `Available`, `SoldOut`.
         */
        status: string;
        /**
         * The value of the resource.
         */
        value: string;
    }

    export interface CommandsCommand {
        /**
         * The base64 encoded content of the ecs command.
         */
        commandContent: string;
        /**
         * The id of ecs command.
         */
        commandId: string;
        /**
         * The provider of public command. When this field is not specified, query for custom commands.
         */
        commandProvider: string;
        /**
         * The create time of the ecs command.
         */
        createdAt: string;
        /**
         * The description of the ecs command.
         */
        description: string;
        /**
         * The id of the ecs command.
         */
        id: string;
        /**
         * The invocation times of the ecs command. Public commands do not display the invocation times.
         */
        invocationTimes: number;
        /**
         * The name of ecs command. This field support fuzzy query.
         */
        name: string;
        /**
         * The timeout of the ecs command.
         */
        timeout: number;
        /**
         * The type of ecs command. Valid values: `Shell`.
         */
        type: string;
        /**
         * The update time of the ecs command.
         */
        updatedAt: string;
        /**
         * The username of the ecs command.
         */
        username: string;
        /**
         * The working directory of the ecs command.
         */
        workingDir: string;
    }

    export interface DeploymentSetsDeploymentSet {
        /**
         * The ID of ECS DeploymentSet.
         */
        deploymentSetId: string;
        /**
         * The name of ECS DeploymentSet.
         */
        deploymentSetName: string;
        /**
         * The description of ECS DeploymentSet.
         */
        description: string;
        /**
         * The granularity of ECS DeploymentSet.Valid values: switch, host, rack.
         */
        granularity: string;
        /**
         * The strategy of ECS DeploymentSet.
         */
        strategy: string;
    }

    export interface ImagesImage {
        /**
         * The architecture of Image.
         */
        architecture: string;
        /**
         * The create time of Image.
         */
        createdAt: string;
        /**
         * The description of Image.
         */
        description: string;
        /**
         * The ID of Image.
         */
        imageId: string;
        /**
         * The name of Image.
         */
        imageName: string;
        /**
         * Whether the Image support cloud-init.
         */
        isSupportCloudInit: boolean;
        /**
         * The name of Image operating system.
         */
        osName: string;
        /**
         * The operating system type of Image.
         */
        osType: string;
        /**
         * The platform of Image.
         */
        platform: string;
        /**
         * The platform version of Image.
         */
        platformVersion: string;
        /**
         * The share mode of Image.
         */
        shareStatus: string;
        /**
         * The size(GiB) of Image.
         */
        size: number;
        /**
         * A list of Image status, the value can be `available` or `creating` or `error`.
         */
        status: string;
        /**
         * The update time of Image.
         */
        updatedAt: string;
        /**
         * The visibility of Image.
         */
        visibility: string;
    }

    export interface InstanceCpuOptions {
        /**
         * The number of subnuma in socket, only support for ebm. `1` indicates disabling SNC/NPS function. When importing resources, this attribute will not be imported. If this attribute is set, please use lifecycle and ignoreChanges ignore changes in fields.
         */
        numaPerSocket?: number;
        /**
         * The per core of threads, only support for ebm. `1` indicates disabling hyper threading function.
         */
        threadsPerCore: number;
    }

    export interface InstanceDataVolume {
        /**
         * The delete with instance flag of volume.
         */
        deleteWithInstance?: boolean;
        /**
         * The size of volume. The value range of the data volume size is ESSD_PL0: 10~32768, ESSD_FlexPL: 10~32768, PTSSD: 20~8192.
         */
        size: number;
        /**
         * The type of volume, the value is `PTSSD` or `ESSD_PL0` or `ESSD_PL1` or `ESSD_PL2` or `ESSD_FlexPL`.
         */
        volumeType: string;
    }

    export interface InstanceGpuDevice {
        /**
         * The Count of GPU device.
         */
        count: number;
        /**
         * The Encrypted Memory Size of GPU device.
         */
        encryptedMemorySize: number;
        /**
         * The memory size of ECS instance.
         */
        memorySize: number;
        /**
         * The Product Name of GPU device.
         */
        productName: string;
    }

    export interface InstanceSecondaryNetworkInterface {
        /**
         * The private ip address of primary networkInterface.
         */
        primaryIpAddress: string;
        /**
         * The security group ID set of secondary networkInterface.
         */
        securityGroupIds: string[];
        /**
         * The subnet ID of secondary networkInterface.
         */
        subnetId: string;
    }

    export interface InstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface InstanceTypesInstanceType {
        /**
         * The CPU benchmark performance that can be provided steadily by on-demand instances is determined by the instance type.
         */
        baselineCredit: number;
        /**
         * The GPU device info of Instance.
         */
        gpus: outputs.ecs.InstanceTypesInstanceTypeGpus[];
        /**
         * The CPU credits obtained at once when creating a on-demand performance instance are fixed at 30 credits per vCPU.
         */
        initialCredit: number;
        /**
         * The instance type family.
         */
        instanceTypeFamily: string;
        /**
         * The id of the instance type.
         */
        instanceTypeId: string;
        /**
         * Local disk configuration information corresponding to instance specifications.
         */
        localVolumes: outputs.ecs.InstanceTypesInstanceTypeLocalVolume[];
        /**
         * Memory information of instance specifications.
         */
        memories: outputs.ecs.InstanceTypesInstanceTypeMemory[];
        /**
         * Network information of instance specifications.
         */
        networks: outputs.ecs.InstanceTypesInstanceTypeNetwork[];
        /**
         * CPU information of instance specifications.
         */
        processors: outputs.ecs.InstanceTypesInstanceTypeProcessor[];
        /**
         * RDMA Specification Information.
         */
        rdmas: outputs.ecs.InstanceTypesInstanceTypeRdma[];
        /**
         * Cloud disk information for instance specifications.
         */
        volumes: outputs.ecs.InstanceTypesInstanceTypeVolume[];
    }

    export interface InstanceTypesInstanceTypeGpus {
        /**
         * GPU device information list.
         */
        gpuDevices: outputs.ecs.InstanceTypesInstanceTypeGpusGpuDevice[];
    }

    export interface InstanceTypesInstanceTypeGpusGpuDevice {
        /**
         * The number of local disks mounted on the instance.
         */
        count: number;
        /**
         * Memory information of instance specifications.
         */
        memories: outputs.ecs.InstanceTypesInstanceTypeGpusGpuDeviceMemory[];
        /**
         * The Product Name of GPU device.
         */
        productName: string;
    }

    export interface InstanceTypesInstanceTypeGpusGpuDeviceMemory {
        /**
         * The Encrypted Memory Size of GPU device.
         */
        encryptedSize: number;
        /**
         * Memory size, unit: MiB.
         */
        size: number;
    }

    export interface InstanceTypesInstanceTypeLocalVolume {
        /**
         * The number of local disks mounted on the instance.
         */
        count: number;
        /**
         * Memory size, unit: MiB.
         */
        size: number;
        /**
         * The type of volume.
         */
        volumeType: string;
    }

    export interface InstanceTypesInstanceTypeMemory {
        /**
         * The Encrypted Memory Size of GPU device.
         */
        encryptedSize: number;
        /**
         * Memory size, unit: MiB.
         */
        size: number;
    }

    export interface InstanceTypesInstanceTypeNetwork {
        /**
         * Network benchmark bandwidth capacity (out/in), unit: Mbps.
         */
        baselineBandwidthMbps: number;
        /**
         * Peak network bandwidth capacity (out/in), unit: Mbps.
         */
        maximumBandwidthMbps: number;
        /**
         * Maximum number of elastic network interfaces supported for attachment.
         */
        maximumNetworkInterfaces: number;
        /**
         * Maximum number of IPv4 addresses for a single elastic network interface.
         */
        maximumPrivateIpv4AddressesPerNetworkInterface: number;
        /**
         * Maximum queue number for a single elastic network interface, including the queue number supported by the primary network interface and the auxiliary network interface.
         */
        maximumQueuesPerNetworkInterface: number;
        /**
         * Network packet sending and receiving capacity (in+out), unit: Kpps.
         */
        maximumThroughputKpps: number;
    }

    export interface InstanceTypesInstanceTypeProcessor {
        /**
         * CPU clock speed, unit: GHz.
         */
        baseFrequency: number;
        /**
         * The number of ECS instance CPU cores.
         */
        cpus: number;
        /**
         * CPU model.
         */
        model: string;
        /**
         * CPU Turbo Boost, unit: GHz.
         */
        turboFrequency: number;
    }

    export interface InstanceTypesInstanceTypeRdma {
        /**
         * Number of RDMA network cards.
         */
        rdmaNetworkInterfaces: number;
    }

    export interface InstanceTypesInstanceTypeVolume {
        /**
         * The maximum number of volumes.
         */
        maximumCount: number;
        /**
         * List of supported volume types.
         */
        supportedVolumeTypes: string[];
    }

    export interface InstancesInstance {
        /**
         * The number of ECS instance CPU cores.
         */
        cpus: number;
        /**
         * The create time of ECS instance.
         */
        createdAt: string;
        /**
         * The ID of DeploymentSet.
         */
        deploymentSetId: string;
        /**
         * The description of ECS instance.
         */
        description: string;
        /**
         * The GPU device info of Instance.
         */
        gpuDevices: outputs.ecs.InstancesInstanceGpuDevice[];
        /**
         * The host name of ECS instance.
         */
        hostName: string;
        /**
         * The image ID of ECS instance.
         */
        imageId: string;
        /**
         * The charge type of ECS instance.
         */
        instanceChargeType: string;
        /**
         * The ID of ECS instance.
         */
        instanceId: string;
        /**
         * The name of ECS instance.
         */
        instanceName: string;
        /**
         * The spec type of ECS instance.
         */
        instanceType: string;
        /**
         * The number of IPv6 addresses of the ECS instance.
         */
        ipv6AddressCount: number;
        /**
         * The  IPv6 address list of the ECS instance.
         */
        ipv6Addresses: string[];
        /**
         * The Flag of GPU instance.If the instance is GPU,The flag is true.
         */
        isGpu: boolean;
        /**
         * The ssh key ID of ECS instance.
         */
        keyPairId: string;
        /**
         * The key pair name of ECS instance.
         */
        keyPairName: string;
        /**
         * The memory size of ECS instance.
         */
        memorySize: number;
        /**
         * The networkInterface detail collection of ECS instance.
         */
        networkInterfaces: outputs.ecs.InstancesInstanceNetworkInterface[];
        /**
         * The os name of ECS instance.
         */
        osName: string;
        /**
         * The os type of ECS instance.
         */
        osType: string;
        /**
         * The ProjectName of ECS instance.
         */
        projectName: string;
        /**
         * The spot price limit of ECS instance.
         */
        spotPriceLimit: number;
        /**
         * The spot strategy of ECS instance.
         */
        spotStrategy: string;
        /**
         * The status of ECS instance.
         */
        status: string;
        /**
         * The stop mode of ECS instance.
         */
        stoppedMode: string;
        /**
         * Tags.
         */
        tags: outputs.ecs.InstancesInstanceTag[];
        /**
         * The update time of ECS instance.
         */
        updatedAt: string;
        /**
         * The volume detail collection of volume.
         */
        volumes: outputs.ecs.InstancesInstanceVolume[];
        /**
         * The VPC ID of ECS instance.
         */
        vpcId: string;
        /**
         * The available zone ID of ECS instance.
         */
        zoneId: string;
    }

    export interface InstancesInstanceGpuDevice {
        /**
         * The Count of GPU device.
         */
        count: number;
        /**
         * The Encrypted Memory Size of GPU device.
         */
        encryptedMemorySize: number;
        /**
         * The memory size of ECS instance.
         */
        memorySize: number;
        /**
         * The Product Name of GPU device.
         */
        productName: string;
    }

    export interface InstancesInstanceNetworkInterface {
        /**
         * The mac address of networkInterface.
         */
        macAddress: string;
        /**
         * The ID of networkInterface.
         */
        networkInterfaceId: string;
        /**
         * The primary ip address of ECS instance.
         */
        primaryIpAddress: string;
        /**
         * The subnet ID of networkInterface.
         */
        subnetId: string;
        /**
         * The type of networkInterface.
         */
        type: string;
        /**
         * The VPC ID of ECS instance.
         */
        vpcId: string;
    }

    export interface InstancesInstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface InstancesInstanceVolume {
        /**
         * The delete with instance flag of volume.
         */
        deleteWithInstance: boolean;
        /**
         * The size of volume.
         */
        size: number;
        /**
         * The ID of volume.
         */
        volumeId: string;
        /**
         * The Name of volume.
         */
        volumeName: string;
        /**
         * The type of volume.
         */
        volumeType: string;
    }

    export interface InstancesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface InvocationResultsInvocationResult {
        /**
         * The id of ecs command.
         */
        commandId: string;
        /**
         * The end time of the ecs invocation in the instance.
         */
        endTime: string;
        /**
         * The error code of the ecs invocation.
         */
        errorCode: string;
        /**
         * The error message of the ecs invocation.
         */
        errorMessage: string;
        /**
         * The exit code of the ecs command.
         */
        exitCode: number;
        /**
         * The id of the ecs invocation result.
         */
        id: string;
        /**
         * The id of ecs instance.
         */
        instanceId: string;
        /**
         * The id of ecs invocation.
         */
        invocationId: string;
        /**
         * The id of the ecs invocation result.
         */
        invocationResultId: string;
        /**
         * The list of status of ecs invocation in a single instance. Valid values: `Pending`, `Running`, `Success`, `Failed`, `Timeout`.
         */
        invocationResultStatus: string;
        /**
         * The base64 encoded output message of the ecs invocation.
         */
        output: string;
        /**
         * The start time of the ecs invocation in the instance.
         */
        startTime: string;
        /**
         * The username of the ecs command.
         */
        username: string;
    }

    export interface InvocationsInvocation {
        /**
         * The base64 encoded content of the ecs command.
         */
        commandContent: string;
        /**
         * The description of the ecs command.
         */
        commandDescription: string;
        /**
         * The id of ecs command.
         */
        commandId: string;
        /**
         * The name of ecs command. This field support fuzzy query.
         */
        commandName: string;
        /**
         * The provider of the ecs command.
         */
        commandProvider: string;
        /**
         * The type of ecs command. Valid values: `Shell`.
         */
        commandType: string;
        /**
         * The end time of the ecs invocation.
         */
        endTime: string;
        /**
         * The frequency of the ecs invocation.
         */
        frequency: string;
        /**
         * The id of the ecs invocation.
         */
        id: string;
        /**
         * The list of ECS instance IDs.
         */
        instanceIds: string[];
        /**
         * The instance number of the ecs invocation.
         */
        instanceNumber: number;
        /**
         * The description of the ecs invocation.
         */
        invocationDescription: string;
        /**
         * The id of ecs invocation.
         */
        invocationId: string;
        /**
         * The name of ecs invocation. This field support fuzzy query.
         */
        invocationName: string;
        /**
         * The list of status of ecs invocation. Valid values: `Pending`, `Scheduled`, `Running`, `Success`, `Failed`, `Stopped`, `PartialFailed`, `Finished`.
         */
        invocationStatus: string;
        /**
         * The launch time of the ecs invocation.
         */
        launchTime: string;
        /**
         * The recurrence end time of the ecs invocation.
         */
        recurrenceEndTime: string;
        /**
         * The repeat mode of ecs invocation. Valid values: `Once`, `Rate`, `Fixed`.
         */
        repeatMode: string;
        /**
         * The start time of the ecs invocation.
         */
        startTime: string;
        /**
         * The timeout of the ecs command.
         */
        timeout: number;
        /**
         * The username of the ecs command.
         */
        username: string;
        /**
         * The working directory of the ecs command.
         */
        workingDir: string;
    }

    export interface KeyPairsKeyPair {
        /**
         * The creation time of key pair.
         */
        createdAt: string;
        /**
         * The description of key pair.
         */
        description: string;
        /**
         * The finger print info.
         */
        fingerPrint: string;
        /**
         * The id of key pair.
         */
        id: string;
        /**
         * The id of key pair.
         */
        keyPairId: string;
        /**
         * Name of key pair.
         */
        keyPairName: string;
        /**
         * The update time of key pair.
         */
        updatedAt: string;
    }

    export interface LaunchTemplateNetworkInterface {
        /**
         * The security group ID associated with the NIC.
         */
        securityGroupIds?: string[];
        /**
         * The private network subnet ID of the instance, when creating the instance, supports binding the secondary NIC at the same time.
         */
        subnetId?: string;
    }

    export interface LaunchTemplateVolume {
        /**
         * The delete with instance flag of volume. Valid values: true, false. Default value: true.
         */
        deleteWithInstance?: boolean;
        /**
         * The size of volume.
         */
        size?: number;
        /**
         * The type of volume.
         */
        volumeType?: string;
    }

    export interface LaunchTemplatesLaunchTemplate {
        /**
         * The created time of the launch template.
         */
        createdAt: string;
        /**
         * The default version of the launch template.
         */
        defaultVersionNumber: number;
        /**
         * The description of the instance.
         */
        description: string;
        /**
         * The EIP bandwidth which the scaling configuration set.
         */
        eipBandwidth: number;
        /**
         * The EIP billing type which the scaling configuration set. Valid values: PostPaidByBandwidth, PostPaidByTraffic.
         */
        eipBillingType: string;
        /**
         * The EIP ISP which the scaling configuration set. Valid values: BGP, ChinaMobile, ChinaUnicom, ChinaTelecom.
         */
        eipIsp: string;
        /**
         * The host name of the instance.
         */
        hostName: string;
        /**
         * The hpc cluster id.
         */
        hpcClusterId: string;
        /**
         * The id of the launch template.
         */
        id: string;
        /**
         * The image id.
         */
        imageId: string;
        /**
         * The charge type of the instance and volume.
         */
        instanceChargeType: string;
        /**
         * The name of the instance.
         */
        instanceName: string;
        /**
         * When you log in to the instance using the SSH key pair, enter the name of the key pair.
         */
        keyPairName: string;
        /**
         * The latest version of the launch template.
         */
        latestVersionNumber: number;
        /**
         * The id of the launch template.
         */
        launchTemplateId: string;
        /**
         * The name of the launch template.
         */
        launchTemplateName: string;
        /**
         * The list of network interfaces.
         */
        networkInterfaces: outputs.ecs.LaunchTemplatesLaunchTemplateNetworkInterface[];
        /**
         * Whether to open the security reinforcement.
         */
        securityEnhancementStrategy: string;
        /**
         * The index of the ordered suffix.
         */
        suffixIndex: number;
        /**
         * Indicates whether the ordered suffix is automatically added to Hostname and InstanceName when multiple instances are created.
         */
        uniqueSuffix: boolean;
        /**
         * The updated time of the launch template.
         */
        updatedAt: string;
        /**
         * The latest version description of the launch template.
         */
        versionDescription: string;
        /**
         * The list of volume of the scaling configuration.
         */
        volumes: outputs.ecs.LaunchTemplatesLaunchTemplateVolume[];
        /**
         * The vpc id.
         */
        vpcId: string;
        /**
         * The zone ID of the instance.
         */
        zoneId: string;
    }

    export interface LaunchTemplatesLaunchTemplateNetworkInterface {
        /**
         * The security group ID associated with the NIC.
         */
        securityGroupIds: string[];
        /**
         * The private network subnet ID of the instance, when creating the instance, supports binding the secondary NIC at the same time.
         */
        subnetId: string;
    }

    export interface LaunchTemplatesLaunchTemplateVolume {
        /**
         * The delete with instance flag of volume. Valid values: true, false. Default value: true.
         */
        deleteWithInstance: boolean;
        /**
         * The size of volume.
         */
        size: number;
        /**
         * The type of volume.
         */
        volumeType: string;
    }

    export interface RegionsRegion {
        /**
         * The id of the region.
         */
        id: string;
        /**
         * The id of the region.
         */
        regionId: string;
    }

    export interface ZonesZone {
        /**
         * The id of the zone.
         */
        id: string;
        /**
         * The id of the zone.
         */
        zoneId: string;
    }

}

export namespace eip {
    export interface AddressTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface AddressesAddress {
        /**
         * The id of the EIP address.
         */
        allocationId: string;
        /**
         * The allocation time of the EIP.
         */
        allocationTime: string;
        /**
         * The peek bandwidth of the EIP.
         */
        bandwidth: number;
        /**
         * The id of the bandwidth package.
         */
        bandwidthPackageId: string;
        /**
         * The billing type of the EIP.
         */
        billingType: string;
        /**
         * The business status of the EIP.
         */
        businessStatus: string;
        /**
         * The deleted time of the EIP.
         */
        deletedTime: string;
        /**
         * The description of the EIP.
         */
        description: string;
        /**
         * The EIP ip address of the EIP.
         */
        eipAddress: string;
        /**
         * The expired time of the EIP.
         */
        expiredTime: string;
        /**
         * The id of the EIP address.
         */
        id: string;
        /**
         * The instance id which be associated to the EIP.
         */
        instanceId: string;
        /**
         * The type of the associated instance.
         */
        instanceType: string;
        /**
         * An ISP of EIP Address, the value can be `BGP` or `ChinaMobile` or `ChinaUnicom` or `ChinaTelecom`.
         */
        isp: string;
        /**
         * The lock reason of the EIP.
         */
        lockReason: string;
        /**
         * A name of EIP.
         */
        name: string;
        /**
         * The overdue time of the EIP.
         */
        overdueTime: string;
        /**
         * The ProjectName of EIP.
         */
        projectName: string;
        /**
         * Security protection types for shared bandwidth packages. Parameter - N: Indicates the number of security protection types, currently only supports taking 1. Value: `AntiDDoS_Enhanced`.
         */
        securityProtectionTypes: string[];
        /**
         * A status of EIP, the value can be `Attaching` or `Detaching` or `Attached` or `Available`.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.eip.AddressesAddressTag[];
        /**
         * The last update time of the EIP.
         */
        updatedAt: string;
    }

    export interface AddressesAddressTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface AddressesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

}

export namespace escloud {
    export interface InstanceInstanceConfiguration {
        /**
         * The password of administrator account. When importing resources, this attribute will not be imported. If this attribute is set, please use lifecycle and ignoreChanges ignore changes in fields.
         */
        adminPassword: string;
        /**
         * The name of administrator account(should be admin).
         */
        adminUserName: string;
        /**
         * The charge type of ESCloud instance, the value can be PostPaid or PrePaid.
         */
        chargeType: string;
        /**
         * Configuration code used for billing.
         */
        configurationCode: string;
        /**
         * Whether Https access is enabled.
         */
        enableHttps: boolean;
        /**
         * Whether the Master node is independent.
         */
        enablePureMaster: boolean;
        /**
         * Whether to force restart when changes are made. If true, it means that the cluster will be forced to restart without paying attention to instance availability. Works only on modified the nodeSpecsAssigns field.
         */
        forceRestartAfterScale?: boolean;
        /**
         * The name of ESCloud instance.
         */
        instanceName?: string;
        /**
         * The maintainable date for the instance. Works only on modified scenes.
         */
        maintenanceDays: string[];
        /**
         * The maintainable time period for the instance. Works only on modified scenes.
         */
        maintenanceTime: string;
        /**
         * The number and configuration of various ESCloud instance node. Kibana NodeSpecsAssign should not be modified.
         */
        nodeSpecsAssigns: outputs.escloud.InstanceInstanceConfigurationNodeSpecsAssign[];
        /**
         * The project name  to which the ESCloud instance belongs.
         */
        projectName: string;
        /**
         * The region ID of ESCloud instance.
         */
        regionId: string;
        /**
         * The ID of subnet, the subnet must belong to the AZ selected.
         */
        subnetId: string;
        /**
         * The version of ESCloud instance, the value is V6_7 or V7_10.
         */
        version: string;
        /**
         * The available zone ID of ESCloud instance.
         */
        zoneId: string;
        /**
         * The zone count of the ESCloud instance used.
         */
        zoneNumber: number;
    }

    export interface InstanceInstanceConfigurationNodeSpecsAssign {
        /**
         * The number of node.
         */
        number: number;
        /**
         * The name of compute resource spec, the value is `kibana.x2.small` or `es.x4.medium` or `es.x4.large` or `es.x4.xlarge` or `es.x2.2xlarge` or `es.x4.2xlarge` or `es.x2.3xlarge`.
         */
        resourceSpecName: string;
        /**
         * The size of storage. Kibana NodeSpecsAssign should not specify this field.
         */
        storageSize?: number;
        /**
         * The name of storage spec. Kibana NodeSpecsAssign should not specify this field.
         */
        storageSpecName?: string;
        /**
         * The type of node, the value is `Master` or `Hot` or `Kibana`.
         */
        type: string;
    }

    export interface InstancesInstance {
        /**
         * The charge status of instance.
         */
        chargeEnabled: boolean;
        /**
         * The create time of instance.
         */
        createTime: string;
        /**
         * whether enable es private network.
         */
        enableEsPrivateNetwork: boolean;
        /**
         * whether enable es public network.
         */
        enableEsPublicNetwork: boolean;
        /**
         * whether enable kibana private network.
         */
        enableKibanaPrivateNetwork: boolean;
        /**
         * whether enable kibana public network.
         */
        enableKibanaPublicNetwork: boolean;
        /**
         * The es inner endpoint of instance.
         */
        esInnerEndpoint: string;
        /**
         * The es private domain of instance.
         */
        esPrivateDomain: string;
        /**
         * The es private endpoint of instance.
         */
        esPrivateEndpoint: string;
        /**
         * The es public domain of instance.
         */
        esPublicDomain: string;
        /**
         * The es public endpoint of instance.
         */
        esPublicEndpoint: string;
        /**
         * The expire time of instance.
         */
        expireDate: string;
        /**
         * The Id of instance.
         */
        id: string;
        /**
         * The configuration of instance.
         */
        instanceConfiguration: outputs.escloud.InstancesInstanceInstanceConfiguration;
        /**
         * The Id of instance.
         */
        instanceId: string;
        /**
         * The kibana private domain of instance.
         */
        kibanaPrivateDomain: string;
        /**
         * The kibana public domain of instance.
         */
        kibanaPublicDomain: string;
        /**
         * The maintenance day of instance.
         */
        maintenanceDays: string[];
        /**
         * The maintenance time of instance.
         */
        maintenanceTime: string;
        /**
         * The namespace of instance.
         */
        namespace: string;
        /**
         * The nodes info of instance.
         */
        nodes: outputs.escloud.InstancesInstanceNode[];
        /**
         * The plugin info of instance.
         */
        plugins: outputs.escloud.InstancesInstancePlugin[];
        /**
         * The status of instance.
         */
        status: string;
        /**
         * The total nodes of instance.
         */
        totalNodes: number;
        /**
         * The user id of instance.
         */
        userId: string;
    }

    export interface InstancesInstanceInstanceConfiguration {
        /**
         * The user name of instance.
         */
        adminUserName: string;
        /**
         * The charge type of instance.
         */
        chargeType: string;
        /**
         * whether enable https.
         */
        enableHttps: boolean;
        /**
         * Whether enable pure master.
         */
        enablePureMaster: boolean;
        /**
         * The node number of host.
         */
        hotNodeNumber: number;
        /**
         * The node resource spec of host.
         */
        hotNodeResourceSpec: outputs.escloud.InstancesInstanceInstanceConfigurationHotNodeResourceSpec;
        /**
         * The node storage spec of host.
         */
        hotNodeStorageSpec: outputs.escloud.InstancesInstanceInstanceConfigurationHotNodeStorageSpec;
        /**
         * The name of instance.
         */
        instanceName: string;
        /**
         * The node number of kibana.
         */
        kibanaNodeNumber: number;
        /**
         * The node resource spec of kibana.
         */
        kibanaNodeResourceSpec: outputs.escloud.InstancesInstanceInstanceConfigurationKibanaNodeResourceSpec;
        /**
         * The node storage spec of kibana.
         */
        kibanaNodeStorageSpec: outputs.escloud.InstancesInstanceInstanceConfigurationKibanaNodeStorageSpec;
        /**
         * The node number of master.
         */
        masterNodeNumber: number;
        /**
         * The node resource spec of master.
         */
        masterNodeResourceSpec: outputs.escloud.InstancesInstanceInstanceConfigurationMasterNodeResourceSpec;
        /**
         * The node storage spec of master.
         */
        masterNodeStorageSpec: outputs.escloud.InstancesInstanceInstanceConfigurationMasterNodeStorageSpec;
        /**
         * The period of project.
         */
        period: number;
        /**
         * The name of project.
         */
        projectName: string;
        /**
         * The region info of instance.
         */
        regionId: string;
        /**
         * The subnet info.
         */
        subnet: outputs.escloud.InstancesInstanceInstanceConfigurationSubnet;
        /**
         * The version of plugin.
         */
        version: string;
        /**
         * The vpc info.
         */
        vpc: outputs.escloud.InstancesInstanceInstanceConfigurationVpc;
        /**
         * The zoneId of instance.
         */
        zoneId: string;
        /**
         * The zone number of instance.
         */
        zoneNumber: number;
    }

    export interface InstancesInstanceInstanceConfigurationHotNodeResourceSpec {
        /**
         * The cpu info of resource spec.
         */
        cpu: number;
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The memory info of resource spec.
         */
        memory: number;
        /**
         * The name of storage spec.
         */
        name: string;
    }

    export interface InstancesInstanceInstanceConfigurationHotNodeStorageSpec {
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The max size of storage spec.
         */
        maxSize: number;
        /**
         * The min size of storage spec.
         */
        minSize: number;
        /**
         * The name of storage spec.
         */
        name: string;
        /**
         * The size of storage spec.
         */
        size: number;
        /**
         * The type of storage spec.
         */
        type: string;
    }

    export interface InstancesInstanceInstanceConfigurationKibanaNodeResourceSpec {
        /**
         * The cpu info of resource spec.
         */
        cpu: number;
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The memory info of resource spec.
         */
        memory: number;
        /**
         * The name of storage spec.
         */
        name: string;
    }

    export interface InstancesInstanceInstanceConfigurationKibanaNodeStorageSpec {
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The max size of storage spec.
         */
        maxSize: number;
        /**
         * The min size of storage spec.
         */
        minSize: number;
        /**
         * The name of storage spec.
         */
        name: string;
        /**
         * The size of storage spec.
         */
        size: number;
        /**
         * The type of storage spec.
         */
        type: string;
    }

    export interface InstancesInstanceInstanceConfigurationMasterNodeResourceSpec {
        /**
         * The cpu info of resource spec.
         */
        cpu: number;
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The memory info of resource spec.
         */
        memory: number;
        /**
         * The name of storage spec.
         */
        name: string;
    }

    export interface InstancesInstanceInstanceConfigurationMasterNodeStorageSpec {
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The max size of storage spec.
         */
        maxSize: number;
        /**
         * The min size of storage spec.
         */
        minSize: number;
        /**
         * The name of storage spec.
         */
        name: string;
        /**
         * The size of storage spec.
         */
        size: number;
        /**
         * The type of storage spec.
         */
        type: string;
    }

    export interface InstancesInstanceInstanceConfigurationSubnet {
        /**
         * The id of subnet.
         */
        subnetId: string;
        /**
         * The name of subnet.
         */
        subnetName: string;
    }

    export interface InstancesInstanceInstanceConfigurationVpc {
        /**
         * The id of vpc.
         */
        vpcId: string;
        /**
         * The name of vpc.
         */
        vpcName: string;
    }

    export interface InstancesInstanceNode {
        /**
         * Is cold node.
         */
        isCold: boolean;
        /**
         * Is hot node.
         */
        isHot: boolean;
        /**
         * Is kibana node.
         */
        isKibana: boolean;
        /**
         * Is master node.
         */
        isMaster: boolean;
        /**
         * Is warm node.
         */
        isWarm: boolean;
        /**
         * The show name of node.
         */
        nodeDisplayName: string;
        /**
         * The name of node.
         */
        nodeName: string;
        /**
         * The node resource spec of master.
         */
        resourceSpec: outputs.escloud.InstancesInstanceNodeResourceSpec;
        /**
         * The restart times of node.
         */
        restartNumber: number;
        /**
         * The start time of node.
         */
        startTime: string;
        /**
         * The status of instance.
         */
        status: string;
        /**
         * The node storage spec of master.
         */
        storageSpec: outputs.escloud.InstancesInstanceNodeStorageSpec;
    }

    export interface InstancesInstanceNodeResourceSpec {
        /**
         * The cpu info of resource spec.
         */
        cpu: number;
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The memory info of resource spec.
         */
        memory: number;
        /**
         * The name of storage spec.
         */
        name: string;
    }

    export interface InstancesInstanceNodeStorageSpec {
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The show name of storage spec.
         */
        displayName: string;
        /**
         * The max size of storage spec.
         */
        maxSize: number;
        /**
         * The min size of storage spec.
         */
        minSize: number;
        /**
         * The name of storage spec.
         */
        name: string;
        /**
         * The size of storage spec.
         */
        size: number;
        /**
         * The type of storage spec.
         */
        type: string;
    }

    export interface InstancesInstancePlugin {
        /**
         * The description of plugin.
         */
        description: string;
        /**
         * The name of plugin.
         */
        pluginName: string;
        /**
         * The version of plugin.
         */
        version: string;
    }

    export interface RegionsRegion {
        /**
         * The id of the region.
         */
        regionId: string;
        /**
         * The name of region.
         */
        regionName: string;
    }

    export interface ZonesZone {
        /**
         * The id of the zone.
         */
        id: string;
        /**
         * The id of the zone.
         */
        zoneId: string;
        /**
         * The name of the zone.
         */
        zoneName: string;
    }

}

export namespace iam {
    export interface AccessKeysAccessKeyMetadata {
        /**
         * The user access key id.
         */
        accessKeyId: string;
        /**
         * The user access key create date.
         */
        createDate: string;
        /**
         * The user access key status.
         */
        status: string;
        /**
         * The user access key update date.
         */
        updateDate: string;
        /**
         * The user names.
         */
        userName: string;
    }

    export interface PoliciesPolicy {
        /**
         * The create time of the Policy.
         */
        createDate: string;
        /**
         * The description of the Policy.
         */
        description: string;
        /**
         * The ID of the Policy.
         */
        id: string;
        /**
         * The document of the Policy.
         */
        policyDocument: string;
        /**
         * The name of the Policy.
         */
        policyName: string;
        /**
         * The resource name of the Policy.
         */
        policyTrn: string;
        /**
         * The type of the Policy.
         */
        policyType: string;
        /**
         * The role attach time of the Policy.The data show only query with role_name.
         */
        roleAttachDate: string;
        /**
         * The name of the IAM role.
         */
        roleName: string;
        /**
         * The update time of the Policy.
         */
        updateDate: string;
        /**
         * The user attach time of the Policy.The data show only query with user_name.
         */
        userAttachDate: string;
        /**
         * The name of the IAM user.
         */
        userName: string;
    }

    export interface RolesRole {
        /**
         * The create time of the Role.
         */
        createDate: string;
        /**
         * The description of the Role.
         */
        description: string;
        /**
         * The ID of the Role.
         */
        id: string;
        /**
         * The name of the Role, comma separated.
         */
        roleName: string;
        /**
         * The resource name of the Role.
         */
        trn: string;
        /**
         * The trust policy document of the Role.
         */
        trustPolicyDocument: string;
    }

    export interface SamlProvidersProvider {
        /**
         * Identity provider creation time, such as 20150123T123318Z.
         */
        createDate: string;
        /**
         * The description of the SAML provider.
         */
        description: string;
        /**
         * Metadata document, encoded in Base64.
         */
        encodedSamlMetadataDocument: string;
        /**
         * The name of the SAML provider.
         */
        samlProviderName: string;
        /**
         * SSO types, 1. Role-based SSO, 2. User-based SSO.
         */
        ssoType: number;
        /**
         * User SSO status, 1. Enabled, 2. Disable other console login methods after enabling, 3. Disabled, is a required field when creating user SSO.
         */
        status: number;
        /**
         * The format for the resource name of an identity provider is trn:iam::${accountID}:saml-provider/{$SAMLProviderName}.
         */
        trn: string;
        /**
         * Identity provider update time, such as: 20150123T123318Z.
         */
        updateDate: string;
    }

    export interface UserGroupPolicyAttachmentsPolicy {
        /**
         * Attached time.
         */
        attachDate: string;
        /**
         * The description.
         */
        description: string;
        /**
         * Name of the policy.
         */
        policyName: string;
        /**
         * Resource name of the strategy.
         */
        policyTrn: string;
        /**
         * The type of the policy.
         */
        policyType: string;
    }

    export interface UserGroupsUserGroup {
        /**
         * The id of the account.
         */
        accountId: number;
        /**
         * The creation date of the user group.
         */
        createDate: string;
        /**
         * The description of the user group.
         */
        description: string;
        /**
         * The display name of the user group.
         */
        displayName: string;
        /**
         * The update date of the user group.
         */
        updateDate: string;
        /**
         * The name of the user group.
         */
        userGroupName: string;
    }

    export interface UsersUser {
        /**
         * Main account ID to which the sub-user belongs.
         */
        accountId: string;
        /**
         * The create date of the user.
         */
        createDate: string;
        /**
         * The description of the user.
         */
        description: string;
        /**
         * The display name of the user.
         */
        displayName: string;
        /**
         * The email of the user.
         */
        email: string;
        /**
         * Whether the email has been verified.
         */
        emailIsVerify: boolean;
        /**
         * The mobile phone of the user.
         */
        mobilePhone: string;
        /**
         * Whether the phone number has been verified.
         */
        mobilePhoneIsVerify: boolean;
        /**
         * The trn of the user.
         */
        trn: string;
        /**
         * The update date of the user.
         */
        updateDate: string;
        /**
         * The id of the user.
         */
        userId: string;
        /**
         * The name of the user.
         */
        userName: string;
    }

}

export namespace mongodb {
    export interface AccountsAccount {
        /**
         * The name of account, current support only `root`.
         */
        accountName: string;
        /**
         * The privilege info of mongo instance.
         */
        accountPrivileges: outputs.mongodb.AccountsAccountAccountPrivilege[];
        /**
         * The type of account.
         */
        accountType: string;
    }

    export interface AccountsAccountAccountPrivilege {
        /**
         * The Name of DB.
         */
        dbName: string;
        /**
         * The Name of role.
         */
        roleName: string;
    }

    export interface EndpointsEndpoint {
        /**
         * The list of mongodb addresses.
         */
        dbAddresses: outputs.mongodb.EndpointsEndpointDbAddress[];
        /**
         * The ID of endpoint.
         */
        endpointId: string;
        /**
         * The endpoint information.
         */
        endpointStr: string;
        /**
         * The node type corresponding to the endpoint.
         */
        endpointType: string;
        /**
         * The network type of endpoint.
         */
        networkType: string;
        /**
         * The object ID corresponding to the endpoint.
         */
        objectId: string;
        /**
         * The subnet ID.
         */
        subnetId: string;
        /**
         * The VPC ID.
         */
        vpcId: string;
    }

    export interface EndpointsEndpointDbAddress {
        /**
         * The domain of mongodb connection.
         */
        addressDomain: string;
        /**
         * The IP of mongodb connection.
         */
        addressIp: string;
        /**
         * The port of mongodb connection.
         */
        addressPort: string;
        /**
         * The connection type of mongodb.
         */
        addressType: string;
        /**
         * The EIP ID bound to the instance's public network address.
         */
        eipId: string;
        /**
         * The node ID.
         */
        nodeId: string;
    }

    export interface InstanceMongo {
        /**
         * The mongos node ID.
         */
        mongosNodeId: string;
        /**
         * The spec of node.
         */
        nodeSpec: string;
        /**
         * The node status.
         */
        nodeStatus: string;
    }

    export interface InstanceParameterLogsParameterChangeLogs {
        /**
         * The modifying time of parameter.
         */
        modifyTime: string;
        /**
         * The new parameter value.
         */
        newParameterValue: string;
        /**
         * The old parameter value.
         */
        oldParameterValue: string;
        /**
         * The parameter name.
         */
        parameterName: string;
        /**
         * The node type to which the parameter belongs.
         */
        parameterRole: string;
        /**
         * The status of parameter change.
         */
        parameterStatus: string;
    }

    export interface InstanceParametersInstanceParameter {
        /**
         * The checking code of parameter.
         */
        checkingCode: string;
        /**
         * Whether the parameter supports modifying.
         */
        forceModify: boolean;
        /**
         * Does the new parameter value need to restart the instance to take effect after modification.
         */
        forceRestart: boolean;
        /**
         * The default value of parameter.
         */
        parameterDefaultValue: string;
        /**
         * The description of parameter.
         */
        parameterDescription: string;
        /**
         * The name of parameter.
         */
        parameterName: string;
        /**
         * The node type of instance parameter, valid value contains `Node`, `Shard`, `ConfigServer`, `Mongos`.
         */
        parameterRole: string;
        /**
         * The type of parameter value.
         */
        parameterType: string;
        /**
         * The value of parameter.
         */
        parameterValue: string;
    }

    export interface InstanceParametersParameter {
        /**
         * The database engine.
         */
        dbEngine: string;
        /**
         * The database engine version.
         */
        dbEngineVersion: string;
        /**
         * The instance ID to query.
         */
        instanceId: string;
        /**
         * The list of parameters.
         */
        instanceParameters: outputs.mongodb.InstanceParametersParameterInstanceParameter[];
        /**
         * The total parameters queried.
         */
        total: string;
    }

    export interface InstanceParametersParameterInstanceParameter {
        /**
         * The checking code of parameter.
         */
        checkingCode: string;
        /**
         * Whether the parameter supports modifying.
         */
        forceModify: boolean;
        /**
         * Does the new parameter value need to restart the instance to take effect after modification.
         */
        forceRestart: boolean;
        /**
         * The default value of parameter.
         */
        parameterDefaultValue: string;
        /**
         * The description of parameter.
         */
        parameterDescription: string;
        /**
         * The name of parameter.
         */
        parameterName: string;
        /**
         * The node type of instance parameter, valid value contains `Node`, `Shard`, `ConfigServer`, `Mongos`.
         */
        parameterRole: string;
        /**
         * The type of parameter value.
         */
        parameterType: string;
        /**
         * The value of parameter.
         */
        parameterValue: string;
    }

    export interface InstanceShard {
        /**
         * The shard id.
         */
        shardId: string;
    }

    export interface InstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface InstancesInstance {
        /**
         * Whether to enable automatic renewal.
         */
        autoRenew: boolean;
        /**
         * The charge status.
         */
        chargeStatus: string;
        /**
         * The charge type of instance.
         */
        chargeType: string;
        /**
         * The planned close time.
         */
        closedTime: string;
        /**
         * The list of config servers.
         */
        configServers: outputs.mongodb.InstancesInstanceConfigServer[];
        /**
         * The ID of config servers.
         */
        configServersId: string;
        /**
         * The creation time of instance.
         */
        createTime: string;
        /**
         * The db engine to query, valid value contains `MongoDB`.
         */
        dbEngine: string;
        /**
         * The version of db engine to query, valid value contains `MongoDB_4_0`.
         */
        dbEngineVersion: string;
        /**
         * The version string of database engine.
         */
        dbEngineVersionStr: string;
        /**
         * The expired time of instance.
         */
        expiredTime: string;
        /**
         * The instance ID to query.
         */
        instanceId: string;
        /**
         * The instance name to query.
         */
        instanceName: string;
        /**
         * The instance status to query.
         */
        instanceStatus: string;
        /**
         * The type of instance to query, the valid value contains `ReplicaSet` or `ShardedCluster`.
         */
        instanceType: string;
        /**
         * The list of mongos.
         */
        mongos: outputs.mongodb.InstancesInstanceMongo[];
        /**
         * The ID of mongos.
         */
        mongosId: string;
        /**
         * The node information.
         */
        nodes: outputs.mongodb.InstancesInstanceNode[];
        /**
         * The project name to which the instance belongs.
         */
        projectName: string;
        /**
         * The planned reclaim time of instance.
         */
        reclaimTime: string;
        /**
         * The list of shards.
         */
        shards: outputs.mongodb.InstancesInstanceShard[];
        /**
         * Whether ssl enabled.
         */
        sslEnable: boolean;
        /**
         * The ssl expire time.
         */
        sslExpireTime: string;
        /**
         * Whether ssl is valid.
         */
        sslIsValid: boolean;
        /**
         * The storage type of instance.
         */
        storageType: string;
        /**
         * The subnet id of instance.
         */
        subnetId: string;
        /**
         * Tags.
         */
        tags: outputs.mongodb.InstancesInstanceTag[];
        /**
         * The update time of instance.
         */
        updateTime: string;
        /**
         * The vpc id of instance to query.
         */
        vpcId: string;
        /**
         * The zone ID to query.
         */
        zoneId: string;
    }

    export interface InstancesInstanceConfigServer {
        /**
         * The config server node ID.
         */
        configServerNodeId: string;
        /**
         * The nod role.
         */
        nodeRole: string;
        /**
         * The node status.
         */
        nodeStatus: string;
        /**
         * The total memory in GB.
         */
        totalMemoryGb: number;
        /**
         * The total vCPU.
         */
        totalVcpu: number;
        /**
         * The used memory in GB.
         */
        usedMemoryGb: number;
        /**
         * The used vCPU.
         */
        usedVcpu: number;
        /**
         * The zone ID to query.
         */
        zoneId: string;
    }

    export interface InstancesInstanceMongo {
        /**
         * The mongos node ID.
         */
        mongosNodeId: string;
        /**
         * The node spec.
         */
        nodeSpec: string;
        /**
         * The node status.
         */
        nodeStatus: string;
        /**
         * The total memory in GB.
         */
        totalMemoryGb: number;
        /**
         * The total vCPU.
         */
        totalVcpu: number;
        /**
         * The used memory in GB.
         */
        usedMemoryGb: number;
        /**
         * The used vCPU.
         */
        usedVcpu: number;
        /**
         * The zone ID to query.
         */
        zoneId: string;
    }

    export interface InstancesInstanceNode {
        /**
         * The master-slave delay time.
         */
        nodeDelayTime: number;
        /**
         * The node ID.
         */
        nodeId: string;
        /**
         * The nod role.
         */
        nodeRole: string;
        /**
         * The node spec.
         */
        nodeSpec: string;
        /**
         * The node status.
         */
        nodeStatus: string;
        /**
         * The total memory in GB.
         */
        totalMemoryGb: number;
        /**
         * The total storage in GB.
         */
        totalStorageGb: number;
        /**
         * The total vCPU.
         */
        totalVcpu: number;
        /**
         * The used memory in GB.
         */
        usedMemoryGb: number;
        /**
         * The used storage in GB.
         */
        usedStorageGb: number;
        /**
         * The used vCPU.
         */
        usedVcpu: number;
        /**
         * The zone ID to query.
         */
        zoneId: string;
    }

    export interface InstancesInstanceShard {
        /**
         * The node information.
         */
        nodes: outputs.mongodb.InstancesInstanceShardNode[];
        /**
         * The shard ID.
         */
        shardId: string;
    }

    export interface InstancesInstanceShardNode {
        /**
         * The master-slave delay time.
         */
        nodeDelayTime: number;
        /**
         * The node ID.
         */
        nodeId: string;
        /**
         * The nod role.
         */
        nodeRole: string;
        /**
         * The node spec.
         */
        nodeSpec: string;
        /**
         * The node status.
         */
        nodeStatus: string;
        /**
         * The total memory in GB.
         */
        totalMemoryGb: number;
        /**
         * The total storage in GB.
         */
        totalStorageGb: number;
        /**
         * The total vCPU.
         */
        totalVcpu: number;
        /**
         * The used memory in GB.
         */
        usedMemoryGb: number;
        /**
         * The used storage in GB.
         */
        usedStorageGb: number;
        /**
         * The used vCPU.
         */
        usedVcpu: number;
        /**
         * The zone ID to query.
         */
        zoneId: string;
    }

    export interface InstancesInstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface InstancesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface MongoAllowListsAllowList {
        /**
         * The list of IP address in allow list.
         */
        allowList: string;
        /**
         * The description of allow list.
         */
        allowListDesc: string;
        /**
         * The ID of allow list.
         */
        allowListId: string;
        /**
         * The number of allow list IPs.
         */
        allowListIpNum: number;
        /**
         * The allow list name.
         */
        allowListName: string;
        /**
         * The IP address type in allow list.
         */
        allowListType: string;
        /**
         * The total number of instances bound under the allow list.
         */
        associatedInstanceNum: number;
        /**
         * The list of associated instances.
         */
        associatedInstances: outputs.mongodb.MongoAllowListsAllowListAssociatedInstance[];
    }

    export interface MongoAllowListsAllowListAssociatedInstance {
        /**
         * The instance ID to query.
         */
        instanceId: string;
        /**
         * The instance name that bound to the allow list.
         */
        instanceName: string;
        /**
         * The VPC ID.
         */
        vpc: string;
    }

    export interface RegionsRegion {
        /**
         * The id of the region.
         */
        regionId: string;
        /**
         * The name of region.
         */
        regionName: string;
    }

    export interface SpecsSpecs {
        /**
         * The collection of mongos node specs.
         */
        mongosNodeSpecs: outputs.mongodb.SpecsSpecsMongosNodeSpec[];
        /**
         * The collection of node specs.
         */
        nodeSpecs: outputs.mongodb.SpecsSpecsNodeSpec[];
        /**
         * The collection of shard node specs.
         */
        shardNodeSpecs: outputs.mongodb.SpecsSpecsShardNodeSpec[];
    }

    export interface SpecsSpecsMongosNodeSpec {
        /**
         * The cpu cores.
         */
        cpuNum: number;
        /**
         * The max connections.
         */
        maxConn: number;
        /**
         * The memory in GB.
         */
        memInGb: number;
        /**
         * The shard node spec name.
         */
        specName: string;
    }

    export interface SpecsSpecsNodeSpec {
        /**
         * The cpu cores.
         */
        cpuNum: number;
        /**
         * The max connections.
         */
        maxConn: number;
        /**
         * The max storage.
         */
        maxStorage: number;
        /**
         * The memory in GB.
         */
        memInDb: number;
        /**
         * The shard node spec name.
         */
        specName: string;
    }

    export interface SpecsSpecsShardNodeSpec {
        /**
         * The cpu cores.
         */
        cpuNum: number;
        /**
         * The max connections.
         */
        maxConn: number;
        /**
         * The max storage.
         */
        maxStorage: number;
        /**
         * The memory in GB.
         */
        memInGb: number;
        /**
         * The shard node spec name.
         */
        specName: string;
    }

    export interface SslStatesSslState {
        /**
         * The mongodb instance ID to query.
         */
        instanceId: string;
        /**
         * Whetehr SSL is valid.
         */
        isValid: boolean;
        /**
         * Whether SSL is enabled.
         */
        sslEnable: boolean;
        /**
         * The expire time of SSL.
         */
        sslExpiredTime: string;
    }

    export interface ZonesZone {
        /**
         * The id of the zone.
         */
        id: string;
        /**
         * The id of the zone.
         */
        zoneId: string;
        /**
         * The name of the zone.
         */
        zoneName: string;
    }

}

export namespace nas {
    export interface FileSystemTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface FileSystemsFileSystem {
        /**
         * The capacity of the nas file system.
         */
        capacities: outputs.nas.FileSystemsFileSystemCapacity[];
        /**
         * The charge type of nas file system.
         */
        chargeType: string;
        /**
         * The create time of the nas file system.
         */
        createTime: string;
        /**
         * The description of the nas file system.
         */
        description: string;
        /**
         * The id of the nas file system.
         */
        fileSystemId: string;
        /**
         * The name of nas file system. This field supports fuzzy queries.
         */
        fileSystemName: string;
        /**
         * The type of the nas file system.
         */
        fileSystemType: string;
        /**
         * The id of the nas file system.
         */
        id: string;
        /**
         * The project name of nas file system.
         */
        projectName: string;
        /**
         * The protocol type of nas file system.
         */
        protocolType: string;
        /**
         * The region id of the nas file system.
         */
        regionId: string;
        /**
         * The snapshot count of the nas file system.
         */
        snapshotCount: number;
        /**
         * The status of nas file system.
         */
        status: string;
        /**
         * The storage type of nas file system.
         */
        storageType: string;
        /**
         * Tags.
         */
        tags: outputs.nas.FileSystemsFileSystemTag[];
        /**
         * The update time of the nas file system.
         */
        updateTime: string;
        /**
         * The version of the nas file system.
         */
        version: string;
        /**
         * The zone id of nas file system.
         */
        zoneId: string;
        /**
         * The zone name of the nas file system.
         */
        zoneName: string;
    }

    export interface FileSystemsFileSystemCapacity {
        /**
         * The total capacity of the nas file system. Unit: GiB.
         */
        total: number;
        /**
         * The used capacity of the nas file system. Unit: MiB.
         */
        used: number;
    }

    export interface FileSystemsFileSystemTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Type of Tags.
         */
        type: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface FileSystemsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface MountPointsMountPoint {
        /**
         * The creation time of the permission group.
         */
        createTime: string;
        /**
         * The dns address.
         */
        domain: string;
        /**
         * The address of the mount point.
         */
        ip: string;
        /**
         * The id of the mount point.
         */
        mountPointId: string;
        /**
         * The name of the mount point.
         */
        mountPointName: string;
        /**
         * The struct of the permission group.
         */
        permissionGroups: outputs.nas.MountPointsMountPointPermissionGroup[];
        /**
         * The status of the mount point.
         */
        status: string;
        /**
         * The id of the subnet.
         */
        subnetId: string;
        /**
         * The name of the subnet.
         */
        subnetName: string;
        /**
         * The update time of the mount point.
         */
        updateTime: string;
        /**
         * The id of the vpc.
         */
        vpcId: string;
        /**
         * The name of the vpc.
         */
        vpcName: string;
    }

    export interface MountPointsMountPointPermissionGroup {
        /**
         * The creation time of the permission group.
         */
        createTime: string;
        /**
         * The description of the permission group.
         */
        description: string;
        /**
         * The number of the file system.
         */
        fileSystemCount: number;
        /**
         * The file system type of the permission group.
         */
        fileSystemType: string;
        /**
         * The list of the mount point.
         */
        mountPoints: outputs.nas.MountPointsMountPointPermissionGroupMountPoint[];
        /**
         * The id of the permission group.
         */
        permissionGroupId: string;
        /**
         * The name of the permission group.
         */
        permissionGroupName: string;
        /**
         * The number of the permission rule.
         */
        permissionRuleCount: number;
    }

    export interface MountPointsMountPointPermissionGroupMountPoint {
        /**
         * The id of the file system.
         */
        fileSystemId: string;
        /**
         * The id of the mount point.
         */
        mountPointId: string;
        /**
         * The name of the mount point.
         */
        mountPointName: string;
    }

    export interface PermissionGroupPermissionRule {
        /**
         * Client IP addresses that are allowed access.
         */
        cidrIp: string;
        /**
         * Permission group read and write rules. The value description is as follows:
         * `RW`: Allows reading and writing.
         * `RO`: read-only mode.
         */
        rwMode: string;
        /**
         * Permission group user permissions. The value description is as follows:
         * `All_squash`: All access users are mapped to anonymous users or user groups.
         * `No_all_squash`: The access user is first matched with the local user, and then mapped to an anonymous user or user group after the match fails.
         * `Root_squash`: Map the Root user as an anonymous user or user group.
         * `No_root_squash`: The Root user maintains the Root account authority.
         */
        useMode: string;
    }

    export interface PermissionGroupsFilter {
        /**
         * Filters permission groups for specified characteristics based on attributes. The parameters that support filtering are as follows: `PermissionGroupName`, `PermissionGroupId`.
         */
        key: string;
        /**
         * The value of the filter item.
         */
        value: string;
    }

    export interface PermissionGroupsPermissionGroup {
        /**
         * The creation time of the permission group.
         */
        createTime: string;
        /**
         * The description of the permission group.
         */
        description: string;
        /**
         * The number of the file system.
         */
        fileSystemCount: number;
        /**
         * The file system type of the permission group.
         */
        fileSystemType: string;
        /**
         * The list of the mount point.
         */
        mountPoints: outputs.nas.PermissionGroupsPermissionGroupMountPoint[];
        /**
         * The id of the permission group.
         */
        permissionGroupId: string;
        /**
         * The name of the permission group.
         */
        permissionGroupName: string;
        /**
         * The number of the permission rule.
         */
        permissionRuleCount: number;
        /**
         * The list of permissions rules.
         */
        permissionRules: outputs.nas.PermissionGroupsPermissionGroupPermissionRule[];
    }

    export interface PermissionGroupsPermissionGroupMountPoint {
        /**
         * The id of the file system.
         */
        fileSystemId: string;
        /**
         * The id of the mount point.
         */
        mountPointId: string;
        /**
         * The name of the mount point.
         */
        mountPointName: string;
    }

    export interface PermissionGroupsPermissionGroupPermissionRule {
        /**
         * Client IP addresses that are allowed access.
         */
        cidrIp: string;
        /**
         * The id of the permission rule.
         */
        permissionRuleId: string;
        /**
         * Permission group read and write rules.
         */
        rwMode: string;
        /**
         * Permission group user permissions.
         */
        userMode: string;
    }

    export interface RegionsRegion {
        /**
         * The id of the region.
         */
        regionId: string;
        /**
         * The name of region.
         */
        regionName: string;
        /**
         * The status info of region.
         */
        status: string;
    }

    export interface SnapshotsSnapshot {
        /**
         * The create time of snapshot.
         */
        createTime: string;
        /**
         * The description of snapshot.
         */
        description: string;
        /**
         * The ID of file system.
         */
        fileSystemId: string;
        /**
         * The name of file system.
         */
        fileSystemName: string;
        /**
         * The ID of snapshot.
         */
        id: string;
        /**
         * Whether is encrypt.
         */
        isEncrypt: boolean;
        /**
         * The progress of snapshot.
         */
        progress: string;
        /**
         * The retention days of snapshot.
         */
        retentionDays: number;
        /**
         * The ID of snapshot.
         */
        snapshotId: string;
        /**
         * The name of snapshot.
         */
        snapshotName: string;
        /**
         * The type of snapshot.
         */
        snapshotType: string;
        /**
         * The size of source.
         */
        sourceSize: number;
        /**
         * The source version info.
         */
        sourceVersion: string;
        /**
         * The status of snapshot.
         */
        status: string;
        /**
         * The ID of zone.
         */
        zoneId: string;
    }

    export interface ZonesZone {
        /**
         * The id of the zone.
         */
        id: string;
        /**
         * The collection of sales info.
         */
        sales: outputs.nas.ZonesZoneSale[];
        /**
         * The status info.
         */
        status: string;
        /**
         * The id of the zone.
         */
        zoneId: string;
        /**
         * The name of the zone.
         */
        zoneName: string;
    }

    export interface ZonesZoneSale {
        /**
         * The type of file system.
         */
        fileSystemType: string;
        /**
         * The type of protocol.
         */
        protocolType: string;
        /**
         * The status info.
         */
        status: string;
        /**
         * The type of storage.
         */
        storageType: string;
    }

}

export namespace nat {
    export interface DnatEntriesDnatEntry {
        /**
         * The ID of the DNAT entry.
         */
        dnatEntryId: string;
        /**
         * The name of the DNAT entry.
         */
        dnatEntryName: string;
        /**
         * Provides the public IP address for public network access.
         */
        externalIp: string;
        /**
         * The port or port segment that receives requests from the public network. If InternalPort is passed into the port segment, ExternalPort must also be passed into the port segment.
         */
        externalPort: string;
        /**
         * Provides the internal IP address.
         */
        internalIp: string;
        /**
         * The port or port segment on which the cloud server instance provides services to the public network.
         */
        internalPort: string;
        /**
         * The id of the NAT gateway.
         */
        natGatewayId: string;
        /**
         * The network protocol.
         */
        protocol: string;
        /**
         * The network status.
         */
        status: string;
    }

    export interface GatewayTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GatewaysNatGateway {
        /**
         * The billing type of the NatGateway.
         */
        billingType: string;
        /**
         * Whether the NatGateway is locked.
         */
        businessStatus: string;
        /**
         * The creation time of the NatGateway.
         */
        creationTime: string;
        /**
         * The deleted time of the NatGateway.
         */
        deletedTime: string;
        /**
         * The description of the NatGateway.
         */
        description: string;
        /**
         * The eip addresses of the NatGateway.
         */
        eipAddresses: outputs.nat.GatewaysNatGatewayEipAddress[];
        /**
         * The ID of the NatGateway.
         */
        id: string;
        /**
         * The reason why locking NatGateway.
         */
        lockReason: string;
        /**
         * The ID of the NatGateway.
         */
        natGatewayId: string;
        /**
         * The name of the NatGateway.
         */
        natGatewayName: string;
        /**
         * The ID of the network interface.
         */
        networkInterfaceId: string;
        /**
         * The overdue time of the NatGateway.
         */
        overdueTime: string;
        /**
         * The specification of the NatGateway.
         */
        spec: string;
        /**
         * The status of the NatGateway.
         */
        status: string;
        /**
         * The id of the Subnet.
         */
        subnetId: string;
        /**
         * Tags.
         */
        tags: outputs.nat.GatewaysNatGatewayTag[];
        /**
         * The update time of the NatGateway.
         */
        updatedAt: string;
        /**
         * The id of the VPC.
         */
        vpcId: string;
    }

    export interface GatewaysNatGatewayEipAddress {
        /**
         * The ID of Eip.
         */
        allocationId: string;
        /**
         * The address of Eip.
         */
        eipAddress: string;
        /**
         * The using status of Eip.
         */
        usingStatus: string;
    }

    export interface GatewaysNatGatewayTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GatewaysTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface SnatEntriesSnatEntry {
        /**
         * The public ip address used by the SNAT entry.
         */
        eipAddress: string;
        /**
         * An id of the public ip address used by the SNAT entry.
         */
        eipId: string;
        /**
         * The id of the SNAT entry.
         */
        id: string;
        /**
         * An id of the nat gateway to which the entry belongs.
         */
        natGatewayId: string;
        /**
         * The id of the SNAT entry.
         */
        snatEntryId: string;
        /**
         * A name of SNAT entry.
         */
        snatEntryName: string;
        /**
         * The SourceCidr of SNAT entry.
         */
        sourceCidr: string;
        /**
         * The status of the SNAT entry.
         */
        status: string;
        /**
         * An id of the subnet that is required to access the Internet.
         */
        subnetId: string;
    }

}

export namespace organization {
    export interface AccountTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface AccountsAccount {
        /**
         * The id of the account.
         */
        accountId: string;
        /**
         * The name of the account.
         */
        accountName: string;
        /**
         * Whether to allow the account enable console. `0` means allowed, `1` means not allowed.
         */
        allowConsole: number;
        /**
         * Whether to allow exit the organization. `0` means allowed, `1` means not allowed.
         */
        allowExit: number;
        /**
         * The created time of the account.
         */
        createdTime: string;
        /**
         * The delete uk of the account.
         */
        deleteUk: string;
        /**
         * The deleted time of the account.
         */
        deletedTime: string;
        /**
         * The description of the account.
         */
        description: string;
        /**
         * The name of the iam role.
         */
        iamRole: string;
        /**
         * The id of the account.
         */
        id: string;
        /**
         * Whether the account is owner. `0` means not owner, `1` means owner.
         */
        isOwner: number;
        /**
         * The join type of the account. `0` means create, `1` means invitation.
         */
        joinType: number;
        /**
         * The id of the organization.
         */
        orgId: string;
        /**
         * The type of the organization. `1` means business organization.
         */
        orgType: number;
        /**
         * The id of the organization unit.
         */
        orgUnitId: string;
        /**
         * The name of the organization unit.
         */
        orgUnitName: string;
        /**
         * The id of the organization verification.
         */
        orgVerificationId: string;
        /**
         * The owner id of the account.
         */
        owner: string;
        /**
         * The show name of the account.
         */
        showName: string;
        /**
         * Tags.
         */
        tags: outputs.organization.AccountsAccountTag[];
        /**
         * The updated time of the account.
         */
        updatedTime: string;
    }

    export interface AccountsAccountTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface OrganizationsOrganization {
        /**
         * The account id of the organization owner.
         */
        accountId: number;
        /**
         * The account name of the organization owner.
         */
        accountName: string;
        /**
         * The created time of the organization.
         */
        createdTime: string;
        /**
         * The delete uk of the organization.
         */
        deleteUk: string;
        /**
         * The deleted time of the organization.
         */
        deletedTime: string;
        /**
         * The description of the organization.
         */
        description: string;
        /**
         * The id of the organization.
         */
        id: string;
        /**
         * The main name of the organization owner.
         */
        mainName: string;
        /**
         * The name of the organization.
         */
        name: string;
        /**
         * The owner id of the organization.
         */
        owner: string;
        /**
         * The status of the organization.
         */
        status: number;
        /**
         * The type of the organization.
         */
        type: number;
        /**
         * The updated time of the organization.
         */
        updatedTime: string;
    }

    export interface ServiceControlPoliciesPolicy {
        /**
         * The create time of the Policy.
         */
        createDate: string;
        /**
         * The description of the Policy.
         */
        description: string;
        /**
         * The ID of the Policy.
         */
        id: string;
        /**
         * The name of the Policy.
         */
        policyName: string;
        /**
         * The type of policy. The value can be System or Custom.
         */
        policyType: string;
        /**
         * The statement of the Policy.
         */
        statement: string;
        /**
         * The update time of the Policy.
         */
        updateDate: string;
    }

    export interface UnitsUnit {
        /**
         * The created time of the organization unit.
         */
        createdTime: string;
        /**
         * Delete marker.
         */
        deleteUk: string;
        /**
         * The deleted time of the organization unit.
         */
        deletedTime: string;
        /**
         * The depth of the organization unit.
         */
        depth: number;
        /**
         * The description of the organization unit.
         */
        description: string;
        /**
         * The id of the organization unit.
         */
        id: string;
        /**
         * The name of the organization unit.
         */
        name: string;
        /**
         * The id of the organization.
         */
        orgId: string;
        /**
         * The organization type.
         */
        orgType: number;
        /**
         * The owner of the organization unit.
         */
        owner: string;
        /**
         * Parent Unit ID.
         */
        parentId: string;
        /**
         * The updated time of the organization unit.
         */
        updatedTime: string;
    }

}

export namespace privatelink {
    export interface VpcEndpointConnectionZone {
        /**
         * The id of the network interface.
         */
        networkInterfaceId: string;
        /**
         * The ip address of the network interface.
         */
        networkInterfaceIp: string;
        /**
         * The id of the resource.
         */
        resourceId: string;
        /**
         * The id of the subnet.
         */
        subnetId: string;
        /**
         * The domain of the zone.
         */
        zoneDomain: string;
        /**
         * The id of the zone.
         */
        zoneId: string;
        /**
         * The status of the zone.
         */
        zoneStatus: string;
    }

    export interface VpcEndpointConnectionsConnection {
        /**
         * The status of the connection.
         */
        connectionStatus: string;
        /**
         * The create time of the connection.
         */
        creationTime: string;
        /**
         * The id of the vpc endpoint.
         */
        endpointId: string;
        /**
         * The account id of the vpc endpoint.
         */
        endpointOwnerAccountId: string;
        /**
         * The vpc id of the vpc endpoint.
         */
        endpointVpcId: string;
        /**
         * The id of the vpc endpoint service.
         */
        serviceId: string;
        /**
         * The update time of the connection.
         */
        updateTime: string;
        /**
         * The available zones.
         */
        zones: outputs.privatelink.VpcEndpointConnectionsConnectionZone[];
    }

    export interface VpcEndpointConnectionsConnectionZone {
        /**
         * The id of the network interface.
         */
        networkInterfaceId: string;
        /**
         * The ip address of the network interface.
         */
        networkInterfaceIp: string;
        /**
         * The id of the resource.
         */
        resourceId: string;
        /**
         * The id of the subnet.
         */
        subnetId: string;
        /**
         * The domain of the zone.
         */
        zoneDomain: string;
        /**
         * The id of the zone.
         */
        zoneId: string;
        /**
         * The status of the zone.
         */
        zoneStatus: string;
    }

    export interface VpcEndpointServicePermissionsPermission {
        /**
         * The Id of permit account.
         */
        permitAccountId: string;
    }

    export interface VpcEndpointServiceResource {
        /**
         * The id of resource.
         */
        resourceId: string;
        /**
         * The type of resource.
         */
        resourceType: string;
    }

    export interface VpcEndpointServicesService {
        /**
         * Whether auto accept node connect.
         */
        autoAcceptEnabled: boolean;
        /**
         * The create time of service.
         */
        creationTime: string;
        /**
         * The description of service.
         */
        description: string;
        /**
         * The Id of service.
         */
        id: string;
        /**
         * The resources info.
         */
        resources: outputs.privatelink.VpcEndpointServicesServiceResource[];
        /**
         * The domain of service.
         */
        serviceDomain: string;
        /**
         * The Id of service.
         */
        serviceId: string;
        /**
         * The name of vpc endpoint service.
         */
        serviceName: string;
        /**
         * The resource type of service.
         */
        serviceResourceType: string;
        /**
         * The type of service.
         */
        serviceType: string;
        /**
         * The status of service.
         */
        status: string;
        /**
         * The update time of service.
         */
        updateTime: string;
        /**
         * The IDs of zones.
         */
        zoneIds: string[];
    }

    export interface VpcEndpointServicesServiceResource {
        /**
         * The id of resource.
         */
        resourceId: string;
        /**
         * The type of resource.
         */
        resourceType: string;
        /**
         * The zone id of resource.
         */
        zoneId: string;
    }

    export interface VpcEndpointZonesVpcEndpointZone {
        /**
         * The Id of vpc endpoint zone.
         */
        id: string;
        /**
         * The network interface id of vpc endpoint.
         */
        networkInterfaceId: string;
        /**
         * The network interface ip of vpc endpoint.
         */
        networkInterfaceIp: string;
        /**
         * The status of vpc endpoint service.
         */
        serviceStatus: string;
        /**
         * The subnet id of vpc endpoint.
         */
        subnetId: string;
        /**
         * The domain of vpc endpoint zone.
         */
        zoneDomain: string;
        /**
         * The Id of vpc endpoint zone.
         */
        zoneId: string;
        /**
         * The status of vpc endpoint zone.
         */
        zoneStatus: string;
    }

    export interface VpcEndpointsVpcEndpoint {
        /**
         * Whether the vpc endpoint is locked.
         */
        businessStatus: string;
        /**
         * The connection  status of vpc endpoint.
         */
        connectionStatus: string;
        /**
         * The create time of vpc endpoint.
         */
        creationTime: string;
        /**
         * The delete time of vpc endpoint.
         */
        deletedTime: string;
        /**
         * The description of vpc endpoint.
         */
        description: string;
        /**
         * The domain of vpc endpoint.
         */
        endpointDomain: string;
        /**
         * The Id of vpc endpoint.
         */
        endpointId: string;
        /**
         * The name of vpc endpoint.
         */
        endpointName: string;
        /**
         * The type of vpc endpoint.
         */
        endpointType: string;
        /**
         * The Id of vpc endpoint.
         */
        id: string;
        /**
         * The Id of vpc endpoint service.
         */
        serviceId: string;
        /**
         * The name of vpc endpoint service.
         */
        serviceName: string;
        /**
         * The status of vpc endpoint. Valid values: `Creating`, `Pending`, `Available`, `Deleting`, `Inactive`.
         */
        status: string;
        /**
         * The update time of vpc endpoint.
         */
        updateTime: string;
        /**
         * The vpc id of vpc endpoint.
         */
        vpcId: string;
    }

}

export namespace rds {
    export interface AccountPrivilegeDbPrivilege {
        /**
         * The privilege type of the account.
         */
        accountPrivilege: string;
        /**
         * The privilege string of the account.
         */
        accountPrivilegeStr: string;
        /**
         * The name of database.
         */
        dbName: string;
    }

    export interface AccountsRdsAccount {
        /**
         * The name of the database account.
         */
        accountName: string;
        /**
         * The status of the database account.
         */
        accountStatus: string;
        /**
         * The type of the database account.
         */
        accountType: string;
        /**
         * The privilege detail list of RDS instance account.
         */
        dbPrivileges: outputs.rds.AccountsRdsAccountDbPrivilege[];
        /**
         * The ID of the RDS instance account.
         */
        id: string;
    }

    export interface AccountsRdsAccountDbPrivilege {
        /**
         * The privilege type of the account.
         */
        accountPrivilege: string;
        /**
         * The privilege string of the account.
         */
        accountPrivilegeStr: string;
        /**
         * The name of database.
         */
        dbName: string;
    }

    export interface DatabasesRdsDatabase {
        /**
         * The account names of the RDS database.
         */
        accountNames: string;
        /**
         * The character set of the RDS database.
         */
        characterSetName: string;
        /**
         * The name of the RDS database.
         */
        dbName: string;
        /**
         * The status of the RDS database.
         */
        dbStatus: string;
        /**
         * The ID of the RDS database.
         */
        id: string;
    }

    export interface InstanceConnectionInfo {
        /**
         * Whether global read-only is enabled.
         */
        enableReadOnly: string;
        /**
         * Whether read-write separation is enabled.
         */
        enableReadWriteSplitting: string;
        /**
         * The internal domain of the RDS instance.
         */
        internalDomain: string;
        /**
         * The interval port of the RDS instance.
         */
        internalPort: string;
        /**
         * The public domain of the RDS instance.
         */
        publicDomain: string;
        /**
         * The public port of the RDS instance.
         */
        publicPort: string;
    }

    export interface InstancesRdsInstance {
        /**
         * The charge status of the RDS instance.
         */
        chargeStatus: string;
        /**
         * The charge type of the RDS instance.
         */
        chargeType: string;
        /**
         * The connection info ot the RDS instance.
         */
        connectionInfo: outputs.rds.InstancesRdsInstanceConnectionInfo;
        /**
         * The create time of the RDS instance.
         */
        createTime: string;
        /**
         * The engine of the RDS instance.
         */
        dbEngine: string;
        /**
         * The engine version of the RDS instance.
         */
        dbEngineVersion: string;
        /**
         * The ID of the RDS instance.
         */
        id: string;
        /**
         * The id of the RDS instance.
         */
        instanceId: string;
        /**
         * The name of the RDS instance.
         */
        instanceName: string;
        /**
         * The spec type detail of RDS instance.
         */
        instanceSpec: outputs.rds.InstancesRdsInstanceInstanceSpec;
        /**
         * The status of the RDS instance.
         */
        instanceStatus: string;
        /**
         * The type of the RDS instance.
         */
        instanceType: string;
        readOnlyInstanceIds?: string[];
        /**
         * The region of the RDS instance.
         */
        region: string;
        /**
         * The total storage GB of the RDS instance.
         */
        storageSpaceGb: number;
        /**
         * The update time of the RDS instance.
         */
        updateTime: string;
        /**
         * The vpc ID of the RDS instance.
         */
        vpcId: string;
        /**
         * The available zone of the RDS instance.
         */
        zone: string;
    }

    export interface InstancesRdsInstanceConnectionInfo {
        /**
         * Whether global read-only is enabled.
         */
        enableReadOnly: string;
        /**
         * Whether read-write separation is enabled.
         */
        enableReadWriteSplitting: string;
        /**
         * The internal domain of the RDS instance.
         */
        internalDomain: string;
        /**
         * The interval port of the RDS instance.
         */
        internalPort: string;
        /**
         * The public domain of the RDS instance.
         */
        publicDomain: string;
        /**
         * The public port of the RDS instance.
         */
        publicPort: string;
    }

    export interface InstancesRdsInstanceInstanceSpec {
        /**
         * The cpu core count of spec type.
         */
        cpuNum: number;
        /**
         * The memory size(GB) of spec type.
         */
        memInGb: number;
        /**
         * The name of spec type.
         */
        specName: string;
    }

    export interface IpListsRdsIpList {
        /**
         * The name of the RDS ip list.
         */
        groupName: string;
        /**
         * The ID of the RDS ip list.
         */
        id: string;
        /**
         * The list of IP address.
         */
        ipLists: string[];
    }

    export interface ParameterTemplateTemplateParam {
        /**
         * Parameter name.
         */
        name?: string;
        /**
         * Parameter running value.
         */
        runningValue?: string;
    }

    export interface ParameterTemplatesRdsParameterTemplate {
        /**
         * Creation time.
         */
        createTime: string;
        /**
         * The ID of the RDS parameter template.
         */
        id: string;
        /**
         * Whether the template contains parameters that need to be restarted.
         */
        needRestart: boolean;
        /**
         * The number of parameters the template contains.
         */
        parameterNum: number;
        /**
         * The description of the RDS parameter template.
         */
        templateDesc: string;
        /**
         * The ID of the RDS parameter template.
         */
        templateId: string;
        /**
         * The name of the RDS parameter template.
         */
        templateName: string;
        /**
         * Parameters contained in the template.
         */
        templateParams: outputs.rds.ParameterTemplatesRdsParameterTemplateTemplateParam[];
        /**
         * Parameter template database type, range of values:
         * MySQL - MySQL database.
         */
        templateType: string;
        /**
         * Parameter template database version, value range:
         * MySQL_Community_5_7 - MySQL 5.7
         * MySQL_8_0 - MySQL 8.0.
         */
        templateTypeVersion: string;
        /**
         * Update time.
         */
        updateTime: string;
    }

    export interface ParameterTemplatesRdsParameterTemplateTemplateParam {
        /**
         * Parameter default value.
         */
        defaultValue: string;
        /**
         * Parameter description.
         */
        description: string;
        /**
         * Parameter name.
         */
        name: string;
        /**
         * Whether the modified parameters need to be restarted to take effect.
         */
        restart: boolean;
        /**
         * Parameter running value.
         */
        runningValue: string;
        /**
         * Parameter value range.
         */
        valueRange: string;
    }

}

export namespace rds_mssql {
    export interface BackupBackupMeta {
        /**
         * The name of the database.
         */
        dbName: string;
    }

    export interface BackupsBackup {
        /**
         * The detail of the database.
         */
        backupDatabaseDetails: outputs.rds_mssql.BackupsBackupBackupDatabaseDetail[];
        /**
         * The end time of the backup.
         */
        backupEndTime: string;
        /**
         * The size of the backup file.
         */
        backupFileSize: number;
        /**
         * The id of the backup.
         */
        backupId: string;
        /**
         * The name of the backup method.
         */
        backupMethod: string;
        /**
         * The start time of the backup.
         */
        backupStartTime: string;
        /**
         * The status of the backup.
         */
        backupStatus: string;
        /**
         * The type of the backup.
         */
        backupType: string;
        /**
         * The type of the backup create.
         */
        createType: string;
        /**
         * The id of the backup.
         */
        id: string;
    }

    export interface BackupsBackupBackupDatabaseDetail {
        /**
         * External backup download link.
         */
        backupDownloadLinkEip: string;
        /**
         * Intranet backup download link.
         */
        backupDownloadLinkInner: string;
        /**
         * The end time of the backup.
         */
        backupEndTime: string;
        /**
         * The name of the backup file.
         */
        backupFileName: string;
        /**
         * The size of the backup file.
         */
        backupFileSize: number;
        /**
         * The start time of the backup.
         */
        backupStartTime: string;
        /**
         * The type of the backup.
         */
        backupType: string;
        /**
         * The name of the database.
         */
        databaseName: string;
        /**
         * Backup file preparation progress, unit: %.
         */
        downloadProgress: number;
        /**
         * Download status.
         */
        downloadStatus: string;
        /**
         * Download link expiration time.
         */
        linkExpiredTime: string;
    }

    export interface InstanceChargeInfo {
        /**
         * Whether to enable automatic renewal in the prepaid scenario. This parameter can be set when the ChargeType is `Prepaid`.
         */
        autoRenew: boolean;
        chargeEndTime: string;
        chargeStartTime: string;
        chargeStatus: string;
        /**
         * The charge type. Valid values: `PostPaid`, `PrePaid`.
         */
        chargeType: string;
        overdueReclaimTime: string;
        overdueTime: string;
        /**
         * Purchase duration in a prepaid scenario. This parameter is required when the ChargeType is `Prepaid`.
         */
        period: number;
    }

    export interface InstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface InstancesInstance {
        /**
         * The used backup space of the instance. Unit: GiB.
         */
        backupUse: number;
        /**
         * The charge detail.
         */
        chargeDetails: outputs.rds_mssql.InstancesInstanceChargeDetail[];
        /**
         * The connection info of the instance.
         */
        connectionInfos: outputs.rds_mssql.InstancesInstanceConnectionInfo[];
        /**
         * Node creation time.
         */
        createTime: string;
        /**
         * Compatible version. Valid values: `SQLServer_2019_Std`, `SQLServer_2019_Web`, `SQLServer_2019_Ent`.
         */
        dbEngineVersion: string;
        /**
         * The id of the instance.
         */
        id: string;
        /**
         * The inner version of the instance.
         */
        innerVersion: string;
        /**
         * The instance category.
         */
        instanceCategory: string;
        /**
         * Id of the instance.
         */
        instanceId: string;
        /**
         * Name of the instance.
         */
        instanceName: string;
        /**
         * Status of the instance.
         */
        instanceStatus: string;
        /**
         * Instance type. Valid values: `HA`, `Basic`, `Cluster`.
         */
        instanceType: string;
        /**
         * The Memory.
         */
        memory: number;
        /**
         * Node detail information.
         */
        nodeDetailInfos: outputs.rds_mssql.InstancesInstanceNodeDetailInfo[];
        /**
         * The node spec.
         */
        nodeSpec: string;
        /**
         * The count of instance parameters.
         */
        parameterCount: number;
        /**
         * The list of instance parameters.
         */
        parameters: outputs.rds_mssql.InstancesInstanceParameter[];
        /**
         * The port of the instance.
         */
        port: string;
        /**
         * The id of the primary instance.
         */
        primaryInstanceId: string;
        /**
         * The project name.
         */
        projectName: string;
        /**
         * The number of read only instance.
         */
        readOnlyNumber: number;
        /**
         * The region id.
         */
        regionId: string;
        /**
         * Server sorting rules.
         */
        serverCollation: string;
        /**
         * Whether to enable slow query function.
         */
        slowQueryEnable: boolean;
        /**
         * The slow query time. Unit: second.
         */
        slowQueryTime: string;
        /**
         * The storage space.
         */
        storageSpace: number;
        /**
         * The storage type.
         */
        storageType: string;
        /**
         * The used storage space.
         */
        storageUse: number;
        /**
         * The subnet id.
         */
        subnetId: string;
        /**
         * Tags.
         */
        tags: outputs.rds_mssql.InstancesInstanceTag[];
        /**
         * The time zone.
         */
        timeZone: string;
        /**
         * The update time of the instance.
         */
        updateTime: string;
        /**
         * The CPU size of the instance. For example: 1 represents 1U.
         */
        vCpu: number;
        /**
         * The vpc id.
         */
        vpcId: string;
        /**
         * The id of the zone.
         */
        zoneId: string;
    }

    export interface InstancesInstanceChargeDetail {
        /**
         * Whether to enable automatic renewal in the prepaid scenario. This parameter can be set when ChargeType is Prepaid.
         */
        autoRenew: boolean;
        /**
         * Charge end time.
         */
        chargeEndTime: string;
        /**
         * Charge start time.
         */
        chargeStartTime: string;
        /**
         * The charge status.
         */
        chargeStatus: string;
        /**
         * The charge type. Valid values: `PostPaid`, `PrePaid`.
         */
        chargeType: string;
        /**
         * Expected release time when overdue fees are shut down.
         */
        overdueReclaimTime: string;
        /**
         * Time for Disconnection due to Unpaid Fees.
         */
        overdueTime: string;
        /**
         * Purchase duration in a prepaid scenario.
         */
        period: number;
        /**
         * Purchase cycle in prepaid scenarios. This parameter can be set when ChargeType is Prepaid.
         */
        periodUnit: string;
    }

    export interface InstancesInstanceConnectionInfo {
        /**
         * The address info.
         */
        addresses: outputs.rds_mssql.InstancesInstanceConnectionInfoAddress[];
        /**
         * The description.
         */
        description: string;
        /**
         * The endpoint id.
         */
        endpointId: string;
        /**
         * The endpoint name.
         */
        endpointName: string;
        /**
         * The endpoint type.
         */
        endpointType: string;
    }

    export interface InstancesInstanceConnectionInfoAddress {
        /**
         * Whether to enable private to public network resolution.
         */
        dnsVisibility: boolean;
        /**
         * The domain.
         */
        domain: string;
        /**
         * The eip id for public address.
         */
        eipId: string;
        /**
         * The ip address.
         */
        ipAddress: string;
        /**
         * The network type.
         */
        networkType: string;
        /**
         * The port of the instance.
         */
        port: string;
        /**
         * The subnet id.
         */
        subnetId: string;
    }

    export interface InstancesInstanceNodeDetailInfo {
        /**
         * Node creation time.
         */
        createTime: string;
        /**
         * Id of the instance.
         */
        instanceId: string;
        /**
         * The Memory.
         */
        memory: number;
        /**
         * The Node ID.
         */
        nodeId: string;
        /**
         * The node ip.
         */
        nodeIp: string;
        /**
         * The node spec.
         */
        nodeSpec: string;
        /**
         * The node status.
         */
        nodeStatus: string;
        /**
         * The node type.
         */
        nodeType: string;
        /**
         * The region id.
         */
        regionId: string;
        /**
         * The update time of the instance.
         */
        updateTime: string;
        /**
         * The CPU size of the instance. For example: 1 represents 1U.
         */
        vCpu: number;
        /**
         * The id of the zone.
         */
        zoneId: string;
    }

    export interface InstancesInstanceParameter {
        /**
         * The valid value range of the parameter.
         */
        checkingCode: string;
        /**
         * Indicates whether the parameter running value can be modified.
         */
        forceModify: boolean;
        /**
         * Indicates whether the instance needs to be restarted to take effect after modifying the running value of the parameter.
         */
        forceRestart: boolean;
        /**
         * The default value of the parameter.
         */
        parameterDefaultValue: string;
        /**
         * The description of the parameter.
         */
        parameterDescription: string;
        /**
         * The name of the parameter.
         */
        parameterName: string;
        /**
         * The type of the parameter.
         */
        parameterType: string;
        /**
         * The value of the parameter.
         */
        parameterValue: string;
    }

    export interface InstancesInstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface InstancesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface RegionsRegion {
        /**
         * The id of the region.
         */
        regionId: string;
        /**
         * The name of region.
         */
        regionName: string;
    }

    export interface ZonesZone {
        /**
         * The description of the zone.
         */
        description: string;
        /**
         * The id of the zone.
         */
        id: string;
        /**
         * The id of the zone.
         */
        zoneId: string;
        /**
         * The name of the zone.
         */
        zoneName: string;
    }

}

export namespace rds_mysql {
    export interface AccountAccountPrivilege {
        /**
         * The privilege type of the account.
         */
        accountPrivilege: string;
        /**
         * The privilege detail of the account.
         */
        accountPrivilegeDetail?: string;
        /**
         * The name of database.
         */
        dbName: string;
    }

    export interface AccountsAccount {
        /**
         * The name of the database account. This field supports fuzzy query.
         */
        accountName: string;
        /**
         * The privilege detail list of RDS mysql instance account.
         */
        accountPrivileges: outputs.rds_mysql.AccountsAccountAccountPrivilege[];
        /**
         * The status of the database account.
         */
        accountStatus: string;
        /**
         * The type of the database account.
         */
        accountType: string;
    }

    export interface AccountsAccountAccountPrivilege {
        /**
         * The privilege type of the account.
         */
        accountPrivilege: string;
        /**
         * The privilege detail of the account.
         */
        accountPrivilegeDetail: string;
        /**
         * The name of database.
         */
        dbName: string;
    }

    export interface AllowlistsAllowList {
        /**
         * The description of the allow list.
         */
        allowListDesc: string;
        /**
         * The id of the allow list.
         */
        allowListId: string;
        /**
         * The total number of IP addresses (or address ranges) in the whitelist.
         */
        allowListIpNum: number;
        /**
         * The name of the allow list.
         */
        allowListName: string;
        /**
         * The type of the allow list.
         */
        allowListType: string;
        /**
         * The IP address or a range of IP addresses in CIDR format.
         */
        allowLists: string[];
        /**
         * The total number of instances bound under the whitelist.
         */
        associatedInstanceNum: number;
        /**
         * The list of instances.
         */
        associatedInstances: outputs.rds_mysql.AllowlistsAllowListAssociatedInstance[];
    }

    export interface AllowlistsAllowListAssociatedInstance {
        /**
         * Instance ID. When an InstanceId is specified, the DescribeAllowLists interface will return the whitelist bound to the specified instance.
         */
        instanceId: string;
        /**
         * The name of the instance.
         */
        instanceName: string;
        /**
         * The id of the vpc.
         */
        vpc: string;
    }

    export interface DatabasesDatabase {
        /**
         * The character set of the RDS database.
         */
        characterSetName: string;
        /**
         * The privilege detail list of RDS mysql instance database.
         */
        databasePrivileges: outputs.rds_mysql.DatabasesDatabaseDatabasePrivilege[];
        /**
         * The name of the RDS database.
         */
        dbName: string;
    }

    export interface DatabasesDatabaseDatabasePrivilege {
        /**
         * The name of account.
         */
        accountName: string;
        /**
         * The privilege type of the account.
         */
        accountPrivilege: string;
        /**
         * The privilege detail of the account.
         */
        accountPrivilegeDetail: string;
    }

    export interface InstanceChargeDetail {
        /**
         * Whether to automatically renew in prepaid scenarios.
         */
        autoRenew: boolean;
        /**
         * Billing expiry time (yearly and monthly only).
         */
        chargeEndTime: string;
        /**
         * Billing start time (pay-as-you-go & monthly subscription).
         */
        chargeStartTime: string;
        /**
         * Pay status. Value:
         * normal - normal
         * overdue - overdue
         * .
         */
        chargeStatus: string;
        /**
         * Payment type. Value:
         * PostPaid - Pay-As-You-Go
         * PrePaid - Yearly and monthly (default).
         */
        chargeType: string;
        /**
         * Estimated release time when arrears are closed (pay-as-you-go & monthly subscription).
         */
        overdueReclaimTime: string;
        /**
         * Shutdown time in arrears (pay-as-you-go & monthly subscription).
         */
        overdueTime: string;
        /**
         * Purchase duration in prepaid scenarios. Default: 1.
         */
        period: number;
        /**
         * The purchase cycle in the prepaid scenario.
         * Month - monthly subscription (default)
         * Year - Package year.
         */
        periodUnit: string;
    }

    export interface InstanceChargeInfo {
        /**
         * Whether to automatically renew in prepaid scenarios.
         */
        autoRenew: boolean;
        /**
         * Payment type. Value:
         * PostPaid - Pay-As-You-Go
         * PrePaid - Yearly and monthly (default).
         */
        chargeType: string;
        /**
         * Purchase duration in prepaid scenarios. Default: 1.
         */
        period: number;
        /**
         * The purchase cycle in the prepaid scenario.
         * Month - monthly subscription (default)
         * Year - Package year.
         */
        periodUnit: string;
    }

    export interface InstanceEndpoint {
        /**
         * Address list.
         */
        addresses: outputs.rds_mysql.InstanceEndpointAddress[];
        /**
         * When the terminal type is read-write terminal or read-only terminal, it supports setting whether new nodes are automatically added.
         */
        autoAddNewNodes: string;
        /**
         * Address description.
         */
        description: string;
        /**
         * Whether global read-only is enabled, value: Enable: Enable. Disable: Disabled.
         */
        enableReadOnly: string;
        /**
         * Whether read-write separation is enabled, value: Enable: Enable. Disable: Disabled.
         */
        enableReadWriteSplitting: string;
        /**
         * Instance connection terminal ID.
         */
        endpointId: string;
        /**
         * The instance connection terminal name.
         */
        endpointName: string;
        /**
         * Terminal type:
         * Cluster: The default terminal. (created by default)
         * Primary: Primary node terminal.
         * Custom: Custom terminal.
         * Direct: Direct connection to the terminal. (Only the operation and maintenance side)
         * AllNode: All node terminals. (Only the operation and maintenance side).
         */
        endpointType: string;
        /**
         * The list of nodes configured by the connection terminal and the corresponding read-only weights.
         */
        nodeWeights: outputs.rds_mysql.InstanceEndpointNodeWeight[];
        /**
         * Read and write mode:
         * ReadWrite: read and write
         * ReadOnly: read only (default).
         */
        readWriteMode: string;
    }

    export interface InstanceEndpointAddress {
        /**
         * DNS Visibility.
         */
        dnsVisibility: boolean;
        /**
         * Connect domain name.
         */
        domain: string;
        /**
         * The ID of the EIP, only valid for Public addresses.
         */
        eipId: string;
        /**
         * The IP Address.
         */
        ipAddress: string;
        /**
         * Network address type, temporarily Private, Public, PublicService.
         */
        networkType: string;
        /**
         * The Port.
         */
        port: string;
        /**
         * Subnet ID of the RDS instance.
         */
        subnetId: string;
    }

    export interface InstanceEndpointNodeWeight {
        /**
         * Node ID.
         */
        nodeId: string;
        /**
         * Node type. Value: Primary: Primary node.
         * Secondary: Standby node.
         * ReadOnly: Read-only node.
         */
        nodeType: string;
        /**
         * The weight of the node.
         */
        weight: number;
    }

    export interface InstanceMaintenanceWindow {
        /**
         * DayKind of maintainable window. Value: Week. Month.
         */
        dayKind: string;
        /**
         * Days of maintainable window of the month.
         */
        dayOfMonths: number[];
        /**
         * Days of maintainable window of the week.
         */
        dayOfWeeks: string[];
        /**
         * The maintainable time of the RDS instance.
         */
        maintenanceTime: string;
    }

    export interface InstanceNode {
        /**
         * Node creation local time.
         */
        createTime: string;
        /**
         * Instance ID.
         */
        instanceId: string;
        /**
         * Memory size in GB.
         */
        memory: number;
        /**
         * Node ID.
         */
        nodeId: string;
        /**
         * The specification of primary node and secondary node.
         */
        nodeSpec: string;
        /**
         * Node state, value: aligned with instance state.
         */
        nodeStatus: string;
        /**
         * Node type. Value: Primary: Primary node.
         * Secondary: Standby node.
         * ReadOnly: Read-only node.
         */
        nodeType: string;
        /**
         * The region of the RDS instance.
         */
        regionId: string;
        /**
         * The update time of the RDS instance.
         */
        updateTime: string;
        /**
         * CPU size.
         */
        vCpu: number;
        /**
         * The available zone of the RDS instance.
         */
        zoneId: string;
    }

    export interface InstanceParameter {
        /**
         * Parameter name.
         */
        parameterName: string;
        /**
         * Parameter value.
         */
        parameterValue: string;
    }

    export interface InstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface InstancesRdsMysqlInstance {
        /**
         * The version of allow list.
         */
        allowListVersion: string;
        /**
         * The instance has used backup space. Unit: GB.
         */
        backupUse: number;
        /**
         * Payment methods.
         */
        chargeDetail: outputs.rds_mysql.InstancesRdsMysqlInstanceChargeDetail;
        /**
         * Node creation local time.
         */
        createTime: string;
        /**
         * Data synchronization mode.
         */
        dataSyncMode: string;
        /**
         * The version of the RDS instance.
         */
        dbEngineVersion: string;
        /**
         * The endpoint info of the RDS instance.
         */
        endpoints: outputs.rds_mysql.InstancesRdsMysqlInstanceEndpoint[];
        /**
         * The ID of the RDS instance.
         */
        id: string;
        /**
         * The id of the RDS instance.
         */
        instanceId: string;
        /**
         * The name of the RDS instance.
         */
        instanceName: string;
        /**
         * The status of the RDS instance.
         */
        instanceStatus: string;
        /**
         * Whether the table name is case sensitive, the default value is 1.
         * Ranges:
         * 0: Table names are stored as fixed and table names are case-sensitive.
         * 1: Table names will be stored in lowercase and table names are not case sensitive.
         */
        lowerCaseTableNames: string;
        /**
         * Maintenance Window.
         */
        maintenanceWindows: outputs.rds_mysql.InstancesRdsMysqlInstanceMaintenanceWindow[];
        /**
         * Memory size in GB.
         */
        memory: number;
        /**
         * The number of nodes.
         */
        nodeNumber: number;
        /**
         * General instance type, different from Custom instance type.
         */
        nodeSpec: string;
        /**
         * Instance node information.
         */
        nodes: outputs.rds_mysql.InstancesRdsMysqlInstanceNode[];
        /**
         * The project name of the RDS instance.
         */
        projectName: string;
        /**
         * The region of the RDS instance.
         */
        regionId: string;
        /**
         * Total instance storage space. Unit: GB.
         */
        storageSpace: number;
        /**
         * Instance storage type.
         */
        storageType: string;
        /**
         * The instance has used storage space. Unit: GB.
         */
        storageUse: number;
        /**
         * The subnet ID of the RDS instance.
         */
        subnetId: string;
        /**
         * Tags.
         */
        tags: outputs.rds_mysql.InstancesRdsMysqlInstanceTag[];
        /**
         * Time zone.
         */
        timeZone: string;
        /**
         * The update time of the RDS instance.
         */
        updateTime: string;
        /**
         * CPU size.
         */
        vCpu: number;
        /**
         * The vpc ID of the RDS instance.
         */
        vpcId: string;
        /**
         * The available zone of the RDS instance.
         */
        zoneId: string;
    }

    export interface InstancesRdsMysqlInstanceChargeDetail {
        /**
         * Whether to automatically renew in prepaid scenarios.
         * Autorenew_Enable
         * Autorenew_Disable (default).
         */
        autoRenew: boolean;
        /**
         * Billing expiry time (yearly and monthly only).
         */
        chargeEndTime: string;
        /**
         * Billing start time (pay-as-you-go & monthly subscription).
         */
        chargeStartTime: string;
        /**
         * Pay status. Value:
         * normal - normal
         * overdue - overdue
         * .
         */
        chargeStatus: string;
        /**
         * The charge type of the RDS instance.
         */
        chargeType: string;
        /**
         * Estimated release time when arrears are closed (pay-as-you-go & monthly subscription).
         */
        overdueReclaimTime: string;
        /**
         * Shutdown time in arrears (pay-as-you-go & monthly subscription).
         */
        overdueTime: string;
        /**
         * Purchase duration in prepaid scenarios. Default: 1.
         */
        period: number;
        /**
         * The purchase cycle in the prepaid scenario.
         * Month - monthly subscription (default)
         * Year - Package year.
         */
        periodUnit: string;
    }

    export interface InstancesRdsMysqlInstanceEndpoint {
        /**
         * Address list.
         */
        addresses: outputs.rds_mysql.InstancesRdsMysqlInstanceEndpointAddress[];
        /**
         * When the terminal type is read-write terminal or read-only terminal, it supports setting whether new nodes are automatically added.
         */
        autoAddNewNodes: string;
        /**
         * Address description.
         */
        description: string;
        /**
         * Whether global read-only is enabled, value: Enable: Enable. Disable: Disabled.
         */
        enableReadOnly: string;
        /**
         * Whether read-write separation is enabled, value: Enable: Enable. Disable: Disabled.
         */
        enableReadWriteSplitting: string;
        /**
         * Instance connection terminal ID.
         */
        endpointId: string;
        /**
         * The instance connection terminal name.
         */
        endpointName: string;
        /**
         * Terminal type:
         * Cluster: The default terminal. (created by default)
         * Primary: Primary node terminal.
         * Custom: Custom terminal.
         * Direct: Direct connection to the terminal. (Only the operation and maintenance side)
         * AllNode: All node terminals. (Only the operation and maintenance side).
         */
        endpointType: string;
        /**
         * The list of nodes configured by the connection terminal and the corresponding read-only weights.
         */
        nodeWeights: outputs.rds_mysql.InstancesRdsMysqlInstanceEndpointNodeWeight[];
        /**
         * Read and write mode:
         * ReadWrite: read and write
         * ReadOnly: read only (default).
         */
        readWriteMode: string;
    }

    export interface InstancesRdsMysqlInstanceEndpointAddress {
        /**
         * DNS Visibility.
         */
        dnsVisibility: boolean;
        /**
         * Connect domain name.
         */
        domain: string;
        /**
         * The ID of the EIP, only valid for Public addresses.
         */
        eipId: string;
        /**
         * The IP Address.
         */
        ipAddress: string;
        /**
         * Network address type, temporarily Private, Public, PublicService.
         */
        networkType: string;
        /**
         * The Port.
         */
        port: string;
        /**
         * The subnet ID of the RDS instance.
         */
        subnetId: string;
    }

    export interface InstancesRdsMysqlInstanceEndpointNodeWeight {
        /**
         * Node ID.
         */
        nodeId: string;
        /**
         * Node type. Value: Primary: Primary node.
         * Secondary: Standby node.
         * ReadOnly: Read-only node.
         */
        nodeType: string;
        /**
         * The weight of the node.
         */
        weight: number;
    }

    export interface InstancesRdsMysqlInstanceMaintenanceWindow {
        /**
         * DayKind of maintainable window. Value: Week. Month.
         */
        dayKind: string;
        /**
         * Days of maintainable window of the month.
         */
        dayOfMonths: number[];
        /**
         * Days of maintainable window of the week.
         */
        dayOfWeeks: string[];
        /**
         * The maintainable time of the RDS instance.
         */
        maintenanceTime: string;
    }

    export interface InstancesRdsMysqlInstanceNode {
        /**
         * Node creation local time.
         */
        createTime: string;
        /**
         * The id of the RDS instance.
         */
        instanceId: string;
        /**
         * Memory size in GB.
         */
        memory: number;
        /**
         * Node ID.
         */
        nodeId: string;
        /**
         * General instance type, different from Custom instance type.
         */
        nodeSpec: string;
        /**
         * Node state, value: aligned with instance state.
         */
        nodeStatus: string;
        /**
         * Node type. Value: Primary: Primary node.
         * Secondary: Standby node.
         * ReadOnly: Read-only node.
         */
        nodeType: string;
        /**
         * The region of the RDS instance.
         */
        regionId: string;
        /**
         * The update time of the RDS instance.
         */
        updateTime: string;
        /**
         * CPU size.
         */
        vCpu: number;
        /**
         * The available zone of the RDS instance.
         */
        zoneId: string;
    }

    export interface InstancesRdsMysqlInstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface InstancesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

}

export namespace rds_postgresql {
    export interface AccountsAccount {
        /**
         * The name of the database account. This field supports fuzzy query.
         */
        accountName: string;
        /**
         * The privileges of the database account.
         */
        accountPrivileges: string;
        /**
         * The status of the database account.
         */
        accountStatus: string;
        /**
         * The type of the database account.
         */
        accountType: string;
    }

    export interface DatabasesDatabase {
        /**
         * Character classification.
         */
        cType: string;
        /**
         * The character set of the RDS database.
         */
        characterSetName: string;
        /**
         * The collate of database.
         */
        collate: string;
        /**
         * The name of the RDS database.
         */
        dbName: string;
        /**
         * The status of the RDS database.
         */
        dbStatus: string;
        /**
         * The owner of database.
         */
        owner: string;
    }

    export interface InstanceChargeDetail {
        /**
         * Whether to automatically renew in prepaid scenarios.
         */
        autoRenew: boolean;
        /**
         * Billing expiry time (yearly and monthly only).
         */
        chargeEndTime: string;
        /**
         * Billing start time (pay-as-you-go & monthly subscription).
         */
        chargeStartTime: string;
        /**
         * Pay status. Value:
         * normal - normal
         * overdue - overdue
         * .
         */
        chargeStatus: string;
        /**
         * Payment type. Value:
         * PostPaid - Pay-As-You-Go
         * PrePaid - Yearly and monthly (default).
         */
        chargeType: string;
        /**
         * Estimated release time when arrears are closed (pay-as-you-go & monthly subscription).
         */
        overdueReclaimTime: string;
        /**
         * Shutdown time in arrears (pay-as-you-go & monthly subscription).
         */
        overdueTime: string;
        /**
         * Purchase duration in prepaid scenarios. Default: 1.
         */
        period: number;
        /**
         * The purchase cycle in the prepaid scenario.
         * Month - monthly subscription (default)
         * Year - Package year.
         */
        periodUnit: string;
        /**
         * Temporary upgrade of restoration time.
         */
        tempModifyEndTime: string;
        /**
         * Start time of temporary upgrade.
         */
        tempModifyStartTime: string;
    }

    export interface InstanceChargeInfo {
        /**
         * Whether to automatically renew in prepaid scenarios.
         */
        autoRenew: boolean;
        /**
         * Payment type. Value:
         * PostPaid - Pay-As-You-Go
         * PrePaid - Yearly and monthly (default).
         */
        chargeType: string;
        /**
         * Purchase duration in prepaid scenarios. Default: 1.
         */
        period: number;
        /**
         * The purchase cycle in the prepaid scenario.
         * Month - monthly subscription (default)
         * Year - Package year.
         */
        periodUnit: string;
    }

    export interface InstanceEndpoint {
        /**
         * Address list.
         */
        addresses: outputs.rds_postgresql.InstanceEndpointAddress[];
        /**
         * When the terminal type is read-write terminal or read-only terminal, it supports setting whether new nodes are automatically added.
         */
        autoAddNewNodes: string;
        /**
         * Address description.
         */
        description: string;
        /**
         * Whether global read-only is enabled, value: Enable: Enable. Disable: Disabled.
         */
        enableReadOnly: string;
        /**
         * Whether read-write separation is enabled, value: Enable: Enable. Disable: Disabled.
         */
        enableReadWriteSplitting: string;
        /**
         * Instance connection terminal ID.
         */
        endpointId: string;
        /**
         * The instance connection terminal name.
         */
        endpointName: string;
        /**
         * Terminal type:
         * Cluster: The default terminal. (created by default)
         * Primary: Primary node terminal.
         * Custom: Custom terminal.
         * Direct: Direct connection to the terminal. (Only the operation and maintenance side)
         * AllNode: All node terminals. (Only the operation and maintenance side).
         */
        endpointType: string;
        /**
         * The list of nodes configured by the connection terminal and the corresponding read-only weights.
         */
        readOnlyNodeWeights: outputs.rds_postgresql.InstanceEndpointReadOnlyNodeWeight[];
        /**
         * Read and write mode:
         * ReadWrite: read and write
         * ReadOnly: read only (default).
         */
        readWriteMode: string;
    }

    export interface InstanceEndpointAddress {
        /**
         * DNS Visibility.
         */
        dnsVisibility: boolean;
        /**
         * Connect domain name.
         */
        domain: string;
        /**
         * The ID of the EIP, only valid for Public addresses.
         */
        eipId: string;
        /**
         * The IP Address.
         */
        ipAddress: string;
        /**
         * Network address type, temporarily Private, Public, PublicService.
         */
        networkType: string;
        /**
         * The Port.
         */
        port: string;
        /**
         * Subnet ID of the RDS PostgreSQL instance.
         */
        subnetId: string;
    }

    export interface InstanceEndpointReadOnlyNodeWeight {
        /**
         * Node ID.
         */
        nodeId: string;
        /**
         * Node type. Value: Primary: Primary node.
         * Secondary: Standby node.
         * ReadOnly: Read-only node.
         */
        nodeType: string;
        /**
         * The weight of the node.
         */
        weight: number;
    }

    export interface InstanceNode {
        /**
         * Node creation local time.
         */
        createTime: string;
        /**
         * Instance ID.
         */
        instanceId: string;
        /**
         * Memory size in GB.
         */
        memory: number;
        /**
         * Node ID.
         */
        nodeId: string;
        /**
         * The specification of primary node and secondary node.
         */
        nodeSpec: string;
        /**
         * Node state, value: aligned with instance state.
         */
        nodeStatus: string;
        /**
         * Node type. Value: Primary: Primary node.
         * Secondary: Standby node.
         * ReadOnly: Read-only node.
         */
        nodeType: string;
        /**
         * The region of the RDS PostgreSQL instance.
         */
        regionId: string;
        /**
         * The update time of the RDS PostgreSQL instance.
         */
        updateTime: string;
        /**
         * CPU size.
         */
        vCpu: number;
        /**
         * The available zone of the RDS PostgreSQL instance.
         */
        zoneId: string;
    }

    export interface InstanceParameter {
        /**
         * Parameter name.
         */
        name: string;
        /**
         * Parameter value.
         */
        value: string;
    }

    export interface InstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface InstancesInstance {
        /**
         * The instance has used backup space. Unit: GB.
         */
        backupUse: number;
        /**
         * Payment methods.
         */
        chargeDetails: outputs.rds_postgresql.InstancesInstanceChargeDetail[];
        /**
         * Node creation local time.
         */
        createTime: string;
        /**
         * Data synchronization mode.
         */
        dataSyncMode: string;
        /**
         * The version of the RDS PostgreSQL instance.
         */
        dbEngineVersion: string;
        /**
         * The endpoint info of the RDS instance.
         */
        endpoints: outputs.rds_postgresql.InstancesInstanceEndpoint[];
        /**
         * The ID of the RDS PostgreSQL instance.
         */
        id: string;
        /**
         * The id of the RDS PostgreSQL instance.
         */
        instanceId: string;
        /**
         * The name of the RDS PostgreSQL instance.
         */
        instanceName: string;
        /**
         * The status of the RDS PostgreSQL instance.
         */
        instanceStatus: string;
        /**
         * The instance type of the RDS PostgreSQL instance.
         */
        instanceType: string;
        /**
         * Memory size in GB.
         */
        memory: number;
        /**
         * The number of nodes.
         */
        nodeNumber: number;
        /**
         * General instance type, different from Custom instance type.
         */
        nodeSpec: string;
        /**
         * Instance node information.
         */
        nodes: outputs.rds_postgresql.InstancesInstanceNode[];
        /**
         * The project name of the RDS PostgreSQL instance.
         */
        projectName: string;
        /**
         * The region of the RDS PostgreSQL instance.
         */
        regionId: string;
        /**
         * Total instance storage space. Unit: GB.
         */
        storageSpace: number;
        /**
         * Instance storage type.
         */
        storageType: string;
        /**
         * The subnet ID of the RDS PostgreSQL instance.
         */
        subnetId: string;
        /**
         * Tags.
         */
        tags: outputs.rds_postgresql.InstancesInstanceTag[];
        /**
         * The update time of the RDS PostgreSQL instance.
         */
        updateTime: string;
        /**
         * CPU size.
         */
        vCpu: number;
        /**
         * The vpc ID of the RDS PostgreSQL instance.
         */
        vpcId: string;
        /**
         * The available zone of the RDS PostgreSQL instance.
         */
        zoneId: string;
        /**
         * ID of the availability zone where each instance is located.
         */
        zoneIds: string[];
    }

    export interface InstancesInstanceChargeDetail {
        /**
         * Whether to automatically renew in prepaid scenarios.
         * Autorenew_Enable
         * Autorenew_Disable (default).
         */
        autoRenew: boolean;
        /**
         * Billing expiry time (yearly and monthly only).
         */
        chargeEndTime: string;
        /**
         * Billing start time (pay-as-you-go & monthly subscription).
         */
        chargeStartTime: string;
        /**
         * Pay status. Value:
         * normal - normal
         * overdue - overdue
         * .
         */
        chargeStatus: string;
        /**
         * The charge type of the RDS instance.
         */
        chargeType: string;
        /**
         * Estimated release time when arrears are closed (pay-as-you-go & monthly subscription).
         */
        overdueReclaimTime: string;
        /**
         * Shutdown time in arrears (pay-as-you-go & monthly subscription).
         */
        overdueTime: string;
        /**
         * Purchase duration in prepaid scenarios. Default: 1.
         */
        period: number;
        /**
         * The purchase cycle in the prepaid scenario.
         * Month - monthly subscription (default)
         * Year - Package year.
         */
        periodUnit: string;
        /**
         * Temporary upgrade of restoration time.
         */
        tempModifyEndTime: string;
        /**
         * Start time of temporary upgrade.
         */
        tempModifyStartTime: string;
    }

    export interface InstancesInstanceEndpoint {
        /**
         * Address list.
         */
        addresses: outputs.rds_postgresql.InstancesInstanceEndpointAddress[];
        /**
         * When the terminal type is read-write terminal or read-only terminal, it supports setting whether new nodes are automatically added.
         */
        autoAddNewNodes: string;
        /**
         * Address description.
         */
        description: string;
        /**
         * Whether global read-only is enabled, value: Enable: Enable. Disable: Disabled.
         */
        enableReadOnly: string;
        /**
         * Whether read-write separation is enabled, value: Enable: Enable. Disable: Disabled.
         */
        enableReadWriteSplitting: string;
        /**
         * Instance connection terminal ID.
         */
        endpointId: string;
        /**
         * The instance connection terminal name.
         */
        endpointName: string;
        /**
         * Terminal type:
         * Cluster: The default terminal. (created by default)
         * Primary: Primary node terminal.
         * Custom: Custom terminal.
         * Direct: Direct connection to the terminal. (Only the operation and maintenance side)
         * AllNode: All node terminals. (Only the operation and maintenance side).
         */
        endpointType: string;
        /**
         * The list of nodes configured by the connection terminal and the corresponding read-only weights.
         */
        readOnlyNodeWeights: outputs.rds_postgresql.InstancesInstanceEndpointReadOnlyNodeWeight[];
        /**
         * Read and write mode:
         * ReadWrite: read and write
         * ReadOnly: read only (default).
         */
        readWriteMode: string;
    }

    export interface InstancesInstanceEndpointAddress {
        /**
         * DNS Visibility.
         */
        dnsVisibility: boolean;
        /**
         * Connect domain name.
         */
        domain: string;
        /**
         * The ID of the EIP, only valid for Public addresses.
         */
        eipId: string;
        /**
         * The IP Address.
         */
        ipAddress: string;
        /**
         * Network address type, temporarily Private, Public, PublicService.
         */
        networkType: string;
        /**
         * The Port.
         */
        port: string;
        /**
         * The subnet ID of the RDS PostgreSQL instance.
         */
        subnetId: string;
    }

    export interface InstancesInstanceEndpointReadOnlyNodeWeight {
        /**
         * Node ID.
         */
        nodeId: string;
        /**
         * Node type. Value: Primary: Primary node.
         * Secondary: Standby node.
         * ReadOnly: Read-only node.
         */
        nodeType: string;
        /**
         * The weight of the node.
         */
        weight: number;
    }

    export interface InstancesInstanceNode {
        /**
         * Node creation local time.
         */
        createTime: string;
        /**
         * The id of the RDS PostgreSQL instance.
         */
        instanceId: string;
        /**
         * Memory size in GB.
         */
        memory: number;
        /**
         * Node ID.
         */
        nodeId: string;
        /**
         * General instance type, different from Custom instance type.
         */
        nodeSpec: string;
        /**
         * Node state, value: aligned with instance state.
         */
        nodeStatus: string;
        /**
         * Node type. Value: Primary: Primary node.
         * Secondary: Standby node.
         * ReadOnly: Read-only node.
         */
        nodeType: string;
        /**
         * The region of the RDS PostgreSQL instance.
         */
        regionId: string;
        /**
         * The update time of the RDS PostgreSQL instance.
         */
        updateTime: string;
        /**
         * CPU size.
         */
        vCpu: number;
        /**
         * The available zone of the RDS PostgreSQL instance.
         */
        zoneId: string;
    }

    export interface InstancesInstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface InstancesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface SchemasSchema {
        /**
         * The name of the database.
         */
        dbName: string;
        /**
         * The owner of the schema.
         */
        owner: string;
        /**
         * The name of the schema.
         */
        schemaName: string;
    }

}

export namespace rds_v2 {
    export interface RdsInstanceV2ChargeInfo {
        /**
         * Whether to automatically renew in prepaid scenarios.
         */
        autoRenew: boolean;
        /**
         * Payment type. Value:
         * PostPaid - Pay-As-You-Go
         * PrePaid - Yearly and monthly (default).
         */
        chargeType: string;
        /**
         * Purchase duration in prepaid scenarios. Default: 1.
         */
        period: number;
        /**
         * The purchase cycle in the prepaid scenario.
         * Month - monthly subscription (default)
         * Year - Package year.
         */
        periodUnit: string;
    }

    export interface RdsInstanceV2ConnectionInfo {
        /**
         * Address list.
         */
        addresses: outputs.rds_v2.RdsInstanceV2ConnectionInfoAddress[];
        /**
         * When the terminal type is read-write terminal or read-only terminal, it supports setting whether new nodes are automatically added.
         */
        autoAddNewNodes: string;
        /**
         * Address description.
         */
        description: string;
        /**
         * Whether global read-only is enabled, value: Enable: Enable. Disable: Disabled.
         */
        enableReadOnly: string;
        /**
         * Whether read-write separation is enabled, value: Enable: Enable. Disable: Disabled.
         */
        enableReadWriteSplitting: string;
        /**
         * Instance connection terminal ID.
         */
        endpointId: string;
        /**
         * The instance connection terminal name.
         */
        endpointName: string;
        /**
         * Terminal type:
         * Cluster: The default terminal. (created by default)
         * Primary: Primary node terminal.
         * Custom: Custom terminal.
         * Direct: Direct connection to the terminal. (Only the operation and maintenance side)
         * AllNode: All node terminals. (Only the operation and maintenance side).
         */
        endpointType: string;
        /**
         * The list of nodes configured by the connection terminal and the corresponding read-only weights.
         */
        readOnlyNodeWeights: outputs.rds_v2.RdsInstanceV2ConnectionInfoReadOnlyNodeWeight[];
        /**
         * Read and write mode:
         * ReadWrite: read and write
         * ReadOnly: read only (default).
         */
        readWriteMode: string;
    }

    export interface RdsInstanceV2ConnectionInfoAddress {
        /**
         * Connect domain name.
         */
        domain: string;
        /**
         * The ID of the EIP, only valid for Public addresses.
         */
        eipId: string;
        /**
         * The IP Address.
         */
        ipAddress: string;
        /**
         * Network address type, temporarily Private, Public, PublicService.
         */
        networkType: string;
        /**
         * The Port.
         */
        port: string;
        /**
         * Subnet ID.
         */
        subnetId: string;
    }

    export interface RdsInstanceV2ConnectionInfoReadOnlyNodeWeight {
        /**
         * The ID of the node.
         */
        nodeId: string;
        /**
         * Node type, the value is "Primary", "Secondary", "ReadOnly".
         */
        nodeType: string;
        /**
         * The weight of the node.
         */
        weight: number;
    }

    export interface RdsInstanceV2NodeInfo {
        /**
         * The ID of the node.
         */
        nodeId: string;
        /**
         * Masternode specs. Pass
         * DescribeDBInstanceSpecs Query the instance specifications that can be sold.
         */
        nodeSpec: string;
        /**
         * Node type, the value is "Primary", "Secondary", "ReadOnly".
         */
        nodeType: string;
        /**
         * Zone ID.
         */
        zoneId: string;
    }

    export interface RdsInstancesV2RdsInstance {
        /**
         * Payment methods.
         */
        chargeDetail: outputs.rds_v2.RdsInstancesV2RdsInstanceChargeDetail;
        /**
         * The connection info ot the RDS instance.
         */
        connectionInfos: outputs.rds_v2.RdsInstancesV2RdsInstanceConnectionInfo[];
        /**
         * Node creation local time.
         */
        createTime: string;
        /**
         * The engine of the RDS instance.
         */
        dbEngine: string;
        /**
         * The version of the RDS instance, Value:
         * MySQL Community:
         * MySQL_5.7 - MySQL 5.7
         * MySQL_8_0 - MySQL 8.0
         * PostgreSQL Community:
         * PostgreSQL_11 - PostgreSQL 11
         * PostgreSQL_12 - PostgreSQL 12
         * Microsoft SQL Server: Not available at this time
         * SQLServer_2019 - SQL Server 2019
         * veDB for MySQL:
         * MySQL_8_0 - MySQL 8.0
         * veDB for PostgreSQL:
         * PostgreSQL_13 - PostgreSQL 13.
         */
        dbEngineVersion: string;
        /**
         * The ID of the RDS instance.
         */
        id: string;
        /**
         * The id of the RDS instance.
         */
        instanceId: string;
        /**
         * The name of the RDS instance.
         */
        instanceName: string;
        /**
         * The status of the RDS instance, Value:
         * Running - running
         * Creating - Creating
         * Deleting - Deleting
         * Restarting - Restarting
         * Restoring - Restoring
         * Updating - changing
         * Upgrading - Upgrading
         * Error - the error.
         */
        instanceStatus: string;
        /**
         * The type of the RDS instance, Value:
         * Value:
         * RDS for MySQL:
         * HA - high availability version;
         * RDS for PostgreSQL:
         * HA - high availability version;
         * Microsoft SQL Server: Not available at this time
         * Enterprise - Enterprise Edition
         * Standard - Standard Edition
         * Web - Web version
         * veDB for MySQL:
         * Cluster - Cluster Edition
         * veDB for PostgreSQL:
         * Cluster - Cluster Edition
         * MySQL Sharding:
         * HA - high availability version;.
         */
        instanceType: string;
        /**
         * Instance node information.
         */
        nodeDetailInfos: outputs.rds_v2.RdsInstancesV2RdsInstanceNodeDetailInfo[];
        /**
         * The number of nodes.
         */
        nodeNumber: number;
        /**
         * General instance type, different from Custom instance type.
         */
        nodeSpec: string;
        /**
         * Instance intranet port.
         */
        port: string;
        /**
         * Subordinate to the project.
         */
        projectName: string;
        /**
         * The region of the RDS instance.
         */
        regionId: string;
        /**
         * The number of shards.
         */
        shardNumber: number;
        /**
         * Total instance storage space. Unit: GB.
         */
        storageSpace: number;
        /**
         * Instance storage type. When the database type is MySQL/PostgreSQL/SQL_Server/MySQL Sharding, the value is:
         * LocalSSD - local SSD disk
         * When the database type is veDB_MySQL/veDB_PostgreSQL, the value is:
         * DistributedStorage - Distributed Storage.
         */
        storageType: string;
        /**
         * The instance has used storage space. Unit: GB.
         */
        storageUse: number;
        /**
         * The subnet ID of the RDS instance.
         */
        subnetId: string;
        /**
         * Time zone.
         */
        timeZone: string;
        /**
         * The vpc ID of the RDS instance.
         */
        vpcId: string;
        /**
         * The available zone of the RDS instance.
         */
        zoneId: string;
    }

    export interface RdsInstancesV2RdsInstanceChargeDetail {
        /**
         * Whether to automatically renew in prepaid scenarios.
         * Autorenew_Enable
         * Autorenew_Disable (default).
         */
        autoRenew: boolean;
        /**
         * Billing expiry time (yearly and monthly only).
         */
        chargeEndTime: string;
        /**
         * Billing start time (pay-as-you-go & monthly subscription).
         */
        chargeStartTime: string;
        /**
         * Pay status. Value:
         * normal - normal
         * overdue - overdue
         * .
         */
        chargeStatus: string;
        /**
         * The charge type of the RDS instance.
         */
        chargeType: string;
        /**
         * Estimated release time when arrears are closed (pay-as-you-go & monthly subscription).
         */
        overdueReclaimTime: string;
        /**
         * Shutdown time in arrears (pay-as-you-go & monthly subscription).
         */
        overdueTime: string;
        /**
         * Purchase duration in prepaid scenarios. Default: 1.
         */
        period: number;
        /**
         * The purchase cycle in the prepaid scenario.
         * Month - monthly subscription (default)
         * Year - Package year.
         */
        periodUnit: string;
    }

    export interface RdsInstancesV2RdsInstanceConnectionInfo {
        /**
         * Address list.
         */
        addresses: outputs.rds_v2.RdsInstancesV2RdsInstanceConnectionInfoAddress[];
        /**
         * When the terminal type is read-write terminal or read-only terminal, it supports setting whether new nodes are automatically added.
         */
        autoAddNewNodes: string;
        /**
         * Address description.
         */
        description: string;
        /**
         * Whether global read-only is enabled, value: Enable: Enable. Disable: Disabled.
         */
        enableReadOnly: string;
        /**
         * Whether read-write separation is enabled, value: Enable: Enable. Disable: Disabled.
         */
        enableReadWriteSplitting: string;
        /**
         * Instance connection terminal ID.
         */
        endpointId: string;
        /**
         * The instance connection terminal name.
         */
        endpointName: string;
        /**
         * Terminal type:
         * Cluster: The default terminal. (created by default)
         * Primary: Primary node terminal.
         * Custom: Custom terminal.
         * Direct: Direct connection to the terminal. (Only the operation and maintenance side)
         * AllNode: All node terminals. (Only the operation and maintenance side).
         */
        endpointType: string;
        /**
         * The list of nodes configured by the connection terminal and the corresponding read-only weights.
         */
        readOnlyNodeWeights: outputs.rds_v2.RdsInstancesV2RdsInstanceConnectionInfoReadOnlyNodeWeight[];
        /**
         * Read and write mode:
         * ReadWrite: read and write
         * ReadOnly: read only (default).
         */
        readWriteMode: string;
    }

    export interface RdsInstancesV2RdsInstanceConnectionInfoAddress {
        /**
         * Connect domain name.
         */
        domain: string;
        /**
         * The ID of the EIP, only valid for Public addresses.
         */
        eipId: string;
        /**
         * The IP Address.
         */
        ipAddress: string;
        /**
         * Network address type, temporarily Private, Public, PublicService.
         */
        networkType: string;
        /**
         * Instance intranet port.
         */
        port: string;
        /**
         * The subnet ID of the RDS instance.
         */
        subnetId: string;
    }

    export interface RdsInstancesV2RdsInstanceConnectionInfoReadOnlyNodeWeight {
        /**
         * Node ID.
         */
        nodeId: string;
        /**
         * Node type. Value: Primary: Primary node.
         * Secondary: Standby node.
         * ReadOnly: Read-only node.
         */
        nodeType: string;
        /**
         * The weight of the node.
         */
        weight: number;
    }

    export interface RdsInstancesV2RdsInstanceNodeDetailInfo {
        /**
         * Node creation local time.
         */
        createTime: string;
        /**
         * The id of the RDS instance.
         */
        instanceId: string;
        /**
         * Memory size in GB.
         */
        memory: number;
        /**
         * Node ID.
         */
        nodeId: string;
        /**
         * General instance type, different from Custom instance type.
         */
        nodeSpec: string;
        /**
         * Node state, value: aligned with instance state.
         */
        nodeStatus: string;
        /**
         * Node type. Value: Primary: Primary node.
         * Secondary: Standby node.
         * ReadOnly: Read-only node.
         */
        nodeType: string;
        /**
         * The region of the RDS instance.
         */
        regionId: string;
        /**
         * Node updates local time.
         */
        updateTime: string;
        /**
         * CPU size. For example: 1 means 1U.
         */
        vCpu: number;
        /**
         * The available zone of the RDS instance.
         */
        zoneId: string;
    }

}

export namespace redis {
    export interface AccountsAccount {
        /**
         * The name of the redis account.
         */
        accountName: string;
        /**
         * The description of the redis account.
         */
        description: string;
        /**
         * The id of the Redis instance.
         */
        instanceId: string;
        /**
         * The role info.
         */
        roleName: string;
    }

    export interface AllowListAssociatedInstance {
        /**
         * Id of instance.
         */
        instanceId: string;
        /**
         * Name of instance.
         */
        instanceName: string;
        /**
         * Id of virtual private cloud.
         */
        vpc: string;
    }

    export interface AllowListsAllowList {
        /**
         * Description of allow list.
         */
        allowListDesc: string;
        /**
         * Id of allow list.
         */
        allowListId: string;
        /**
         * The IP number of allow list.
         */
        allowListIpNum: number;
        /**
         * Name of allow list.
         */
        allowListName: string;
        /**
         * Type of allow list.
         */
        allowListType: string;
        /**
         * Ip list of allow list.
         */
        allowLists: string[];
        /**
         * The number of instance that associated to allow list.
         */
        associatedInstanceNum: number;
        /**
         * Instances associated by this allow list.
         */
        associatedInstances: outputs.redis.AllowListsAllowListAssociatedInstance[];
    }

    export interface AllowListsAllowListAssociatedInstance {
        /**
         * The Id of instance.
         */
        instanceId: string;
        /**
         * Name of instance.
         */
        instanceName: string;
        /**
         * Id of virtual private cloud.
         */
        vpc: string;
    }

    export interface BackupInstanceDetail {
        /**
         * Id of account.
         */
        accountId: number;
        /**
         * Arch type of instance(Standard/Cluster).
         */
        archType: string;
        /**
         * Charge type of instance(Postpaid/Prepaid).
         */
        chargeType: string;
        /**
         * Engine version of instance.
         */
        engineVersion: string;
        /**
         * Expired time of instance.
         */
        expiredTime: string;
        /**
         * Id of instance to create backup.
         */
        instanceId: string;
        /**
         * Name of instance.
         */
        instanceName: string;
        /**
         * The maintainable period (in UTC) of the instance.
         */
        maintenanceTime: string;
        /**
         * Network type of instance.
         */
        networkType: string;
        /**
         * Project name of instance.
         */
        projectName: string;
        /**
         * Id of region.
         */
        regionId: string;
        /**
         * Count of replica in which shard.
         */
        replicas: number;
        /**
         * Count of cpu cores of instance.
         */
        serverCpu: number;
        /**
         * Capacity of shard.
         */
        shardCapacity: number;
        /**
         * Count of shard.
         */
        shardCount: number;
        /**
         * Total capacity of instance.
         */
        totalCapacity: number;
        /**
         * Capacity used of this instance.
         */
        usedCapacity: number;
        /**
         * Information of vpc.
         */
        vpcInfos: outputs.redis.BackupInstanceDetailVpcInfo[];
        /**
         * List of id of zone.
         */
        zoneIds: string[];
    }

    export interface BackupInstanceDetailVpcInfo {
        /**
         * Id of vpc.
         */
        id: string;
        /**
         * Name of vpc.
         */
        name: string;
    }

    export interface BackupsBackup {
        /**
         * The id of backup point.
         */
        backupPointId: string;
        /**
         * Backup strategy.
         */
        backupStrategy: string;
        /**
         * Backup type.
         */
        backupType: string;
        /**
         * Query end time.
         */
        endTime: string;
        /**
         * Information of instance.
         */
        instanceDetails: outputs.redis.BackupsBackupInstanceDetail[];
        /**
         * Id of instance.
         */
        instanceId: string;
        /**
         * Size in MiB.
         */
        size: number;
        /**
         * Query start time.
         */
        startTime: string;
        /**
         * Status of backup (Creating/Available/Unavailable/Deleting).
         */
        status: string;
    }

    export interface BackupsBackupInstanceDetail {
        /**
         * Id of account.
         */
        accountId: number;
        /**
         * Arch type of instance(Standard/Cluster).
         */
        archType: string;
        /**
         * Charge type of instance(Postpaid/Prepaid).
         */
        chargeType: string;
        /**
         * Engine version of instance.
         */
        engineVersion: string;
        /**
         * Expired time of instance.
         */
        expiredTime: string;
        /**
         * Id of instance.
         */
        instanceId: string;
        /**
         * Name of instance.
         */
        instanceName: string;
        /**
         * The maintainable period (in UTC) of the instance.
         */
        maintenanceTime: string;
        /**
         * Network type of instance.
         */
        networkType: string;
        /**
         * Project name of instance.
         */
        projectName: string;
        /**
         * Id of region.
         */
        regionId: string;
        /**
         * Count of replica in which shard.
         */
        replicas: number;
        /**
         * Count of cpu cores of instance.
         */
        serverCpu: number;
        /**
         * Capacity of shard.
         */
        shardCapacity: number;
        /**
         * Count of shard.
         */
        shardCount: number;
        /**
         * Total capacity of instance.
         */
        totalCapacity: number;
        /**
         * Capacity used of this instance.
         */
        usedCapacity: number;
        /**
         * Information of vpc.
         */
        vpcInfos: outputs.redis.BackupsBackupInstanceDetailVpcInfo[];
        /**
         * List of id of zone.
         */
        zoneIds: string[];
    }

    export interface BackupsBackupInstanceDetailVpcInfo {
        /**
         * Id of vpc.
         */
        id: string;
        /**
         * Name of vpc.
         */
        name: string;
    }

    export interface InstanceParamValue {
        /**
         * The name of configuration parameter.
         */
        name: string;
        /**
         * The value of configuration parameter.
         */
        value: string;
    }

    export interface InstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface InstancesInstance {
        /**
         * The list of backup plans.
         */
        backupPlan: outputs.redis.InstancesInstanceBackupPlan;
        /**
         * The memory capacity information.
         */
        capacity: outputs.redis.InstancesInstanceCapacity;
        /**
         * The charge type of redis instance to query. Valid values: `PostPaid`, `PrePaid`.
         */
        chargeType: string;
        /**
         * The creation time of the redis instance.
         */
        createTime: string;
        /**
         * whether enable deletion protection.
         */
        deletionProtection: string;
        /**
         * The engine version of redis instance to query. Valid values: `4.0`, `5.0`, `6.0`.
         */
        engineVersion: string;
        /**
         * The expire time of the redis instance, valid when charge type is `PrePaid`.
         */
        expiredTime: string;
        /**
         * The id of the redis instance.
         */
        id: string;
        /**
         * The id of redis instance to query. This field supports fuzzy queries.
         */
        instanceId: string;
        /**
         * The name of redis instance to query. This field supports fuzzy queries.
         */
        instanceName: string;
        /**
         * The maintainable time of the redis instance.
         */
        maintenanceTime: string;
        /**
         * The list of redis instance node IDs.
         */
        nodeIds: string[];
        /**
         * The number of nodes in each shard.
         */
        nodeNumber: number;
        /**
         * The list of params.
         */
        params: outputs.redis.InstancesInstanceParam[];
        /**
         * The project name of redis instance to query.
         */
        projectName: string;
        /**
         * The region id of the redis instance.
         */
        regionId: string;
        /**
         * The memory capacity of each shard. Unit: GiB.
         */
        shardCapacity: number;
        /**
         * The number of shards in the redis instance.
         */
        shardNumber: number;
        /**
         * Whether enable sharded cluster for redis instance. Valid values: 0, 1.
         */
        shardedCluster: number;
        /**
         * The status of redis instance to query.
         */
        status: string;
        /**
         * The subnet id of the redis instance.
         */
        subnetId: string;
        /**
         * Tags.
         */
        tags: outputs.redis.InstancesInstanceTag[];
        /**
         * The list of connection information.
         */
        visitAddrs: outputs.redis.InstancesInstanceVisitAddr[];
        /**
         * Whether to enable password-free access when connecting to an instance through a private network.
         */
        vpcAuthMode: string;
        /**
         * The vpc id of redis instance to query. This field supports fuzzy queries.
         */
        vpcId: string;
        /**
         * The list of zone ID which the redis instance belongs.
         */
        zoneIds: string[];
    }

    export interface InstancesInstanceBackupPlan {
        /**
         * Whether enable auto backup.
         */
        active: boolean;
        /**
         * The time period to start performing the backup. The value range is any integer between 0 and 23, where 0 means that the system will perform the backup in the period of 00:00~01:00, 1 means that the backup will be performed in the period of 01:00~02:00, and so on.
         */
        backupHour: number;
        /**
         * The backup type.
         */
        backupType: string;
        /**
         * The expected time for the next backup to be performed.
         */
        expectNextBackupTime: string;
        /**
         * The id of redis instance to query. This field supports fuzzy queries.
         */
        instanceId: string;
        /**
         * The last time the backup policy was modified.
         */
        lastUpdateTime: string;
        /**
         * The backup cycle. The value can be any integer between 1 and 7. Among them, 1 means backup every Monday, 2 means backup every Tuesday, and so on.
         */
        periods: number[];
        /**
         * The number of days to keep backups, the default is 7 days.
         */
        ttl: number;
    }

    export interface InstancesInstanceCapacity {
        /**
         * The total memory capacity of the redis instance. Unit: MiB.
         */
        total: number;
        /**
         * The used memory capacity of the redis instance. Unit: MiB.
         */
        used: number;
    }

    export interface InstancesInstanceParam {
        /**
         * Current value of the configuration parameter.
         */
        currentValue: string;
        /**
         * Default value of the configuration parameter.
         */
        defaultValue: string;
        /**
         * The description of this option item.
         */
        description: string;
        /**
         * Whether the current redis instance supports editing this parameter.
         */
        editableForInstance: boolean;
        /**
         * Whether need to reboot the redis instance when modifying this parameter.
         */
        needReboot: boolean;
        /**
         * The list of options. Valid when the configuration parameter type is `Radio`.
         */
        options: outputs.redis.InstancesInstanceParamOption[];
        /**
         * The name of the configuration parameter.
         */
        paramName: string;
        /**
         * The valid value range of the numeric type configuration parameter.
         */
        range: string;
        /**
         * The type of the configuration parameter.
         */
        type: string;
        /**
         * The unit of the numeric type configuration parameter.
         */
        unit: string;
    }

    export interface InstancesInstanceParamOption {
        /**
         * The description of this option item.
         */
        description: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface InstancesInstanceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface InstancesInstanceVisitAddr {
        /**
         * The connection address type.
         */
        addrType: string;
        /**
         * The connection address.
         */
        address: string;
        /**
         * The EIP ID bound to the instance's public network address.
         */
        eipId: string;
        /**
         * The connection port.
         */
        port: string;
    }

    export interface InstancesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface PitrTimeWindowsPeriod {
        endTime: string;
        instanceId: string;
        startTime: string;
    }

    export interface RegionsRegion {
        /**
         * Target region info.
         */
        regionId: string;
        /**
         * The name of region.
         */
        regionName: string;
    }

    export interface ZonesZone {
        /**
         * The id of the zone.
         */
        id: string;
        /**
         * The id of the zone.
         */
        zoneId: string;
        /**
         * The name of the zone.
         */
        zoneName: string;
    }

}

export namespace tls {
    export interface AlarmAlarmPeriodDetail {
        /**
         * Email alarm period, the unit is minutes, and the value range is 1~1440.
         */
        email: number;
        /**
         * Customize the webhook alarm period, the unit is minutes, and the value range is 1~1440.
         */
        generalWebhook: number;
        /**
         * Telephone alarm cycle, the unit is minutes, and the value range is 10~1440.
         */
        phone: number;
        /**
         * SMS alarm cycle, the unit is minutes, and the value range is 10~1440.
         */
        sms: number;
    }

    export interface AlarmNotifyGroupReceiver {
        /**
         * The end time.
         */
        endTime: string;
        /**
         * The list of the receiver channels. Currently supported channels: Email, Sms, Phone.
         */
        receiverChannels: string[];
        /**
         * List of the receiver names.
         */
        receiverNames: string[];
        /**
         * The receiver type, Can be set as: `User`(The id of user).
         */
        receiverType: string;
        /**
         * The start time.
         */
        startTime: string;
    }

    export interface AlarmNotifyGroupsGroup {
        /**
         * The id of the alarm notify group.
         */
        alarmNotifyGroupId: string;
        /**
         * The name of the alarm notify group.
         */
        alarmNotifyGroupName: string;
        /**
         * The create time the notification.
         */
        createTime: string;
        /**
         * The name of the iam project.
         */
        iamProjectName: string;
        /**
         * The modification time the notification.
         */
        modifyTime: string;
        /**
         * The notify group type.
         */
        notifyTypes: string[];
        /**
         * List of IAM users to receive alerts.
         */
        receivers: outputs.tls.AlarmNotifyGroupsGroupReceiver[];
    }

    export interface AlarmNotifyGroupsGroupReceiver {
        /**
         * The end time.
         */
        endTime: string;
        /**
         * The list of the receiver channels.
         */
        receiverChannels: string[];
        /**
         * List of the receiver names.
         */
        receiverNames: string[];
        /**
         * The receiver type.
         */
        receiverType: string;
        /**
         * The start time.
         */
        startTime: string;
    }

    export interface AlarmQueryRequest {
        /**
         * The end time of the query range is relative to the current historical time. The unit is minutes. The value is not positive and must be greater than StartTimeOffset. The maximum value is 0 and the minimum value is -1440.
         */
        endTimeOffset: number;
        /**
         * Alarm object sequence number; increments from 1.
         */
        number: number;
        /**
         * Query statement, the maximum supported length is 1024.
         */
        query: string;
        /**
         * The start time of the query range is relative to the current historical time, in minutes. The value is non-positive, the maximum value is 0, and the minimum value is -1440.
         */
        startTimeOffset: number;
        /**
         * The id of the topic.
         */
        topicId: string;
    }

    export interface AlarmRequestCycle {
        /**
         * The cycle of alarm task execution, or the time point of periodic execution. The unit is minutes, and the value range is 1~1440.
         */
        time: number;
        /**
         * Execution cycle type.
         * Period: Periodic execution, which means executing once every certain period of time.
         * Fixed: Regular execution, which means executing at a fixed time point every day.
         */
        type: string;
    }

    export interface AlarmsAlarm {
        /**
         * The alarm id.
         */
        alarmId: string;
        /**
         * The alarm name.
         */
        alarmName: string;
        /**
         * List of notification groups corresponding to the alarm.
         */
        alarmNotifyGroups: outputs.tls.AlarmsAlarmAlarmNotifyGroup[];
        /**
         * Period for sending alarm notifications. When the number of continuous alarm triggers reaches the specified limit (TriggerPeriod), Log Service will send alarm notifications according to the specified period.
         */
        alarmPeriod: number;
        /**
         * Period for sending alarm notifications. When the number of continuous alarm triggers reaches the specified limit (TriggerPeriod), Log Service will send alarm notifications according to the specified period.
         */
        alarmPeriodDetails: outputs.tls.AlarmsAlarmAlarmPeriodDetail[];
        /**
         * Alarm trigger condition.
         */
        condition: string;
        /**
         * The create time.
         */
        createTime: string;
        /**
         * The modify time.
         */
        modifyTime: string;
        /**
         * The project id.
         */
        projectId: string;
        /**
         * Search and analyze sentences, 1~3 can be configured.
         */
        queryRequests: outputs.tls.AlarmsAlarmQueryRequest[];
        /**
         * The execution period of the alarm task.
         */
        requestCycles: outputs.tls.AlarmsAlarmRequestCycle[];
        /**
         * The status.
         */
        status: boolean;
        /**
         * Continuous cycle. The alarm will be issued after the trigger condition is continuously met for TriggerPeriod periods; the minimum value is 1, the maximum value is 10, and the default value is 1.
         */
        triggerPeriod: number;
        /**
         * Customize the alarm notification content.
         */
        userDefineMsg: string;
    }

    export interface AlarmsAlarmAlarmNotifyGroup {
        /**
         * The id of the notify group.
         */
        alarmNotifyGroupId: string;
        /**
         * Name of the notification group.
         */
        alarmNotifyGroupName: string;
        /**
         * The create time.
         */
        createTime: string;
        /**
         * The iam project name.
         */
        iamProjectName: string;
        /**
         * The modify time.
         */
        modifyTime: string;
        /**
         * The notify group type.
         */
        notifyTypes: string[];
        /**
         * List of IAM users to receive alerts.
         */
        receivers: outputs.tls.AlarmsAlarmAlarmNotifyGroupReceiver[];
    }

    export interface AlarmsAlarmAlarmNotifyGroupReceiver {
        /**
         * The end time.
         */
        endTime: string;
        /**
         * The list of the receiver channels.
         */
        receiverChannels: string[];
        /**
         * List of the receiver names.
         */
        receiverNames: string[];
        /**
         * The receiver type.
         */
        receiverType: string;
        /**
         * The start time.
         */
        startTime: string;
    }

    export interface AlarmsAlarmAlarmPeriodDetail {
        /**
         * Email alarm period, the unit is minutes, and the value range is 1~1440.
         */
        email: number;
        /**
         * Customize the webhook alarm period, the unit is minutes, and the value range is 1~1440.
         */
        generalWebhook: number;
        /**
         * Telephone alarm cycle, the unit is minutes, and the value range is 10~1440.
         */
        phone: number;
        /**
         * SMS alarm cycle, the unit is minutes, and the value range is 10~1440.
         */
        sms: number;
    }

    export interface AlarmsAlarmQueryRequest {
        /**
         * The end time of the query range is relative to the current historical time. The unit is minutes. The value is not positive and must be greater than StartTimeOffset. The maximum value is 0 and the minimum value is -1440.
         */
        endTimeOffset: number;
        /**
         * Alarm object sequence number; increments from 1.
         */
        number: number;
        /**
         * Query statement, the maximum supported length is 1024.
         */
        query: string;
        /**
         * The start time of the query range is relative to the current historical time, in minutes. The value is non-positive, the maximum value is 0, and the minimum value is -1440.
         */
        startTimeOffset: number;
        /**
         * The topic id.
         */
        topicId: string;
        /**
         * The topic name.
         */
        topicName: string;
    }

    export interface AlarmsAlarmRequestCycle {
        /**
         * The cycle of alarm task execution, or the time point of periodic execution. The unit is minutes, and the value range is 1~1440.
         */
        time: number;
        /**
         * Execution cycle type.
         */
        type: string;
    }

    export interface HostGroupsInfo {
        /**
         * The abnormal heartbeat status count of host.
         */
        abnormalHeartbeatStatusCount: number;
        /**
         * The latest version of log collector.
         */
        agentLatestVersion: string;
        /**
         * Whether enable auto update.
         */
        autoUpdate: boolean;
        /**
         * The create time of host group.
         */
        createTime: string;
        /**
         * The count of host.
         */
        hostCount: number;
        /**
         * The id of host group.
         */
        hostGroupId: string;
        /**
         * The name of host group.
         */
        hostGroupName: string;
        /**
         * The type of host group.
         */
        hostGroupType: string;
        /**
         * The identifier of host.
         */
        hostIdentifier: string;
        /**
         * The ip list of host group.
         */
        hostIpLists: string[];
        /**
         * The project name of iam.
         */
        iamProjectName: string;
        /**
         * The modify time of host group.
         */
        modifyTime: string;
        /**
         * The normal heartbeat status count of host.
         */
        normalHeartbeatStatusCount: number;
        /**
         * The rule count of host.
         */
        ruleCount: number;
        /**
         * Whether enable service logging.
         */
        serviceLogging: boolean;
        /**
         * The update end time of log collector.
         */
        updateEndTime: string;
        /**
         * The update start time of log collector.
         */
        updateStartTime: string;
    }

    export interface HostsHostInfo {
        /**
         * The the heartbeat status.
         */
        heartbeatStatus: number;
        /**
         * The id of host group.
         */
        hostGroupId: string;
        /**
         * The ip address.
         */
        ip: string;
        /**
         * The version of log collector.
         */
        logCollectorVersion: string;
    }

    export interface IndexFullText {
        /**
         * Whether the FullTextInfo is case sensitive.
         */
        caseSensitive: boolean;
        /**
         * The delimiter of the FullTextInfo.
         */
        delimiter?: string;
        /**
         * Whether the FullTextInfo include chinese.
         */
        includeChinese?: boolean;
    }

    export interface IndexKeyValue {
        /**
         * Whether the value is case sensitive.
         */
        caseSensitive?: boolean;
        /**
         * The delimiter of the value.
         */
        delimiter?: string;
        /**
         * Whether the value include chinese.
         */
        includeChinese?: boolean;
        /**
         * The JSON subfield key value index.
         */
        jsonKeys?: outputs.tls.IndexKeyValueJsonKey[];
        /**
         * The key of the KeyValueInfo.
         */
        key: string;
        /**
         * Whether the filed is enabled for analysis.
         */
        sqlFlag?: boolean;
        /**
         * The type of value. Valid values: `long`, `double`, `text`, `json`.
         */
        valueType: string;
    }

    export interface IndexKeyValueJsonKey {
        /**
         * The key of the subfield key value index.
         */
        key: string;
        /**
         * The type of value. Valid values: `long`, `double`, `text`.
         */
        valueType: string;
    }

    export interface IndexUserInnerKeyValue {
        /**
         * Whether the value is case sensitive.
         */
        caseSensitive?: boolean;
        /**
         * The delimiter of the value.
         */
        delimiter?: string;
        /**
         * Whether the value include chinese.
         */
        includeChinese?: boolean;
        /**
         * The JSON subfield key value index.
         */
        jsonKeys?: outputs.tls.IndexUserInnerKeyValueJsonKey[];
        /**
         * The key of the KeyValueInfo.
         */
        key: string;
        /**
         * Whether the filed is enabled for analysis.
         */
        sqlFlag?: boolean;
        /**
         * The type of value. Valid values: `long`, `double`, `text`, `json`.
         */
        valueType: string;
    }

    export interface IndexUserInnerKeyValueJsonKey {
        /**
         * The key of the subfield key value index.
         */
        key: string;
        /**
         * The type of value. Valid values: `long`, `double`, `text`.
         */
        valueType: string;
    }

    export interface IndexesTlsIndex {
        /**
         * The create time of the tls index.
         */
        createTime: string;
        /**
         * The FullText index of the tls topic.
         */
        fullText: outputs.tls.IndexesTlsIndexFullText;
        /**
         * The topic id of the tls index.
         */
        id: string;
        /**
         * The KeyValue index of the tls topic.
         */
        keyValues: outputs.tls.IndexesTlsIndexKeyValue[];
        /**
         * The modify time of the tls index.
         */
        modifyTime: string;
        /**
         * The topic id of the tls index.
         */
        topicId: string;
        /**
         * The reserved field index configuration of the tls topic.
         */
        userInnerKeyValues: outputs.tls.IndexesTlsIndexUserInnerKeyValue[];
    }

    export interface IndexesTlsIndexFullText {
        /**
         * Whether the value is case sensitive.
         */
        caseSensitive: boolean;
        /**
         * The delimiter of the value.
         */
        delimiter: string;
        /**
         * Whether the value include chinese.
         */
        includeChinese: boolean;
    }

    export interface IndexesTlsIndexKeyValue {
        /**
         * Whether the value is case sensitive.
         */
        caseSensitive: boolean;
        /**
         * The delimiter of the value.
         */
        delimiter: string;
        /**
         * Whether the value include chinese.
         */
        includeChinese: boolean;
        /**
         * The JSON subfield key value index.
         */
        jsonKeys: outputs.tls.IndexesTlsIndexKeyValueJsonKey[];
        /**
         * The key of the KeyValue index.
         */
        key: string;
        /**
         * Whether the filed is enabled for analysis.
         */
        sqlFlag: boolean;
        /**
         * The type of value.
         */
        valueType: string;
    }

    export interface IndexesTlsIndexKeyValueJsonKey {
        /**
         * Whether the value is case sensitive.
         */
        caseSensitive: boolean;
        /**
         * The delimiter of the value.
         */
        delimiter: string;
        /**
         * Whether the value include chinese.
         */
        includeChinese: boolean;
        /**
         * The key of the KeyValue index.
         */
        key: string;
        /**
         * Whether the filed is enabled for analysis.
         */
        sqlFlag: boolean;
        /**
         * The type of value.
         */
        valueType: string;
    }

    export interface IndexesTlsIndexUserInnerKeyValue {
        /**
         * Whether the value is case sensitive.
         */
        caseSensitive: boolean;
        /**
         * The delimiter of the value.
         */
        delimiter: string;
        /**
         * Whether the value include chinese.
         */
        includeChinese: boolean;
        /**
         * The JSON subfield key value index.
         */
        jsonKeys: outputs.tls.IndexesTlsIndexUserInnerKeyValueJsonKey[];
        /**
         * The key of the KeyValue index.
         */
        key: string;
        /**
         * Whether the filed is enabled for analysis.
         */
        sqlFlag: boolean;
        /**
         * The type of value.
         */
        valueType: string;
    }

    export interface IndexesTlsIndexUserInnerKeyValueJsonKey {
        /**
         * Whether the value is case sensitive.
         */
        caseSensitive: boolean;
        /**
         * The delimiter of the value.
         */
        delimiter: string;
        /**
         * Whether the value include chinese.
         */
        includeChinese: boolean;
        /**
         * The key of the KeyValue index.
         */
        key: string;
        /**
         * Whether the filed is enabled for analysis.
         */
        sqlFlag: boolean;
        /**
         * The type of value.
         */
        valueType: string;
    }

    export interface KafkaConsumersData {
        /**
         * Whether allow consume.
         */
        allowConsume: boolean;
        /**
         * The topic of consume.
         */
        consumeTopic: string;
        /**
         * The ID of Topic.
         */
        topicId: string;
    }

    export interface ProjectTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface ProjectsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface ProjectsTlsProject {
        /**
         * The create time of the tls project.
         */
        createTime: string;
        /**
         * The description of the tls project.
         */
        description: string;
        /**
         * The IAM project name of the tls project.
         */
        iamProjectName: string;
        /**
         * The ID of the tls project.
         */
        id: string;
        /**
         * The inner net domain of the tls project.
         */
        innerNetDomain: string;
        /**
         * The id of tls project. This field supports fuzzy queries. It is not supported to specify both ProjectName and ProjectId at the same time.
         */
        projectId: string;
        /**
         * The name of tls project. This field supports fuzzy queries. It is not supported to specify both ProjectName and ProjectId at the same time.
         */
        projectName: string;
        /**
         * Tags.
         */
        tags: outputs.tls.ProjectsTlsProjectTag[];
        /**
         * The count of topics in the tls project.
         */
        topicCount: number;
    }

    export interface ProjectsTlsProjectTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface RuleAppliersRule {
        /**
         * Container collection rules.
         */
        containerRules: outputs.tls.RuleAppliersRuleContainerRule[];
        /**
         * The creation time.
         */
        createTime: string;
        /**
         * Collect the blacklist list.
         */
        excludePaths: outputs.tls.RuleAppliersRuleExcludePath[];
        /**
         * The extract rule.
         */
        extractRules: outputs.tls.RuleAppliersRuleExtractRule[];
        /**
         * The collection type.
         */
        inputType: number;
        /**
         * Log sample.
         */
        logSample: string;
        /**
         * The log type.
         */
        logType: string;
        /**
         * The modification time.
         */
        modifyTime: string;
        /**
         * Collection path list.
         */
        paths: string[];
        /**
         * The rule id.
         */
        ruleId: string;
        /**
         * The rule name.
         */
        ruleName: string;
        /**
         * The topic id.
         */
        topicId: string;
        /**
         * The topic name.
         */
        topicName: string;
        /**
         * User-defined collection rules.
         */
        userDefineRules: outputs.tls.RuleAppliersRuleUserDefineRule[];
    }

    export interface RuleAppliersRuleContainerRule {
        /**
         * The name of the container to be collected.
         */
        containerNameRegex: string;
        /**
         * Whether to add environment variables as log tags to raw log data.
         */
        envTag: {[key: string]: any};
        /**
         * The container environment variable blacklist is used to specify the range of containers not to be collected.
         */
        excludeContainerEnvRegex: {[key: string]: any};
        /**
         * The container Label blacklist is used to specify the range of containers not to be collected.
         */
        excludeContainerLabelRegex: {[key: string]: any};
        /**
         * The container environment variable whitelist specifies the container to be collected through the container environment variable. If the whitelist is not enabled, it means that all containers are specified to be collected.
         */
        includeContainerEnvRegex: {[key: string]: any};
        /**
         * The container label whitelist specifies the containers to be collected through the container label. If the whitelist is not enabled, all containers are specified to be collected.
         */
        includeContainerLabelRegex: {[key: string]: any};
        /**
         * Collection rules for Kubernetes containers.
         */
        kubernetesRules: outputs.tls.RuleAppliersRuleContainerRuleKubernetesRule[];
        /**
         * The collection mode.
         */
        stream: string;
    }

    export interface RuleAppliersRuleContainerRuleKubernetesRule {
        /**
         * Whether to add Kubernetes Annotation as a log tag to the raw log data.
         */
        annotationTag: {[key: string]: any};
        /**
         * Specify the containers not to be collected through the Pod Label blacklist, and not enable means to collect all containers.
         */
        excludePodLabelRegex: {[key: string]: any};
        /**
         * The Pod Label whitelist is used to specify containers to be collected. When the Pod Label whitelist is not enabled, it means that all containers are collected.
         */
        includePodLabelRegex: {[key: string]: any};
        /**
         * Whether to add Kubernetes Label as a log label to the original log data.
         */
        labelTag: {[key: string]: any};
        /**
         * The name of the Kubernetes Namespace to be collected. If no Namespace name is specified, all containers will be collected. Namespace names support regular matching.
         */
        namespaceNameRegex: string;
        /**
         * The Pod name is used to specify the container to be collected. When no Pod name is specified, it means to collect all containers.
         */
        podNameRegex: string;
        /**
         * Specify the container to be collected by the name of the workload. When no workload name is specified, all containers are collected. The workload name supports regular matching.
         */
        workloadNameRegex: string;
        /**
         * Specify the container to be collected by the type of workload. Only one type can be selected. When no type is specified, it means to collect all types of containers.
         */
        workloadType: string;
    }

    export interface RuleAppliersRuleExcludePath {
        /**
         * The type of the log template.
         */
        type: string;
        /**
         * Collection path.
         */
        value: string;
    }

    export interface RuleAppliersRuleExtractRule {
        /**
         * The first log line needs to match the regular expression.
         */
        beginRegex: string;
        /**
         * The delimiter of the log.
         */
        delimiter: string;
        /**
         * The filter key list.
         */
        filterKeyRegexes: outputs.tls.RuleAppliersRuleExtractRuleFilterKeyRegex[];
        /**
         * A list of field names. Log Service will parse the path sample (PathSample) into multiple fields according to the regular expression (Regex), and Keys is used to specify the field name of each field.
         */
        keys: string[];
        /**
         * The entire log needs to match the regular expression.
         */
        logRegex: string;
        /**
         * Automatically extract log fields according to the specified log template.
         */
        logTemplates: outputs.tls.RuleAppliersRuleExtractRuleLogTemplate[];
        /**
         * Parsing format of the time field.
         */
        timeFormat: string;
        /**
         * The field name of the log time field.
         */
        timeKey: string;
        /**
         * When uploading the failed log, the key name of the failed log.
         */
        unMatchLogKey: string;
        /**
         * Whether to upload the log of parsing failure.
         */
        unMatchUpLoadSwitch: boolean;
    }

    export interface RuleAppliersRuleExtractRuleFilterKeyRegex {
        /**
         * The name of the filter key.
         */
        key: string;
        /**
         * Regular expression for extracting path fields. It must match the collection path sample, otherwise it cannot be extracted successfully.
         */
        regex: string;
    }

    export interface RuleAppliersRuleExtractRuleLogTemplate {
        /**
         * Log template content.
         */
        format: string;
        /**
         * The type of the log template.
         */
        type: string;
    }

    export interface RuleAppliersRuleUserDefineRule {
        /**
         * LogCollector extension configuration.
         */
        advanceds: outputs.tls.RuleAppliersRuleUserDefineRuleAdvanced[];
        /**
         * Whether to upload raw logs.
         */
        enableRawLog: boolean;
        /**
         * Add constant fields to logs.
         */
        fields: {[key: string]: any};
        /**
         * Rules for parsing collection paths. After the rules are set, the fields in the collection path will be extracted through the regular expressions specified in the rules, and added to the log data as metadata.
         */
        parsePathRules: outputs.tls.RuleAppliersRuleUserDefineRuleParsePathRule[];
        /**
         * Plugin configuration. After the plugin configuration is enabled, one or more LogCollector processor plugins can be added to parse logs with complex or variable structures.
         */
        plugins: outputs.tls.RuleAppliersRuleUserDefineRulePlugin[];
        /**
         * Rules for routing log partitions. Setting this parameter indicates that the HashKey routing shard mode is used when collecting logs, and Log Service will write the data to the shard containing the specified Key value.
         */
        shardHashKeys: outputs.tls.RuleAppliersRuleUserDefineRuleShardHashKey[];
        /**
         * LogCollector collection strategy, which specifies whether LogCollector collects incremental logs or full logs. The default is false, which means to collect all logs.
         */
        tailFiles: boolean;
    }

    export interface RuleAppliersRuleUserDefineRuleAdvanced {
        /**
         * Whether to release the log file handle after reading to the end of the log file. The default is false.
         */
        closeEof: boolean;
        /**
         * The wait time to release the log file handle. When the log file has not written a new log for more than the specified time, release the handle of the log file.
         */
        closeInactive: number;
        /**
         * After the log file is removed, whether to release the handle of the log file. The default is false.
         */
        closeRemoved: boolean;
        /**
         * After the log file is renamed, whether to release the handle of the log file. The default is false.
         */
        closeRenamed: boolean;
        /**
         * The maximum length of time that LogCollector monitors log files. The unit is seconds, and the default is 0 seconds, which means that there is no limit to the length of time LogCollector monitors log files.
         */
        closeTimeout: number;
    }

    export interface RuleAppliersRuleUserDefineRuleParsePathRule {
        /**
         * A list of field names. Log Service will parse the path sample (PathSample) into multiple fields according to the regular expression (Regex), and Keys is used to specify the field name of each field.
         */
        keys: string[];
        /**
         * Sample capture path for a real scene.
         */
        pathSample: string;
        /**
         * Regular expression for extracting path fields. It must match the collection path sample, otherwise it cannot be extracted successfully.
         */
        regex: string;
    }

    export interface RuleAppliersRuleUserDefineRulePlugin {
        /**
         * LogCollector plugin.
         */
        processors: string;
    }

    export interface RuleAppliersRuleUserDefineRuleShardHashKey {
        /**
         * The HashKey of the log group is used to specify the partition (shard) to be written to by the current log group.
         */
        hashKey: string;
    }

    export interface RuleContainerRule {
        /**
         * The name of the container to be collected.
         */
        containerNameRegex?: string;
        /**
         * Whether to add environment variables as log tags to raw log data.
         */
        envTag?: {[key: string]: string};
        /**
         * The container environment variable blacklist is used to specify the range of containers not to be collected.
         */
        excludeContainerEnvRegex?: {[key: string]: string};
        /**
         * The container Label blacklist is used to specify the range of containers not to be collected.
         */
        excludeContainerLabelRegex?: {[key: string]: string};
        /**
         * The container environment variable whitelist specifies the container to be collected through the container environment variable. If the whitelist is not enabled, it means that all containers are specified to be collected.
         */
        includeContainerEnvRegex?: {[key: string]: string};
        /**
         * The container label whitelist specifies the containers to be collected through the container label. If the whitelist is not enabled, all containers are specified to be collected.
         */
        includeContainerLabelRegex?: {[key: string]: string};
        /**
         * Collection rules for Kubernetes containers.
         */
        kubernetesRule?: outputs.tls.RuleContainerRuleKubernetesRule;
        /**
         * The collection mode.
         */
        stream: string;
    }

    export interface RuleContainerRuleKubernetesRule {
        /**
         * Whether to add Kubernetes Annotation as a log tag to the raw log data.
         */
        annotationTag?: {[key: string]: string};
        /**
         * Specify the containers not to be collected through the Pod Label blacklist, and not enable means to collect all containers.
         */
        excludePodLabelRegex?: {[key: string]: string};
        /**
         * The Pod Label whitelist is used to specify containers to be collected. When the Pod Label whitelist is not enabled, it means that all containers are collected.
         */
        includePodLabelRegex?: {[key: string]: string};
        /**
         * Whether to add Kubernetes Label as a log label to the original log data.
         */
        labelTag?: {[key: string]: string};
        /**
         * The name of the Kubernetes Namespace to be collected. If no Namespace name is specified, all containers will be collected. Namespace names support regular matching.
         */
        namespaceNameRegex?: string;
        /**
         * The Pod name is used to specify the container to be collected. When no Pod name is specified, it means to collect all containers.
         */
        podNameRegex?: string;
        /**
         * Specify the container to be collected by the name of the workload. When no workload name is specified, all containers are collected. The workload name supports regular matching.
         */
        workloadNameRegex?: string;
        /**
         * Specify the containers to be collected by the type of workload, only one type can be selected. When no type is specified, it means all types of containers are collected. The supported types of workloads are:
         * Deployment: stateless workload.
         * StatefulSet: stateful workload.
         * DaemonSet: daemon process.
         * Job: task.
         * CronJob: scheduled task.
         */
        workloadType?: string;
    }

    export interface RuleExcludePath {
        /**
         * Collection path type. The path type can be `File` or `Path`.
         */
        type: string;
        /**
         * Collection path.
         */
        value: string;
    }

    export interface RuleExtractRule {
        /**
         * The first log line needs to match the regular expression.
         */
        beginRegex?: string;
        /**
         * The delimiter of the log.
         */
        delimiter?: string;
        /**
         * The filter key list.
         */
        filterKeyRegexes?: outputs.tls.RuleExtractRuleFilterKeyRegex[];
        /**
         * A list of log field names (Key).
         */
        keys: string[];
        /**
         * The entire log needs to match the regular expression.
         */
        logRegex?: string;
        /**
         * Automatically extract log fields according to the specified log template.
         */
        logTemplate?: outputs.tls.RuleExtractRuleLogTemplate;
        /**
         * Parsing format of the time field.
         */
        timeFormat?: string;
        /**
         * The field name of the log time field.
         */
        timeKey?: string;
        /**
         * When uploading the failed log, the key name of the failed log.
         */
        unMatchLogKey?: string;
        /**
         * Whether to upload the log of parsing failure.
         */
        unMatchUpLoadSwitch: boolean;
    }

    export interface RuleExtractRuleFilterKeyRegex {
        /**
         * The name of the filter key.
         */
        key: string;
        /**
         * The log content of the filter field needs to match the regular expression.
         */
        regex: string;
    }

    export interface RuleExtractRuleLogTemplate {
        /**
         * Log template content.
         */
        format: string;
        /**
         * The type of the log template.
         */
        type: string;
    }

    export interface RuleUserDefineRule {
        /**
         * LogCollector extension configuration.
         */
        advanced?: outputs.tls.RuleUserDefineRuleAdvanced;
        /**
         * Whether to upload raw logs.
         */
        enableRawLog?: boolean;
        /**
         * Add constant fields to logs.
         */
        fields?: {[key: string]: string};
        /**
         * Rules for parsing collection paths. After the rules are set, the fields in the collection path will be extracted through the regular expressions specified in the rules, and added to the log data as metadata.
         */
        parsePathRule?: outputs.tls.RuleUserDefineRuleParsePathRule;
        /**
         * Plugin configuration. After the plugin configuration is enabled, one or more LogCollector processor plugins can be added to parse logs with complex or variable structures.
         */
        plugin?: outputs.tls.RuleUserDefineRulePlugin;
        /**
         * Rules for routing log partitions. Setting this parameter indicates that the HashKey routing shard mode is used when collecting logs, and Log Service will write the data to the shard containing the specified Key value.
         */
        shardHashKey?: outputs.tls.RuleUserDefineRuleShardHashKey;
        /**
         * LogCollector collection strategy, which specifies whether LogCollector collects incremental logs or full logs. The default is false, which means to collect all logs.
         */
        tailFiles?: boolean;
    }

    export interface RuleUserDefineRuleAdvanced {
        /**
         * Whether to release the log file handle after reading to the end of the log file. The default is false.
         */
        closeEof?: boolean;
        /**
         * The wait time to release the log file handle. When the log file has not written a new log for more than the specified time, release the handle of the log file.
         */
        closeInactive?: number;
        /**
         * After the log file is removed, whether to release the handle of the log file. The default is false.
         */
        closeRemoved?: boolean;
        /**
         * After the log file is renamed, whether to release the handle of the log file. The default is false.
         */
        closeRenamed?: boolean;
        /**
         * The maximum length of time that LogCollector monitors log files. The unit is seconds, and the default is 0 seconds, which means that there is no limit to the length of time LogCollector monitors log files.
         */
        closeTimeout?: number;
    }

    export interface RuleUserDefineRuleParsePathRule {
        /**
         * A list of field names. Log Service will parse the path sample (PathSample) into multiple fields according to the regular expression (Regex), and Keys is used to specify the field name of each field.
         */
        keys?: string[];
        /**
         * Sample capture path for a real scene.
         */
        pathSample?: string;
        /**
         * Regular expression for extracting path fields. It must match the collection path sample, otherwise it cannot be extracted successfully.
         */
        regex?: string;
    }

    export interface RuleUserDefineRulePlugin {
        /**
         * LogCollector plugin.
         */
        processors: string[];
    }

    export interface RuleUserDefineRuleShardHashKey {
        /**
         * The HashKey of the log group is used to specify the partition (shard) to be written to by the current log group.
         */
        hashKey: string;
    }

    export interface RulesRule {
        /**
         * Container collection rules.
         */
        containerRules: outputs.tls.RulesRuleContainerRule[];
        /**
         * The creation time.
         */
        createTime: string;
        /**
         * Collect the blacklist list.
         */
        excludePaths: outputs.tls.RulesRuleExcludePath[];
        /**
         * The extract rule.
         */
        extractRules: outputs.tls.RulesRuleExtractRule[];
        /**
         * The collection type.
         */
        inputType: number;
        /**
         * Log sample.
         */
        logSample: string;
        /**
         * The log type.
         */
        logType: string;
        /**
         * The modification time.
         */
        modifyTime: string;
        /**
         * Collection path list.
         */
        paths: string[];
        /**
         * The rule id.
         */
        ruleId: string;
        /**
         * The rule name.
         */
        ruleName: string;
        /**
         * The topic id.
         */
        topicId: string;
        /**
         * The topic name.
         */
        topicName: string;
        /**
         * User-defined collection rules.
         */
        userDefineRules: outputs.tls.RulesRuleUserDefineRule[];
    }

    export interface RulesRuleContainerRule {
        /**
         * The name of the container to be collected.
         */
        containerNameRegex: string;
        /**
         * Whether to add environment variables as log tags to raw log data.
         */
        envTag: {[key: string]: any};
        /**
         * The container environment variable blacklist is used to specify the range of containers not to be collected.
         */
        excludeContainerEnvRegex: {[key: string]: any};
        /**
         * The container Label blacklist is used to specify the range of containers not to be collected.
         */
        excludeContainerLabelRegex: {[key: string]: any};
        /**
         * The container environment variable whitelist specifies the container to be collected through the container environment variable. If the whitelist is not enabled, it means that all containers are specified to be collected.
         */
        includeContainerEnvRegex: {[key: string]: any};
        /**
         * The container label whitelist specifies the containers to be collected through the container label. If the whitelist is not enabled, all containers are specified to be collected.
         */
        includeContainerLabelRegex: {[key: string]: any};
        /**
         * Collection rules for Kubernetes containers.
         */
        kubernetesRules: outputs.tls.RulesRuleContainerRuleKubernetesRule[];
        /**
         * The collection mode.
         */
        stream: string;
    }

    export interface RulesRuleContainerRuleKubernetesRule {
        /**
         * Whether to add Kubernetes Annotation as a log tag to the raw log data.
         */
        annotationTag: {[key: string]: any};
        /**
         * Specify the containers not to be collected through the Pod Label blacklist, and not enable means to collect all containers.
         */
        excludePodLabelRegex: {[key: string]: any};
        /**
         * The Pod Label whitelist is used to specify containers to be collected. When the Pod Label whitelist is not enabled, it means that all containers are collected.
         */
        includePodLabelRegex: {[key: string]: any};
        /**
         * Whether to add Kubernetes Label as a log label to the original log data.
         */
        labelTag: {[key: string]: any};
        /**
         * The name of the Kubernetes Namespace to be collected. If no Namespace name is specified, all containers will be collected. Namespace names support regular matching.
         */
        namespaceNameRegex: string;
        /**
         * The Pod name is used to specify the container to be collected. When no Pod name is specified, it means to collect all containers.
         */
        podNameRegex: string;
        /**
         * Specify the container to be collected by the name of the workload. When no workload name is specified, all containers are collected. The workload name supports regular matching.
         */
        workloadNameRegex: string;
        /**
         * Specify the container to be collected by the type of workload. Only one type can be selected. When no type is specified, it means to collect all types of containers.
         */
        workloadType: string;
    }

    export interface RulesRuleExcludePath {
        /**
         * The type of the log template.
         */
        type: string;
        /**
         * Collection path.
         */
        value: string;
    }

    export interface RulesRuleExtractRule {
        /**
         * The first log line needs to match the regular expression.
         */
        beginRegex: string;
        /**
         * The delimiter of the log.
         */
        delimiter: string;
        /**
         * The filter key list.
         */
        filterKeyRegexes: outputs.tls.RulesRuleExtractRuleFilterKeyRegex[];
        /**
         * A list of field names. Log Service will parse the path sample (PathSample) into multiple fields according to the regular expression (Regex), and Keys is used to specify the field name of each field.
         */
        keys: string[];
        /**
         * The entire log needs to match the regular expression.
         */
        logRegex: string;
        /**
         * Automatically extract log fields according to the specified log template.
         */
        logTemplates: outputs.tls.RulesRuleExtractRuleLogTemplate[];
        /**
         * Parsing format of the time field.
         */
        timeFormat: string;
        /**
         * The field name of the log time field.
         */
        timeKey: string;
        /**
         * When uploading the failed log, the key name of the failed log.
         */
        unMatchLogKey: string;
        /**
         * Whether to upload the log of parsing failure.
         */
        unMatchUpLoadSwitch: boolean;
    }

    export interface RulesRuleExtractRuleFilterKeyRegex {
        /**
         * The name of the filter key.
         */
        key: string;
        /**
         * Regular expression for extracting path fields. It must match the collection path sample, otherwise it cannot be extracted successfully.
         */
        regex: string;
    }

    export interface RulesRuleExtractRuleLogTemplate {
        /**
         * Log template content.
         */
        format: string;
        /**
         * The type of the log template.
         */
        type: string;
    }

    export interface RulesRuleUserDefineRule {
        /**
         * LogCollector extension configuration.
         */
        advanceds: outputs.tls.RulesRuleUserDefineRuleAdvanced[];
        /**
         * Whether to upload raw logs.
         */
        enableRawLog: boolean;
        /**
         * Add constant fields to logs.
         */
        fields: {[key: string]: any};
        /**
         * Rules for parsing collection paths. After the rules are set, the fields in the collection path will be extracted through the regular expressions specified in the rules, and added to the log data as metadata.
         */
        parsePathRules: outputs.tls.RulesRuleUserDefineRuleParsePathRule[];
        /**
         * Plugin configuration. After the plugin configuration is enabled, one or more LogCollector processor plugins can be added to parse logs with complex or variable structures.
         */
        plugins: outputs.tls.RulesRuleUserDefineRulePlugin[];
        /**
         * Rules for routing log partitions. Setting this parameter indicates that the HashKey routing shard mode is used when collecting logs, and Log Service will write the data to the shard containing the specified Key value.
         */
        shardHashKeys: outputs.tls.RulesRuleUserDefineRuleShardHashKey[];
        /**
         * LogCollector collection strategy, which specifies whether LogCollector collects incremental logs or full logs. The default is false, which means to collect all logs.
         */
        tailFiles: boolean;
    }

    export interface RulesRuleUserDefineRuleAdvanced {
        /**
         * Whether to release the log file handle after reading to the end of the log file. The default is false.
         */
        closeEof: boolean;
        /**
         * The wait time to release the log file handle. When the log file has not written a new log for more than the specified time, release the handle of the log file.
         */
        closeInactive: number;
        /**
         * After the log file is removed, whether to release the handle of the log file. The default is false.
         */
        closeRemoved: boolean;
        /**
         * After the log file is renamed, whether to release the handle of the log file. The default is false.
         */
        closeRenamed: boolean;
        /**
         * The maximum length of time that LogCollector monitors log files. The unit is seconds, and the default is 0 seconds, which means that there is no limit to the length of time LogCollector monitors log files.
         */
        closeTimeout: number;
    }

    export interface RulesRuleUserDefineRuleParsePathRule {
        /**
         * A list of field names. Log Service will parse the path sample (PathSample) into multiple fields according to the regular expression (Regex), and Keys is used to specify the field name of each field.
         */
        keys: string[];
        /**
         * Sample capture path for a real scene.
         */
        pathSample: string;
        /**
         * Regular expression for extracting path fields. It must match the collection path sample, otherwise it cannot be extracted successfully.
         */
        regex: string;
    }

    export interface RulesRuleUserDefineRulePlugin {
        /**
         * LogCollector plugin.
         */
        processors: string[];
    }

    export interface RulesRuleUserDefineRuleShardHashKey {
        /**
         * The HashKey of the log group is used to specify the partition (shard) to be written to by the current log group.
         */
        hashKey: string;
    }

    export interface ShardsShard {
        /**
         * The end key info.
         */
        exclusiveEndKey: string;
        /**
         * The begin key info.
         */
        inclusiveBeginKey: string;
        /**
         * The modify time.
         */
        modifyTime: string;
        /**
         * The id of shard.
         */
        shardId: number;
        /**
         * The status of shard.
         */
        status: string;
        /**
         * The stop write time.
         */
        stopWriteTime: string;
        /**
         * The id of topic.
         */
        topicId: string;
    }

    export interface TopicTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface TopicsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface TopicsTlsTopic {
        /**
         * Whether to enable automatic partition splitting function of the tls topic.
         */
        autoSplit: boolean;
        /**
         * The create time of the tls topic.
         */
        createTime: string;
        /**
         * The description of the tls topic.
         */
        description: string;
        /**
         * Whether to enable WebTracking function of the tls topic.
         */
        enableTracking: boolean;
        /**
         * The ID of the tls topic.
         */
        id: string;
        /**
         * The max count of shards in the tls topic.
         */
        maxSplitShard: number;
        /**
         * The modify time of the tls topic.
         */
        modifyTime: string;
        /**
         * The project id of tls topic.
         */
        projectId: string;
        /**
         * The count of shards in the tls topic.
         */
        shardCount: number;
        /**
         * Tags.
         */
        tags: outputs.tls.TopicsTlsTopicTag[];
        /**
         * The format of the time field.
         */
        timeFormat: string;
        /**
         * The name of the time field.
         */
        timeKey: string;
        /**
         * The id of tls topic. This field supports fuzzy queries. It is not supported to specify both TopicName and TopicId at the same time.
         */
        topicId: string;
        /**
         * The name of tls topic. This field supports fuzzy queries. It is not supported to specify both TopicName and TopicId at the same time.
         */
        topicName: string;
        /**
         * The data storage time of the tls topic. Unit: Day.
         */
        ttl: number;
    }

    export interface TopicsTlsTopicTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

}

export namespace tos {
    export interface BucketAccountAcl {
        /**
         * The accountId to control.
         */
        accountId: string;
        /**
         * The acl type to control.Valid value is CanonicalUser.
         */
        aclType?: string;
        /**
         * The permission to control.Valid value is FULL_CONTROL|READ|READ_ACP|WRITE|WRITE_ACP.
         */
        permission: string;
    }

    export interface BucketObjectAccountAcl {
        /**
         * The accountId to control.
         */
        accountId: string;
        /**
         * The acl type to control.Valid value is CanonicalUser.
         */
        aclType?: string;
        /**
         * The permission to control.Valid value is FULL_CONTROL|READ|READ_ACP|WRITE|WRITE_ACP.
         */
        permission: string;
    }

    export interface BucketObjectTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface BucketObjectsObject {
        /**
         * The content the TOS Object when content type is json or text and xml.
         */
        content: string;
        /**
         * The name the TOS Object.
         */
        name: string;
        /**
         * The name the TOS Object size.
         */
        size: number;
        /**
         * The name the TOS Object storage class.
         */
        storageClass: string;
    }

    export interface BucketTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface BucketsBucket {
        /**
         * The create date of the TOS bucket.
         */
        creationDate: string;
        /**
         * The extranet endpoint of the TOS bucket.
         */
        extranetEndpoint: string;
        /**
         * The intranet endpoint the TOS bucket.
         */
        intranetEndpoint: string;
        /**
         * (**Deprecated**) The Field is Deprecated. The truncated the TOS bucket.
         *
         * @deprecated The Field is Deprecated.
         */
        isTruncated: boolean;
        /**
         * The location of the TOS bucket.
         */
        location: string;
        /**
         * (**Deprecated**) The Field is Deprecated. The marker the TOS bucket.
         *
         * @deprecated The Field is Deprecated.
         */
        marker: string;
        /**
         * (**Deprecated**) The Field is Deprecated. The max keys the TOS bucket.
         *
         * @deprecated The Field is Deprecated.
         */
        maxKeys: number;
        /**
         * The name the TOS bucket.
         */
        name: string;
        /**
         * (**Deprecated**) The Field is Deprecated. The prefix the TOS bucket.
         *
         * @deprecated The Field is Deprecated.
         */
        prefix: string;
    }

}

export namespace transit_router {
    export interface BandwidthPackageAllocation {
        /**
         * The delete time of the transit router bandwidth package.
         */
        allocateTime: string;
        /**
         * The delete time of the transit router bandwidth package.
         */
        deleteTime: string;
        /**
         * The local region id of the transit router.
         */
        localRegionId: string;
        /**
         * The ID of the peer attachment.
         */
        transitRouterPeerAttachmentId: string;
    }

    export interface BandwidthPackageTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface BandwidthPackagesBandwidthPackage {
        /**
         * The account id.
         */
        accountId: string;
        /**
         * The detailed information on cross regional connections associated with bandwidth packets.
         */
        allocations: outputs.transit_router.BandwidthPackagesBandwidthPackageAllocation[];
        /**
         * The bandwidth peak of the transit router bandwidth package. Unit: Mbps.
         */
        bandwidth: number;
        /**
         * The billing type of the transit router bandwidth package.
         */
        billingType: string;
        /**
         * The business status of the transit router bandwidth package.
         */
        businessStatus: string;
        /**
         * The create time of the transit router bandwidth package.
         */
        creationTime: string;
        /**
         * The delete time of the transit router bandwidth package.
         */
        deleteTime: string;
        /**
         * The description of the transit router bandwidth package.
         */
        description: string;
        /**
         * The expired time of the transit router bandwidth package.
         */
        expiredTime: string;
        /**
         * The id of the transit router bandwidth package.
         */
        id: string;
        /**
         * The local geographic region set ID.
         */
        localGeographicRegionSetId: string;
        /**
         * The peer geographic region set ID.
         */
        peerGeographicRegionSetId: string;
        /**
         * The ProjectName of the TransitRouter bandwidth package.
         */
        projectName: string;
        /**
         * The remaining bandwidth of the transit router bandwidth package. Unit: Mbps.
         */
        remainingBandwidth: number;
        /**
         * The status of the transit router bandwidth package.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.transit_router.BandwidthPackagesBandwidthPackageTag[];
        /**
         * The id of the transit router attachment.
         */
        transitRouterBandwidthPackageId: string;
        /**
         * The name of the TransitRouter bandwidth package.
         */
        transitRouterBandwidthPackageName: string;
        /**
         * The update time of the transit router bandwidth package.
         */
        updateTime: string;
    }

    export interface BandwidthPackagesBandwidthPackageAllocation {
        /**
         * The delete time of the transit router bandwidth package.
         */
        allocateTime: string;
        /**
         * The delete time of the transit router bandwidth package.
         */
        deleteTime: string;
        /**
         * The local region id of the transit router.
         */
        localRegionId: string;
        /**
         * The ID of the peer attachment.
         */
        transitRouterPeerAttachmentId: string;
    }

    export interface BandwidthPackagesBandwidthPackageTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface BandwidthPackagesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface DirectConnectGatewayAttachmentTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface DirectConnectGatewayAttachmentsAttachment {
        /**
         * The account id.
         */
        accountId: string;
        /**
         * The create time.
         */
        creationTime: string;
        /**
         * The description info.
         */
        description: string;
        /**
         * ID of the direct connection gateway.
         */
        directConnectGatewayId: string;
        /**
         * The status of the network instance connection.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.transit_router.DirectConnectGatewayAttachmentsAttachmentTag[];
        /**
         * The id of the transit router attachment.
         */
        transitRouterAttachmentId: string;
        /**
         * The name of the transit router attachment.
         */
        transitRouterAttachmentName: string;
        /**
         * The id of the transit router.
         */
        transitRouterId: string;
        /**
         * The update time.
         */
        updateTime: string;
    }

    export interface DirectConnectGatewayAttachmentsAttachmentTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface DirectConnectGatewayAttachmentsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GrantRulesRule {
        /**
         * The creation time of the rule.
         */
        creationTime: string;
        /**
         * The description of the rule.
         */
        description: string;
        /**
         * The id of the grant account.
         */
        grantAccountId: string;
        /**
         * The status of the rule.
         */
        status: string;
        /**
         * The id of the transit router.
         */
        transitRouterId: string;
        /**
         * The update time of the rule.
         */
        updateTime: string;
    }

    export interface PeerAttachmentTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface PeerAttachmentsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface PeerAttachmentsTransitRouterAttachment {
        /**
         * The bandwidth of the transit router peer attachment.
         */
        bandwidth: number;
        /**
         * The creation time of the transit router peer attachment.
         */
        creationTime: string;
        /**
         * The description of the transit router peer attachment.
         */
        description: string;
        /**
         * The id of the transit router peer attachment.
         */
        id: string;
        /**
         * The id of peer transit router.
         */
        peerTransitRouterId: string;
        /**
         * The region id of peer transit router.
         */
        peerTransitRouterRegionId: string;
        /**
         * The status of the transit router peer attachment.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.transit_router.PeerAttachmentsTransitRouterAttachmentTag[];
        /**
         * The id of the transit router peer attachment.
         */
        transitRouterAttachmentId: string;
        /**
         * The name of transit router peer attachment.
         */
        transitRouterAttachmentName: string;
        /**
         * The bandwidth package id of the transit router peer attachment.
         */
        transitRouterBandwidthPackageId: string;
        /**
         * The id of local transit router.
         */
        transitRouterId: string;
        /**
         * The route table id of the transit router peer attachment.
         */
        transitRouterRouteTableId: string;
        /**
         * The update time of the transit router peer attachment.
         */
        updateTime: string;
    }

    export interface PeerAttachmentsTransitRouterAttachmentTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface RouteEntriesEntry {
        /**
         * The creation time of the route entry.
         */
        creationTime: string;
        /**
         * Description of the transit router route entry.
         */
        description: string;
        /**
         * The target network segment of the route entry.
         */
        destinationCidrBlock: string;
        /**
         * The status of the route entry.
         */
        status: string;
        /**
         * The id of the route entry.
         */
        transitRouterRouteEntryId: string;
        /**
         * The name of the route entry.
         */
        transitRouterRouteEntryName: string;
        /**
         * The next hot id of the routing entry.
         */
        transitRouterRouteEntryNextHopId: string;
        /**
         * The next hop type of the routing entry. The value can be Attachment or BlackHole.
         */
        transitRouterRouteEntryNextHopType: string;
        /**
         * The type of the route entry.
         */
        transitRouterRouteEntryType: string;
        /**
         * The update time of the route entry.
         */
        updateTime: string;
    }

    export interface RouteTableAssociationsAssociation {
        /**
         * The status of the route table.
         */
        status: string;
        /**
         * The ID of the network instance connection.
         */
        transitRouterAttachmentId: string;
        /**
         * The ID of the routing table associated with the transit router instance.
         */
        transitRouterRouteTableId: string;
    }

    export interface RouteTablePropagationsPropagation {
        /**
         * The creation time of the route table propagation.
         */
        creationTime: string;
        /**
         * The status of the route table.
         */
        status: string;
        /**
         * The ID of the network instance connection.
         */
        transitRouterAttachmentId: string;
        /**
         * The ID of the routing table associated with the transit router instance.
         */
        transitRouterRouteTableId: string;
    }

    export interface RouteTableTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface RouteTablesRouteTable {
        /**
         * The creation time of the route table.
         */
        creationTime: string;
        /**
         * The description.
         */
        description: string;
        /**
         * The status of the route table.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.transit_router.RouteTablesRouteTableTag[];
        /**
         * The id of the route table.
         */
        transitRouterRouteTableId: string;
        /**
         * The name of the route table.
         */
        transitRouterRouteTableName: string;
        /**
         * The type of the route table. The value can be System or Custom.
         */
        transitRouterRouteTableType: string;
        /**
         * The update time of the route table.
         */
        updateTime: string;
    }

    export interface RouteTablesRouteTableTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface RouteTablesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface TransitRouterTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface TransitRouterTransitRouterAttachment {
        /**
         * The create time.
         */
        creationTime: string;
        /**
         * The id of resource.
         */
        resourceId: string;
        /**
         * The type of resource.
         */
        resourceType: string;
        /**
         * The status of the transit router.
         */
        status: string;
        /**
         * The id of transit router attachment.
         */
        transitRouterAttachmentId: string;
        /**
         * The name of transit router attachment.
         */
        transitRouterAttachmentName: string;
        /**
         * The id of transit router route table.
         */
        transitRouterRouteTableId: string;
        /**
         * The update time.
         */
        updateTime: string;
    }

    export interface TransitRoutersTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface TransitRoutersTransitRouter {
        /**
         * The ID of account.
         */
        accountId: string;
        /**
         * The business status of the transit router.
         */
        businessStatus: string;
        /**
         * The create time.
         */
        creationTime: string;
        /**
         * The description info.
         */
        description: string;
        /**
         * The ID of the transit router.
         */
        id: string;
        /**
         * The overdue time.
         */
        overdueTime: string;
        /**
         * The ProjectName of the transit router.
         */
        projectName: string;
        /**
         * The status of the transit router.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.transit_router.TransitRoutersTransitRouterTag[];
        /**
         * The attachments of transit router.
         */
        transitRouterAttachments: outputs.transit_router.TransitRoutersTransitRouterTransitRouterAttachment[];
        /**
         * The ID of the transit router.
         */
        transitRouterId: string;
        /**
         * The name info.
         */
        transitRouterName: string;
        /**
         * The update time.
         */
        updateTime: string;
    }

    export interface TransitRoutersTransitRouterTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface TransitRoutersTransitRouterTransitRouterAttachment {
        /**
         * The create time.
         */
        creationTime: string;
        /**
         * The id of resource.
         */
        resourceId: string;
        /**
         * The type of resource.
         */
        resourceType: string;
        /**
         * The status of the transit router.
         */
        status: string;
        /**
         * The id of transit router attachment.
         */
        transitRouterAttachmentId: string;
        /**
         * The name of transit router attachment.
         */
        transitRouterAttachmentName: string;
        /**
         * The id of transit router route table.
         */
        transitRouterRouteTableId: string;
        /**
         * The update time.
         */
        updateTime: string;
    }

    export interface VpcAttachmentAttachPoint {
        /**
         * The id of subnet.
         */
        subnetId: string;
        /**
         * The id of zone.
         */
        zoneId: string;
    }

    export interface VpcAttachmentTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface VpcAttachmentsAttachment {
        /**
         * The collection of attach points.
         */
        attachPoints: outputs.transit_router.VpcAttachmentsAttachmentAttachPoint[];
        /**
         * The create time.
         */
        creationTime: string;
        /**
         * The description info.
         */
        description: string;
        /**
         * The status of the transit router.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.transit_router.VpcAttachmentsAttachmentTag[];
        /**
         * The id of the transit router attachment.
         */
        transitRouterAttachmentId: string;
        /**
         * The name of the transit router attachment.
         */
        transitRouterAttachmentName: string;
        /**
         * The id of transit router.
         */
        transitRouterId: string;
        /**
         * The update time.
         */
        updateTime: string;
        /**
         * The id of vpc.
         */
        vpcId: string;
    }

    export interface VpcAttachmentsAttachmentAttachPoint {
        /**
         * The ID of network interface.
         */
        networkInterfaceId: string;
        /**
         * The ID of subnet.
         */
        subnetId: string;
        /**
         * The ID of zone.
         */
        zoneId: string;
    }

    export interface VpcAttachmentsAttachmentTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface VpcAttachmentsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface VpnAttachmentTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface VpnAttachmentsAttachment {
        /**
         * The create time.
         */
        creationTime: string;
        /**
         * The description info.
         */
        description: string;
        /**
         * The status of the transit router.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.transit_router.VpnAttachmentsAttachmentTag[];
        /**
         * The id of the transit router attachment.
         */
        transitRouterAttachmentId: string;
        /**
         * The name of the transit router attachment.
         */
        transitRouterAttachmentName: string;
        /**
         * The id of the transit router.
         */
        transitRouterId: string;
        /**
         * The update time.
         */
        updateTime: string;
        /**
         * The ID of the IPSec connection.
         */
        vpnConnectionId: string;
        /**
         * The ID of the availability zone.
         */
        zoneId: string;
    }

    export interface VpnAttachmentsAttachmentTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface VpnAttachmentsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

}

export namespace veenedge {
    export interface AvailableResourcesRegion {
        /**
         * The config of area.
         */
        area: outputs.veenedge.AvailableResourcesRegionArea;
        /**
         * The config of city.
         */
        city: outputs.veenedge.AvailableResourcesRegionCity;
        /**
         * The config of cluster.
         */
        cluster: outputs.veenedge.AvailableResourcesRegionCluster;
        /**
         * The config of country.
         */
        country: outputs.veenedge.AvailableResourcesRegionCountry;
        /**
         * The config of isp.
         */
        isp: outputs.veenedge.AvailableResourcesRegionIsp;
    }

    export interface AvailableResourcesRegionArea {
        /**
         * The english name of region.
         */
        enName: string;
        /**
         * The id of region.
         */
        id: string;
        /**
         * The name of region.
         */
        name: string;
    }

    export interface AvailableResourcesRegionCity {
        /**
         * The english name of region.
         */
        enName: string;
        /**
         * The id of region.
         */
        id: string;
        /**
         * The name of region.
         */
        name: string;
    }

    export interface AvailableResourcesRegionCluster {
        /**
         * The english name of region.
         */
        enName: string;
        /**
         * The id of region.
         */
        id: string;
        /**
         * The name of region.
         */
        name: string;
    }

    export interface AvailableResourcesRegionCountry {
        /**
         * The english name of region.
         */
        enName: string;
        /**
         * The id of region.
         */
        id: string;
        /**
         * The name of region.
         */
        name: string;
    }

    export interface AvailableResourcesRegionIsp {
        /**
         * The english name of region.
         */
        enName: string;
        /**
         * The id of region.
         */
        id: string;
        /**
         * The name of region.
         */
        name: string;
    }

    export interface CloudServerBillingConfig {
        /**
         * The method of bandwidth billing. The value can be `MonthlyP95` or `DailyPeak`.
         */
        bandwidthBillingMethod: string;
        /**
         * The method of computing billing. The value can be `MonthlyPeak` or `DailyPeak`.
         */
        computingBillingMethod: string;
    }

    export interface CloudServerCustomData {
        /**
         * The custom data info.
         */
        data: string;
    }

    export interface CloudServerNetworkConfig {
        /**
         * The peak of bandwidth.
         */
        bandwidthPeak: string;
        /**
         * The name of custom external interface.
         */
        customExternalInterfaceName?: string;
        /**
         * The name of custom internal interface.
         */
        customInternalInterfaceName?: string;
        /**
         * Whether enable ipv6.
         */
        enableIpv6: boolean;
        /**
         * The internal peak of bandwidth.
         */
        internalBandwidthPeak: string;
    }

    export interface CloudServerScheduleStrategy {
        /**
         * The network strategy.
         */
        networkStrategy: string;
        /**
         * The price strategy. The value can be `highPriority` or `lowPriority`.
         */
        priceStrategy: string;
        /**
         * The type of schedule strategy. The value can be `dispersion` or `concentration`.
         */
        scheduleStrategy: string;
    }

    export interface CloudServerStorageConfig {
        /**
         * The disk list info of data.
         */
        dataDiskLists?: outputs.veenedge.CloudServerStorageConfigDataDiskList[];
        /**
         * The disk info of system.
         */
        systemDisk: outputs.veenedge.CloudServerStorageConfigSystemDisk;
    }

    export interface CloudServerStorageConfigDataDiskList {
        /**
         * The capacity of storage.
         */
        capacity: string;
        /**
         * The type of storage. The value can be `CloudBlockHDD` or `CloudBlockSSD`.
         */
        storageType: string;
    }

    export interface CloudServerStorageConfigSystemDisk {
        /**
         * The capacity of storage.
         */
        capacity: string;
        /**
         * The type of storage. The value can be `CloudBlockHDD` or `CloudBlockSSD`.
         */
        storageType: string;
    }

    export interface CloudServersCloudServer {
        /**
         * The config of billing.
         */
        billingConfig: outputs.veenedge.CloudServersCloudServerBillingConfig;
        /**
         * The Id of cloud server.
         */
        cloudServerIdentity: string;
        /**
         * The cpu info of cloud server.
         */
        cpu: string;
        /**
         * The create time info.
         */
        createTime: number;
        /**
         * The config of custom data.
         */
        customData: outputs.veenedge.CloudServersCloudServerCustomData;
        /**
         * The config of gpu.
         */
        gpu: outputs.veenedge.CloudServersCloudServerGpu;
        /**
         * The Id of cloud server.
         */
        id: string;
        /**
         * The config of image.
         */
        image: outputs.veenedge.CloudServersCloudServerImage;
        /**
         * The count of instance.
         */
        instanceCount: number;
        /**
         * The status of instances.
         */
        instanceStatuses: outputs.veenedge.CloudServersCloudServerInstanceStatus[];
        /**
         * The memory info of cloud server.
         */
        mem: string;
        /**
         * The name of cloud server.
         */
        name: string;
        /**
         * The config of network.
         */
        network: outputs.veenedge.CloudServersCloudServerNetwork;
        /**
         * The config of schedule strategy.
         */
        scheduleStrategyConfigs: outputs.veenedge.CloudServersCloudServerScheduleStrategyConfigs;
        /**
         * The config of secret.
         */
        secretConfig: outputs.veenedge.CloudServersCloudServerSecretConfig;
        /**
         * The server area count number.
         */
        serverAreaCount: number;
        /**
         * The area level of cloud server.
         */
        serverAreaLevel: string;
        /**
         * The server areas info.
         */
        serverAreas: outputs.veenedge.CloudServersCloudServerServerArea[];
        /**
         * The spec info of cloud server.
         */
        spec: string;
        /**
         * The Chinese spec info of cloud server.
         */
        specDisplay: string;
        /**
         * The spec summary of cloud server.
         */
        specSum: {[key: string]: any};
        /**
         * The config of storage.
         */
        storage: outputs.veenedge.CloudServersCloudServerStorage;
        /**
         * The update time info.
         */
        updateTime: number;
    }

    export interface CloudServersCloudServerBillingConfig {
        /**
         * The bandwidth billing method.
         */
        bandwidthBillingMethod: string;
        /**
         * The computing billing method.
         */
        computingBillingMethod: string;
    }

    export interface CloudServersCloudServerCustomData {
        /**
         * The data info.
         */
        data: string;
    }

    export interface CloudServersCloudServerGpu {
        /**
         * The list gpu info.
         */
        gpuses: outputs.veenedge.CloudServersCloudServerGpuGpus[];
    }

    export interface CloudServersCloudServerGpuGpus {
        /**
         * The spec of gpu.
         */
        gpuSpec: outputs.veenedge.CloudServersCloudServerGpuGpusGpuSpec;
        /**
         * The number of gpu.
         */
        num: number;
    }

    export interface CloudServersCloudServerGpuGpusGpuSpec {
        /**
         * The type of gpu.
         */
        gpuType: string;
    }

    export interface CloudServersCloudServerImage {
        /**
         * The id of image.
         */
        imageIdentity: string;
        /**
         * The name of image.
         */
        imageName: string;
        /**
         * The property of system.
         */
        property: string;
        /**
         * The arch of system.
         */
        systemArch: string;
        /**
         * The bit of system.
         */
        systemBit: string;
        /**
         * The type of system.
         */
        systemType: string;
        /**
         * The version of system.
         */
        systemVersion: string;
    }

    export interface CloudServersCloudServerInstanceStatus {
        /**
         * The count of instance.
         */
        instanceCount: number;
        /**
         * The status info.
         */
        status: string;
    }

    export interface CloudServersCloudServerNetwork {
        /**
         * The peak of bandwidth.
         */
        bandwidthPeak: string;
        /**
         * Whether enable ipv6.
         */
        enableIpv6: boolean;
        /**
         * The internal peak of bandwidth.
         */
        internalBandwidthPeak: string;
    }

    export interface CloudServersCloudServerScheduleStrategyConfigs {
        /**
         * The price strategy.
         */
        priceStrategy: string;
        /**
         * The schedule strategy.
         */
        scheduleStrategy: string;
    }

    export interface CloudServersCloudServerSecretConfig {
        /**
         * The data of secret.
         */
        secretData: string;
        /**
         * The type of secret.
         */
        secretType: number;
    }

    export interface CloudServersCloudServerServerArea {
        /**
         * The area info.
         */
        area: string;
        /**
         * The number of instance.
         */
        instanceNum: number;
        /**
         * The isp info.
         */
        isp: string;
    }

    export interface CloudServersCloudServerStorage {
        /**
         * The disk info of data.
         */
        dataDisk: outputs.veenedge.CloudServersCloudServerStorageDataDisk;
        /**
         * The disk list info of data.
         */
        dataDiskLists: outputs.veenedge.CloudServersCloudServerStorageDataDiskList[];
        /**
         * The disk info of system.
         */
        systemDisk: outputs.veenedge.CloudServersCloudServerStorageSystemDisk;
    }

    export interface CloudServersCloudServerStorageDataDisk {
        /**
         * The capacity of storage.
         */
        capacity: string;
        /**
         * The type of storage.
         */
        storageType: string;
    }

    export interface CloudServersCloudServerStorageDataDiskList {
        /**
         * The capacity of storage.
         */
        capacity: string;
        /**
         * The type of storage.
         */
        storageType: string;
    }

    export interface CloudServersCloudServerStorageSystemDisk {
        /**
         * The capacity of storage.
         */
        capacity: string;
        /**
         * The type of storage.
         */
        storageType: string;
    }

    export interface InstanceTypesInstanceTypeConfig {
        /**
         * The cpu of instance type.
         */
        cpu: number;
        /**
         * The gpu of instance type.
         */
        gpu: number;
        /**
         * The gpu spec of instance.
         */
        gpuSpec: string;
        /**
         * The type of instance.
         */
        instanceType: string;
        /**
         * The type family of instance.
         */
        instanceTypeFamily: string;
        /**
         * The name of instance type family.
         */
        instanceTypeFamilyName: string;
        /**
         * The memory of instance type.
         */
        memory: number;
        /**
         * The config of storage.
         */
        storages: outputs.veenedge.InstanceTypesInstanceTypeConfigStorage[];
    }

    export interface InstanceTypesInstanceTypeConfigStorage {
        /**
         * The amount of local storage.
         */
        localStorageAmount: number;
        /**
         * The capacity of local storage.
         */
        localStorageCapacity: number;
        /**
         * The local storage category.
         */
        localStorageCategory: string;
        /**
         * The unit of local storage.
         */
        localStorageUnit: string;
    }

    export interface InstancesInstance {
        /**
         * The id of cloud server.
         */
        cloudServerIdentity: string;
        /**
         * The name of cloud server.
         */
        cloudServerName: string;
        /**
         * The cluster info.
         */
        cluster: outputs.veenedge.InstancesInstanceCluster;
        /**
         * The cpu of instance.
         */
        cpu: string;
        /**
         * The create time of instance.
         */
        createTime: number;
        /**
         * The creator of instance.
         */
        creator: string;
        /**
         * The delete time of instance.
         */
        deleteTime: number;
        /**
         * The end time of instance.
         */
        endTime: number;
        /**
         * The config of gpu.
         */
        gpu: outputs.veenedge.InstancesInstanceGpu;
        /**
         * The Id of instance.
         */
        id: string;
        /**
         * The config of image.
         */
        image: outputs.veenedge.InstancesInstanceImage;
        /**
         * The Id of instance.
         */
        instanceIdentity: string;
        /**
         * The name of instance.
         */
        instanceName: string;
        /**
         * The memory of instance.
         */
        mem: string;
        /**
         * The config of network.
         */
        network: outputs.veenedge.InstancesInstanceNetwork;
        /**
         * The spec of instance.
         */
        spec: string;
        /**
         * The spec display of instance.
         */
        specDisplay: string;
        /**
         * The start time of instance.
         */
        startTime: number;
        /**
         * The status of instance.
         */
        status: string;
        /**
         * The config of storage.
         */
        storage: outputs.veenedge.InstancesInstanceStorage;
        /**
         * The subnet cidr.
         */
        subnetCidr: string;
        /**
         * The update time of instance.
         */
        updateTime: number;
        /**
         * The id of vpc.
         */
        vpcIdentity: string;
    }

    export interface InstancesInstanceCluster {
        /**
         * The alias of cluster.
         */
        alias: string;
        /**
         * The city of cluster.
         */
        city: string;
        /**
         * The name of cluster.
         */
        clusterName: string;
        /**
         * The country of cluster.
         */
        country: string;
        /**
         * The isp info.
         */
        isp: string;
        /**
         * The level of cluster.
         */
        level: string;
        /**
         * The province of cluster.
         */
        province: string;
        /**
         * The region of cluster.
         */
        region: string;
    }

    export interface InstancesInstanceGpu {
        /**
         * The list gpu info.
         */
        gpuses: outputs.veenedge.InstancesInstanceGpuGpus[];
    }

    export interface InstancesInstanceGpuGpus {
        /**
         * The spec of gpu.
         */
        gpuSpec: outputs.veenedge.InstancesInstanceGpuGpusGpuSpec;
        /**
         * The number of gpu.
         */
        num: number;
    }

    export interface InstancesInstanceGpuGpusGpuSpec {
        /**
         * The type of gpu.
         */
        gpuType: string;
    }

    export interface InstancesInstanceImage {
        /**
         * The id of image.
         */
        imageIdentity: string;
        /**
         * The name of image.
         */
        imageName: string;
        /**
         * The property of system.
         */
        property: string;
        /**
         * The arch of system.
         */
        systemArch: string;
        /**
         * The bit of system.
         */
        systemBit: string;
        /**
         * The type of system.
         */
        systemType: string;
        /**
         * The version of system.
         */
        systemVersion: string;
    }

    export interface InstancesInstanceNetwork {
        /**
         * Whether enable ipv6.
         */
        enableIpv6: boolean;
        /**
         * The external interface of network.
         */
        externalInterface: outputs.veenedge.InstancesInstanceNetworkExternalInterface;
        /**
         * The internal interface of network.
         */
        internalInterface: outputs.veenedge.InstancesInstanceNetworkInternalInterface;
        /**
         * The passthrough info.
         */
        vfPassthrough: boolean;
    }

    export interface InstancesInstanceNetworkExternalInterface {
        /**
         * The peak of bandwidth.
         */
        bandwidthPeak: string;
        /**
         * The ipv6 address.
         */
        ip6Addr: string;
        /**
         * The ip address.
         */
        ipAddr: string;
        /**
         * The ips of network.
         */
        ips: outputs.veenedge.InstancesInstanceNetworkExternalInterfaceIp[];
        /**
         * The mac address.
         */
        macAddr: string;
        /**
         * The mask info.
         */
        mask: string;
        /**
         * The ipv6 mask info.
         */
        mask6: string;
    }

    export interface InstancesInstanceNetworkExternalInterfaceIp {
        /**
         * The ip address.
         */
        addr: string;
        /**
         * The version of ip address.
         */
        ipVersion: string;
        /**
         * The isp info.
         */
        isp: string;
        /**
         * The mask info.
         */
        mask: string;
    }

    export interface InstancesInstanceNetworkInternalInterface {
        /**
         * The peak of bandwidth.
         */
        bandwidthPeak: string;
        /**
         * The ipv6 address.
         */
        ip6Addr: string;
        /**
         * The ip address.
         */
        ipAddr: string;
        /**
         * The ips of network.
         */
        ips: outputs.veenedge.InstancesInstanceNetworkInternalInterfaceIp[];
        /**
         * The mac address.
         */
        macAddr: string;
        /**
         * The mask info.
         */
        mask: string;
        /**
         * The ipv6 mask info.
         */
        mask6: string;
    }

    export interface InstancesInstanceNetworkInternalInterfaceIp {
        /**
         * The ip address.
         */
        addr: string;
        /**
         * The version of ip address.
         */
        ipVersion: string;
        /**
         * The isp info.
         */
        isp: string;
        /**
         * The mask info.
         */
        mask: string;
    }

    export interface InstancesInstanceStorage {
        /**
         * The disk info of data.
         */
        dataDisk: outputs.veenedge.InstancesInstanceStorageDataDisk;
        /**
         * The disk list info of data.
         */
        dataDiskLists: outputs.veenedge.InstancesInstanceStorageDataDiskList[];
        /**
         * The disk info of system.
         */
        systemDisk: outputs.veenedge.InstancesInstanceStorageSystemDisk;
    }

    export interface InstancesInstanceStorageDataDisk {
        /**
         * The capacity of storage.
         */
        capacity: string;
        /**
         * The type of storage.
         */
        storageType: string;
    }

    export interface InstancesInstanceStorageDataDiskList {
        /**
         * The capacity of storage.
         */
        capacity: string;
        /**
         * The type of storage.
         */
        storageType: string;
    }

    export interface InstancesInstanceStorageSystemDisk {
        /**
         * The capacity of storage.
         */
        capacity: string;
        /**
         * The type of storage.
         */
        storageType: string;
    }

    export interface VpcsVpcInstance {
        /**
         * The account id.
         */
        accountIdentity: number;
        /**
         * The cluster info.
         */
        cluster: outputs.veenedge.VpcsVpcInstanceCluster;
        /**
         * The cluster vpc id.
         */
        clusterVpcId: number;
        /**
         * The creation time.
         */
        createTime: number;
        /**
         * The description of VPC.
         */
        desc: string;
        /**
         * The ID of VPC.
         */
        id: string;
        /**
         * Is default vpc.
         */
        isDefault: boolean;
        /**
         * The resource statistic info.
         */
        resourceStatistics: outputs.veenedge.VpcsVpcInstanceResourceStatistic[];
        /**
         * The status of VPC.
         */
        status: string;
        /**
         * The subnets info.
         */
        subNets: outputs.veenedge.VpcsVpcInstanceSubNet[];
        /**
         * The update time of VPC.
         */
        updateTime: number;
        /**
         * The id of user.
         */
        userIdentity: number;
        /**
         * The ID of VPC.
         */
        vpcIdentity: string;
        /**
         * The name of VPC.
         */
        vpcName: string;
        /**
         * The namespace of VPC.
         */
        vpcNs: string;
    }

    export interface VpcsVpcInstanceCluster {
        /**
         * The alias of cluster.
         */
        alias: string;
        /**
         * The city of cluster.
         */
        city: string;
        /**
         * The name of cluster.
         */
        clusterName: string;
        /**
         * The country of cluster.
         */
        country: string;
        /**
         * The isp of cluster.
         */
        isp: string;
        /**
         * The level of cluster.
         */
        level: string;
        /**
         * The province of cluster.
         */
        province: string;
        /**
         * The region of cluster.
         */
        region: string;
    }

    export interface VpcsVpcInstanceResourceStatistic {
        /**
         * The count of instance.
         */
        veenInstanceCount: number;
        /**
         * The count of load balancers.
         */
        veewLbInstanceCount: number;
        /**
         * The count of security groups.
         */
        veewSgInstanceCount: number;
    }

    export interface VpcsVpcInstanceSubNet {
        /**
         * The account id.
         */
        accountIdentity: number;
        /**
         * The ip of cidr.
         */
        cidrIp: string;
        /**
         * The mask of cidr.
         */
        cidrMask: number;
        /**
         * The creation time.
         */
        createTime: number;
        /**
         * The id of subnet.
         */
        subnetIdentity: string;
        /**
         * The update time of VPC.
         */
        updateTime: number;
        /**
         * The id of user.
         */
        userIdentity: number;
    }

}

export namespace vke {
    export interface AddonsAddon {
        /**
         * The ID of the Cluster.
         */
        clusterId: string;
        /**
         * The config of addon.
         */
        config: string;
        /**
         * ClientToken when the addon is created successfully. ClientToken is a string that guarantees the idempotency of the request. This string is passed in by the caller.
         */
        createClientToken?: string;
        /**
         * Addon creation time. UTC+0 time in standard RFC3339 format.
         */
        createTime: string;
        /**
         * The deploy mode.
         */
        deployMode: string;
        /**
         * The deploy node type.
         */
        deployNodeType: string;
        /**
         * The name of the cluster.
         */
        name: string;
        /**
         * The status of the addon.
         */
        status: outputs.vke.AddonsAddonStatus;
        /**
         * The ClientToken when the last addon update succeeded. ClientToken is a string that guarantees the idempotency of the request. This string is passed in by the caller.
         */
        updateClientToken?: string;
        /**
         * The last time a request was accepted by the addon and executed or completed. UTC+0 time in standard RFC3339 format.
         */
        updateTime: string;
        /**
         * The name of the cluster.
         */
        version: string;
    }

    export interface AddonsAddonStatus {
        /**
         * The state condition in the current primary state of the cluster, that is, the reason for entering the primary state.
         */
        conditions: outputs.vke.AddonsAddonStatusCondition[];
        /**
         * The status of addon. the value contains `Creating`, `Running`, `Updating`, `Deleting`, `Failed`.
         */
        phase: string;
    }

    export interface AddonsAddonStatusCondition {
        /**
         * The state condition in the current main state of the addon, that is, the reason for entering the main state, there can be multiple reasons, the value contains `Progressing`, `Ok`, `Degraded`,`Unknown`, `ClusterNotRunning`, `CrashLoopBackOff`, `SchedulingFailed`, `NameConflict`, `ResourceCleanupFailed`, `ClusterVersionUpgrading`.
         */
        type: string;
    }

    export interface AddonsStatus {
        /**
         * The state condition in the current main state of the addon, that is, the reason for entering the main state, there can be multiple reasons, the value contains `Progressing`, `Ok`, `Degraded`,`Unknown`, `ClusterNotRunning`, `CrashLoopBackOff`, `SchedulingFailed`, `NameConflict`, `ResourceCleanupFailed`, `ClusterVersionUpgrading`.
         */
        conditionsType?: string;
        /**
         * The status of addon. the value contains `Creating`, `Running`, `Updating`, `Deleting`, `Failed`.
         */
        phase?: string;
    }

    export interface ClusterClusterConfig {
        /**
         * Cluster API Server public network access configuration.
         */
        apiServerPublicAccessConfig?: outputs.vke.ClusterClusterConfigApiServerPublicAccessConfig;
        /**
         * Cluster API Server public network access configuration, the value is `true` or `false`.
         */
        apiServerPublicAccessEnabled?: boolean;
        ipFamily: string;
        /**
         * Node public network access configuration, the value is `true` or `false`.
         */
        resourcePublicAccessDefaultEnabled?: boolean;
        /**
         * The subnet ID for the cluster control plane to communicate within the private network.
         */
        subnetIds: string[];
    }

    export interface ClusterClusterConfigApiServerPublicAccessConfig {
        /**
         * Public network access network configuration.
         */
        publicAccessNetworkConfig?: outputs.vke.ClusterClusterConfigApiServerPublicAccessConfigPublicAccessNetworkConfig;
    }

    export interface ClusterClusterConfigApiServerPublicAccessConfigPublicAccessNetworkConfig {
        /**
         * The peak bandwidth of the public IP, unit: Mbps.
         */
        bandwidth?: number;
        /**
         * Billing type of public IP, the value is `PostPaidByBandwidth` or `PostPaidByTraffic`.
         */
        billingType?: string;
    }

    export interface ClusterLoggingConfig {
        /**
         * The TLS log item ID of the collection target.
         */
        logProjectId: string;
        /**
         * Cluster logging options. This structure can only be modified and added, and cannot be deleted. When encountering a `cannot be deleted` error, please query the log setups of the current cluster and fill in the current `tf` file.
         */
        logSetups?: outputs.vke.ClusterLoggingConfigLogSetup[];
    }

    export interface ClusterLoggingConfigLogSetup {
        /**
         * Whether to enable the log option, true means enable, false means not enable, the default is false. When Enabled is changed from false to true, a new Topic will be created.
         */
        enabled?: boolean;
        /**
         * The storage time of logs in Log Service. After the specified log storage time is exceeded, the expired logs in this log topic will be automatically cleared. The unit is days, and the default is 30 days. The value range is 1 to 3650, specifying 3650 days means permanent storage.
         */
        logTtl?: number;
        /**
         * The current types of logs that can be enabled are:
         * Audit: Cluster audit logs.
         * KubeApiServer: kube-apiserver component logs.
         * KubeScheduler: kube-scheduler component logs.
         * KubeControllerManager: kube-controller-manager component logs.
         */
        logType: string;
    }

    export interface ClusterPodsConfig {
        /**
         * Flannel network configuration.
         */
        flannelConfig?: outputs.vke.ClusterPodsConfigFlannelConfig;
        /**
         * The container network model of the cluster, the value is `Flannel` or `VpcCniShared`. Flannel: Flannel network model, an independent Underlay container network solution, combined with the global routing capability of VPC, to achieve a high-performance network experience for the cluster. VpcCniShared: VPC-CNI network model, an Underlay container network solution based on the ENI of the private network elastic network card, with high network communication performance.
         */
        podNetworkMode: string;
        /**
         * VPC-CNI network configuration.
         */
        vpcCniConfig?: outputs.vke.ClusterPodsConfigVpcCniConfig;
    }

    export interface ClusterPodsConfigFlannelConfig {
        /**
         * The maximum number of single-node Pod instances for a Flannel container network, the value can be `16` or `32` or `64` or `128` or `256`.
         */
        maxPodsPerNode?: number;
        /**
         * Pod CIDR for the Flannel container network.
         */
        podCidrs?: string[];
    }

    export interface ClusterPodsConfigVpcCniConfig {
        /**
         * A list of Pod subnet IDs for the VPC-CNI container network.
         */
        subnetIds?: string[];
        /**
         * The private network where the cluster control plane network resides.
         */
        vpcId?: string;
    }

    export interface ClusterServicesConfig {
        /**
         * The IPv4 private network address exposed by the service.
         */
        serviceCidrsv4s: string[];
    }

    export interface ClusterTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface ClustersCluster {
        /**
         * The config of the cluster.
         */
        clusterConfig: outputs.vke.ClustersClusterClusterConfig;
        /**
         * ClientToken when the cluster is created successfully. ClientToken is a string that guarantees the idempotency of the request. This string is passed in by the caller.
         */
        createClientToken?: string;
        /**
         * Cluster creation time. UTC+0 time in standard RFC3339 format.
         */
        createTime: string;
        /**
         * The delete protection of the cluster, the value is `true` or `false`.
         */
        deleteProtectionEnabled: boolean;
        /**
         * The description of the cluster.
         */
        description: string;
        /**
         * Eip allocation Id.
         */
        eipAllocationId: string;
        /**
         * The ID of the Cluster.
         */
        id: string;
        /**
         * Kubeconfig data with private network access, returned in BASE64 encoding, it is suggested to use vkeKubeconfig instead.
         */
        kubeconfigPrivate: string;
        /**
         * Kubeconfig data with public network access, returned in BASE64 encoding, it is suggested to use vkeKubeconfig instead.
         */
        kubeconfigPublic: string;
        /**
         * The Kubernetes version information corresponding to the cluster, specific to the patch version.
         */
        kubernetesVersion: string;
        /**
         * Cluster log configuration information.
         */
        loggingConfigs: outputs.vke.ClustersClusterLoggingConfig[];
        /**
         * The name of the cluster.
         */
        name: string;
        /**
         * Statistics on the number of nodes corresponding to each master state in the cluster.
         */
        nodeStatistics: outputs.vke.ClustersClusterNodeStatistics;
        /**
         * The config of the pods.
         */
        podsConfig: outputs.vke.ClustersClusterPodsConfig;
        /**
         * The config of the services.
         */
        servicesConfig: outputs.vke.ClustersClusterServicesConfig;
        /**
         * The status of the cluster.
         */
        status: outputs.vke.ClustersClusterStatus;
        /**
         * Tags.
         */
        tags: outputs.vke.ClustersClusterTag[];
        /**
         * The ClientToken when the last cluster update succeeded. ClientToken is a string that guarantees the idempotency of the request. This string is passed in by the caller.
         */
        updateClientToken?: string;
        /**
         * The last time a request was accepted by the cluster and executed or completed. UTC+0 time in standard RFC3339 format.
         */
        updateTime: string;
    }

    export interface ClustersClusterClusterConfig {
        /**
         * Endpoint information accessed by the cluster API Server.
         */
        apiServerEndpoints: outputs.vke.ClustersClusterClusterConfigApiServerEndpoints;
        /**
         * Cluster API Server public network access configuration.
         */
        apiServerPublicAccessConfig: outputs.vke.ClustersClusterClusterConfigApiServerPublicAccessConfig;
        /**
         * Cluster API Server public network access configuration, the value is `true` or `false`.
         */
        apiServerPublicAccessEnabled: boolean;
        /**
         * Node public network access configuration, the value is `true` or `false`.
         */
        resourcePublicAccessDefaultEnabled: boolean;
        /**
         * The security group used by the cluster control plane and nodes.
         */
        securityGroupIds: string[];
        /**
         * A list of Pod subnet IDs for the VPC-CNI container network.
         */
        subnetIds: string[];
        /**
         * The private network where the cluster control plane network resides.
         */
        vpcId: string;
    }

    export interface ClustersClusterClusterConfigApiServerEndpoints {
        /**
         * Endpoint address of the cluster API Server private network.
         */
        privateIp: outputs.vke.ClustersClusterClusterConfigApiServerEndpointsPrivateIp;
        /**
         * Endpoint address of the cluster API Server public network.
         */
        publicIp: outputs.vke.ClustersClusterClusterConfigApiServerEndpointsPublicIp;
    }

    export interface ClustersClusterClusterConfigApiServerEndpointsPrivateIp {
        /**
         * Ipv4 address.
         */
        ipv4: string;
    }

    export interface ClustersClusterClusterConfigApiServerEndpointsPublicIp {
        /**
         * Ipv4 address.
         */
        ipv4: string;
    }

    export interface ClustersClusterClusterConfigApiServerPublicAccessConfig {
        /**
         * IPv4 public network access whitelist. A null value means all network segments (0.0.0.0/0) are allowed to pass.
         */
        accessSourceIpsv4s: string[];
        ipFamily: string;
        /**
         * Public network access network configuration.
         */
        publicAccessNetworkConfig: outputs.vke.ClustersClusterClusterConfigApiServerPublicAccessConfigPublicAccessNetworkConfig;
    }

    export interface ClustersClusterClusterConfigApiServerPublicAccessConfigPublicAccessNetworkConfig {
        /**
         * The peak bandwidth of the public IP, unit: Mbps.
         */
        bandwidth: number;
        /**
         * Billing type of public IP, the value is `PostPaidByBandwidth` or `PostPaidByTraffic`.
         */
        billingType: string;
        /**
         * The ISP of public IP.
         */
        isp: string;
    }

    export interface ClustersClusterLoggingConfig {
        /**
         * The TLS log item ID of the collection target.
         */
        logProjectId: string;
        /**
         * Cluster logging options.
         */
        logSetups: outputs.vke.ClustersClusterLoggingConfigLogSetup[];
    }

    export interface ClustersClusterLoggingConfigLogSetup {
        /**
         * Whether to enable the log option, true means enable, false means not enable, the default is false. When Enabled is changed from false to true, a new Topic will be created.
         */
        enabled: boolean;
        /**
         * The storage time of logs in Log Service. After the specified log storage time is exceeded, the expired logs in this log topic will be automatically cleared. The unit is days, and the default is 30 days. The value range is 1 to 3650, specifying 3650 days means permanent storage.
         */
        logTtl: number;
        /**
         * The currently enabled log type.
         */
        logType: string;
    }

    export interface ClustersClusterNodeStatistics {
        /**
         * Phase=Creating total number of nodes.
         */
        creatingCount: number;
        /**
         * Phase=Deleting total number of nodes.
         */
        deletingCount: number;
        /**
         * Phase=Failed total number of nodes.
         */
        failedCount: number;
        /**
         * Phase=Running total number of nodes.
         */
        runningCount: number;
        /**
         * (**Deprecated**) This field has been deprecated and is not recommended for use. Phase=Stopped total number of nodes.
         *
         * @deprecated This field has been deprecated and is not recommended for use.
         */
        stoppedCount: number;
        /**
         * The total count of Cluster query.
         */
        totalCount: number;
        /**
         * Phase=Updating total number of nodes.
         */
        updatingCount: number;
    }

    export interface ClustersClusterPodsConfig {
        /**
         * Flannel network configuration.
         */
        flannelConfig: outputs.vke.ClustersClusterPodsConfigFlannelConfig;
        /**
         * Container Pod Network Type (CNI), the value is `Flannel` or `VpcCniShared`.
         */
        podNetworkMode: string;
        /**
         * VPC-CNI network configuration.
         */
        vpcCniConfig: outputs.vke.ClustersClusterPodsConfigVpcCniConfig;
    }

    export interface ClustersClusterPodsConfigFlannelConfig {
        /**
         * The maximum number of single-node Pod instances for a Flannel container network.
         */
        maxPodsPerNode: number;
        /**
         * Pod CIDR for the Flannel container network.
         */
        podCidrs: string[];
    }

    export interface ClustersClusterPodsConfigVpcCniConfig {
        /**
         * A list of Pod subnet IDs for the VPC-CNI container network.
         */
        subnetIds: string[];
        /**
         * The private network where the cluster control plane network resides.
         */
        vpcId: string;
    }

    export interface ClustersClusterServicesConfig {
        /**
         * The IPv4 private network address exposed by the service.
         */
        serviceCidrsv4s: string[];
    }

    export interface ClustersClusterStatus {
        /**
         * The state condition in the current primary state of the cluster, that is, the reason for entering the primary state.
         */
        conditions: outputs.vke.ClustersClusterStatusCondition[];
        /**
         * The status of cluster. the value contains `Creating`, `Running`, `Updating`, `Deleting`, `Stopped`, `Failed`.
         */
        phase: string;
    }

    export interface ClustersClusterStatusCondition {
        /**
         * The Type of Tags.
         */
        type: string;
    }

    export interface ClustersClusterTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Type of Tags.
         */
        type: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface ClustersStatus {
        /**
         * The state condition in the current main state of the cluster, that is, the reason for entering the main state, there can be multiple reasons, the value contains `Progressing`, `Ok`, `Degraded`, `SetByProvider`, `Balance`, `Security`, `CreateError`, `ResourceCleanupFailed`, `LimitedByQuota`, `StockOut`,`Unknown`.
         */
        conditionsType?: string;
        /**
         * The status of cluster. the value contains `Creating`, `Running`, `Updating`, `Deleting`, `Stopped`, `Failed`.
         */
        phase?: string;
    }

    export interface ClustersTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface DefaultNodePoolBatchAttachInstance {
        /**
         * The flag of additional container storage enable, the value is `true` or `false`..Default is `false`.
         */
        additionalContainerStorageEnabled?: boolean;
        /**
         * The container storage path.When additionalContainerStorageEnabled is `false` will ignore.
         */
        containerStoragePath: string;
        /**
         * ID of the resource.
         */
        id: string;
        /**
         * The Image Id to the ECS Instance.
         */
        imageId: string;
        /**
         * The instance id.
         */
        instanceId: string;
        /**
         * The flag of keep instance name, the value is `true` or `false`.Default is `false`.
         */
        keepInstanceName?: boolean;
        phase: string;
    }

    export interface DefaultNodePoolBatchAttachKubernetesConfig {
        /**
         * The Cordon of KubernetesConfig.
         */
        cordon?: boolean;
        /**
         * The Labels of KubernetesConfig.
         */
        labels?: outputs.vke.DefaultNodePoolBatchAttachKubernetesConfigLabel[];
        /**
         * The Taints of KubernetesConfig.
         */
        taints?: outputs.vke.DefaultNodePoolBatchAttachKubernetesConfigTaint[];
    }

    export interface DefaultNodePoolBatchAttachKubernetesConfigLabel {
        /**
         * The Key of Labels.
         */
        key: string;
        /**
         * The Value of Labels.
         */
        value?: string;
    }

    export interface DefaultNodePoolBatchAttachKubernetesConfigTaint {
        /**
         * The Effect of Taints. The value can be one of the following: `NoSchedule`, `NoExecute`, `PreferNoSchedule`, default value is `NoSchedule`.
         */
        effect?: string;
        /**
         * The Key of Taints.
         */
        key: string;
        /**
         * The Value of Taints.
         */
        value?: string;
    }

    export interface DefaultNodePoolBatchAttachNodeConfig {
        /**
         * Tags for Ecs.
         */
        ecsTags: outputs.vke.DefaultNodePoolBatchAttachNodeConfigEcsTag[];
        /**
         * The initializeScript of NodeConfig.
         */
        initializeScript: string;
        /**
         * The NamePrefix of NodeConfig.
         */
        namePrefix: string;
        /**
         * The Security of NodeConfig.
         */
        securities: outputs.vke.DefaultNodePoolBatchAttachNodeConfigSecurity[];
    }

    export interface DefaultNodePoolBatchAttachNodeConfigEcsTag {
        /**
         * The Key of Labels.
         */
        key: string;
        /**
         * The Value of Labels.
         */
        value: string;
    }

    export interface DefaultNodePoolBatchAttachNodeConfigSecurity {
        /**
         * The Login of Security.
         */
        logins: outputs.vke.DefaultNodePoolBatchAttachNodeConfigSecurityLogin[];
        /**
         * The SecurityGroupIds of Security.
         */
        securityGroupIds: string[];
        /**
         * The SecurityStrategies of Security.
         */
        securityStrategies: string[];
    }

    export interface DefaultNodePoolBatchAttachNodeConfigSecurityLogin {
        /**
         * The Password of Security.
         */
        password: string;
        /**
         * The SshKeyPairName of Security.
         */
        sshKeyPairName: string;
    }

    export interface DefaultNodePoolBatchAttachTag {
        /**
         * The Key of Labels.
         */
        key: string;
        /**
         * The Value of Labels.
         */
        value: string;
    }

    export interface DefaultNodePoolInstance {
        /**
         * The flag of additional container storage enable, the value is `true` or `false`..Default is `false`.
         */
        additionalContainerStorageEnabled?: boolean;
        /**
         * The container storage path.When additionalContainerStorageEnabled is `false` will ignore.
         */
        containerStoragePath: string;
        /**
         * ID of the resource.
         */
        id: string;
        /**
         * The Image Id to the ECS Instance.
         */
        imageId: string;
        /**
         * The instance id.
         */
        instanceId: string;
        /**
         * The flag of keep instance name, the value is `true` or `false`.Default is `false`.
         */
        keepInstanceName?: boolean;
        phase: string;
    }

    export interface DefaultNodePoolKubernetesConfig {
        /**
         * The Cordon of KubernetesConfig.
         */
        cordon: boolean;
        /**
         * The Labels of KubernetesConfig.
         */
        labels?: outputs.vke.DefaultNodePoolKubernetesConfigLabel[];
        /**
         * The NamePrefix of node metadata.
         */
        namePrefix?: string;
        /**
         * The Taints of KubernetesConfig.
         */
        taints?: outputs.vke.DefaultNodePoolKubernetesConfigTaint[];
    }

    export interface DefaultNodePoolKubernetesConfigLabel {
        /**
         * The Key of Labels.
         */
        key?: string;
        /**
         * The Value of Labels.
         */
        value?: string;
    }

    export interface DefaultNodePoolKubernetesConfigTaint {
        /**
         * The Effect of Taints.
         */
        effect?: string;
        /**
         * The Key of Taints.
         */
        key?: string;
        /**
         * The Value of Taints.
         */
        value?: string;
    }

    export interface DefaultNodePoolNodeConfig {
        /**
         * Tags for Ecs.
         */
        ecsTags?: outputs.vke.DefaultNodePoolNodeConfigEcsTag[];
        /**
         * The initializeScript of NodeConfig.
         */
        initializeScript?: string;
        /**
         * The NamePrefix of NodeConfig.
         */
        namePrefix?: string;
        /**
         * The Security of NodeConfig.
         */
        security: outputs.vke.DefaultNodePoolNodeConfigSecurity;
    }

    export interface DefaultNodePoolNodeConfigEcsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface DefaultNodePoolNodeConfigSecurity {
        /**
         * The Login of Security.
         */
        login: outputs.vke.DefaultNodePoolNodeConfigSecurityLogin;
        /**
         * The SecurityGroupIds of Security.
         */
        securityGroupIds: string[];
        /**
         * The SecurityStrategies of Security.
         */
        securityStrategies?: string[];
    }

    export interface DefaultNodePoolNodeConfigSecurityLogin {
        /**
         * The Password of Security.
         */
        password?: string;
        /**
         * The SshKeyPairName of Security.
         */
        sshKeyPairName?: string;
    }

    export interface DefaultNodePoolTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface KubeconfigsKubeconfig {
        /**
         * The Cluster ID of the Kubeconfig.
         */
        clusterId: string;
        /**
         * The create time of the Kubeconfig.
         */
        createTime: string;
        /**
         * The expire time of the Kubeconfig.
         */
        expireTime: string;
        /**
         * The ID of the Kubeconfig.
         */
        id: string;
        /**
         * Kubeconfig data with public/private network access, returned in BASE64 encoding.
         */
        kubeconfig: string;
        /**
         * The ID of the Kubeconfig.
         */
        kubeconfigId: string;
        /**
         * The type of the Kubeconfig.
         */
        type: string;
        /**
         * The account ID of the Kubeconfig.
         */
        userId: number;
    }

    export interface NodeKubernetesConfig {
        /**
         * The Cordon of KubernetesConfig.
         */
        cordon: boolean;
        /**
         * The Labels of KubernetesConfig.
         */
        labels?: outputs.vke.NodeKubernetesConfigLabel[];
        /**
         * The Taints of KubernetesConfig.
         */
        taints: outputs.vke.NodeKubernetesConfigTaint[];
    }

    export interface NodeKubernetesConfigLabel {
        /**
         * The Key of Labels.
         */
        key?: string;
        /**
         * The Value of Labels.
         */
        value?: string;
    }

    export interface NodeKubernetesConfigTaint {
        /**
         * The Effect of Taints, the value can be `NoSchedule` or `NoExecute` or `PreferNoSchedule`.
         */
        effect?: string;
        /**
         * The Key of Taints.
         */
        key?: string;
        /**
         * The Value of Taints.
         */
        value?: string;
    }

    export interface NodePoolAutoScaling {
        /**
         * The DesiredReplicas of AutoScaling, default 0, range in minReplicas to max_replicas.
         */
        desiredReplicas: number;
        /**
         * Whether to enable the auto scaling function of the node pool. When a node needs to be manually added to the node pool, the value of this field must be `false`.
         */
        enabled: boolean;
        /**
         * The MaxReplicas of AutoScaling, default 10, range in 1~2000. This field is valid when the value of `enabled` is `true`.
         */
        maxReplicas?: number;
        /**
         * The MinReplicas of AutoScaling, default 0. This field is valid when the value of `enabled` is `true`.
         */
        minReplicas: number;
        /**
         * The Priority of AutoScaling, default 10, rang in 0~100. This field is valid when the value of `enabled` is `true` and the value of `subnetPolicy` is `Priority`.
         */
        priority: number;
        /**
         * Multi-subnet scheduling strategy for nodes. The value can be `ZoneBalance` or `Priority`.
         */
        subnetPolicy: string;
    }

    export interface NodePoolKubernetesConfig {
        /**
         * The Cordon of KubernetesConfig.
         */
        cordon: boolean;
        /**
         * The Labels of KubernetesConfig.
         */
        labels?: outputs.vke.NodePoolKubernetesConfigLabel[];
        /**
         * The NamePrefix of node metadata.
         */
        namePrefix?: string;
        /**
         * The Taints of KubernetesConfig.
         */
        taints?: outputs.vke.NodePoolKubernetesConfigTaint[];
    }

    export interface NodePoolKubernetesConfigLabel {
        /**
         * The Key of Labels.
         */
        key?: string;
        /**
         * The Value of Labels.
         */
        value?: string;
    }

    export interface NodePoolKubernetesConfigTaint {
        /**
         * The Effect of Taints, the value can be `NoSchedule` or `NoExecute` or `PreferNoSchedule`.
         */
        effect?: string;
        /**
         * The Key of Taints.
         */
        key?: string;
        /**
         * The Value of Taints.
         */
        value?: string;
    }

    export interface NodePoolNodeConfig {
        /**
         * The AdditionalContainerStorageEnabled of NodeConfig.
         */
        additionalContainerStorageEnabled?: boolean;
        /**
         * Is AutoRenew of PrePaid instance of NodeConfig. Valid values: true, false. when InstanceChargeType is PrePaid, default value is true.
         */
        autoRenew: boolean;
        /**
         * The AutoRenewPeriod of PrePaid instance of NodeConfig. Valid values: 1, 2, 3, 6, 12. Unit: month. when InstanceChargeType is PrePaid and AutoRenew enable, default value is 1.
         */
        autoRenewPeriod: number;
        /**
         * The DataVolumes of NodeConfig.
         */
        dataVolumes?: outputs.vke.NodePoolNodeConfigDataVolume[];
        /**
         * Tags for Ecs.
         */
        ecsTags?: outputs.vke.NodePoolNodeConfigEcsTag[];
        /**
         * The IDs of HpcCluster, only one ID is supported currently.
         */
        hpcClusterIds?: string[];
        /**
         * The ImageId of NodeConfig.
         */
        imageId: string;
        /**
         * The initializeScript of NodeConfig.
         */
        initializeScript?: string;
        /**
         * The InstanceChargeType of PrePaid instance of NodeConfig. Valid values: PostPaid, PrePaid. Default value: PostPaid.
         */
        instanceChargeType?: string;
        /**
         * The InstanceTypeIds of NodeConfig. The value can get from volcengine.vke.SupportResourceTypes datasource.
         */
        instanceTypeIds: string[];
        /**
         * The NamePrefix of NodeConfig.
         */
        namePrefix?: string;
        /**
         * The Period of PrePaid instance of NodeConfig. Valid values: 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 24, 36. Unit: month. when InstanceChargeType is PrePaid, default value is 12.
         */
        period: number;
        /**
         * The Security of NodeConfig.
         */
        security: outputs.vke.NodePoolNodeConfigSecurity;
        /**
         * The SubnetIds of NodeConfig.
         */
        subnetIds: string[];
        /**
         * The SystemVolume of NodeConfig.
         */
        systemVolume: outputs.vke.NodePoolNodeConfigSystemVolume;
    }

    export interface NodePoolNodeConfigDataVolume {
        /**
         * The target mount directory of the disk. Must start with `/`.
         */
        mountPoint?: string;
        /**
         * The Size of DataVolumes, the value range in 20~32768. Default value is `20`.
         */
        size?: number;
        /**
         * The Type of DataVolumes, the value can be `PTSSD` or `ESSD_PL0` or `ESSD_FlexPL`. Default value is `ESSD_PL0`.
         */
        type?: string;
    }

    export interface NodePoolNodeConfigEcsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface NodePoolNodeConfigSecurity {
        /**
         * The Login of Security.
         */
        login?: outputs.vke.NodePoolNodeConfigSecurityLogin;
        /**
         * The SecurityGroupIds of Security.
         */
        securityGroupIds: string[];
        /**
         * The SecurityStrategies of Security, the value can be empty or `Hids`.
         */
        securityStrategies?: string[];
    }

    export interface NodePoolNodeConfigSecurityLogin {
        /**
         * The Password of Security, this field must be encoded with base64.
         */
        password?: string;
        /**
         * The SshKeyPairName of Security.
         */
        sshKeyPairName?: string;
    }

    export interface NodePoolNodeConfigSystemVolume {
        /**
         * The Size of SystemVolume, the value range in 20~2048.
         */
        size: number;
        /**
         * The Type of SystemVolume, the value can be `PTSSD` or `ESSD_PL0` or `ESSD_FlexPL`.
         */
        type: string;
    }

    export interface NodePoolNodeStatistic {
        /**
         * The CreatingCount of Node.
         */
        creatingCount: number;
        /**
         * The DeletingCount of Node.
         */
        deletingCount: number;
        /**
         * The FailedCount of Node.
         */
        failedCount: number;
        /**
         * The RunningCount of Node.
         */
        runningCount: number;
        /**
         * (**Deprecated**) This field has been deprecated and is not recommended for use. The StartingCount of Node.
         *
         * @deprecated This field has been deprecated and is not recommended for use.
         */
        startingCount: number;
        /**
         * (**Deprecated**) This field has been deprecated and is not recommended for use. The StoppedCount of Node.
         *
         * @deprecated This field has been deprecated and is not recommended for use.
         */
        stoppedCount: number;
        /**
         * (**Deprecated**) This field has been deprecated and is not recommended for use. The StoppingCount of Node.
         *
         * @deprecated This field has been deprecated and is not recommended for use.
         */
        stoppingCount: number;
        /**
         * The TotalCount of Node.
         */
        totalCount: number;
        /**
         * The UpdatingCount of Node.
         */
        updatingCount: number;
    }

    export interface NodePoolTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface NodePoolsNodePool {
        /**
         * Is AdditionalContainerStorageEnabled of NodeConfig.
         */
        additionalContainerStorageEnabled: boolean;
        /**
         * Is auto renew of the PrePaid instance of NodeConfig.
         */
        autoRenew: boolean;
        /**
         * The AutoRenewPeriod of the PrePaid instance of NodeConfig.
         */
        autoRenewPeriod: number;
        /**
         * The ClusterId of NodePool.
         */
        clusterId: string;
        /**
         * The Condition of Status.
         */
        conditionTypes: string[];
        /**
         * The Cordon of KubernetesConfig.
         */
        cordon: boolean;
        /**
         * The ClientToken when successfully created.
         */
        createClientToken: string;
        /**
         * The CreateTime of NodePool.
         */
        createTime: string;
        /**
         * The DataVolume of NodeConfig.
         */
        dataVolumes: outputs.vke.NodePoolsNodePoolDataVolume[];
        /**
         * The DesiredReplicas of AutoScaling.
         */
        desiredReplicas: number;
        /**
         * Tags for Ecs.
         */
        ecsTags: outputs.vke.NodePoolsNodePoolEcsTag[];
        /**
         * Is Enabled of AutoScaling.
         */
        enabled: boolean;
        /**
         * The IDs of HpcCluster.
         */
        hpcClusterIds: string[];
        /**
         * The Id of NodePool.
         */
        id: string;
        /**
         * The ImageId of NodeConfig.
         */
        imageId: string;
        /**
         * The InitializeScript of NodeConfig.
         */
        initializeScript: string;
        /**
         * The InstanceChargeType of NodeConfig.
         */
        instanceChargeType: string;
        /**
         * The InstanceTypeIds of NodeConfig.
         */
        instanceTypeIds: string[];
        /**
         * The NamePrefix of node metadata.
         */
        kubeConfigNamePrefix: string;
        /**
         * The LabelContent of KubernetesConfig.
         */
        labelContents: outputs.vke.NodePoolsNodePoolLabelContent[];
        /**
         * The login SshKeyPairName of NodeConfig.
         */
        loginKeyPairName: string;
        /**
         * The login type of NodeConfig.
         */
        loginType: string;
        /**
         * The MaxReplicas of AutoScaling.
         */
        maxReplicas: number;
        /**
         * The MinReplicas of AutoScaling.
         */
        minReplicas: number;
        /**
         * The Name of NodePool.
         */
        name: string;
        /**
         * The NamePrefix of NodeConfig.
         */
        namePrefix: string;
        /**
         * The NodeStatistics of NodeConfig.
         */
        nodeStatistics: outputs.vke.NodePoolsNodePoolNodeStatistic[];
        /**
         * The period of the PrePaid instance of NodeConfig.
         */
        period: number;
        /**
         * The Phase of Status. The value can be `Creating` or `Running` or `Updating` or `Deleting` or `Failed` or `Scaling`.
         */
        phase: string;
        /**
         * The Priority of AutoScaling.
         */
        priority: number;
        /**
         * The SecurityGroupIds of NodeConfig.
         */
        securityGroupIds: string[];
        /**
         * The SecurityStrategies of NodeConfig.
         */
        securityStrategies: string[];
        /**
         * The SecurityStrategyEnabled of NodeConfig.
         */
        securityStrategyEnabled: boolean;
        /**
         * The SubnetId of NodeConfig.
         */
        subnetIds: string[];
        /**
         * Multi-subnet scheduling strategy for nodes. The value can be `ZoneBalance` or `Priority`.
         */
        subnetPolicy: string;
        /**
         * The SystemVolume of NodeConfig.
         */
        systemVolumes: outputs.vke.NodePoolsNodePoolSystemVolume[];
        /**
         * Tags.
         */
        tags: outputs.vke.NodePoolsNodePoolTag[];
        /**
         * The TaintContent of NodeConfig.
         */
        taintContents: outputs.vke.NodePoolsNodePoolTaintContent[];
        /**
         * The ClientToken when last update was successful.
         */
        updateClientToken: string;
        /**
         * The UpdateTime time of NodePool.
         */
        updateTime: string;
    }

    export interface NodePoolsNodePoolDataVolume {
        /**
         * The target mount directory of the disk.
         */
        mountPoint: string;
        /**
         * The Size of SystemVolume.
         */
        size: string;
        /**
         * The Type of Tags.
         */
        type: string;
    }

    export interface NodePoolsNodePoolEcsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface NodePoolsNodePoolLabelContent {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface NodePoolsNodePoolNodeStatistic {
        /**
         * The CreatingCount of Node.
         */
        creatingCount: number;
        /**
         * The DeletingCount of Node.
         */
        deletingCount: number;
        /**
         * The FailedCount of Node.
         */
        failedCount: number;
        /**
         * The RunningCount of Node.
         */
        runningCount: number;
        /**
         * (**Deprecated**) This field has been deprecated and is not recommended for use. The StartingCount of Node.
         *
         * @deprecated This field has been deprecated and is not recommended for use.
         */
        startingCount: number;
        /**
         * (**Deprecated**) This field has been deprecated and is not recommended for use. The StoppedCount of Node.
         *
         * @deprecated This field has been deprecated and is not recommended for use.
         */
        stoppedCount: number;
        /**
         * (**Deprecated**) This field has been deprecated and is not recommended for use. The StoppingCount of Node.
         *
         * @deprecated This field has been deprecated and is not recommended for use.
         */
        stoppingCount: number;
        /**
         * Returns the total amount of the data list.
         */
        totalCount: number;
        /**
         * The UpdatingCount of Node.
         */
        updatingCount: number;
    }

    export interface NodePoolsNodePoolSystemVolume {
        /**
         * The Size of SystemVolume.
         */
        size: string;
        /**
         * The Type of Tags.
         */
        type: string;
    }

    export interface NodePoolsNodePoolTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Type of Tags.
         */
        type: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface NodePoolsNodePoolTaintContent {
        /**
         * The Effect of Taint.
         */
        effect: string;
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface NodePoolsStatus {
        /**
         * Indicates the status condition of the node pool in the active state. The value can be `Progressing` or `Ok` or `VersionPartlyUpgraded` or `StockOut` or `LimitedByQuota` or `Balance` or `Degraded` or `ClusterVersionUpgrading` or `Cluster` or `ResourceCleanupFailed` or `Unknown` or `ClusterNotRunning` or `SetByProvider`.
         */
        conditionsType?: string;
        /**
         * The Phase of Status. The value can be `Creating` or `Running` or `Updating` or `Deleting` or `Failed` or `Scaling`.
         */
        phase?: string;
    }

    export interface NodePoolsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface NodesNode {
        /**
         * Is Additional Container storage enables.
         */
        additionalContainerStorageEnabled: boolean;
        /**
         * The cluster id of node.
         */
        clusterId: string;
        /**
         * The Condition of Node.
         */
        conditionTypes: string[];
        /**
         * The Storage Path.
         */
        containerStoragePath: string;
        /**
         * The Cordon of KubernetesConfig.
         */
        cordon: boolean;
        /**
         * The Create Client Token.
         */
        createClientToken: string;
        /**
         * The create time of Node.
         */
        createTime: string;
        /**
         * The ID of Node.
         */
        id: string;
        /**
         * The ImageId of NodeConfig.
         */
        imageId: string;
        /**
         * The InitializeScript of NodeConfig.
         */
        initializeScript: string;
        /**
         * The instance id of node.
         */
        instanceId: string;
        /**
         * Is virtual node.
         */
        isVirtual: boolean;
        /**
         * The Label of KubernetesConfig.
         */
        labels: outputs.vke.NodesNodeLabel[];
        /**
         * The Name of Node.
         */
        name: string;
        /**
         * The node pool id.
         */
        nodePoolId: string;
        /**
         * The Phase of Node, the value is `Creating` or `Running` or `Updating` or `Deleting` or `Failed` or `Starting` or `Stopping` or `Stopped`.
         */
        phase: string;
        /**
         * The roles of node.
         */
        roles: string[];
        /**
         * The Taint of KubernetesConfig.
         */
        taints: outputs.vke.NodesNodeTaint[];
        /**
         * The update time of Node.
         */
        updateTime: string;
        /**
         * The zone id.
         */
        zoneId: string;
    }

    export interface NodesNodeLabel {
        /**
         * The Key of Taint.
         */
        key: string;
        /**
         * The Value of Taint.
         */
        value: string;
    }

    export interface NodesNodeTaint {
        /**
         * The Effect of Taint.
         */
        effect: string;
        /**
         * The Key of Taint.
         */
        key: string;
        /**
         * The Value of Taint.
         */
        value: string;
    }

    export interface NodesStatus {
        /**
         * The Type of Node Condition, the value is `Progressing` or `Ok` or `Unschedulable` or `InitilizeFailed` or `Unknown` or `NotReady` or `Security` or `Balance` or `ResourceCleanupFailed`.
         */
        conditionsType?: string;
        /**
         * The Phase of Node, the value is `Creating` or `Running` or `Updating` or `Deleting` or `Failed` or `Starting` or `Stopping` or `Stopped`.
         */
        phase?: string;
    }

    export interface SupportAddonsAddon {
        /**
         * The categories of addons, the value is `Storage` or `Network` or `Monitor` or `Scheduler` or `Dns` or `Security` or `Gpu` or `Image`.
         */
        categories?: string[];
        /**
         * The deploy model.
         */
        deployMode: string;
        /**
         * The deploy node types, the value is `Node` or `VirtualNode`. Only effected when deployMode is `Unmanaged`.
         */
        deployNodeTypes: string[];
        /**
         * The name of the addon.
         */
        name: string;
        necessary?: string;
        /**
         * The container network model, the value is `Flannel` or `VpcCniShared`. Flannel: Flannel network model, an independent Underlay container network solution, combined with the global routing capability of VPC, to achieve a high-performance network experience for the cluster. VpcCniShared: VPC-CNI network model, an Underlay container network solution based on the ENI of the private network elastic network card, with high network communication performance.
         */
        podNetworkModes: string[];
        /**
         * The version info of addon.
         */
        versions: outputs.vke.SupportAddonsAddonVersion[];
    }

    export interface SupportAddonsAddonVersion {
        /**
         * The compatible version list.
         */
        compatibilities: outputs.vke.SupportAddonsAddonVersionCompatibility[];
        /**
         * The compatible version list.
         */
        compatibleVersions: string[];
        /**
         * The basic version info.
         */
        version: string;
    }

    export interface SupportAddonsAddonVersionCompatibility {
        /**
         * The Kubernetes Version of addon.
         */
        kubernetesVersion: string;
    }

    export interface SupportResourceTypesResource {
        /**
         * The scope of resource.
         */
        resourceScope: string;
        /**
         * The resource specifications info.
         */
        resourceSpecifications: string[];
        /**
         * The type of resource.
         */
        resourceType: string;
        /**
         * The id of zone.
         */
        zoneId: string;
    }

}

export namespace vpc {
    export interface HaVipsHaVip {
        /**
         * The account id of the Ha Vip.
         */
        accountId: string;
        /**
         * The associated eip address of the Ha Vip.
         */
        associatedEipAddress: string;
        /**
         * The associated eip id of the Ha Vip.
         */
        associatedEipId: string;
        /**
         * The associated instance ids of the Ha Vip.
         */
        associatedInstanceIds: string[];
        /**
         * The associated instance type of the Ha Vip.
         */
        associatedInstanceType: string;
        /**
         * The create time of the Ha Vip.
         */
        createdAt: string;
        /**
         * The description of the Ha Vip.
         */
        description: string;
        /**
         * The id of the Ha Vip.
         */
        haVipId: string;
        /**
         * The name of Ha Vip.
         */
        haVipName: string;
        /**
         * The id of the Ha Vip.
         */
        id: string;
        /**
         * The ip address of Ha Vip.
         */
        ipAddress: string;
        /**
         * The master instance id of the Ha Vip.
         */
        masterInstanceId: string;
        /**
         * The project name of Ha Vip.
         */
        projectName: string;
        /**
         * The status of Ha Vip.
         */
        status: string;
        /**
         * The id of subnet.
         */
        subnetId: string;
        /**
         * The update time of the Ha Vip.
         */
        updatedAt: string;
        /**
         * The id of vpc.
         */
        vpcId: string;
    }

    export interface Ipv6AddressBandwidthsIpv6AddressBandwidth {
        /**
         * The ID of the Ipv6AddressBandwidth.
         */
        allocationId: string;
        /**
         * Peek bandwidth of the Ipv6 address.
         */
        bandwidth: number;
        /**
         * BillingType of the Ipv6 bandwidth.
         */
        billingType: string;
        /**
         * The BusinessStatus of the Ipv6AddressBandwidth.
         */
        businessStatus: string;
        /**
         * Creation time of the Ipv6AddressBandwidth.
         */
        creationTime: string;
        /**
         * Delete time of the Ipv6AddressBandwidth.
         */
        deleteTime: string;
        /**
         * The ID of the Ipv6AddressBandwidth.
         */
        id: string;
        /**
         * The ID of the associated instance.
         */
        instanceId: string;
        /**
         * The type of the associated instance.
         */
        instanceType: string;
        /**
         * The IPv6 address.
         */
        ipv6Address: string;
        /**
         * ISP of the ipv6 address.
         */
        isp: string;
        /**
         * The BusinessStatus of the Ipv6AddressBandwidth.
         */
        lockReason: string;
        /**
         * The network type of the ipv6 address.
         */
        networkType: string;
        /**
         * Overdue time of the Ipv6AddressBandwidth.
         */
        overdueTime: string;
        /**
         * The status of the Ipv6AddressBandwidth.
         */
        status: string;
        /**
         * Update time of the Ipv6AddressBandwidth.
         */
        updateTime: string;
    }

    export interface Ipv6AddressesIpv6Address {
        /**
         * The IPv6 address.
         */
        ipv6Address: string;
    }

    export interface Ipv6GatewaysIpv6Gateway {
        /**
         * Creation time of the Ipv6Gateway.
         */
        creationTime: string;
        /**
         * The description of the Ipv6Gateway.
         */
        description: string;
        /**
         * The ID of the Ipv6Gateway.
         */
        id: string;
        /**
         * The ID of the Ipv6Gateway.
         */
        ipv6GatewayId: string;
        /**
         * The name of the Ipv6Gateway.
         */
        name: string;
        /**
         * The Status of the Ipv6Gateway.
         */
        status: string;
        /**
         * Update time of the Ipv6Gateway.
         */
        updateTime: string;
        /**
         * The id of the VPC which the Ipv6Gateway belongs to.
         */
        vpcId: string;
    }

    export interface NetworkAclEgressAclEntry {
        /**
         * The description of entry.
         */
        description?: string;
        /**
         * The DestinationCidrIp of entry.
         */
        destinationCidrIp?: string;
        networkAclEntryId: string;
        /**
         * The name of entry.
         */
        networkAclEntryName?: string;
        /**
         * The policy of entry. Default is `accept`. The value can be `accept` or `drop`.
         */
        policy?: string;
        /**
         * The port of entry. Default is `-1/-1`. When Protocol is `all`, `icmp` or `gre`, the port range is `-1/-1`, which means no port restriction.When the Protocol is `tcp` or `udp`, the port range is `1~65535`, and the format is `1/200`, `80/80`,which means port 1 to port 200, port 80.
         */
        port?: string;
        priority: number;
        /**
         * The protocol of entry. The value can be `icmp` or `gre` or `tcp` or `udp` or `all`. Default is `all`.
         */
        protocol?: string;
    }

    export interface NetworkAclIngressAclEntry {
        /**
         * The description of entry.
         */
        description?: string;
        networkAclEntryId: string;
        /**
         * The name of entry.
         */
        networkAclEntryName?: string;
        /**
         * The policy of entry, default is `accept`. The value can be `accept` or `drop`.
         */
        policy?: string;
        /**
         * The port of entry. Default is `-1/-1`. When Protocol is `all`, `icmp` or `gre`, the port range is `-1/-1`, which means no port restriction. When the Protocol is `tcp` or `udp`, the port range is `1~65535`, and the format is `1/200`, `80/80`, which means port 1 to port 200, port 80.
         */
        port?: string;
        priority: number;
        /**
         * The protocol of entry, default is `all`. The value can be `icmp` or `gre` or `tcp` or `udp` or `all`.
         */
        protocol?: string;
        /**
         * The SourceCidrIp of entry.
         */
        sourceCidrIp?: string;
    }

    export interface NetworkAclsNetworkAcl {
        /**
         * The count of Network acl entry.
         */
        aclEntryCount: number;
        /**
         * Creation time of Network Acl.
         */
        creationTime: string;
        /**
         * The description of entry.
         */
        description: string;
        /**
         * The egress entries info of Network Acl.
         */
        egressAclEntries: outputs.vpc.NetworkAclsNetworkAclEgressAclEntry[];
        /**
         * The ID of Network Acl.
         */
        id: string;
        /**
         * The ingress entries info of Network Acl.
         */
        ingressAclEntries: outputs.vpc.NetworkAclsNetworkAclIngressAclEntry[];
        /**
         * The ID of Network Acl.
         */
        networkAclId: string;
        /**
         * The name of Network Acl.
         */
        networkAclName: string;
        /**
         * The resources info of Network Acl.
         */
        resources: outputs.vpc.NetworkAclsNetworkAclResource[];
        /**
         * The Status of Network Acl.
         */
        status: string;
        /**
         * Update time of Network Acl.
         */
        updateTime: string;
        /**
         * The vpc id of Network Acl.
         */
        vpcId: string;
    }

    export interface NetworkAclsNetworkAclEgressAclEntry {
        /**
         * The description of entry.
         */
        description: string;
        /**
         * The DestinationCidrIp of entry.
         */
        destinationCidrIp: string;
        /**
         * The id of entry.
         */
        networkAclEntryId: string;
        /**
         * The name of entry.
         */
        networkAclEntryName: string;
        /**
         * The policy of entry.
         */
        policy: string;
        /**
         * The port of entry.
         */
        port: string;
        /**
         * The priority of entry.
         */
        priority: number;
        /**
         * The protocol of entry.
         */
        protocol: string;
    }

    export interface NetworkAclsNetworkAclIngressAclEntry {
        /**
         * The description of entry.
         */
        description: string;
        /**
         * The id of entry.
         */
        networkAclEntryId: string;
        /**
         * The name of entry.
         */
        networkAclEntryName: string;
        /**
         * The policy of entry.
         */
        policy: string;
        /**
         * The port of entry.
         */
        port: string;
        /**
         * The priority of entry.
         */
        priority: number;
        /**
         * The protocol of entry.
         */
        protocol: string;
        /**
         * The SourceCidrIp of entry.
         */
        sourceCidrIp: string;
    }

    export interface NetworkAclsNetworkAclResource {
        /**
         * The resource id of Network Acl.
         */
        resourceId: string;
        /**
         * The Status of Network Acl.
         */
        status: string;
    }

    export interface NetworkInterfaceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface NetworkInterfacesNetworkInterface {
        /**
         * The account id of the ENI creator.
         */
        accountId: string;
        /**
         * The IP address of the EIP to which the ENI associates.
         */
        associatedElasticIpAddress: string;
        /**
         * The allocation id of the EIP to which the ENI associates.
         */
        associatedElasticIpId: string;
        /**
         * The create time of the ENI.
         */
        createdAt: string;
        /**
         * The description of the ENI.
         */
        description: string;
        /**
         * The id of the device to which the ENI is bound.
         */
        deviceId: string;
        /**
         * The id of the ENI.
         */
        id: string;
        /**
         * The IPv6 address list of the ENI.
         */
        ipv6Sets: string[];
        /**
         * The mac address of the ENI.
         */
        macAddress: string;
        /**
         * The id of the ENI.
         */
        networkInterfaceId: string;
        /**
         * A name of ENI.
         */
        networkInterfaceName: string;
        /**
         * The enable of port security.
         */
        portSecurityEnabled: boolean;
        /**
         * The primary IP address of the ENI.
         */
        primaryIpAddress: string;
        /**
         * The IP address of secondary private network interface.
         */
        privateIpSets: outputs.vpc.NetworkInterfacesNetworkInterfacePrivateIpSet[];
        /**
         * The ProjectName of the ENI.
         */
        projectName: string;
        /**
         * The list of the security group id to which the secondary ENI belongs.
         */
        securityGroupIds: string[];
        /**
         * Whether the network card has been authorized to be used by other account services.
         */
        serviceManaged: boolean;
        /**
         * A status of ENI, Optional choice contains `Creating`, `Available`, `Attaching`, `InUse`, `Detaching`, `Deleting`.
         */
        status: string;
        /**
         * An id of the subnet to which the ENI is connected.
         */
        subnetId: string;
        /**
         * Tags.
         */
        tags: outputs.vpc.NetworkInterfacesNetworkInterfaceTag[];
        /**
         * A type of ENI, Optional choice contains `primary`, `secondary`.
         */
        type: string;
        /**
         * The last update time of the ENI.
         */
        updatedAt: string;
        /**
         * An id of the virtual private cloud (VPC) to which the ENI belongs.
         */
        vpcId: string;
        /**
         * The name of the virtual private cloud (VPC) to which the ENI belongs.
         */
        vpcName: string;
        /**
         * The zone ID.
         */
        zoneId: string;
    }

    export interface NetworkInterfacesNetworkInterfacePrivateIpSet {
        /**
         * The public IP that secondary private network IP associated with.
         */
        associatedElasticIps: outputs.vpc.NetworkInterfacesNetworkInterfacePrivateIpSetAssociatedElasticIp[];
        /**
         * Whether the network interface is primary IP address.
         */
        primary: boolean;
        /**
         * The secondary private network IP address of the network interface card.
         */
        privateIpAddress: string;
    }

    export interface NetworkInterfacesNetworkInterfacePrivateIpSetAssociatedElasticIp {
        /**
         * The public IP ID.
         */
        allocationId: string;
        /**
         * The public IP address.
         */
        eipAddress: string;
    }

    export interface NetworkInterfacesNetworkInterfaceTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface NetworkInterfacesTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface PrefixListPrefixListAssociation {
        /**
         * Associated resource ID.
         */
        resourceId: string;
        /**
         * Related resource types.
         */
        resourceType: string;
    }

    export interface PrefixListPrefixListEntry {
        /**
         * CIDR of prefix list entries.
         */
        cidr?: string;
        /**
         * Description of prefix list entries.
         */
        description?: string;
    }

    export interface PrefixListTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface PrefixListsPrefixList {
        /**
         * Number of associated resources for prefix list.
         */
        associationCount: number;
        /**
         * CIDR address block information for prefix list.
         */
        cidrs: string[];
        /**
         * The creation time of the prefix list.
         */
        creationTime: string;
        /**
         * Description.
         */
        description: string;
        /**
         * The id of the prefix list.
         */
        id: string;
        /**
         * IP version of prefix list.
         */
        ipVersion: string;
        /**
         * Maximum number of entries, which is the maximum number of items that can be added to the prefix list.
         */
        maxEntries: number;
        /**
         * Collection of resources associated with VPC prefix list.
         */
        prefixListAssociations: outputs.vpc.PrefixListsPrefixListPrefixListAssociation[];
        /**
         * The prefix list entries.
         */
        prefixListEntries: outputs.vpc.PrefixListsPrefixListPrefixListEntry[];
        /**
         * The prefix list id.
         */
        prefixListId: string;
        /**
         * A Name of prefix list.
         */
        prefixListName: string;
        /**
         * The status of the prefix list.
         */
        status: string;
        /**
         * The update time of the prefix list.
         */
        updateTime: string;
    }

    export interface PrefixListsPrefixListPrefixListAssociation {
        /**
         * Associated resource ID.
         */
        resourceId: string;
        /**
         * Related resource types.
         */
        resourceType: string;
    }

    export interface PrefixListsPrefixListPrefixListEntry {
        /**
         * CIDR address blocks for prefix list entries.
         */
        cidr: string;
        /**
         * Description.
         */
        description: string;
        /**
         * The prefix list id.
         */
        prefixListId: string;
    }

    export interface PrefixListsTagFilter {
        /**
         * The key of the tag.
         */
        key?: string;
        /**
         * The values of the tag.
         */
        values?: string[];
    }

    export interface RouteEntriesRouteEntry {
        /**
         * The description of the route entry.
         */
        description: string;
        /**
         * A destination CIDR block of route entry.
         */
        destinationCidrBlock: string;
        /**
         * The id of the route entry.
         */
        id: string;
        /**
         * An id of next hop.
         */
        nextHopId: string;
        /**
         * The name of the next hop.
         */
        nextHopName: string;
        /**
         * A type of next hop, Optional choice contains `Instance`, `NetworkInterface`, `NatGW`, `VpnGW`.
         */
        nextHopType: string;
        /**
         * The id of the route entry.
         */
        routeEntryId: string;
        /**
         * A name of route entry.
         */
        routeEntryName: string;
        /**
         * An id of route table.
         */
        routeTableId: string;
        /**
         * The status of the route entry.
         */
        status: string;
        /**
         * The type of the route entry.
         */
        type: string;
        /**
         * The id of the virtual private cloud (VPC) to which the route entry belongs.
         */
        vpcId: string;
    }

    export interface RouteTablesRouteTable {
        /**
         * The account id of the route table creator.
         */
        accountId: string;
        /**
         * The create time of the route table.
         */
        creationTime: string;
        /**
         * The description of the route table.
         */
        description: string;
        /**
         * The id of the route table.
         */
        id: string;
        /**
         * The ProjectName of the route table.
         */
        projectName: string;
        /**
         * The id of the route table.
         */
        routeTableId: string;
        /**
         * A name of route table.
         */
        routeTableName: string;
        /**
         * The type of the route table.
         */
        routeTableType: string;
        /**
         * The list of the subnet ids to which the entry table associates.
         */
        subnetIds: string[];
        /**
         * The last update time of the route table.
         */
        updateTime: string;
        /**
         * An id of VPC.
         */
        vpcId: string;
        /**
         * The name of the virtual private cloud (VPC) to which the route entry belongs.
         */
        vpcName: string;
    }

    export interface SecurityGroupRulesSecurityGroupRule {
        /**
         * Cidr ip of egress/ingress Rule.
         */
        cidrIp: string;
        /**
         * The creation time of security group rule.
         */
        creationTime: string;
        /**
         * description of a group rule.
         */
        description: string;
        /**
         * Direction of rule, ingress (inbound) or egress (outbound).
         */
        direction: string;
        /**
         * Access strategy.
         */
        policy: string;
        /**
         * Port end of egress/ingress Rule.
         */
        portEnd: number;
        /**
         * Port start of egress/ingress Rule.
         */
        portStart: number;
        /**
         * Priority of a security group rule.
         */
        priority: number;
        /**
         * Protocol of the SecurityGroup, the value can be `tcp` or `udp` or `icmp` or `all`.
         */
        protocol: string;
        /**
         * SecurityGroup ID.
         */
        securityGroupId: string;
        /**
         * ID of the source security group whose access permission you want to set.
         */
        sourceGroupId: string;
        /**
         * The update time of security group rule.
         */
        updateTime: string;
    }

    export interface SecurityGroupTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface SecurityGroupsSecurityGroup {
        /**
         * The creation time of SecurityGroup.
         */
        creationTime: string;
        /**
         * The description of SecurityGroup.
         */
        description: string;
        /**
         * The ID of SecurityGroup.
         */
        id: string;
        /**
         * The ProjectName of SecurityGroup.
         */
        projectName: string;
        /**
         * The ID of SecurityGroup.
         */
        securityGroupId: string;
        /**
         * The Name of SecurityGroup.
         */
        securityGroupName: string;
        /**
         * The Status of SecurityGroup.
         */
        status: string;
        /**
         * Tags.
         */
        tags: outputs.vpc.SecurityGroupsSecurityGroupTag[];
        /**
         * A Name Regex of SecurityGroup.
         */
        type: string;
        /**
         * The ID of vpc where security group is located.
         */
        vpcId: string;
    }

    export interface SecurityGroupsSecurityGroupTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface SecurityGroupsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface SubnetTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface SubnetsSubnet {
        /**
         * The account ID which the subnet belongs to.
         */
        accountId: string;
        /**
         * The count of available ip address.
         */
        availableIpAddressCount: number;
        /**
         * The cidr block of Subnet.
         */
        cidrBlock: string;
        /**
         * Creation time of Subnet.
         */
        creationTime: string;
        /**
         * The description of Subnet.
         */
        description: string;
        /**
         * The ID of Subnet.
         */
        id: string;
        /**
         * The IPv6 CIDR block of the VPC.
         */
        ipv6CidrBlock: string;
        /**
         * The ID of network acl which this subnet associate with.
         */
        networkAclId: string;
        /**
         * The route table information.
         */
        routeTable: outputs.vpc.SubnetsSubnetRouteTable;
        /**
         * The ID of route table which subnet associated with.
         */
        routeTableId: string;
        /**
         * The route table type.
         */
        routeTableType: string;
        /**
         * The Status of Subnet.
         */
        status: string;
        /**
         * The subnet name to query.
         */
        subnetName: string;
        /**
         * Tags.
         */
        tags: outputs.vpc.SubnetsSubnetTag[];
        /**
         * The Count of ipv4.
         */
        totalIpv4Count: number;
        /**
         * Update time of Subnet.
         */
        updateTime: string;
        /**
         * The ID of VPC which subnet belongs to.
         */
        vpcId: string;
        /**
         * The ID of zone which subnet belongs to.
         */
        zoneId: string;
    }

    export interface SubnetsSubnetRouteTable {
        /**
         * The ID of route table which subnet associated with.
         */
        routeTableId: string;
        /**
         * The route table type.
         */
        routeTableType: string;
    }

    export interface SubnetsSubnetTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface SubnetsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface VpcAssociateCen {
        /**
         * The ID of CEN.
         */
        cenId: string;
        /**
         * The owner ID of CEN.
         */
        cenOwnerId: string;
        /**
         * The status of CEN.
         */
        cenStatus: string;
    }

    export interface VpcTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface VpcsTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface VpcsVpc {
        /**
         * The account ID of VPC.
         */
        accountId: string;
        /**
         * The associate cen list of VPC.
         */
        associateCens: outputs.vpc.VpcsVpcAssociateCen[];
        /**
         * The auxiliary cidr block list of VPC.
         */
        auxiliaryCidrBlocks: string[];
        /**
         * The cidr block of VPC.
         */
        cidrBlock: string;
        /**
         * The create time of VPC.
         */
        creationTime: string;
        /**
         * The description of VPC.
         */
        description: string;
        /**
         * The dns server list of VPC.
         */
        dnsServers: string[];
        /**
         * The IPv6 CIDR block of the VPC.
         */
        ipv6CidrBlock: string;
        /**
         * The nat gateway ID list of VPC.
         */
        natGatewayIds: string[];
        /**
         * The ProjectName of the VPC.
         */
        projectName: string;
        /**
         * The route table ID list of VPC.
         */
        routeTableIds: string[];
        /**
         * The security group ID list of VPC.
         */
        securityGroupIds: string[];
        /**
         * The status of VPC.
         */
        status: string;
        /**
         * The subnet ID list of VPC.
         */
        subnetIds: string[];
        /**
         * Tags.
         */
        tags: outputs.vpc.VpcsVpcTag[];
        /**
         * The update time of VPC.
         */
        updateTime: string;
        /**
         * The ID of VPC.
         */
        vpcId: string;
        /**
         * The vpc name to query.
         */
        vpcName: string;
    }

    export interface VpcsVpcAssociateCen {
        /**
         * The ID of CEN.
         */
        cenId: string;
        /**
         * The owner ID of CEN.
         */
        cenOwnerId: string;
        /**
         * The status of CEN.
         */
        cenStatus: string;
    }

    export interface VpcsVpcTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

}

export namespace vpn {
    export interface ConnectionsVpnConnection {
        /**
         * The account ID of the VPN connection.
         */
        accountId: string;
        /**
         * The IPsec attach status.
         */
        attachStatus: string;
        /**
         * The IPsec attach type.
         */
        attachType: string;
        /**
         * The business status of IPsec connection, valid when the attach type is 'TransitRouter'.
         */
        businessStatus: string;
        /**
         * The connect status of the VPN connection.
         */
        connectStatus: string;
        /**
         * The create time of VPN connection.
         */
        creationTime: string;
        /**
         * An ID of customer gateway.
         */
        customerGatewayId: string;
        /**
         * The delete time of resource, valid when the attach type is 'TransitRouter'.
         */
        deletedTime: string;
        /**
         * The description of the VPN connection.
         */
        description: string;
        /**
         * The dpd action of the VPN connection.
         */
        dpdAction: string;
        /**
         * The ID of the VPN connection.
         */
        id: string;
        /**
         * The auth alg of the ike config of the VPN connection.
         */
        ikeConfigAuthAlg: string;
        /**
         * The dk group of the ike config of the VPN connection.
         */
        ikeConfigDhGroup: string;
        /**
         * The enc alg of the ike config of the VPN connection.
         */
        ikeConfigEncAlg: string;
        /**
         * The lifetime of the ike config of the VPN connection.
         */
        ikeConfigLifetime: number;
        /**
         * The localId of the ike config of the VPN connection.
         */
        ikeConfigLocalId: string;
        /**
         * The mode of the ike config of the VPN connection.
         */
        ikeConfigMode: string;
        /**
         * The psk of the ike config of the VPN connection.
         */
        ikeConfigPsk: string;
        /**
         * The remote id of the ike config of the VPN connection.
         */
        ikeConfigRemoteId: string;
        /**
         * The version of the ike config of the VPN connection.
         */
        ikeConfigVersion: string;
        /**
         * The ip address of transit router, valid when the attach type is 'TransitRouter'.
         */
        ipAddress: string;
        /**
         * The auth alg of the ipsec config of the VPN connection.
         */
        ipsecConfigAuthAlg: string;
        /**
         * The dh group of the ipsec config of the VPN connection.
         */
        ipsecConfigDhGroup: string;
        /**
         * The enc alg of the ipsec config of the VPN connection.
         */
        ipsecConfigEncAlg: string;
        /**
         * The lifetime of the ike config of the VPN connection.
         */
        ipsecConfigLifetime: number;
        /**
         * The local subnet of the VPN connection.
         */
        localSubnets: string[];
        /**
         * Whether to enable the connection log.
         */
        logEnabled: boolean;
        /**
         * The nat traversal of the VPN connection.
         */
        natTraversal: boolean;
        /**
         * Whether to initiate negotiation mode immediately.
         */
        negotiateInstantly: boolean;
        /**
         * The overdue time of resource, valid when the attach type is 'TransitRouter'.
         */
        overdueTime: string;
        /**
         * The remote subnet of the VPN connection.
         */
        remoteSubnets: string[];
        /**
         * The status of the VPN connection.
         */
        status: string;
        /**
         * The id of transit router, valid when the attach type is 'TransitRouter'.
         */
        transitRouterId: string;
        /**
         * The update time of VPN connection.
         */
        updateTime: string;
        /**
         * The ID of the VPN connection.
         */
        vpnConnectionId: string;
        /**
         * The name of the VPN connection.
         */
        vpnConnectionName: string;
        /**
         * An ID of VPN gateway.
         */
        vpnGatewayId: string;
        /**
         * The zone id of transit router, valid when the attach type is 'TransitRouter'.
         */
        zoneId: string;
    }

    export interface CustomerGatewaysCustomerGateway {
        /**
         * The account ID of the customer gateway.
         */
        accountId: string;
        /**
         * The connection count of the customer gateway.
         */
        connectionCount: number;
        /**
         * The create time of customer gateway.
         */
        creationTime: string;
        /**
         * The ID of the customer gateway.
         */
        customerGatewayId: string;
        /**
         * The name of the customer gateway.
         */
        customerGatewayName: string;
        /**
         * The description of the customer gateway.
         */
        description: string;
        /**
         * The ID of the customer gateway.
         */
        id: string;
        /**
         * A IP address of the customer gateway.
         */
        ipAddress: string;
        /**
         * The status of the customer gateway.
         */
        status: string;
        /**
         * The update time of customer gateway.
         */
        updateTime: string;
    }

    export interface GatewayRoutesVpnGatewayRoute {
        /**
         * The create time of VPN gateway route.
         */
        creationTime: string;
        /**
         * A destination cidr block.
         */
        destinationCidrBlock: string;
        /**
         * The ID of the VPN gateway route.
         */
        id: string;
        /**
         * An ID of next hop.
         */
        nextHopId: string;
        /**
         * The status of the VPN gateway route.
         */
        status: string;
        /**
         * The update time of VPN gateway route.
         */
        updateTime: string;
        /**
         * An ID of VPN gateway.
         */
        vpnGatewayId: string;
        /**
         * The ID of the VPN gateway route.
         */
        vpnGatewayRouteId: string;
    }

    export interface GatewayTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GatewaysTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface GatewaysVpnGateway {
        /**
         * The account ID of the VPN gateway.
         */
        accountId: string;
        /**
         * The bandwidth of the VPN gateway.
         */
        bandwidth: number;
        /**
         * The BillingType of the VPN gateway.
         */
        billingType: string;
        /**
         * The business status of the VPN gateway.
         */
        businessStatus: string;
        /**
         * The connection count of the VPN gateway.
         */
        connectionCount: number;
        /**
         * The create time of VPN gateway.
         */
        creationTime: string;
        /**
         * The deleted time of the VPN gateway.
         */
        deletedTime: string;
        /**
         * The description of the VPN gateway.
         */
        description: string;
        /**
         * The expired time of the VPN gateway.
         */
        expiredTime: string;
        /**
         * The ID of the VPN gateway.
         */
        id: string;
        /**
         * A IP address of the VPN gateway.
         */
        ipAddress: string;
        /**
         * Whether ipsec is enabled.
         */
        ipsecEnabled: boolean;
        /**
         * The lock reason of the VPN gateway.
         */
        lockReason: string;
        /**
         * The name of project.
         */
        projectName: string;
        /**
         * The route count of the VPN gateway.
         */
        routeCount: number;
        /**
         * Whether ssl is enabled.
         */
        sslEnabled: boolean;
        /**
         * The max connections of ssl.
         */
        sslMaxConnections: number;
        /**
         * The status of the VPN gateway.
         */
        status: string;
        /**
         * A subnet ID of the VPN gateway.
         */
        subnetId?: string;
        /**
         * Tags.
         */
        tags: outputs.vpn.GatewaysVpnGatewayTag[];
        /**
         * The update time of VPN gateway.
         */
        updateTime: string;
        /**
         * A VPC ID of the VPN gateway.
         */
        vpcId: string;
        /**
         * The ID of the VPN gateway.
         */
        vpnGatewayId: string;
        /**
         * The name of the VPN gateway.
         */
        vpnGatewayName: string;
    }

    export interface GatewaysVpnGatewayTag {
        /**
         * The Key of Tags.
         */
        key: string;
        /**
         * The Value of Tags.
         */
        value: string;
    }

    export interface SslVpnClientCertsSslVpnClientCert {
        /**
         * The CA certificate.
         */
        caCertificate: string;
        /**
         * The status of the ssl vpn client cert.
         */
        certificateStatus: string;
        /**
         * The client certificate.
         */
        clientCertificate: string;
        /**
         * The key of the ssl vpn client.
         */
        clientKey: string;
        /**
         * The creation time of the ssl vpn client cert.
         */
        creationTime: string;
        /**
         * The description of the ssl vpn client cert.
         */
        description: string;
        /**
         * The expired time of the ssl vpn client cert.
         */
        expiredTime: string;
        /**
         * The id of the ssl vpn client cert.
         */
        id: string;
        /**
         * The config of the open vpn client.
         */
        openVpnClientConfig: string;
        /**
         * The id of the ssl vpn client cert.
         */
        sslVpnClientCertId: string;
        /**
         * The name of the ssl vpn client cert.
         */
        sslVpnClientCertName: string;
        /**
         * The id of the ssl vpn server.
         */
        sslVpnServerId: string;
        /**
         * The status of the ssl vpn client.
         */
        status: string;
        /**
         * The update time of the ssl vpn client cert.
         */
        updateTime: string;
    }

    export interface SslVpnServersSslVpnServer {
        /**
         * The authentication algorithm of the SSL server.
         * Values:
         * `SHA1` (default)
         * `MD5`
         * `None` (do not use encryption).
         */
        auth: string;
        /**
         * The encryption algorithm of the SSL server.
         * Values:
         * `AES-128-CBC` (default)
         * `AES-192-CBC`
         * `AES-256-CBC`
         * `None` (do not use encryption).
         */
        cipher: string;
        /**
         * SSL client network segment.
         */
        clientIpPool: string;
        /**
         * Whether to compress the transmitted data. The default value is false.
         */
        compress: boolean;
        /**
         * The creation time.
         */
        creationTime: string;
        /**
         * The description of the ssl server.
         */
        description: string;
        /**
         * The SSL VPN server id.
         */
        id: string;
        /**
         * The local network segment of the SSL server. The local network segment is the address segment that the client accesses through the SSL VPN connection.
         */
        localSubnets: string[];
        /**
         * The protocol used by the SSL server. Valid values are `TCP`, `UDP`. Default Value: `UDP`.
         */
        protocol: string;
        /**
         * The id of the ssl vpn server.
         */
        sslVpnServerId: string;
        /**
         * The name of the ssl vpn server.
         */
        sslVpnServerName: string;
        /**
         * The status of the ssl vpn server.
         */
        status: string;
        /**
         * The update time.
         */
        updateTime: string;
        /**
         * The id of the vpn gateway.
         */
        vpnGatewayId: string;
    }

}
